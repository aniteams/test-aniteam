"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_media-captions_dist_dev_js"],{

/***/ "(app-pages-browser)/./node_modules/media-captions/dist/dev.js":
/*!*************************************************!*\
  !*** ./node_modules/media-captions/dist/dev.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CaptionsRenderer: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   ParseError: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   ParseErrorCode: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   TextCue: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.T),\n/* harmony export */   VTTCue: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   VTTRegion: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   createVTTCueTemplate: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   parseByteStream: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   parseResponse: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   parseText: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   parseTextStream: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   parseVTTTimestamp: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   renderVTTCueString: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   renderVTTTokensString: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   tokenizeVTTCue: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   updateTimedVTTCueNodes: () => (/* reexport safe */ _dev_index_js__WEBPACK_IMPORTED_MODULE_0__.u)\n/* harmony export */ });\n/* harmony import */ var _dev_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dev/index.js */ \"(app-pages-browser)/./node_modules/media-captions/dist/dev/index.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jYXB0aW9ucy9kaXN0L2Rldi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFrWCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXG1lZGlhLWNhcHRpb25zXFxkaXN0XFxkZXYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgQyBhcyBDYXB0aW9uc1JlbmRlcmVyLCBQIGFzIFBhcnNlRXJyb3IsIGMgYXMgUGFyc2VFcnJvckNvZGUsIFQgYXMgVGV4dEN1ZSwgYiBhcyBWVFRDdWUsIGggYXMgVlRUUmVnaW9uLCBpIGFzIGNyZWF0ZVZUVEN1ZVRlbXBsYXRlLCBlIGFzIHBhcnNlQnl0ZVN0cmVhbSwgZCBhcyBwYXJzZVJlc3BvbnNlLCBmIGFzIHBhcnNlVGV4dCwgZyBhcyBwYXJzZVRleHRTdHJlYW0sIHAgYXMgcGFyc2VWVFRUaW1lc3RhbXAsIHIgYXMgcmVuZGVyVlRUQ3VlU3RyaW5nLCBqIGFzIHJlbmRlclZUVFRva2Vuc1N0cmluZywgdCBhcyB0b2tlbml6ZVZUVEN1ZSwgdSBhcyB1cGRhdGVUaW1lZFZUVEN1ZU5vZGVzIH0gZnJvbSAnLi9kZXYvaW5kZXguanMnO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-captions/dist/dev.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/media-captions/dist/dev/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/media-captions/dist/dev/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   C: () => (/* binding */ CaptionsRenderer),\n/* harmony export */   P: () => (/* binding */ ParseError),\n/* harmony export */   T: () => (/* binding */ TextCue),\n/* harmony export */   V: () => (/* binding */ VTTParser),\n/* harmony export */   a: () => (/* binding */ VTTBlock),\n/* harmony export */   b: () => (/* binding */ VTTCue),\n/* harmony export */   c: () => (/* binding */ ParseErrorCode),\n/* harmony export */   d: () => (/* binding */ parseResponse),\n/* harmony export */   e: () => (/* binding */ parseByteStream),\n/* harmony export */   f: () => (/* binding */ parseText),\n/* harmony export */   g: () => (/* binding */ parseTextStream),\n/* harmony export */   h: () => (/* binding */ VTTRegion),\n/* harmony export */   i: () => (/* binding */ createVTTCueTemplate),\n/* harmony export */   j: () => (/* binding */ renderVTTTokensString),\n/* harmony export */   p: () => (/* binding */ parseVTTTimestamp),\n/* harmony export */   r: () => (/* binding */ renderVTTCueString),\n/* harmony export */   t: () => (/* binding */ tokenizeVTTCue),\n/* harmony export */   u: () => (/* binding */ updateTimedVTTCueNodes)\n/* harmony export */ });\nconst ParseErrorCode = {\n  LoadFail: 0,\n  BadSignature: 1,\n  BadTimestamp: 2,\n  BadSettingValue: 3,\n  BadFormat: 4,\n  UnknownSetting: 5\n};\nclass ParseError extends Error {\n  code;\n  line;\n  constructor(init) {\n    super(init.reason);\n    this.code = init.code;\n    this.line = init.line;\n  }\n}\n\nconst LINE_TERMINATOR_RE = /\\r?\\n|\\r/gm;\nclass TextLineTransformStream {\n  writable;\n  readable;\n  constructor(encoding) {\n    const transformer = new TextStreamLineIterator(encoding);\n    this.writable = new WritableStream({\n      write(chunk) {\n        transformer.transform(chunk);\n      },\n      close() {\n        transformer.close();\n      }\n    });\n    this.readable = new ReadableStream({\n      start(controller) {\n        transformer.onLine = (line) => controller.enqueue(line);\n        transformer.onClose = () => controller.close();\n      }\n    });\n  }\n}\nclass TextStreamLineIterator {\n  _buffer = \"\";\n  _decoder;\n  onLine;\n  onClose;\n  constructor(encoding) {\n    this._decoder = new TextDecoder(encoding);\n  }\n  transform(chunk) {\n    this._buffer += this._decoder.decode(chunk, { stream: true });\n    const lines = this._buffer.split(LINE_TERMINATOR_RE);\n    this._buffer = lines.pop() || \"\";\n    for (let i = 0; i < lines.length; i++)\n      this.onLine(lines[i].trim());\n  }\n  close() {\n    if (this._buffer)\n      this.onLine(this._buffer.trim());\n    this._buffer = \"\";\n    this.onClose();\n  }\n}\n\nasync function parseText(text, options) {\n  const stream = new ReadableStream({\n    start(controller) {\n      const lines = text.split(LINE_TERMINATOR_RE);\n      for (const line of lines)\n        controller.enqueue(line);\n      controller.close();\n    }\n  });\n  return parseTextStream(stream, options);\n}\nasync function parseTextStream(stream, options) {\n  const type = options?.type ?? \"vtt\";\n  let factory;\n  if (typeof type === \"string\") {\n    switch (type) {\n      case \"srt\":\n        factory = (await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_media-captions_dist_dev_srt-parser_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./srt-parser.js */ \"(app-pages-browser)/./node_modules/media-captions/dist/dev/srt-parser.js\"))).default;\n        break;\n      case \"ssa\":\n      case \"ass\":\n        factory = (await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_media-captions_dist_dev_ssa-parser_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./ssa-parser.js */ \"(app-pages-browser)/./node_modules/media-captions/dist/dev/ssa-parser.js\"))).default;\n        break;\n      default:\n        factory = (await Promise.resolve().then(function () { return vttParser; })).default;\n    }\n  } else {\n    factory = type;\n  }\n  let result;\n  const reader = stream.getReader(), parser = factory(), errors = options?.errors !== false || !!options?.strict || !!options?.errors;\n  await parser.init({\n    strict: false,\n    ...options,\n    errors,\n    type,\n    cancel() {\n      reader.cancel();\n      result = parser.done(true);\n    }\n  });\n  let i = 1;\n  while (true) {\n    const { value, done } = await reader.read();\n    if (done) {\n      parser.parse(\"\", i);\n      result = parser.done(false);\n      break;\n    }\n    parser.parse(value, i);\n    i++;\n  }\n  return result;\n}\n\nasync function parseResponse(response, options) {\n  const res = await response;\n  if (!res.ok || !res.body) {\n    let error;\n    {\n      error = new ParseError({\n        code: ParseErrorCode.LoadFail,\n        reason: !res.ok ? `response is not ok (status: ${res.status})` : `response body is missing (status: ${res.status})`,\n        line: -1\n      });\n      options?.onError?.(error);\n    }\n    return {\n      metadata: {},\n      cues: [],\n      regions: [],\n      errors: [error]\n    };\n  }\n  const contentType = res.headers.get(\"content-type\") || \"\", type = contentType.match(/text\\/(.*?)(?:;|$)/)?.[1], encoding = contentType.match(/charset=(.*?)(?:;|$)/)?.[1];\n  return parseByteStream(res.body, { type, encoding, ...options });\n}\nasync function parseByteStream(stream, { encoding = \"utf-8\", ...options } = {}) {\n  const textStream = stream.pipeThrough(new TextLineTransformStream(encoding));\n  return parseTextStream(textStream, options);\n}\n\nclass TextCue extends EventTarget {\n  /**\n   * A string that identifies the cue.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/id}\n   */\n  id = \"\";\n  /**\n   * A `double` that represents the video time that the cue will start being displayed, in seconds.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/startTime}\n   */\n  startTime;\n  /**\n   * A `double` that represents the video time that the cue will stop being displayed, in seconds.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/endTime}\n   */\n  endTime;\n  /**\n   * Returns a string with the contents of the cue.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/text}\n   */\n  text;\n  /**\n   * A `boolean` for whether the video will pause when this cue stops being displayed.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/TextTrackCue/pauseOnExit}\n   */\n  pauseOnExit = false;\n  constructor(startTime, endTime, text) {\n    super();\n    this.startTime = startTime;\n    this.endTime = endTime;\n    this.text = text;\n  }\n  addEventListener(type, listener, options) {\n    super.addEventListener(type, listener, options);\n  }\n  removeEventListener(type, listener, options) {\n    super.removeEventListener(type, listener, options);\n  }\n}\n\nconst IS_SERVER = typeof document === \"undefined\";\n\nconst CueBase = IS_SERVER ? TextCue : window.VTTCue;\nclass VTTCue extends CueBase {\n  /**\n   * A `VTTRegion` object describing the video's sub-region that the cue will be drawn onto,\n   * or `null` if none is assigned.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/region}\n   */\n  region = null;\n  /**\n   * The cue writing direction.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/vertical}\n   */\n  vertical = \"\";\n  /**\n   * Returns `true` if the `VTTCue.line` attribute is an integer number of lines or a percentage\n   * of the video size.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/snapToLines}\n   */\n  snapToLines = true;\n  /**\n   * Returns the line positioning of the cue. This can be the string `'auto'` or a number whose\n   * interpretation depends on the value of `VTTCue.snapToLines`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/line}\n   */\n  line = \"auto\";\n  /**\n   * Returns an enum representing the alignment of the `VTTCue.line`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/lineAlign}\n   */\n  lineAlign = \"start\";\n  /**\n   * Returns the indentation of the cue within the line. This can be the string `'auto'` or a\n   * number representing the percentage of the `VTTCue.region`, or the video size if `VTTCue`.region`\n   * is `null`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/position}\n   */\n  position = \"auto\";\n  /**\n   * Returns an enum representing the alignment of the cue. This is used to determine what\n   * the `VTTCue.position` is anchored to. The default is `'auto'`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/positionAlign}\n   */\n  positionAlign = \"auto\";\n  /**\n   * Returns a double representing the size of the cue, as a percentage of the video size.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/size}\n   */\n  size = 100;\n  /**\n   * Returns an enum representing the alignment of all the lines of text within the cue box.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/VTTCue/align}\n   */\n  align = \"center\";\n  /**\n   * Additional styles associated with the cue.\n   */\n  style;\n}\n\nclass VTTRegion {\n  /**\n   * A string that identifies the region.\n   */\n  id = \"\";\n  /**\n   * A `double` representing the width of the region, as a percentage of the video.\n   */\n  width = 100;\n  /**\n   * A `double` representing the height of the region, in number of lines.\n   */\n  lines = 3;\n  /**\n   * A `double` representing the region anchor X offset, as a percentage of the region.\n   */\n  regionAnchorX = 0;\n  /**\n   * A `double` representing the region anchor Y offset, as a percentage of the region.\n   */\n  regionAnchorY = 100;\n  /**\n   * A `double` representing the viewport anchor X offset, as a percentage of the video.\n   */\n  viewportAnchorX = 0;\n  /**\n   * A `double` representing the viewport anchor Y offset, as a percentage of the video.\n   */\n  viewportAnchorY = 100;\n  /**\n   * An enum representing how adding new cues will move existing cues.\n   */\n  scroll = \"\";\n}\n\nconst COMMA$1 = \",\", PERCENT_SIGN$1 = \"%\";\nfunction toNumber(text) {\n  const num = parseInt(text, 10);\n  return !Number.isNaN(num) ? num : null;\n}\nfunction toPercentage(text) {\n  const num = parseInt(text.replace(PERCENT_SIGN$1, \"\"), 10);\n  return !Number.isNaN(num) && num >= 0 && num <= 100 ? num : null;\n}\nfunction toCoords(text) {\n  if (!text.includes(COMMA$1))\n    return null;\n  const [x, y] = text.split(COMMA$1).map(toPercentage);\n  return x !== null && y !== null ? [x, y] : null;\n}\nfunction toFloat(text) {\n  const num = parseFloat(text);\n  return !Number.isNaN(num) ? num : null;\n}\n\nconst HEADER_MAGIC = \"WEBVTT\", COMMA = \",\", PERCENT_SIGN = \"%\", SETTING_SEP_RE = /[:=]/, SETTING_LINE_RE = /^[\\s\\t]*(region|vertical|line|position|size|align)[:=]/, NOTE_BLOCK_START = \"NOTE\", REGION_BLOCK_START = \"REGION\", REGION_BLOCK_START_RE = /^REGION:?[\\s\\t]+/, SPACE_RE = /[\\s\\t]+/, TIMESTAMP_SEP = \"-->\", TIMESTAMP_SEP_RE = /[\\s\\t]*-->[\\s\\t]+/, ALIGN_RE = /start|center|end|left|right/, LINE_ALIGN_RE = /start|center|end/, POS_ALIGN_RE = /line-(?:left|right)|center|auto/, TIMESTAMP_RE = /^(?:(\\d{1,2}):)?(\\d{2}):(\\d{2})(?:\\.(\\d{1,3}))?$/;\nvar VTTBlock = /* @__PURE__ */ ((VTTBlock2) => {\n  VTTBlock2[VTTBlock2[\"None\"] = 0] = \"None\";\n  VTTBlock2[VTTBlock2[\"Header\"] = 1] = \"Header\";\n  VTTBlock2[VTTBlock2[\"Cue\"] = 2] = \"Cue\";\n  VTTBlock2[VTTBlock2[\"Region\"] = 3] = \"Region\";\n  VTTBlock2[VTTBlock2[\"Note\"] = 4] = \"Note\";\n  return VTTBlock2;\n})(VTTBlock || {});\nclass VTTParser {\n  _init;\n  _block = 0 /* None */;\n  _metadata = {};\n  _regions = {};\n  _cues = [];\n  _cue = null;\n  _region = null;\n  _errors = [];\n  _errorBuilder;\n  _prevLine = \"\";\n  async init(init) {\n    this._init = init;\n    if (init.strict)\n      this._block = 1 /* Header */;\n    if (init.errors)\n      this._errorBuilder = (await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_media-captions_dist_dev_errors_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./errors.js */ \"(app-pages-browser)/./node_modules/media-captions/dist/dev/errors.js\"))).ParseErrorBuilder;\n  }\n  parse(line, lineCount) {\n    if (line === \"\") {\n      if (this._cue) {\n        this._cues.push(this._cue);\n        this._init.onCue?.(this._cue);\n        this._cue = null;\n      } else if (this._region) {\n        this._regions[this._region.id] = this._region;\n        this._init.onRegion?.(this._region);\n        this._region = null;\n      } else if (this._block === 1 /* Header */) {\n        this._parseHeader(line, lineCount);\n        this._init.onHeaderMetadata?.(this._metadata);\n      }\n      this._block = 0 /* None */;\n    } else if (this._block) {\n      switch (this._block) {\n        case 1 /* Header */:\n          this._parseHeader(line, lineCount);\n          break;\n        case 2 /* Cue */:\n          if (this._cue) {\n            const hasText = this._cue.text.length > 0;\n            if (!hasText && SETTING_LINE_RE.test(line)) {\n              this._parseCueSettings(line.split(SPACE_RE), lineCount);\n            } else {\n              this._cue.text += (hasText ? \"\\n\" : \"\") + line;\n            }\n          }\n          break;\n        case 3 /* Region */:\n          this._parseRegionSettings(line.split(SPACE_RE), lineCount);\n          break;\n      }\n    } else if (line.startsWith(NOTE_BLOCK_START)) {\n      this._block = 4 /* Note */;\n    } else if (line.startsWith(REGION_BLOCK_START)) {\n      this._block = 3 /* Region */;\n      this._region = new VTTRegion();\n      this._parseRegionSettings(line.replace(REGION_BLOCK_START_RE, \"\").split(SPACE_RE), lineCount);\n    } else if (line.includes(TIMESTAMP_SEP)) {\n      const result = this._parseTimestamp(line, lineCount);\n      if (result) {\n        this._cue = new VTTCue(result[0], result[1], \"\");\n        this._cue.id = this._prevLine;\n        this._parseCueSettings(result[2], lineCount);\n      }\n      this._block = 2 /* Cue */;\n    } else if (lineCount === 1) {\n      this._parseHeader(line, lineCount);\n    }\n    this._prevLine = line;\n  }\n  done() {\n    return {\n      metadata: this._metadata,\n      cues: this._cues,\n      regions: Object.values(this._regions),\n      errors: this._errors\n    };\n  }\n  _parseHeader(line, lineCount) {\n    if (lineCount > 1) {\n      if (SETTING_SEP_RE.test(line)) {\n        const [key, value] = line.split(SETTING_SEP_RE);\n        if (key)\n          this._metadata[key] = (value || \"\").replace(SPACE_RE, \"\");\n      }\n    } else if (line.startsWith(HEADER_MAGIC)) {\n      this._block = 1 /* Header */;\n    } else {\n      this._handleError(this._errorBuilder?._badVTTHeader());\n    }\n  }\n  _parseTimestamp(line, lineCount) {\n    const [startTimeText, trailingText = \"\"] = line.split(TIMESTAMP_SEP_RE), [endTimeText, ...settingsText] = trailingText.split(SPACE_RE), startTime = parseVTTTimestamp(startTimeText), endTime = parseVTTTimestamp(endTimeText);\n    if (startTime !== null && endTime !== null && endTime > startTime) {\n      return [startTime, endTime, settingsText];\n    } else {\n      if (startTime === null) {\n        this._handleError(this._errorBuilder?._badStartTimestamp(startTimeText, lineCount));\n      }\n      if (endTime === null) {\n        this._handleError(this._errorBuilder?._badEndTimestamp(endTimeText, lineCount));\n      }\n      if (startTime != null && endTime !== null && endTime > startTime) {\n        this._handleError(this._errorBuilder?._badRangeTimestamp(startTime, endTime, lineCount));\n      }\n    }\n  }\n  /**\n   * @see {@link https://www.w3.org/TR/webvtt1/#region-settings-parsing}\n   */\n  _parseRegionSettings(settings, line) {\n    let badValue;\n    for (let i = 0; i < settings.length; i++) {\n      if (SETTING_SEP_RE.test(settings[i])) {\n        badValue = false;\n        const [name, value] = settings[i].split(SETTING_SEP_RE);\n        switch (name) {\n          case \"id\":\n            this._region.id = value;\n            break;\n          case \"width\":\n            const width = toPercentage(value);\n            if (width !== null)\n              this._region.width = width;\n            else\n              badValue = true;\n            break;\n          case \"lines\":\n            const lines = toNumber(value);\n            if (lines !== null)\n              this._region.lines = lines;\n            else\n              badValue = true;\n            break;\n          case \"regionanchor\":\n            const region = toCoords(value);\n            if (region !== null) {\n              this._region.regionAnchorX = region[0];\n              this._region.regionAnchorY = region[1];\n            } else\n              badValue = true;\n            break;\n          case \"viewportanchor\":\n            const viewport = toCoords(value);\n            if (viewport !== null) {\n              this._region.viewportAnchorX = viewport[0];\n              this._region.viewportAnchorY = viewport[1];\n            } else\n              badValue = true;\n            break;\n          case \"scroll\":\n            if (value === \"up\")\n              this._region.scroll = \"up\";\n            else\n              badValue = true;\n            break;\n          default:\n            this._handleError(this._errorBuilder?._unknownRegionSetting(name, value, line));\n        }\n        if (badValue) {\n          this._handleError(this._errorBuilder?._badRegionSetting(name, value, line));\n        }\n      }\n    }\n  }\n  /**\n   * @see {@link https://www.w3.org/TR/webvtt1/#cue-timings-and-settings-parsing}\n   */\n  _parseCueSettings(settings, line) {\n    let badValue;\n    for (let i = 0; i < settings.length; i++) {\n      badValue = false;\n      if (SETTING_SEP_RE.test(settings[i])) {\n        const [name, value] = settings[i].split(SETTING_SEP_RE);\n        switch (name) {\n          case \"region\":\n            const region = this._regions[value];\n            if (region)\n              this._cue.region = region;\n            break;\n          case \"vertical\":\n            if (value === \"lr\" || value === \"rl\") {\n              this._cue.vertical = value;\n              this._cue.region = null;\n            } else\n              badValue = true;\n            break;\n          case \"line\":\n            const [linePos, lineAlign] = value.split(COMMA);\n            if (linePos.includes(PERCENT_SIGN)) {\n              const percentage = toPercentage(linePos);\n              if (percentage !== null) {\n                this._cue.line = percentage;\n                this._cue.snapToLines = false;\n              } else\n                badValue = true;\n            } else {\n              const number = toFloat(linePos);\n              if (number !== null)\n                this._cue.line = number;\n              else\n                badValue = true;\n            }\n            if (LINE_ALIGN_RE.test(lineAlign)) {\n              this._cue.lineAlign = lineAlign;\n            } else if (lineAlign) {\n              badValue = true;\n            }\n            if (this._cue.line !== \"auto\")\n              this._cue.region = null;\n            break;\n          case \"position\":\n            const [colPos, colAlign] = value.split(COMMA), position = toPercentage(colPos);\n            if (position !== null)\n              this._cue.position = position;\n            else\n              badValue = true;\n            if (colAlign && POS_ALIGN_RE.test(colAlign)) {\n              this._cue.positionAlign = colAlign;\n            } else if (colAlign) {\n              badValue = true;\n            }\n            break;\n          case \"size\":\n            const size = toPercentage(value);\n            if (size !== null) {\n              this._cue.size = size;\n              if (size < 100)\n                this._cue.region = null;\n            } else {\n              badValue = true;\n            }\n            break;\n          case \"align\":\n            if (ALIGN_RE.test(value)) {\n              this._cue.align = value;\n            } else {\n              badValue = true;\n            }\n            break;\n          default:\n            this._handleError(this._errorBuilder?._unknownCueSetting(name, value, line));\n        }\n        if (badValue) {\n          this._handleError(this._errorBuilder?._badCueSetting(name, value, line));\n        }\n      }\n    }\n  }\n  _handleError(error) {\n    if (!error)\n      return;\n    this._errors.push(error);\n    if (this._init.strict) {\n      this._init.cancel();\n      throw error;\n    } else {\n      this._init.onError?.(error);\n    }\n  }\n}\nfunction parseVTTTimestamp(timestamp) {\n  const match = timestamp.match(TIMESTAMP_RE);\n  if (!match)\n    return null;\n  const hours = match[1] ? parseInt(match[1], 10) : 0, minutes = parseInt(match[2], 10), seconds = parseInt(match[3], 10), milliseconds = match[4] ? parseInt(match[4].padEnd(3, \"0\"), 10) : 0, total = hours * 3600 + minutes * 60 + seconds + milliseconds / 1e3;\n  if (hours < 0 || minutes < 0 || seconds < 0 || milliseconds < 0 || minutes > 59 || seconds > 59) {\n    return null;\n  }\n  return total;\n}\nfunction createVTTParser() {\n  return new VTTParser();\n}\n\nvar vttParser = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  VTTBlock: VTTBlock,\n  VTTParser: VTTParser,\n  default: createVTTParser,\n  parseVTTTimestamp: parseVTTTimestamp\n});\n\nconst DIGIT_RE = /[0-9]/, MULTI_SPACE_RE = /[\\s\\t]+/, TAG_NAME = {\n  c: \"span\",\n  i: \"i\",\n  b: \"b\",\n  u: \"u\",\n  ruby: \"ruby\",\n  rt: \"rt\",\n  v: \"span\",\n  lang: \"span\",\n  timestamp: \"span\"\n}, HTML_ENTITIES = {\n  \"&amp;\": \"&\",\n  \"&lt;\": \"<\",\n  \"&gt;\": \">\",\n  \"&quot;\": '\"',\n  \"&#39;\": \"'\",\n  \"&nbsp;\": \"\\xA0\",\n  \"&lrm;\": \"\\u200E\",\n  \"&rlm;\": \"\\u200F\"\n}, HTML_ENTITY_RE = /&(?:amp|lt|gt|quot|#(0+)?39|nbsp|lrm|rlm);/g, COLORS = /* @__PURE__ */ new Set([\n  \"white\",\n  \"lime\",\n  \"cyan\",\n  \"red\",\n  \"yellow\",\n  \"magenta\",\n  \"blue\",\n  \"black\"\n]), BLOCK_TYPES = /* @__PURE__ */ new Set(Object.keys(TAG_NAME));\nfunction tokenizeVTTCue(cue) {\n  let buffer = \"\", mode = 1 /* Data */, result = [], stack = [], node;\n  for (let i = 0; i < cue.text.length; i++) {\n    const char = cue.text[i];\n    switch (mode) {\n      case 1 /* Data */:\n        if (char === \"<\") {\n          addText();\n          mode = 2 /* Tag */;\n        } else {\n          buffer += char;\n        }\n        break;\n      case 2 /* Tag */:\n        switch (char) {\n          case \"\\n\":\n          case \"\t\":\n          case \" \":\n            addNode();\n            mode = 4 /* Annotation */;\n            break;\n          case \".\":\n            addNode();\n            mode = 3 /* Class */;\n            break;\n          case \"/\":\n            mode = 5 /* EndTag */;\n            break;\n          case \">\":\n            addNode();\n            mode = 1 /* Data */;\n            break;\n          default:\n            if (!buffer && DIGIT_RE.test(char))\n              mode = 6 /* Timestamp */;\n            buffer += char;\n            break;\n        }\n        break;\n      case 3 /* Class */:\n        switch (char) {\n          case \"\t\":\n          case \" \":\n          case \"\\n\":\n            addClass();\n            if (node)\n              node.class?.trim();\n            mode = 4 /* Annotation */;\n            break;\n          case \".\":\n            addClass();\n            break;\n          case \">\":\n            addClass();\n            if (node)\n              node.class?.trim();\n            mode = 1 /* Data */;\n            break;\n          default:\n            buffer += char;\n        }\n        break;\n      case 4 /* Annotation */:\n        if (char === \">\") {\n          buffer = buffer.replace(MULTI_SPACE_RE, \" \");\n          if (node?.type === \"v\")\n            node.voice = replaceHTMLEntities(buffer);\n          else if (node?.type === \"lang\")\n            node.lang = replaceHTMLEntities(buffer);\n          buffer = \"\";\n          mode = 1 /* Data */;\n        } else {\n          buffer += char;\n        }\n        break;\n      case 5 /* EndTag */:\n        if (char === \">\") {\n          buffer = \"\";\n          node = stack.pop();\n          mode = 1 /* Data */;\n        }\n        break;\n      case 6 /* Timestamp */:\n        if (char === \">\") {\n          const time = parseVTTTimestamp(buffer);\n          if (time !== null && time >= cue.startTime && time <= cue.endTime) {\n            buffer = \"timestamp\";\n            addNode();\n            node.time = time;\n          }\n          buffer = \"\";\n          mode = 1 /* Data */;\n        } else {\n          buffer += char;\n        }\n        break;\n    }\n  }\n  function addNode() {\n    if (BLOCK_TYPES.has(buffer)) {\n      const parent = node;\n      node = createBlockNode(buffer);\n      if (parent) {\n        if (stack[stack.length - 1] !== parent)\n          stack.push(parent);\n        parent.children.push(node);\n      } else\n        result.push(node);\n    }\n    buffer = \"\";\n    mode = 1 /* Data */;\n  }\n  function addClass() {\n    if (node && buffer) {\n      const color = buffer.replace(\"bg_\", \"\");\n      if (COLORS.has(color)) {\n        node[buffer.startsWith(\"bg_\") ? \"bgColor\" : \"color\"] = color;\n      } else {\n        node.class = !node.class ? buffer : node.class + \" \" + buffer;\n      }\n    }\n    buffer = \"\";\n  }\n  function addText() {\n    if (!buffer)\n      return;\n    const text = { type: \"text\", data: replaceHTMLEntities(buffer) };\n    node ? node.children.push(text) : result.push(text);\n    buffer = \"\";\n  }\n  if (mode === 1 /* Data */)\n    addText();\n  return result;\n}\nfunction createBlockNode(type) {\n  return {\n    tagName: TAG_NAME[type],\n    type,\n    children: []\n  };\n}\nfunction replaceHTMLEntities(text) {\n  return text.replace(HTML_ENTITY_RE, (entity) => HTML_ENTITIES[entity] || \"'\");\n}\n\nfunction setCSSVar(el, name, value) {\n  el.style.setProperty(`--${name}`, value + \"\");\n}\nfunction setDataAttr(el, name, value = true) {\n  el.setAttribute(`data-${name}`, value === true ? \"\" : value + \"\");\n}\nfunction setPartAttr(el, name) {\n  el.setAttribute(\"data-part\", name);\n}\nfunction getLineHeight(el) {\n  return parseFloat(getComputedStyle(el).lineHeight) || 0;\n}\n\nfunction createVTTCueTemplate(cue) {\n  if (IS_SERVER) {\n    throw Error(\n      \"[media-captions] called `createVTTCueTemplate` on the server - use `renderVTTCueString`\"\n    );\n  }\n  const template = document.createElement(\"template\");\n  template.innerHTML = renderVTTCueString(cue);\n  return { cue, content: template.content };\n}\nfunction renderVTTCueString(cue, currentTime = 0) {\n  return renderVTTTokensString(tokenizeVTTCue(cue), currentTime);\n}\nfunction renderVTTTokensString(tokens, currentTime = 0) {\n  let attrs, result = \"\";\n  for (const token of tokens) {\n    if (token.type === \"text\") {\n      result += token.data;\n    } else {\n      const isTimestamp = token.type === \"timestamp\";\n      attrs = {};\n      attrs.class = token.class;\n      attrs.title = token.type === \"v\" && token.voice;\n      attrs.lang = token.type === \"lang\" && token.lang;\n      attrs[\"data-part\"] = token.type === \"v\" && \"voice\";\n      if (isTimestamp) {\n        attrs[\"data-part\"] = \"timed\";\n        attrs[\"data-time\"] = token.time;\n        attrs[\"data-future\"] = token.time > currentTime;\n        attrs[\"data-past\"] = token.time < currentTime;\n      }\n      attrs.style = `${token.color ? `color: ${token.color};` : \"\"}${token.bgColor ? `background-color: ${token.bgColor};` : \"\"}`;\n      const attributes = Object.entries(attrs).filter((v) => v[1]).map((v) => `${v[0]}=\"${v[1] === true ? \"\" : v[1]}\"`).join(\" \");\n      result += `<${token.tagName}${attributes ? \" \" + attributes : \"\"}>${renderVTTTokensString(\n        token.children\n      )}</${token.tagName}>`;\n    }\n  }\n  return result;\n}\nfunction updateTimedVTTCueNodes(root, currentTime) {\n  if (IS_SERVER)\n    return;\n  for (const el of root.querySelectorAll('[data-part=\"timed\"]')) {\n    const time = Number(el.getAttribute(\"data-time\"));\n    if (Number.isNaN(time))\n      continue;\n    if (time > currentTime)\n      setDataAttr(el, \"future\");\n    else\n      el.removeAttribute(\"data-future\");\n    if (time < currentTime)\n      setDataAttr(el, \"past\");\n    else\n      el.removeAttribute(\"data-past\");\n  }\n}\n\nfunction debounce(fn, delay) {\n  let timeout = null, args;\n  function run() {\n    clear();\n    fn(...args);\n    args = void 0;\n  }\n  function clear() {\n    clearTimeout(timeout);\n    timeout = null;\n  }\n  function debounce2() {\n    args = [].slice.call(arguments);\n    clear();\n    timeout = setTimeout(run, delay);\n  }\n  return debounce2;\n}\n\nconst STARTING_BOX = Symbol(\"STARTING_BOX\" );\nfunction createBox(box) {\n  if (box instanceof HTMLElement) {\n    return {\n      top: box.offsetTop,\n      width: box.clientWidth,\n      height: box.clientHeight,\n      left: box.offsetLeft,\n      right: box.offsetLeft + box.clientWidth,\n      bottom: box.offsetTop + box.clientHeight\n    };\n  }\n  return { ...box };\n}\nfunction moveBox(box, axis, delta) {\n  switch (axis) {\n    case \"+x\":\n      box.left += delta;\n      box.right += delta;\n      break;\n    case \"-x\":\n      box.left -= delta;\n      box.right -= delta;\n      break;\n    case \"+y\":\n      box.top += delta;\n      box.bottom += delta;\n      break;\n    case \"-y\":\n      box.top -= delta;\n      box.bottom -= delta;\n      break;\n  }\n}\nfunction isBoxCollision(a, b) {\n  return a.left <= b.right && a.right >= b.left && a.top <= b.bottom && a.bottom >= b.top;\n}\nfunction isAnyBoxCollision(box, boxes) {\n  for (let i = 0; i < boxes.length; i++)\n    if (isBoxCollision(box, boxes[i]))\n      return boxes[i];\n  return null;\n}\nfunction isWithinBox(container, box) {\n  return box.top >= 0 && box.bottom <= container.height && box.left >= 0 && box.right <= container.width;\n}\nfunction isBoxOutOfBounds(container, box, axis) {\n  switch (axis) {\n    case \"+x\":\n      return box.left < 0;\n    case \"-x\":\n      return box.right > container.width;\n    case \"+y\":\n      return box.top < 0;\n    case \"-y\":\n      return box.bottom > container.height;\n  }\n}\nfunction calcBoxIntersectPercentage(container, box) {\n  const x = Math.max(0, Math.min(container.width, box.right) - Math.max(0, box.left)), y = Math.max(0, Math.min(container.height, box.bottom) - Math.max(0, box.top)), intersectArea = x * y;\n  return intersectArea / (container.height * container.width);\n}\nfunction createCSSBox(container, box) {\n  return {\n    top: box.top / container.height,\n    left: box.left / container.width,\n    right: (container.width - box.right) / container.width,\n    bottom: (container.height - box.bottom) / container.height\n  };\n}\nfunction resolveRelativeBox(container, box) {\n  box.top = box.top * container.height;\n  box.left = box.left * container.width;\n  box.right = container.width - box.right * container.width;\n  box.bottom = container.height - box.bottom * container.height;\n  return box;\n}\nconst BOX_SIDES = [\"top\", \"left\", \"right\", \"bottom\"];\nfunction setBoxCSSVars(el, container, box, prefix) {\n  const cssBox = createCSSBox(container, box);\n  for (const side of BOX_SIDES) {\n    setCSSVar(el, `${prefix}-${side}`, cssBox[side] * 100 + \"%\");\n  }\n}\nfunction avoidBoxCollisions(container, box, boxes, axis) {\n  let percentage = 1, positionedBox, startBox = { ...box };\n  for (let i = 0; i < axis.length; i++) {\n    while (isBoxOutOfBounds(container, box, axis[i]) || isWithinBox(container, box) && isAnyBoxCollision(box, boxes)) {\n      moveBox(box, axis[i], 1);\n    }\n    if (isWithinBox(container, box))\n      return box;\n    const intersection = calcBoxIntersectPercentage(container, box);\n    if (percentage > intersection) {\n      positionedBox = { ...box };\n      percentage = intersection;\n    }\n    box = { ...startBox };\n  }\n  return positionedBox || startBox;\n}\n\nconst POSITION_OVERRIDE = Symbol(\"POSITION_OVERRIDE\" );\nfunction positionCue(container, cue, displayEl, boxes) {\n  let cueEl = displayEl.firstElementChild, line = computeCueLine(cue), displayBox, axis = [];\n  if (!displayEl[STARTING_BOX]) {\n    displayEl[STARTING_BOX] = createStartingBox(container, displayEl);\n  }\n  displayBox = resolveRelativeBox(container, { ...displayEl[STARTING_BOX] });\n  if (displayEl[POSITION_OVERRIDE]) {\n    axis = [displayEl[POSITION_OVERRIDE] === \"top\" ? \"+y\" : \"-y\", \"+x\", \"-x\"];\n  } else if (cue.snapToLines) {\n    let size;\n    switch (cue.vertical) {\n      case \"\":\n        axis = [\"+y\", \"-y\"];\n        size = \"height\";\n        break;\n      case \"rl\":\n        axis = [\"+x\", \"-x\"];\n        size = \"width\";\n        break;\n      case \"lr\":\n        axis = [\"-x\", \"+x\"];\n        size = \"width\";\n        break;\n    }\n    let step = getLineHeight(cueEl), position = step * Math.round(line), maxPosition = container[size] + step, initialAxis = axis[0];\n    if (Math.abs(position) > maxPosition) {\n      position = position < 0 ? -1 : 1;\n      position *= Math.ceil(maxPosition / step) * step;\n    }\n    if (line < 0) {\n      position += cue.vertical === \"\" ? container.height : container.width;\n      axis = axis.reverse();\n    }\n    moveBox(displayBox, initialAxis, position);\n  } else {\n    const isHorizontal = cue.vertical === \"\", posAxis = isHorizontal ? \"+y\" : \"+x\", size = isHorizontal ? displayBox.height : displayBox.width;\n    moveBox(\n      displayBox,\n      posAxis,\n      (isHorizontal ? container.height : container.width) * line / 100\n    );\n    moveBox(\n      displayBox,\n      posAxis,\n      cue.lineAlign === \"center\" ? size / 2 : cue.lineAlign === \"end\" ? size : 0\n    );\n    axis = isHorizontal ? [\"-y\", \"+y\", \"-x\", \"+x\"] : [\"-x\", \"+x\", \"-y\", \"+y\"];\n  }\n  displayBox = avoidBoxCollisions(container, displayBox, boxes, axis);\n  setBoxCSSVars(displayEl, container, displayBox, \"cue\");\n  return displayBox;\n}\nfunction createStartingBox(container, cueEl) {\n  const box = createBox(cueEl), pos = getStyledPositions(cueEl);\n  cueEl[POSITION_OVERRIDE] = false;\n  if (pos.top) {\n    box.top = pos.top;\n    box.bottom = pos.top + box.height;\n    cueEl[POSITION_OVERRIDE] = \"top\";\n  }\n  if (pos.bottom) {\n    const bottom = container.height - pos.bottom;\n    box.top = bottom - box.height;\n    box.bottom = bottom;\n    cueEl[POSITION_OVERRIDE] = \"bottom\";\n  }\n  if (pos.left)\n    box.left = pos.left;\n  if (pos.right)\n    box.right = container.width - pos.right;\n  return createCSSBox(container, box);\n}\nfunction getStyledPositions(el) {\n  const positions = {};\n  for (const side of BOX_SIDES) {\n    positions[side] = parseFloat(el.style.getPropertyValue(`--cue-${side}`));\n  }\n  return positions;\n}\nfunction computeCueLine(cue) {\n  if (cue.line === \"auto\") {\n    if (!cue.snapToLines) {\n      return 100;\n    } else {\n      return -1;\n    }\n  }\n  return cue.line;\n}\nfunction computeCuePosition(cue) {\n  if (cue.position === \"auto\") {\n    switch (cue.align) {\n      case \"start\":\n      case \"left\":\n        return 0;\n      case \"right\":\n      case \"end\":\n        return 100;\n      default:\n        return 50;\n    }\n  }\n  return cue.position;\n}\nfunction computeCuePositionAlignment(cue, dir) {\n  if (cue.positionAlign === \"auto\") {\n    switch (cue.align) {\n      case \"start\":\n        return dir === \"ltr\" ? \"line-left\" : \"line-right\";\n      case \"end\":\n        return dir === \"ltr\" ? \"line-right\" : \"line-left\";\n      case \"center\":\n        return \"center\";\n      default:\n        return `line-${cue.align}`;\n    }\n  }\n  return cue.positionAlign;\n}\n\nconst REGION_AXIS = [\"-y\", \"+y\", \"-x\", \"+x\"];\nfunction positionRegion(container, region, regionEl, boxes) {\n  let cues = Array.from(regionEl.querySelectorAll('[data-part=\"cue-display\"]')), height = 0, limit = Math.max(0, cues.length - region.lines);\n  for (let i = cues.length - 1; i >= limit; i--) {\n    height += cues[i].offsetHeight;\n  }\n  setCSSVar(regionEl, \"region-height\", height + \"px\");\n  if (!regionEl[STARTING_BOX]) {\n    regionEl[STARTING_BOX] = createCSSBox(container, createBox(regionEl));\n  }\n  let box = { ...regionEl[STARTING_BOX] };\n  box = resolveRelativeBox(container, box);\n  box.width = regionEl.clientWidth;\n  box.height = height;\n  box.right = box.left + box.width;\n  box.bottom = box.top + height;\n  box = avoidBoxCollisions(container, box, boxes, REGION_AXIS);\n  setBoxCSSVars(regionEl, container, box, \"region\");\n  return box;\n}\n\nclass CaptionsRenderer {\n  overlay;\n  _overlayBox;\n  _currentTime = 0;\n  _dir = \"ltr\";\n  _activeCues = [];\n  _isResizing = false;\n  _resizeObserver;\n  _regions = /* @__PURE__ */ new Map();\n  _cues = /* @__PURE__ */ new Map();\n  /* Text direction. */\n  get dir() {\n    return this._dir;\n  }\n  set dir(dir) {\n    this._dir = dir;\n    setDataAttr(this.overlay, \"dir\", dir);\n  }\n  get currentTime() {\n    return this._currentTime;\n  }\n  set currentTime(time) {\n    this._currentTime = time;\n    this.update();\n  }\n  constructor(overlay, init) {\n    this.overlay = overlay;\n    this.dir = init?.dir ?? \"ltr\";\n    overlay.setAttribute(\"translate\", \"yes\");\n    overlay.setAttribute(\"aria-live\", \"off\");\n    overlay.setAttribute(\"aria-atomic\", \"true\");\n    setPartAttr(overlay, \"captions\");\n    this._updateOverlay();\n    this._resizeObserver = new ResizeObserver(this._resizing.bind(this));\n    this._resizeObserver.observe(overlay);\n  }\n  changeTrack({ regions, cues }) {\n    this.reset();\n    this._buildRegions(regions);\n    for (const cue of cues)\n      this._cues.set(cue, null);\n    this.update();\n  }\n  addCue(cue) {\n    this._cues.set(cue, null);\n    this.update();\n  }\n  removeCue(cue) {\n    this._cues.delete(cue);\n    this.update();\n  }\n  update(forceUpdate = false) {\n    this._render(forceUpdate);\n  }\n  reset() {\n    this._cues.clear();\n    this._regions.clear();\n    this._activeCues = [];\n    this.overlay.textContent = \"\";\n  }\n  destroy() {\n    this.reset();\n    this._resizeObserver.disconnect();\n  }\n  _resizing() {\n    this._isResizing = true;\n    this._resize();\n  }\n  _resize = debounce(() => {\n    this._isResizing = false;\n    this._updateOverlay();\n    for (const el of this._regions.values()) {\n      el[STARTING_BOX] = null;\n    }\n    for (const el of this._cues.values()) {\n      if (el)\n        el[STARTING_BOX] = null;\n    }\n    this._render(true);\n  }, 50);\n  _updateOverlay() {\n    this._overlayBox = createBox(this.overlay);\n    setCSSVar(this.overlay, \"overlay-width\", this._overlayBox.width + \"px\");\n    setCSSVar(this.overlay, \"overlay-height\", this._overlayBox.height + \"px\");\n  }\n  _render(forceUpdate = false) {\n    if (!this._cues.size || this._isResizing)\n      return;\n    let cue, activeCues = [...this._cues.keys()].filter((cue2) => this._currentTime >= cue2.startTime && this._currentTime <= cue2.endTime).sort(\n      (cueA, cueB) => cueA.startTime !== cueB.startTime ? cueA.startTime - cueB.startTime : cueA.endTime - cueB.endTime\n    ), activeRegions = activeCues.map((cue2) => cue2.region);\n    for (let i = 0; i < this._activeCues.length; i++) {\n      cue = this._activeCues[i];\n      if (activeCues[i] === cue)\n        continue;\n      if (cue.region && !activeRegions.includes(cue.region)) {\n        const regionEl = this._regions.get(cue.region.id);\n        if (regionEl) {\n          regionEl.removeAttribute(\"data-active\");\n          forceUpdate = true;\n        }\n      }\n      const cueEl = this._cues.get(cue);\n      if (cueEl) {\n        cueEl.remove();\n        forceUpdate = true;\n      }\n    }\n    for (let i = 0; i < activeCues.length; i++) {\n      cue = activeCues[i];\n      let cueEl = this._cues.get(cue);\n      if (!cueEl)\n        this._cues.set(cue, cueEl = this._createCueElement(cue));\n      const regionEl = this._hasRegion(cue) && this._regions.get(cue.region.id);\n      if (regionEl && !regionEl.hasAttribute(\"data-active\")) {\n        requestAnimationFrame(() => setDataAttr(regionEl, \"active\"));\n        forceUpdate = true;\n      }\n      if (!cueEl.isConnected) {\n        (regionEl || this.overlay).append(cueEl);\n        forceUpdate = true;\n      }\n    }\n    if (forceUpdate) {\n      const boxes = [], seen = /* @__PURE__ */ new Set();\n      for (let i = activeCues.length - 1; i >= 0; i--) {\n        cue = activeCues[i];\n        if (seen.has(cue.region || cue))\n          continue;\n        const isRegion = this._hasRegion(cue), el = isRegion ? this._regions.get(cue.region.id) : this._cues.get(cue);\n        if (isRegion) {\n          boxes.push(positionRegion(this._overlayBox, cue.region, el, boxes));\n        } else {\n          boxes.push(positionCue(this._overlayBox, cue, el, boxes));\n        }\n        seen.add(isRegion ? cue.region : cue);\n      }\n    }\n    updateTimedVTTCueNodes(this.overlay, this._currentTime);\n    this._activeCues = activeCues;\n  }\n  _buildRegions(regions) {\n    if (!regions)\n      return;\n    for (const region of regions) {\n      const el = this._createRegionElement(region);\n      this._regions.set(region.id, el);\n      this.overlay.append(el);\n    }\n  }\n  _createRegionElement(region) {\n    const el = document.createElement(\"div\");\n    setPartAttr(el, \"region\");\n    setDataAttr(el, \"id\", region.id);\n    setDataAttr(el, \"scroll\", region.scroll);\n    setCSSVar(el, \"region-width\", region.width + \"%\");\n    setCSSVar(el, \"region-anchor-x\", region.regionAnchorX);\n    setCSSVar(el, \"region-anchor-y\", region.regionAnchorY);\n    setCSSVar(el, \"region-viewport-anchor-x\", region.viewportAnchorX);\n    setCSSVar(el, \"region-viewport-anchor-y\", region.viewportAnchorY);\n    setCSSVar(el, \"region-lines\", region.lines);\n    return el;\n  }\n  _createCueElement(cue) {\n    const display = document.createElement(\"div\"), position = computeCuePosition(cue), positionAlignment = computeCuePositionAlignment(cue, this._dir);\n    setPartAttr(display, \"cue-display\");\n    if (cue.vertical !== \"\")\n      setDataAttr(display, \"vertical\");\n    setCSSVar(display, \"cue-text-align\", cue.align);\n    if (cue.style) {\n      for (const prop of Object.keys(cue.style)) {\n        display.style.setProperty(prop, cue.style[prop]);\n      }\n    }\n    if (!this._hasRegion(cue)) {\n      setCSSVar(\n        display,\n        \"cue-writing-mode\",\n        cue.vertical === \"\" ? \"horizontal-tb\" : cue.vertical === \"lr\" ? \"vertical-lr\" : \"vertical-rl\"\n      );\n      if (!cue.style?.[\"--cue-width\"]) {\n        let maxSize = position;\n        if (positionAlignment === \"line-left\") {\n          maxSize = 100 - position;\n        } else if (positionAlignment === \"center\" && position <= 50) {\n          maxSize = position * 2;\n        } else if (positionAlignment === \"center\" && position > 50) {\n          maxSize = (100 - position) * 2;\n        }\n        const size = cue.size < maxSize ? cue.size : maxSize;\n        if (cue.vertical === \"\")\n          setCSSVar(display, \"cue-width\", size + \"%\");\n        else\n          setCSSVar(display, \"cue-height\", size + \"%\");\n      }\n    } else {\n      setCSSVar(\n        display,\n        \"cue-offset\",\n        `${position - (positionAlignment === \"line-right\" ? 100 : positionAlignment === \"center\" ? 50 : 0)}%`\n      );\n    }\n    const el = document.createElement(\"div\");\n    setPartAttr(el, \"cue\");\n    if (cue.id)\n      setDataAttr(el, \"id\", cue.id);\n    el.innerHTML = renderVTTCueString(cue);\n    display.append(el);\n    return display;\n  }\n  _hasRegion(cue) {\n    return cue.region && cue.size === 100 && cue.vertical === \"\" && cue.line === \"auto\";\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tZWRpYS1jYXB0aW9ucy9kaXN0L2Rldi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxUUFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFRQUF5QjtBQUNsRDtBQUNBO0FBQ0EsOERBQThELG1CQUFtQjtBQUNqRjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFdBQVcsMENBQTBDLFdBQVc7QUFDekg7QUFDQSxPQUFPO0FBQ1A7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsUUFBUTtBQUNSLE9BQU87QUFDUCxPQUFPO0FBQ1AsU0FBUztBQUNULFFBQVE7QUFDUixTQUFTO0FBQ1QsUUFBUTtBQUNSLFFBQVE7QUFDUixDQUFDLDhEQUE4RDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1C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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkJBQTZCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdHQUFnRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyWCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXG1lZGlhLWNhcHRpb25zXFxkaXN0XFxkZXZcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFBhcnNlRXJyb3JDb2RlID0ge1xuICBMb2FkRmFpbDogMCxcbiAgQmFkU2lnbmF0dXJlOiAxLFxuICBCYWRUaW1lc3RhbXA6IDIsXG4gIEJhZFNldHRpbmdWYWx1ZTogMyxcbiAgQmFkRm9ybWF0OiA0LFxuICBVbmtub3duU2V0dGluZzogNVxufTtcbmNsYXNzIFBhcnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU7XG4gIGxpbmU7XG4gIGNvbnN0cnVjdG9yKGluaXQpIHtcbiAgICBzdXBlcihpbml0LnJlYXNvbik7XG4gICAgdGhpcy5jb2RlID0gaW5pdC5jb2RlO1xuICAgIHRoaXMubGluZSA9IGluaXQubGluZTtcbiAgfVxufVxuXG5jb25zdCBMSU5FX1RFUk1JTkFUT1JfUkUgPSAvXFxyP1xcbnxcXHIvZ207XG5jbGFzcyBUZXh0TGluZVRyYW5zZm9ybVN0cmVhbSB7XG4gIHdyaXRhYmxlO1xuICByZWFkYWJsZTtcbiAgY29uc3RydWN0b3IoZW5jb2RpbmcpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IG5ldyBUZXh0U3RyZWFtTGluZUl0ZXJhdG9yKGVuY29kaW5nKTtcbiAgICB0aGlzLndyaXRhYmxlID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgIHRyYW5zZm9ybWVyLnRyYW5zZm9ybShjaHVuayk7XG4gICAgICB9LFxuICAgICAgY2xvc2UoKSB7XG4gICAgICAgIHRyYW5zZm9ybWVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5yZWFkYWJsZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgIHRyYW5zZm9ybWVyLm9uTGluZSA9IChsaW5lKSA9PiBjb250cm9sbGVyLmVucXVldWUobGluZSk7XG4gICAgICAgIHRyYW5zZm9ybWVyLm9uQ2xvc2UgPSAoKSA9PiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFRleHRTdHJlYW1MaW5lSXRlcmF0b3Ige1xuICBfYnVmZmVyID0gXCJcIjtcbiAgX2RlY29kZXI7XG4gIG9uTGluZTtcbiAgb25DbG9zZTtcbiAgY29uc3RydWN0b3IoZW5jb2RpbmcpIHtcbiAgICB0aGlzLl9kZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nKTtcbiAgfVxuICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICB0aGlzLl9idWZmZXIgKz0gdGhpcy5fZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIGNvbnN0IGxpbmVzID0gdGhpcy5fYnVmZmVyLnNwbGl0KExJTkVfVEVSTUlOQVRPUl9SRSk7XG4gICAgdGhpcy5fYnVmZmVyID0gbGluZXMucG9wKCkgfHwgXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5vbkxpbmUobGluZXNbaV0udHJpbSgpKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyKVxuICAgICAgdGhpcy5vbkxpbmUodGhpcy5fYnVmZmVyLnRyaW0oKSk7XG4gICAgdGhpcy5fYnVmZmVyID0gXCJcIjtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBwYXJzZVRleHQodGV4dCwgb3B0aW9ucykge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdChMSU5FX1RFUk1JTkFUT1JfUkUpO1xuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUobGluZSk7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBhcnNlVGV4dFN0cmVhbShzdHJlYW0sIG9wdGlvbnMpO1xufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2VUZXh0U3RyZWFtKHN0cmVhbSwgb3B0aW9ucykge1xuICBjb25zdCB0eXBlID0gb3B0aW9ucz8udHlwZSA/PyBcInZ0dFwiO1xuICBsZXQgZmFjdG9yeTtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwic3J0XCI6XG4gICAgICAgIGZhY3RvcnkgPSAoYXdhaXQgaW1wb3J0KCcuL3NydC1wYXJzZXIuanMnKSkuZGVmYXVsdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic3NhXCI6XG4gICAgICBjYXNlIFwiYXNzXCI6XG4gICAgICAgIGZhY3RvcnkgPSAoYXdhaXQgaW1wb3J0KCcuL3NzYS1wYXJzZXIuanMnKSkuZGVmYXVsdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBmYWN0b3J5ID0gKGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gdnR0UGFyc2VyOyB9KSkuZGVmYXVsdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZmFjdG9yeSA9IHR5cGU7XG4gIH1cbiAgbGV0IHJlc3VsdDtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpLCBwYXJzZXIgPSBmYWN0b3J5KCksIGVycm9ycyA9IG9wdGlvbnM/LmVycm9ycyAhPT0gZmFsc2UgfHwgISFvcHRpb25zPy5zdHJpY3QgfHwgISFvcHRpb25zPy5lcnJvcnM7XG4gIGF3YWl0IHBhcnNlci5pbml0KHtcbiAgICBzdHJpY3Q6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgZXJyb3JzLFxuICAgIHR5cGUsXG4gICAgY2FuY2VsKCkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgcmVzdWx0ID0gcGFyc2VyLmRvbmUodHJ1ZSk7XG4gICAgfVxuICB9KTtcbiAgbGV0IGkgPSAxO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHBhcnNlci5wYXJzZShcIlwiLCBpKTtcbiAgICAgIHJlc3VsdCA9IHBhcnNlci5kb25lKGZhbHNlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXJzZXIucGFyc2UodmFsdWUsIGkpO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5hc3luYyBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlcyA9IGF3YWl0IHJlc3BvbnNlO1xuICBpZiAoIXJlcy5vayB8fCAhcmVzLmJvZHkpIHtcbiAgICBsZXQgZXJyb3I7XG4gICAge1xuICAgICAgZXJyb3IgPSBuZXcgUGFyc2VFcnJvcih7XG4gICAgICAgIGNvZGU6IFBhcnNlRXJyb3JDb2RlLkxvYWRGYWlsLFxuICAgICAgICByZWFzb246ICFyZXMub2sgPyBgcmVzcG9uc2UgaXMgbm90IG9rIChzdGF0dXM6ICR7cmVzLnN0YXR1c30pYCA6IGByZXNwb25zZSBib2R5IGlzIG1pc3NpbmcgKHN0YXR1czogJHtyZXMuc3RhdHVzfSlgLFxuICAgICAgICBsaW5lOiAtMVxuICAgICAgfSk7XG4gICAgICBvcHRpb25zPy5vbkVycm9yPy4oZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWV0YWRhdGE6IHt9LFxuICAgICAgY3VlczogW10sXG4gICAgICByZWdpb25zOiBbXSxcbiAgICAgIGVycm9yczogW2Vycm9yXVxuICAgIH07XG4gIH1cbiAgY29uc3QgY29udGVudFR5cGUgPSByZXMuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIiwgdHlwZSA9IGNvbnRlbnRUeXBlLm1hdGNoKC90ZXh0XFwvKC4qPykoPzo7fCQpLyk/LlsxXSwgZW5jb2RpbmcgPSBjb250ZW50VHlwZS5tYXRjaCgvY2hhcnNldD0oLio/KSg/Ojt8JCkvKT8uWzFdO1xuICByZXR1cm4gcGFyc2VCeXRlU3RyZWFtKHJlcy5ib2R5LCB7IHR5cGUsIGVuY29kaW5nLCAuLi5vcHRpb25zIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2VCeXRlU3RyZWFtKHN0cmVhbSwgeyBlbmNvZGluZyA9IFwidXRmLThcIiwgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgY29uc3QgdGV4dFN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dExpbmVUcmFuc2Zvcm1TdHJlYW0oZW5jb2RpbmcpKTtcbiAgcmV0dXJuIHBhcnNlVGV4dFN0cmVhbSh0ZXh0U3RyZWFtLCBvcHRpb25zKTtcbn1cblxuY2xhc3MgVGV4dEN1ZSBleHRlbmRzIEV2ZW50VGFyZ2V0IHtcbiAgLyoqXG4gICAqIEEgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGUgY3VlLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dFRyYWNrQ3VlL2lkfVxuICAgKi9cbiAgaWQgPSBcIlwiO1xuICAvKipcbiAgICogQSBgZG91YmxlYCB0aGF0IHJlcHJlc2VudHMgdGhlIHZpZGVvIHRpbWUgdGhhdCB0aGUgY3VlIHdpbGwgc3RhcnQgYmVpbmcgZGlzcGxheWVkLCBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dFRyYWNrQ3VlL3N0YXJ0VGltZX1cbiAgICovXG4gIHN0YXJ0VGltZTtcbiAgLyoqXG4gICAqIEEgYGRvdWJsZWAgdGhhdCByZXByZXNlbnRzIHRoZSB2aWRlbyB0aW1lIHRoYXQgdGhlIGN1ZSB3aWxsIHN0b3AgYmVpbmcgZGlzcGxheWVkLCBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVGV4dFRyYWNrQ3VlL2VuZFRpbWV9XG4gICAqL1xuICBlbmRUaW1lO1xuICAvKipcbiAgICogUmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBjb250ZW50cyBvZiB0aGUgY3VlLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVlRUQ3VlL3RleHR9XG4gICAqL1xuICB0ZXh0O1xuICAvKipcbiAgICogQSBgYm9vbGVhbmAgZm9yIHdoZXRoZXIgdGhlIHZpZGVvIHdpbGwgcGF1c2Ugd2hlbiB0aGlzIGN1ZSBzdG9wcyBiZWluZyBkaXNwbGF5ZWQuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0VHJhY2tDdWUvcGF1c2VPbkV4aXR9XG4gICAqL1xuICBwYXVzZU9uRXhpdCA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcihzdGFydFRpbWUsIGVuZFRpbWUsIHRleHQpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgIHRoaXMuZW5kVGltZSA9IGVuZFRpbWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgc3VwZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHN1cGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICB9XG59XG5cbmNvbnN0IElTX1NFUlZFUiA9IHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIjtcblxuY29uc3QgQ3VlQmFzZSA9IElTX1NFUlZFUiA/IFRleHRDdWUgOiB3aW5kb3cuVlRUQ3VlO1xuY2xhc3MgVlRUQ3VlIGV4dGVuZHMgQ3VlQmFzZSB7XG4gIC8qKlxuICAgKiBBIGBWVFRSZWdpb25gIG9iamVjdCBkZXNjcmliaW5nIHRoZSB2aWRlbydzIHN1Yi1yZWdpb24gdGhhdCB0aGUgY3VlIHdpbGwgYmUgZHJhd24gb250byxcbiAgICogb3IgYG51bGxgIGlmIG5vbmUgaXMgYXNzaWduZWQuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9WVFRDdWUvcmVnaW9ufVxuICAgKi9cbiAgcmVnaW9uID0gbnVsbDtcbiAgLyoqXG4gICAqIFRoZSBjdWUgd3JpdGluZyBkaXJlY3Rpb24uXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9WVFRDdWUvdmVydGljYWx9XG4gICAqL1xuICB2ZXJ0aWNhbCA9IFwiXCI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYFZUVEN1ZS5saW5lYCBhdHRyaWJ1dGUgaXMgYW4gaW50ZWdlciBudW1iZXIgb2YgbGluZXMgb3IgYSBwZXJjZW50YWdlXG4gICAqIG9mIHRoZSB2aWRlbyBzaXplLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVlRUQ3VlL3NuYXBUb0xpbmVzfVxuICAgKi9cbiAgc25hcFRvTGluZXMgPSB0cnVlO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGluZSBwb3NpdGlvbmluZyBvZiB0aGUgY3VlLiBUaGlzIGNhbiBiZSB0aGUgc3RyaW5nIGAnYXV0bydgIG9yIGEgbnVtYmVyIHdob3NlXG4gICAqIGludGVycHJldGF0aW9uIGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIGBWVFRDdWUuc25hcFRvTGluZXNgLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVlRUQ3VlL2xpbmV9XG4gICAqL1xuICBsaW5lID0gXCJhdXRvXCI7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVudW0gcmVwcmVzZW50aW5nIHRoZSBhbGlnbm1lbnQgb2YgdGhlIGBWVFRDdWUubGluZWAuXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9WVFRDdWUvbGluZUFsaWdufVxuICAgKi9cbiAgbGluZUFsaWduID0gXCJzdGFydFwiO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgaW5kZW50YXRpb24gb2YgdGhlIGN1ZSB3aXRoaW4gdGhlIGxpbmUuIFRoaXMgY2FuIGJlIHRoZSBzdHJpbmcgYCdhdXRvJ2Agb3IgYVxuICAgKiBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBgVlRUQ3VlLnJlZ2lvbmAsIG9yIHRoZSB2aWRlbyBzaXplIGlmIGBWVFRDdWVgLnJlZ2lvbmBcbiAgICogaXMgYG51bGxgLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVlRUQ3VlL3Bvc2l0aW9ufVxuICAgKi9cbiAgcG9zaXRpb24gPSBcImF1dG9cIjtcbiAgLyoqXG4gICAqIFJldHVybnMgYW4gZW51bSByZXByZXNlbnRpbmcgdGhlIGFsaWdubWVudCBvZiB0aGUgY3VlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoYXRcbiAgICogdGhlIGBWVFRDdWUucG9zaXRpb25gIGlzIGFuY2hvcmVkIHRvLiBUaGUgZGVmYXVsdCBpcyBgJ2F1dG8nYC5cbiAgICpcbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1ZUVEN1ZS9wb3NpdGlvbkFsaWdufVxuICAgKi9cbiAgcG9zaXRpb25BbGlnbiA9IFwiYXV0b1wiO1xuICAvKipcbiAgICogUmV0dXJucyBhIGRvdWJsZSByZXByZXNlbnRpbmcgdGhlIHNpemUgb2YgdGhlIGN1ZSwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSB2aWRlbyBzaXplLlxuICAgKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVlRUQ3VlL3NpemV9XG4gICAqL1xuICBzaXplID0gMTAwO1xuICAvKipcbiAgICogUmV0dXJucyBhbiBlbnVtIHJlcHJlc2VudGluZyB0aGUgYWxpZ25tZW50IG9mIGFsbCB0aGUgbGluZXMgb2YgdGV4dCB3aXRoaW4gdGhlIGN1ZSBib3guXG4gICAqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9WVFRDdWUvYWxpZ259XG4gICAqL1xuICBhbGlnbiA9IFwiY2VudGVyXCI7XG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIHN0eWxlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1ZS5cbiAgICovXG4gIHN0eWxlO1xufVxuXG5jbGFzcyBWVFRSZWdpb24ge1xuICAvKipcbiAgICogQSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoZSByZWdpb24uXG4gICAqL1xuICBpZCA9IFwiXCI7XG4gIC8qKlxuICAgKiBBIGBkb3VibGVgIHJlcHJlc2VudGluZyB0aGUgd2lkdGggb2YgdGhlIHJlZ2lvbiwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSB2aWRlby5cbiAgICovXG4gIHdpZHRoID0gMTAwO1xuICAvKipcbiAgICogQSBgZG91YmxlYCByZXByZXNlbnRpbmcgdGhlIGhlaWdodCBvZiB0aGUgcmVnaW9uLCBpbiBudW1iZXIgb2YgbGluZXMuXG4gICAqL1xuICBsaW5lcyA9IDM7XG4gIC8qKlxuICAgKiBBIGBkb3VibGVgIHJlcHJlc2VudGluZyB0aGUgcmVnaW9uIGFuY2hvciBYIG9mZnNldCwgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSByZWdpb24uXG4gICAqL1xuICByZWdpb25BbmNob3JYID0gMDtcbiAgLyoqXG4gICAqIEEgYGRvdWJsZWAgcmVwcmVzZW50aW5nIHRoZSByZWdpb24gYW5jaG9yIFkgb2Zmc2V0LCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHJlZ2lvbi5cbiAgICovXG4gIHJlZ2lvbkFuY2hvclkgPSAxMDA7XG4gIC8qKlxuICAgKiBBIGBkb3VibGVgIHJlcHJlc2VudGluZyB0aGUgdmlld3BvcnQgYW5jaG9yIFggb2Zmc2V0LCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIHZpZGVvLlxuICAgKi9cbiAgdmlld3BvcnRBbmNob3JYID0gMDtcbiAgLyoqXG4gICAqIEEgYGRvdWJsZWAgcmVwcmVzZW50aW5nIHRoZSB2aWV3cG9ydCBhbmNob3IgWSBvZmZzZXQsIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgdmlkZW8uXG4gICAqL1xuICB2aWV3cG9ydEFuY2hvclkgPSAxMDA7XG4gIC8qKlxuICAgKiBBbiBlbnVtIHJlcHJlc2VudGluZyBob3cgYWRkaW5nIG5ldyBjdWVzIHdpbGwgbW92ZSBleGlzdGluZyBjdWVzLlxuICAgKi9cbiAgc2Nyb2xsID0gXCJcIjtcbn1cblxuY29uc3QgQ09NTUEkMSA9IFwiLFwiLCBQRVJDRU5UX1NJR04kMSA9IFwiJVwiO1xuZnVuY3Rpb24gdG9OdW1iZXIodGV4dCkge1xuICBjb25zdCBudW0gPSBwYXJzZUludCh0ZXh0LCAxMCk7XG4gIHJldHVybiAhTnVtYmVyLmlzTmFOKG51bSkgPyBudW0gOiBudWxsO1xufVxuZnVuY3Rpb24gdG9QZXJjZW50YWdlKHRleHQpIHtcbiAgY29uc3QgbnVtID0gcGFyc2VJbnQodGV4dC5yZXBsYWNlKFBFUkNFTlRfU0lHTiQxLCBcIlwiKSwgMTApO1xuICByZXR1cm4gIU51bWJlci5pc05hTihudW0pICYmIG51bSA+PSAwICYmIG51bSA8PSAxMDAgPyBudW0gOiBudWxsO1xufVxuZnVuY3Rpb24gdG9Db29yZHModGV4dCkge1xuICBpZiAoIXRleHQuaW5jbHVkZXMoQ09NTUEkMSkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IFt4LCB5XSA9IHRleHQuc3BsaXQoQ09NTUEkMSkubWFwKHRvUGVyY2VudGFnZSk7XG4gIHJldHVybiB4ICE9PSBudWxsICYmIHkgIT09IG51bGwgPyBbeCwgeV0gOiBudWxsO1xufVxuZnVuY3Rpb24gdG9GbG9hdCh0ZXh0KSB7XG4gIGNvbnN0IG51bSA9IHBhcnNlRmxvYXQodGV4dCk7XG4gIHJldHVybiAhTnVtYmVyLmlzTmFOKG51bSkgPyBudW0gOiBudWxsO1xufVxuXG5jb25zdCBIRUFERVJfTUFHSUMgPSBcIldFQlZUVFwiLCBDT01NQSA9IFwiLFwiLCBQRVJDRU5UX1NJR04gPSBcIiVcIiwgU0VUVElOR19TRVBfUkUgPSAvWzo9XS8sIFNFVFRJTkdfTElORV9SRSA9IC9eW1xcc1xcdF0qKHJlZ2lvbnx2ZXJ0aWNhbHxsaW5lfHBvc2l0aW9ufHNpemV8YWxpZ24pWzo9XS8sIE5PVEVfQkxPQ0tfU1RBUlQgPSBcIk5PVEVcIiwgUkVHSU9OX0JMT0NLX1NUQVJUID0gXCJSRUdJT05cIiwgUkVHSU9OX0JMT0NLX1NUQVJUX1JFID0gL15SRUdJT046P1tcXHNcXHRdKy8sIFNQQUNFX1JFID0gL1tcXHNcXHRdKy8sIFRJTUVTVEFNUF9TRVAgPSBcIi0tPlwiLCBUSU1FU1RBTVBfU0VQX1JFID0gL1tcXHNcXHRdKi0tPltcXHNcXHRdKy8sIEFMSUdOX1JFID0gL3N0YXJ0fGNlbnRlcnxlbmR8bGVmdHxyaWdodC8sIExJTkVfQUxJR05fUkUgPSAvc3RhcnR8Y2VudGVyfGVuZC8sIFBPU19BTElHTl9SRSA9IC9saW5lLSg/OmxlZnR8cmlnaHQpfGNlbnRlcnxhdXRvLywgVElNRVNUQU1QX1JFID0gL14oPzooXFxkezEsMn0pOik/KFxcZHsyfSk6KFxcZHsyfSkoPzpcXC4oXFxkezEsM30pKT8kLztcbnZhciBWVFRCbG9jayA9IC8qIEBfX1BVUkVfXyAqLyAoKFZUVEJsb2NrMikgPT4ge1xuICBWVFRCbG9jazJbVlRUQmxvY2syW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIFZUVEJsb2NrMltWVFRCbG9jazJbXCJIZWFkZXJcIl0gPSAxXSA9IFwiSGVhZGVyXCI7XG4gIFZUVEJsb2NrMltWVFRCbG9jazJbXCJDdWVcIl0gPSAyXSA9IFwiQ3VlXCI7XG4gIFZUVEJsb2NrMltWVFRCbG9jazJbXCJSZWdpb25cIl0gPSAzXSA9IFwiUmVnaW9uXCI7XG4gIFZUVEJsb2NrMltWVFRCbG9jazJbXCJOb3RlXCJdID0gNF0gPSBcIk5vdGVcIjtcbiAgcmV0dXJuIFZUVEJsb2NrMjtcbn0pKFZUVEJsb2NrIHx8IHt9KTtcbmNsYXNzIFZUVFBhcnNlciB7XG4gIF9pbml0O1xuICBfYmxvY2sgPSAwIC8qIE5vbmUgKi87XG4gIF9tZXRhZGF0YSA9IHt9O1xuICBfcmVnaW9ucyA9IHt9O1xuICBfY3VlcyA9IFtdO1xuICBfY3VlID0gbnVsbDtcbiAgX3JlZ2lvbiA9IG51bGw7XG4gIF9lcnJvcnMgPSBbXTtcbiAgX2Vycm9yQnVpbGRlcjtcbiAgX3ByZXZMaW5lID0gXCJcIjtcbiAgYXN5bmMgaW5pdChpbml0KSB7XG4gICAgdGhpcy5faW5pdCA9IGluaXQ7XG4gICAgaWYgKGluaXQuc3RyaWN0KVxuICAgICAgdGhpcy5fYmxvY2sgPSAxIC8qIEhlYWRlciAqLztcbiAgICBpZiAoaW5pdC5lcnJvcnMpXG4gICAgICB0aGlzLl9lcnJvckJ1aWxkZXIgPSAoYXdhaXQgaW1wb3J0KCcuL2Vycm9ycy5qcycpKS5QYXJzZUVycm9yQnVpbGRlcjtcbiAgfVxuICBwYXJzZShsaW5lLCBsaW5lQ291bnQpIHtcbiAgICBpZiAobGluZSA9PT0gXCJcIikge1xuICAgICAgaWYgKHRoaXMuX2N1ZSkge1xuICAgICAgICB0aGlzLl9jdWVzLnB1c2godGhpcy5fY3VlKTtcbiAgICAgICAgdGhpcy5faW5pdC5vbkN1ZT8uKHRoaXMuX2N1ZSk7XG4gICAgICAgIHRoaXMuX2N1ZSA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3JlZ2lvbikge1xuICAgICAgICB0aGlzLl9yZWdpb25zW3RoaXMuX3JlZ2lvbi5pZF0gPSB0aGlzLl9yZWdpb247XG4gICAgICAgIHRoaXMuX2luaXQub25SZWdpb24/Lih0aGlzLl9yZWdpb24pO1xuICAgICAgICB0aGlzLl9yZWdpb24gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ibG9jayA9PT0gMSAvKiBIZWFkZXIgKi8pIHtcbiAgICAgICAgdGhpcy5fcGFyc2VIZWFkZXIobGluZSwgbGluZUNvdW50KTtcbiAgICAgICAgdGhpcy5faW5pdC5vbkhlYWRlck1ldGFkYXRhPy4odGhpcy5fbWV0YWRhdGEpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYmxvY2sgPSAwIC8qIE5vbmUgKi87XG4gICAgfSBlbHNlIGlmICh0aGlzLl9ibG9jaykge1xuICAgICAgc3dpdGNoICh0aGlzLl9ibG9jaykge1xuICAgICAgICBjYXNlIDEgLyogSGVhZGVyICovOlxuICAgICAgICAgIHRoaXMuX3BhcnNlSGVhZGVyKGxpbmUsIGxpbmVDb3VudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBDdWUgKi86XG4gICAgICAgICAgaWYgKHRoaXMuX2N1ZSkge1xuICAgICAgICAgICAgY29uc3QgaGFzVGV4dCA9IHRoaXMuX2N1ZS50ZXh0Lmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBpZiAoIWhhc1RleHQgJiYgU0VUVElOR19MSU5FX1JFLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcGFyc2VDdWVTZXR0aW5ncyhsaW5lLnNwbGl0KFNQQUNFX1JFKSwgbGluZUNvdW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1ZS50ZXh0ICs9IChoYXNUZXh0ID8gXCJcXG5cIiA6IFwiXCIpICsgbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMyAvKiBSZWdpb24gKi86XG4gICAgICAgICAgdGhpcy5fcGFyc2VSZWdpb25TZXR0aW5ncyhsaW5lLnNwbGl0KFNQQUNFX1JFKSwgbGluZUNvdW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChOT1RFX0JMT0NLX1NUQVJUKSkge1xuICAgICAgdGhpcy5fYmxvY2sgPSA0IC8qIE5vdGUgKi87XG4gICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoUkVHSU9OX0JMT0NLX1NUQVJUKSkge1xuICAgICAgdGhpcy5fYmxvY2sgPSAzIC8qIFJlZ2lvbiAqLztcbiAgICAgIHRoaXMuX3JlZ2lvbiA9IG5ldyBWVFRSZWdpb24oKTtcbiAgICAgIHRoaXMuX3BhcnNlUmVnaW9uU2V0dGluZ3MobGluZS5yZXBsYWNlKFJFR0lPTl9CTE9DS19TVEFSVF9SRSwgXCJcIikuc3BsaXQoU1BBQ0VfUkUpLCBsaW5lQ291bnQpO1xuICAgIH0gZWxzZSBpZiAobGluZS5pbmNsdWRlcyhUSU1FU1RBTVBfU0VQKSkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VUaW1lc3RhbXAobGluZSwgbGluZUNvdW50KTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5fY3VlID0gbmV3IFZUVEN1ZShyZXN1bHRbMF0sIHJlc3VsdFsxXSwgXCJcIik7XG4gICAgICAgIHRoaXMuX2N1ZS5pZCA9IHRoaXMuX3ByZXZMaW5lO1xuICAgICAgICB0aGlzLl9wYXJzZUN1ZVNldHRpbmdzKHJlc3VsdFsyXSwgbGluZUNvdW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Jsb2NrID0gMiAvKiBDdWUgKi87XG4gICAgfSBlbHNlIGlmIChsaW5lQ291bnQgPT09IDEpIHtcbiAgICAgIHRoaXMuX3BhcnNlSGVhZGVyKGxpbmUsIGxpbmVDb3VudCk7XG4gICAgfVxuICAgIHRoaXMuX3ByZXZMaW5lID0gbGluZTtcbiAgfVxuICBkb25lKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXRhZGF0YTogdGhpcy5fbWV0YWRhdGEsXG4gICAgICBjdWVzOiB0aGlzLl9jdWVzLFxuICAgICAgcmVnaW9uczogT2JqZWN0LnZhbHVlcyh0aGlzLl9yZWdpb25zKSxcbiAgICAgIGVycm9yczogdGhpcy5fZXJyb3JzXG4gICAgfTtcbiAgfVxuICBfcGFyc2VIZWFkZXIobGluZSwgbGluZUNvdW50KSB7XG4gICAgaWYgKGxpbmVDb3VudCA+IDEpIHtcbiAgICAgIGlmIChTRVRUSU5HX1NFUF9SRS50ZXN0KGxpbmUpKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGxpbmUuc3BsaXQoU0VUVElOR19TRVBfUkUpO1xuICAgICAgICBpZiAoa2V5KVxuICAgICAgICAgIHRoaXMuX21ldGFkYXRhW2tleV0gPSAodmFsdWUgfHwgXCJcIikucmVwbGFjZShTUEFDRV9SRSwgXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoSEVBREVSX01BR0lDKSkge1xuICAgICAgdGhpcy5fYmxvY2sgPSAxIC8qIEhlYWRlciAqLztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlRXJyb3IodGhpcy5fZXJyb3JCdWlsZGVyPy5fYmFkVlRUSGVhZGVyKCkpO1xuICAgIH1cbiAgfVxuICBfcGFyc2VUaW1lc3RhbXAobGluZSwgbGluZUNvdW50KSB7XG4gICAgY29uc3QgW3N0YXJ0VGltZVRleHQsIHRyYWlsaW5nVGV4dCA9IFwiXCJdID0gbGluZS5zcGxpdChUSU1FU1RBTVBfU0VQX1JFKSwgW2VuZFRpbWVUZXh0LCAuLi5zZXR0aW5nc1RleHRdID0gdHJhaWxpbmdUZXh0LnNwbGl0KFNQQUNFX1JFKSwgc3RhcnRUaW1lID0gcGFyc2VWVFRUaW1lc3RhbXAoc3RhcnRUaW1lVGV4dCksIGVuZFRpbWUgPSBwYXJzZVZUVFRpbWVzdGFtcChlbmRUaW1lVGV4dCk7XG4gICAgaWYgKHN0YXJ0VGltZSAhPT0gbnVsbCAmJiBlbmRUaW1lICE9PSBudWxsICYmIGVuZFRpbWUgPiBzdGFydFRpbWUpIHtcbiAgICAgIHJldHVybiBbc3RhcnRUaW1lLCBlbmRUaW1lLCBzZXR0aW5nc1RleHRdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhcnRUaW1lID09PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKHRoaXMuX2Vycm9yQnVpbGRlcj8uX2JhZFN0YXJ0VGltZXN0YW1wKHN0YXJ0VGltZVRleHQsIGxpbmVDb3VudCkpO1xuICAgICAgfVxuICAgICAgaWYgKGVuZFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IodGhpcy5fZXJyb3JCdWlsZGVyPy5fYmFkRW5kVGltZXN0YW1wKGVuZFRpbWVUZXh0LCBsaW5lQ291bnQpKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydFRpbWUgIT0gbnVsbCAmJiBlbmRUaW1lICE9PSBudWxsICYmIGVuZFRpbWUgPiBzdGFydFRpbWUpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IodGhpcy5fZXJyb3JCdWlsZGVyPy5fYmFkUmFuZ2VUaW1lc3RhbXAoc3RhcnRUaW1lLCBlbmRUaW1lLCBsaW5lQ291bnQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJ2dHQxLyNyZWdpb24tc2V0dGluZ3MtcGFyc2luZ31cbiAgICovXG4gIF9wYXJzZVJlZ2lvblNldHRpbmdzKHNldHRpbmdzLCBsaW5lKSB7XG4gICAgbGV0IGJhZFZhbHVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChTRVRUSU5HX1NFUF9SRS50ZXN0KHNldHRpbmdzW2ldKSkge1xuICAgICAgICBiYWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gc2V0dGluZ3NbaV0uc3BsaXQoU0VUVElOR19TRVBfUkUpO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICAgIHRoaXMuX3JlZ2lvbi5pZCA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHRvUGVyY2VudGFnZSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAod2lkdGggIT09IG51bGwpXG4gICAgICAgICAgICAgIHRoaXMuX3JlZ2lvbi53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBiYWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibGluZXNcIjpcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGxpbmVzICE9PSBudWxsKVxuICAgICAgICAgICAgICB0aGlzLl9yZWdpb24ubGluZXMgPSBsaW5lcztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYmFkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInJlZ2lvbmFuY2hvclwiOlxuICAgICAgICAgICAgY29uc3QgcmVnaW9uID0gdG9Db29yZHModmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlZ2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9yZWdpb24ucmVnaW9uQW5jaG9yWCA9IHJlZ2lvblswXTtcbiAgICAgICAgICAgICAgdGhpcy5fcmVnaW9uLnJlZ2lvbkFuY2hvclkgPSByZWdpb25bMV07XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgYmFkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInZpZXdwb3J0YW5jaG9yXCI6XG4gICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHRvQ29vcmRzKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2aWV3cG9ydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9yZWdpb24udmlld3BvcnRBbmNob3JYID0gdmlld3BvcnRbMF07XG4gICAgICAgICAgICAgIHRoaXMuX3JlZ2lvbi52aWV3cG9ydEFuY2hvclkgPSB2aWV3cG9ydFsxXTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBiYWRWYWx1ZSA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidXBcIilcbiAgICAgICAgICAgICAgdGhpcy5fcmVnaW9uLnNjcm9sbCA9IFwidXBcIjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgYmFkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKHRoaXMuX2Vycm9yQnVpbGRlcj8uX3Vua25vd25SZWdpb25TZXR0aW5nKG5hbWUsIHZhbHVlLCBsaW5lKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhZFZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IodGhpcy5fZXJyb3JCdWlsZGVyPy5fYmFkUmVnaW9uU2V0dGluZyhuYW1lLCB2YWx1ZSwgbGluZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvd2VidnR0MS8jY3VlLXRpbWluZ3MtYW5kLXNldHRpbmdzLXBhcnNpbmd9XG4gICAqL1xuICBfcGFyc2VDdWVTZXR0aW5ncyhzZXR0aW5ncywgbGluZSkge1xuICAgIGxldCBiYWRWYWx1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYWRWYWx1ZSA9IGZhbHNlO1xuICAgICAgaWYgKFNFVFRJTkdfU0VQX1JFLnRlc3Qoc2V0dGluZ3NbaV0pKSB7XG4gICAgICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSBzZXR0aW5nc1tpXS5zcGxpdChTRVRUSU5HX1NFUF9SRSk7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgXCJyZWdpb25cIjpcbiAgICAgICAgICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuX3JlZ2lvbnNbdmFsdWVdO1xuICAgICAgICAgICAgaWYgKHJlZ2lvbilcbiAgICAgICAgICAgICAgdGhpcy5fY3VlLnJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBcImxyXCIgfHwgdmFsdWUgPT09IFwicmxcIikge1xuICAgICAgICAgICAgICB0aGlzLl9jdWUudmVydGljYWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgdGhpcy5fY3VlLnJlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgYmFkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImxpbmVcIjpcbiAgICAgICAgICAgIGNvbnN0IFtsaW5lUG9zLCBsaW5lQWxpZ25dID0gdmFsdWUuc3BsaXQoQ09NTUEpO1xuICAgICAgICAgICAgaWYgKGxpbmVQb3MuaW5jbHVkZXMoUEVSQ0VOVF9TSUdOKSkge1xuICAgICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gdG9QZXJjZW50YWdlKGxpbmVQb3MpO1xuICAgICAgICAgICAgICBpZiAocGVyY2VudGFnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1ZS5saW5lID0gcGVyY2VudGFnZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jdWUuc25hcFRvTGluZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgYmFkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgbnVtYmVyID0gdG9GbG9hdChsaW5lUG9zKTtcbiAgICAgICAgICAgICAgaWYgKG51bWJlciAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aGlzLl9jdWUubGluZSA9IG51bWJlcjtcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChMSU5FX0FMSUdOX1JFLnRlc3QobGluZUFsaWduKSkge1xuICAgICAgICAgICAgICB0aGlzLl9jdWUubGluZUFsaWduID0gbGluZUFsaWduO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lQWxpZ24pIHtcbiAgICAgICAgICAgICAgYmFkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1ZS5saW5lICE9PSBcImF1dG9cIilcbiAgICAgICAgICAgICAgdGhpcy5fY3VlLnJlZ2lvbiA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwicG9zaXRpb25cIjpcbiAgICAgICAgICAgIGNvbnN0IFtjb2xQb3MsIGNvbEFsaWduXSA9IHZhbHVlLnNwbGl0KENPTU1BKSwgcG9zaXRpb24gPSB0b1BlcmNlbnRhZ2UoY29sUG9zKTtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiAhPT0gbnVsbClcbiAgICAgICAgICAgICAgdGhpcy5fY3VlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChjb2xBbGlnbiAmJiBQT1NfQUxJR05fUkUudGVzdChjb2xBbGlnbikpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VlLnBvc2l0aW9uQWxpZ24gPSBjb2xBbGlnbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sQWxpZ24pIHtcbiAgICAgICAgICAgICAgYmFkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNpemVcIjpcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0b1BlcmNlbnRhZ2UodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fY3VlLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICBpZiAoc2l6ZSA8IDEwMClcbiAgICAgICAgICAgICAgICB0aGlzLl9jdWUucmVnaW9uID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJhZFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJhbGlnblwiOlxuICAgICAgICAgICAgaWYgKEFMSUdOX1JFLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX2N1ZS5hbGlnbiA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmFkVmFsdWUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKHRoaXMuX2Vycm9yQnVpbGRlcj8uX3Vua25vd25DdWVTZXR0aW5nKG5hbWUsIHZhbHVlLCBsaW5lKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhZFZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IodGhpcy5fZXJyb3JCdWlsZGVyPy5fYmFkQ3VlU2V0dGluZyhuYW1lLCB2YWx1ZSwgbGluZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9oYW5kbGVFcnJvcihlcnJvcikge1xuICAgIGlmICghZXJyb3IpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIGlmICh0aGlzLl9pbml0LnN0cmljdCkge1xuICAgICAgdGhpcy5faW5pdC5jYW5jZWwoKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbml0Lm9uRXJyb3I/LihlcnJvcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwYXJzZVZUVFRpbWVzdGFtcCh0aW1lc3RhbXApIHtcbiAgY29uc3QgbWF0Y2ggPSB0aW1lc3RhbXAubWF0Y2goVElNRVNUQU1QX1JFKTtcbiAgaWYgKCFtYXRjaClcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgaG91cnMgPSBtYXRjaFsxXSA/IHBhcnNlSW50KG1hdGNoWzFdLCAxMCkgOiAwLCBtaW51dGVzID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKSwgc2Vjb25kcyA9IHBhcnNlSW50KG1hdGNoWzNdLCAxMCksIG1pbGxpc2Vjb25kcyA9IG1hdGNoWzRdID8gcGFyc2VJbnQobWF0Y2hbNF0ucGFkRW5kKDMsIFwiMFwiKSwgMTApIDogMCwgdG90YWwgPSBob3VycyAqIDM2MDAgKyBtaW51dGVzICogNjAgKyBzZWNvbmRzICsgbWlsbGlzZWNvbmRzIC8gMWUzO1xuICBpZiAoaG91cnMgPCAwIHx8IG1pbnV0ZXMgPCAwIHx8IHNlY29uZHMgPCAwIHx8IG1pbGxpc2Vjb25kcyA8IDAgfHwgbWludXRlcyA+IDU5IHx8IHNlY29uZHMgPiA1OSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB0b3RhbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZUVFBhcnNlcigpIHtcbiAgcmV0dXJuIG5ldyBWVFRQYXJzZXIoKTtcbn1cblxudmFyIHZ0dFBhcnNlciA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBWVFRCbG9jazogVlRUQmxvY2ssXG4gIFZUVFBhcnNlcjogVlRUUGFyc2VyLFxuICBkZWZhdWx0OiBjcmVhdGVWVFRQYXJzZXIsXG4gIHBhcnNlVlRUVGltZXN0YW1wOiBwYXJzZVZUVFRpbWVzdGFtcFxufSk7XG5cbmNvbnN0IERJR0lUX1JFID0gL1swLTldLywgTVVMVElfU1BBQ0VfUkUgPSAvW1xcc1xcdF0rLywgVEFHX05BTUUgPSB7XG4gIGM6IFwic3BhblwiLFxuICBpOiBcImlcIixcbiAgYjogXCJiXCIsXG4gIHU6IFwidVwiLFxuICBydWJ5OiBcInJ1YnlcIixcbiAgcnQ6IFwicnRcIixcbiAgdjogXCJzcGFuXCIsXG4gIGxhbmc6IFwic3BhblwiLFxuICB0aW1lc3RhbXA6IFwic3BhblwiXG59LCBIVE1MX0VOVElUSUVTID0ge1xuICBcIiZhbXA7XCI6IFwiJlwiLFxuICBcIiZsdDtcIjogXCI8XCIsXG4gIFwiJmd0O1wiOiBcIj5cIixcbiAgXCImcXVvdDtcIjogJ1wiJyxcbiAgXCImIzM5O1wiOiBcIidcIixcbiAgXCImbmJzcDtcIjogXCJcXHhBMFwiLFxuICBcIiZscm07XCI6IFwiXFx1MjAwRVwiLFxuICBcIiZybG07XCI6IFwiXFx1MjAwRlwiXG59LCBIVE1MX0VOVElUWV9SRSA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IygwKyk/Mzl8bmJzcHxscm18cmxtKTsvZywgQ09MT1JTID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcIndoaXRlXCIsXG4gIFwibGltZVwiLFxuICBcImN5YW5cIixcbiAgXCJyZWRcIixcbiAgXCJ5ZWxsb3dcIixcbiAgXCJtYWdlbnRhXCIsXG4gIFwiYmx1ZVwiLFxuICBcImJsYWNrXCJcbl0pLCBCTE9DS19UWVBFUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KE9iamVjdC5rZXlzKFRBR19OQU1FKSk7XG5mdW5jdGlvbiB0b2tlbml6ZVZUVEN1ZShjdWUpIHtcbiAgbGV0IGJ1ZmZlciA9IFwiXCIsIG1vZGUgPSAxIC8qIERhdGEgKi8sIHJlc3VsdCA9IFtdLCBzdGFjayA9IFtdLCBub2RlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ZS50ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhciA9IGN1ZS50ZXh0W2ldO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgY2FzZSAxIC8qIERhdGEgKi86XG4gICAgICAgIGlmIChjaGFyID09PSBcIjxcIikge1xuICAgICAgICAgIGFkZFRleHQoKTtcbiAgICAgICAgICBtb2RlID0gMiAvKiBUYWcgKi87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIgLyogVGFnICovOlxuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgY2FzZSBcIlx0XCI6XG4gICAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICAgIGFkZE5vZGUoKTtcbiAgICAgICAgICAgIG1vZGUgPSA0IC8qIEFubm90YXRpb24gKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgYWRkTm9kZSgpO1xuICAgICAgICAgICAgbW9kZSA9IDMgLyogQ2xhc3MgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgbW9kZSA9IDUgLyogRW5kVGFnICovO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIj5cIjpcbiAgICAgICAgICAgIGFkZE5vZGUoKTtcbiAgICAgICAgICAgIG1vZGUgPSAxIC8qIERhdGEgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKCFidWZmZXIgJiYgRElHSVRfUkUudGVzdChjaGFyKSlcbiAgICAgICAgICAgICAgbW9kZSA9IDYgLyogVGltZXN0YW1wICovO1xuICAgICAgICAgICAgYnVmZmVyICs9IGNoYXI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMyAvKiBDbGFzcyAqLzpcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSBcIlx0XCI6XG4gICAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICBjYXNlIFwiXFxuXCI6XG4gICAgICAgICAgICBhZGRDbGFzcygpO1xuICAgICAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICAgIG5vZGUuY2xhc3M/LnRyaW0oKTtcbiAgICAgICAgICAgIG1vZGUgPSA0IC8qIEFubm90YXRpb24gKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgYWRkQ2xhc3MoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICBhZGRDbGFzcygpO1xuICAgICAgICAgICAgaWYgKG5vZGUpXG4gICAgICAgICAgICAgIG5vZGUuY2xhc3M/LnRyaW0oKTtcbiAgICAgICAgICAgIG1vZGUgPSAxIC8qIERhdGEgKi87XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnVmZmVyICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQgLyogQW5ub3RhdGlvbiAqLzpcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiPlwiKSB7XG4gICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnJlcGxhY2UoTVVMVElfU1BBQ0VfUkUsIFwiIFwiKTtcbiAgICAgICAgICBpZiAobm9kZT8udHlwZSA9PT0gXCJ2XCIpXG4gICAgICAgICAgICBub2RlLnZvaWNlID0gcmVwbGFjZUhUTUxFbnRpdGllcyhidWZmZXIpO1xuICAgICAgICAgIGVsc2UgaWYgKG5vZGU/LnR5cGUgPT09IFwibGFuZ1wiKVxuICAgICAgICAgICAgbm9kZS5sYW5nID0gcmVwbGFjZUhUTUxFbnRpdGllcyhidWZmZXIpO1xuICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgbW9kZSA9IDEgLyogRGF0YSAqLztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXIgKz0gY2hhcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNSAvKiBFbmRUYWcgKi86XG4gICAgICAgIGlmIChjaGFyID09PSBcIj5cIikge1xuICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgbm9kZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgIG1vZGUgPSAxIC8qIERhdGEgKi87XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYgLyogVGltZXN0YW1wICovOlxuICAgICAgICBpZiAoY2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgICBjb25zdCB0aW1lID0gcGFyc2VWVFRUaW1lc3RhbXAoYnVmZmVyKTtcbiAgICAgICAgICBpZiAodGltZSAhPT0gbnVsbCAmJiB0aW1lID49IGN1ZS5zdGFydFRpbWUgJiYgdGltZSA8PSBjdWUuZW5kVGltZSkge1xuICAgICAgICAgICAgYnVmZmVyID0gXCJ0aW1lc3RhbXBcIjtcbiAgICAgICAgICAgIGFkZE5vZGUoKTtcbiAgICAgICAgICAgIG5vZGUudGltZSA9IHRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgbW9kZSA9IDEgLyogRGF0YSAqLztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXIgKz0gY2hhcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYWRkTm9kZSgpIHtcbiAgICBpZiAoQkxPQ0tfVFlQRVMuaGFzKGJ1ZmZlcikpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGU7XG4gICAgICBub2RlID0gY3JlYXRlQmxvY2tOb2RlKGJ1ZmZlcik7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSAhPT0gcGFyZW50KVxuICAgICAgICAgIHN0YWNrLnB1c2gocGFyZW50KTtcbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgfVxuICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgbW9kZSA9IDEgLyogRGF0YSAqLztcbiAgfVxuICBmdW5jdGlvbiBhZGRDbGFzcygpIHtcbiAgICBpZiAobm9kZSAmJiBidWZmZXIpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gYnVmZmVyLnJlcGxhY2UoXCJiZ19cIiwgXCJcIik7XG4gICAgICBpZiAoQ09MT1JTLmhhcyhjb2xvcikpIHtcbiAgICAgICAgbm9kZVtidWZmZXIuc3RhcnRzV2l0aChcImJnX1wiKSA/IFwiYmdDb2xvclwiIDogXCJjb2xvclwiXSA9IGNvbG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5jbGFzcyA9ICFub2RlLmNsYXNzID8gYnVmZmVyIDogbm9kZS5jbGFzcyArIFwiIFwiICsgYnVmZmVyO1xuICAgICAgfVxuICAgIH1cbiAgICBidWZmZXIgPSBcIlwiO1xuICB9XG4gIGZ1bmN0aW9uIGFkZFRleHQoKSB7XG4gICAgaWYgKCFidWZmZXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdGV4dCA9IHsgdHlwZTogXCJ0ZXh0XCIsIGRhdGE6IHJlcGxhY2VIVE1MRW50aXRpZXMoYnVmZmVyKSB9O1xuICAgIG5vZGUgPyBub2RlLmNoaWxkcmVuLnB1c2godGV4dCkgOiByZXN1bHQucHVzaCh0ZXh0KTtcbiAgICBidWZmZXIgPSBcIlwiO1xuICB9XG4gIGlmIChtb2RlID09PSAxIC8qIERhdGEgKi8pXG4gICAgYWRkVGV4dCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmxvY2tOb2RlKHR5cGUpIHtcbiAgcmV0dXJuIHtcbiAgICB0YWdOYW1lOiBUQUdfTkFNRVt0eXBlXSxcbiAgICB0eXBlLFxuICAgIGNoaWxkcmVuOiBbXVxuICB9O1xufVxuZnVuY3Rpb24gcmVwbGFjZUhUTUxFbnRpdGllcyh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0LnJlcGxhY2UoSFRNTF9FTlRJVFlfUkUsIChlbnRpdHkpID0+IEhUTUxfRU5USVRJRVNbZW50aXR5XSB8fCBcIidcIik7XG59XG5cbmZ1bmN0aW9uIHNldENTU1ZhcihlbCwgbmFtZSwgdmFsdWUpIHtcbiAgZWwuc3R5bGUuc2V0UHJvcGVydHkoYC0tJHtuYW1lfWAsIHZhbHVlICsgXCJcIik7XG59XG5mdW5jdGlvbiBzZXREYXRhQXR0cihlbCwgbmFtZSwgdmFsdWUgPSB0cnVlKSB7XG4gIGVsLnNldEF0dHJpYnV0ZShgZGF0YS0ke25hbWV9YCwgdmFsdWUgPT09IHRydWUgPyBcIlwiIDogdmFsdWUgKyBcIlwiKTtcbn1cbmZ1bmN0aW9uIHNldFBhcnRBdHRyKGVsLCBuYW1lKSB7XG4gIGVsLnNldEF0dHJpYnV0ZShcImRhdGEtcGFydFwiLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIGdldExpbmVIZWlnaHQoZWwpIHtcbiAgcmV0dXJuIHBhcnNlRmxvYXQoZ2V0Q29tcHV0ZWRTdHlsZShlbCkubGluZUhlaWdodCkgfHwgMDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVlRUQ3VlVGVtcGxhdGUoY3VlKSB7XG4gIGlmIChJU19TRVJWRVIpIHtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwiW21lZGlhLWNhcHRpb25zXSBjYWxsZWQgYGNyZWF0ZVZUVEN1ZVRlbXBsYXRlYCBvbiB0aGUgc2VydmVyIC0gdXNlIGByZW5kZXJWVFRDdWVTdHJpbmdgXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO1xuICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSByZW5kZXJWVFRDdWVTdHJpbmcoY3VlKTtcbiAgcmV0dXJuIHsgY3VlLCBjb250ZW50OiB0ZW1wbGF0ZS5jb250ZW50IH07XG59XG5mdW5jdGlvbiByZW5kZXJWVFRDdWVTdHJpbmcoY3VlLCBjdXJyZW50VGltZSA9IDApIHtcbiAgcmV0dXJuIHJlbmRlclZUVFRva2Vuc1N0cmluZyh0b2tlbml6ZVZUVEN1ZShjdWUpLCBjdXJyZW50VGltZSk7XG59XG5mdW5jdGlvbiByZW5kZXJWVFRUb2tlbnNTdHJpbmcodG9rZW5zLCBjdXJyZW50VGltZSA9IDApIHtcbiAgbGV0IGF0dHJzLCByZXN1bHQgPSBcIlwiO1xuICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgIGlmICh0b2tlbi50eXBlID09PSBcInRleHRcIikge1xuICAgICAgcmVzdWx0ICs9IHRva2VuLmRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzVGltZXN0YW1wID0gdG9rZW4udHlwZSA9PT0gXCJ0aW1lc3RhbXBcIjtcbiAgICAgIGF0dHJzID0ge307XG4gICAgICBhdHRycy5jbGFzcyA9IHRva2VuLmNsYXNzO1xuICAgICAgYXR0cnMudGl0bGUgPSB0b2tlbi50eXBlID09PSBcInZcIiAmJiB0b2tlbi52b2ljZTtcbiAgICAgIGF0dHJzLmxhbmcgPSB0b2tlbi50eXBlID09PSBcImxhbmdcIiAmJiB0b2tlbi5sYW5nO1xuICAgICAgYXR0cnNbXCJkYXRhLXBhcnRcIl0gPSB0b2tlbi50eXBlID09PSBcInZcIiAmJiBcInZvaWNlXCI7XG4gICAgICBpZiAoaXNUaW1lc3RhbXApIHtcbiAgICAgICAgYXR0cnNbXCJkYXRhLXBhcnRcIl0gPSBcInRpbWVkXCI7XG4gICAgICAgIGF0dHJzW1wiZGF0YS10aW1lXCJdID0gdG9rZW4udGltZTtcbiAgICAgICAgYXR0cnNbXCJkYXRhLWZ1dHVyZVwiXSA9IHRva2VuLnRpbWUgPiBjdXJyZW50VGltZTtcbiAgICAgICAgYXR0cnNbXCJkYXRhLXBhc3RcIl0gPSB0b2tlbi50aW1lIDwgY3VycmVudFRpbWU7XG4gICAgICB9XG4gICAgICBhdHRycy5zdHlsZSA9IGAke3Rva2VuLmNvbG9yID8gYGNvbG9yOiAke3Rva2VuLmNvbG9yfTtgIDogXCJcIn0ke3Rva2VuLmJnQ29sb3IgPyBgYmFja2dyb3VuZC1jb2xvcjogJHt0b2tlbi5iZ0NvbG9yfTtgIDogXCJcIn1gO1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKGF0dHJzKS5maWx0ZXIoKHYpID0+IHZbMV0pLm1hcCgodikgPT4gYCR7dlswXX09XCIke3ZbMV0gPT09IHRydWUgPyBcIlwiIDogdlsxXX1cImApLmpvaW4oXCIgXCIpO1xuICAgICAgcmVzdWx0ICs9IGA8JHt0b2tlbi50YWdOYW1lfSR7YXR0cmlidXRlcyA/IFwiIFwiICsgYXR0cmlidXRlcyA6IFwiXCJ9PiR7cmVuZGVyVlRUVG9rZW5zU3RyaW5nKFxuICAgICAgICB0b2tlbi5jaGlsZHJlblxuICAgICAgKX08LyR7dG9rZW4udGFnTmFtZX0+YDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVRpbWVkVlRUQ3VlTm9kZXMocm9vdCwgY3VycmVudFRpbWUpIHtcbiAgaWYgKElTX1NFUlZFUilcbiAgICByZXR1cm47XG4gIGZvciAoY29uc3QgZWwgb2Ygcm9vdC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1wYXJ0PVwidGltZWRcIl0nKSkge1xuICAgIGNvbnN0IHRpbWUgPSBOdW1iZXIoZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS10aW1lXCIpKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHRpbWUpKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKHRpbWUgPiBjdXJyZW50VGltZSlcbiAgICAgIHNldERhdGFBdHRyKGVsLCBcImZ1dHVyZVwiKTtcbiAgICBlbHNlXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWZ1dHVyZVwiKTtcbiAgICBpZiAodGltZSA8IGN1cnJlbnRUaW1lKVxuICAgICAgc2V0RGF0YUF0dHIoZWwsIFwicGFzdFwiKTtcbiAgICBlbHNlXG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXBhc3RcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XG4gIGxldCB0aW1lb3V0ID0gbnVsbCwgYXJncztcbiAgZnVuY3Rpb24gcnVuKCkge1xuICAgIGNsZWFyKCk7XG4gICAgZm4oLi4uYXJncyk7XG4gICAgYXJncyA9IHZvaWQgMDtcbiAgfVxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gZGVib3VuY2UyKCkge1xuICAgIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgY2xlYXIoKTtcbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dChydW4sIGRlbGF5KTtcbiAgfVxuICByZXR1cm4gZGVib3VuY2UyO1xufVxuXG5jb25zdCBTVEFSVElOR19CT1ggPSBTeW1ib2woXCJTVEFSVElOR19CT1hcIiApO1xuZnVuY3Rpb24gY3JlYXRlQm94KGJveCkge1xuICBpZiAoYm94IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBib3gub2Zmc2V0VG9wLFxuICAgICAgd2lkdGg6IGJveC5jbGllbnRXaWR0aCxcbiAgICAgIGhlaWdodDogYm94LmNsaWVudEhlaWdodCxcbiAgICAgIGxlZnQ6IGJveC5vZmZzZXRMZWZ0LFxuICAgICAgcmlnaHQ6IGJveC5vZmZzZXRMZWZ0ICsgYm94LmNsaWVudFdpZHRoLFxuICAgICAgYm90dG9tOiBib3gub2Zmc2V0VG9wICsgYm94LmNsaWVudEhlaWdodFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHsgLi4uYm94IH07XG59XG5mdW5jdGlvbiBtb3ZlQm94KGJveCwgYXhpcywgZGVsdGEpIHtcbiAgc3dpdGNoIChheGlzKSB7XG4gICAgY2FzZSBcIit4XCI6XG4gICAgICBib3gubGVmdCArPSBkZWx0YTtcbiAgICAgIGJveC5yaWdodCArPSBkZWx0YTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIteFwiOlxuICAgICAgYm94LmxlZnQgLT0gZGVsdGE7XG4gICAgICBib3gucmlnaHQgLT0gZGVsdGE7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiK3lcIjpcbiAgICAgIGJveC50b3AgKz0gZGVsdGE7XG4gICAgICBib3guYm90dG9tICs9IGRlbHRhO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIi15XCI6XG4gICAgICBib3gudG9wIC09IGRlbHRhO1xuICAgICAgYm94LmJvdHRvbSAtPSBkZWx0YTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5mdW5jdGlvbiBpc0JveENvbGxpc2lvbihhLCBiKSB7XG4gIHJldHVybiBhLmxlZnQgPD0gYi5yaWdodCAmJiBhLnJpZ2h0ID49IGIubGVmdCAmJiBhLnRvcCA8PSBiLmJvdHRvbSAmJiBhLmJvdHRvbSA+PSBiLnRvcDtcbn1cbmZ1bmN0aW9uIGlzQW55Qm94Q29sbGlzaW9uKGJveCwgYm94ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKylcbiAgICBpZiAoaXNCb3hDb2xsaXNpb24oYm94LCBib3hlc1tpXSkpXG4gICAgICByZXR1cm4gYm94ZXNbaV07XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNXaXRoaW5Cb3goY29udGFpbmVyLCBib3gpIHtcbiAgcmV0dXJuIGJveC50b3AgPj0gMCAmJiBib3guYm90dG9tIDw9IGNvbnRhaW5lci5oZWlnaHQgJiYgYm94LmxlZnQgPj0gMCAmJiBib3gucmlnaHQgPD0gY29udGFpbmVyLndpZHRoO1xufVxuZnVuY3Rpb24gaXNCb3hPdXRPZkJvdW5kcyhjb250YWluZXIsIGJveCwgYXhpcykge1xuICBzd2l0Y2ggKGF4aXMpIHtcbiAgICBjYXNlIFwiK3hcIjpcbiAgICAgIHJldHVybiBib3gubGVmdCA8IDA7XG4gICAgY2FzZSBcIi14XCI6XG4gICAgICByZXR1cm4gYm94LnJpZ2h0ID4gY29udGFpbmVyLndpZHRoO1xuICAgIGNhc2UgXCIreVwiOlxuICAgICAgcmV0dXJuIGJveC50b3AgPCAwO1xuICAgIGNhc2UgXCIteVwiOlxuICAgICAgcmV0dXJuIGJveC5ib3R0b20gPiBjb250YWluZXIuaGVpZ2h0O1xuICB9XG59XG5mdW5jdGlvbiBjYWxjQm94SW50ZXJzZWN0UGVyY2VudGFnZShjb250YWluZXIsIGJveCkge1xuICBjb25zdCB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oY29udGFpbmVyLndpZHRoLCBib3gucmlnaHQpIC0gTWF0aC5tYXgoMCwgYm94LmxlZnQpKSwgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKGNvbnRhaW5lci5oZWlnaHQsIGJveC5ib3R0b20pIC0gTWF0aC5tYXgoMCwgYm94LnRvcCkpLCBpbnRlcnNlY3RBcmVhID0geCAqIHk7XG4gIHJldHVybiBpbnRlcnNlY3RBcmVhIC8gKGNvbnRhaW5lci5oZWlnaHQgKiBjb250YWluZXIud2lkdGgpO1xufVxuZnVuY3Rpb24gY3JlYXRlQ1NTQm94KGNvbnRhaW5lciwgYm94KSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiBib3gudG9wIC8gY29udGFpbmVyLmhlaWdodCxcbiAgICBsZWZ0OiBib3gubGVmdCAvIGNvbnRhaW5lci53aWR0aCxcbiAgICByaWdodDogKGNvbnRhaW5lci53aWR0aCAtIGJveC5yaWdodCkgLyBjb250YWluZXIud2lkdGgsXG4gICAgYm90dG9tOiAoY29udGFpbmVyLmhlaWdodCAtIGJveC5ib3R0b20pIC8gY29udGFpbmVyLmhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJlbGF0aXZlQm94KGNvbnRhaW5lciwgYm94KSB7XG4gIGJveC50b3AgPSBib3gudG9wICogY29udGFpbmVyLmhlaWdodDtcbiAgYm94LmxlZnQgPSBib3gubGVmdCAqIGNvbnRhaW5lci53aWR0aDtcbiAgYm94LnJpZ2h0ID0gY29udGFpbmVyLndpZHRoIC0gYm94LnJpZ2h0ICogY29udGFpbmVyLndpZHRoO1xuICBib3guYm90dG9tID0gY29udGFpbmVyLmhlaWdodCAtIGJveC5ib3R0b20gKiBjb250YWluZXIuaGVpZ2h0O1xuICByZXR1cm4gYm94O1xufVxuY29uc3QgQk9YX1NJREVTID0gW1widG9wXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCJdO1xuZnVuY3Rpb24gc2V0Qm94Q1NTVmFycyhlbCwgY29udGFpbmVyLCBib3gsIHByZWZpeCkge1xuICBjb25zdCBjc3NCb3ggPSBjcmVhdGVDU1NCb3goY29udGFpbmVyLCBib3gpO1xuICBmb3IgKGNvbnN0IHNpZGUgb2YgQk9YX1NJREVTKSB7XG4gICAgc2V0Q1NTVmFyKGVsLCBgJHtwcmVmaXh9LSR7c2lkZX1gLCBjc3NCb3hbc2lkZV0gKiAxMDAgKyBcIiVcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGF2b2lkQm94Q29sbGlzaW9ucyhjb250YWluZXIsIGJveCwgYm94ZXMsIGF4aXMpIHtcbiAgbGV0IHBlcmNlbnRhZ2UgPSAxLCBwb3NpdGlvbmVkQm94LCBzdGFydEJveCA9IHsgLi4uYm94IH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXhpcy5sZW5ndGg7IGkrKykge1xuICAgIHdoaWxlIChpc0JveE91dE9mQm91bmRzKGNvbnRhaW5lciwgYm94LCBheGlzW2ldKSB8fCBpc1dpdGhpbkJveChjb250YWluZXIsIGJveCkgJiYgaXNBbnlCb3hDb2xsaXNpb24oYm94LCBib3hlcykpIHtcbiAgICAgIG1vdmVCb3goYm94LCBheGlzW2ldLCAxKTtcbiAgICB9XG4gICAgaWYgKGlzV2l0aGluQm94KGNvbnRhaW5lciwgYm94KSlcbiAgICAgIHJldHVybiBib3g7XG4gICAgY29uc3QgaW50ZXJzZWN0aW9uID0gY2FsY0JveEludGVyc2VjdFBlcmNlbnRhZ2UoY29udGFpbmVyLCBib3gpO1xuICAgIGlmIChwZXJjZW50YWdlID4gaW50ZXJzZWN0aW9uKSB7XG4gICAgICBwb3NpdGlvbmVkQm94ID0geyAuLi5ib3ggfTtcbiAgICAgIHBlcmNlbnRhZ2UgPSBpbnRlcnNlY3Rpb247XG4gICAgfVxuICAgIGJveCA9IHsgLi4uc3RhcnRCb3ggfTtcbiAgfVxuICByZXR1cm4gcG9zaXRpb25lZEJveCB8fCBzdGFydEJveDtcbn1cblxuY29uc3QgUE9TSVRJT05fT1ZFUlJJREUgPSBTeW1ib2woXCJQT1NJVElPTl9PVkVSUklERVwiICk7XG5mdW5jdGlvbiBwb3NpdGlvbkN1ZShjb250YWluZXIsIGN1ZSwgZGlzcGxheUVsLCBib3hlcykge1xuICBsZXQgY3VlRWwgPSBkaXNwbGF5RWwuZmlyc3RFbGVtZW50Q2hpbGQsIGxpbmUgPSBjb21wdXRlQ3VlTGluZShjdWUpLCBkaXNwbGF5Qm94LCBheGlzID0gW107XG4gIGlmICghZGlzcGxheUVsW1NUQVJUSU5HX0JPWF0pIHtcbiAgICBkaXNwbGF5RWxbU1RBUlRJTkdfQk9YXSA9IGNyZWF0ZVN0YXJ0aW5nQm94KGNvbnRhaW5lciwgZGlzcGxheUVsKTtcbiAgfVxuICBkaXNwbGF5Qm94ID0gcmVzb2x2ZVJlbGF0aXZlQm94KGNvbnRhaW5lciwgeyAuLi5kaXNwbGF5RWxbU1RBUlRJTkdfQk9YXSB9KTtcbiAgaWYgKGRpc3BsYXlFbFtQT1NJVElPTl9PVkVSUklERV0pIHtcbiAgICBheGlzID0gW2Rpc3BsYXlFbFtQT1NJVElPTl9PVkVSUklERV0gPT09IFwidG9wXCIgPyBcIit5XCIgOiBcIi15XCIsIFwiK3hcIiwgXCIteFwiXTtcbiAgfSBlbHNlIGlmIChjdWUuc25hcFRvTGluZXMpIHtcbiAgICBsZXQgc2l6ZTtcbiAgICBzd2l0Y2ggKGN1ZS52ZXJ0aWNhbCkge1xuICAgICAgY2FzZSBcIlwiOlxuICAgICAgICBheGlzID0gW1wiK3lcIiwgXCIteVwiXTtcbiAgICAgICAgc2l6ZSA9IFwiaGVpZ2h0XCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJsXCI6XG4gICAgICAgIGF4aXMgPSBbXCIreFwiLCBcIi14XCJdO1xuICAgICAgICBzaXplID0gXCJ3aWR0aFwiO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsclwiOlxuICAgICAgICBheGlzID0gW1wiLXhcIiwgXCIreFwiXTtcbiAgICAgICAgc2l6ZSA9IFwid2lkdGhcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBzdGVwID0gZ2V0TGluZUhlaWdodChjdWVFbCksIHBvc2l0aW9uID0gc3RlcCAqIE1hdGgucm91bmQobGluZSksIG1heFBvc2l0aW9uID0gY29udGFpbmVyW3NpemVdICsgc3RlcCwgaW5pdGlhbEF4aXMgPSBheGlzWzBdO1xuICAgIGlmIChNYXRoLmFicyhwb3NpdGlvbikgPiBtYXhQb3NpdGlvbikge1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA8IDAgPyAtMSA6IDE7XG4gICAgICBwb3NpdGlvbiAqPSBNYXRoLmNlaWwobWF4UG9zaXRpb24gLyBzdGVwKSAqIHN0ZXA7XG4gICAgfVxuICAgIGlmIChsaW5lIDwgMCkge1xuICAgICAgcG9zaXRpb24gKz0gY3VlLnZlcnRpY2FsID09PSBcIlwiID8gY29udGFpbmVyLmhlaWdodCA6IGNvbnRhaW5lci53aWR0aDtcbiAgICAgIGF4aXMgPSBheGlzLnJldmVyc2UoKTtcbiAgICB9XG4gICAgbW92ZUJveChkaXNwbGF5Qm94LCBpbml0aWFsQXhpcywgcG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGN1ZS52ZXJ0aWNhbCA9PT0gXCJcIiwgcG9zQXhpcyA9IGlzSG9yaXpvbnRhbCA/IFwiK3lcIiA6IFwiK3hcIiwgc2l6ZSA9IGlzSG9yaXpvbnRhbCA/IGRpc3BsYXlCb3guaGVpZ2h0IDogZGlzcGxheUJveC53aWR0aDtcbiAgICBtb3ZlQm94KFxuICAgICAgZGlzcGxheUJveCxcbiAgICAgIHBvc0F4aXMsXG4gICAgICAoaXNIb3Jpem9udGFsID8gY29udGFpbmVyLmhlaWdodCA6IGNvbnRhaW5lci53aWR0aCkgKiBsaW5lIC8gMTAwXG4gICAgKTtcbiAgICBtb3ZlQm94KFxuICAgICAgZGlzcGxheUJveCxcbiAgICAgIHBvc0F4aXMsXG4gICAgICBjdWUubGluZUFsaWduID09PSBcImNlbnRlclwiID8gc2l6ZSAvIDIgOiBjdWUubGluZUFsaWduID09PSBcImVuZFwiID8gc2l6ZSA6IDBcbiAgICApO1xuICAgIGF4aXMgPSBpc0hvcml6b250YWwgPyBbXCIteVwiLCBcIit5XCIsIFwiLXhcIiwgXCIreFwiXSA6IFtcIi14XCIsIFwiK3hcIiwgXCIteVwiLCBcIit5XCJdO1xuICB9XG4gIGRpc3BsYXlCb3ggPSBhdm9pZEJveENvbGxpc2lvbnMoY29udGFpbmVyLCBkaXNwbGF5Qm94LCBib3hlcywgYXhpcyk7XG4gIHNldEJveENTU1ZhcnMoZGlzcGxheUVsLCBjb250YWluZXIsIGRpc3BsYXlCb3gsIFwiY3VlXCIpO1xuICByZXR1cm4gZGlzcGxheUJveDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0YXJ0aW5nQm94KGNvbnRhaW5lciwgY3VlRWwpIHtcbiAgY29uc3QgYm94ID0gY3JlYXRlQm94KGN1ZUVsKSwgcG9zID0gZ2V0U3R5bGVkUG9zaXRpb25zKGN1ZUVsKTtcbiAgY3VlRWxbUE9TSVRJT05fT1ZFUlJJREVdID0gZmFsc2U7XG4gIGlmIChwb3MudG9wKSB7XG4gICAgYm94LnRvcCA9IHBvcy50b3A7XG4gICAgYm94LmJvdHRvbSA9IHBvcy50b3AgKyBib3guaGVpZ2h0O1xuICAgIGN1ZUVsW1BPU0lUSU9OX09WRVJSSURFXSA9IFwidG9wXCI7XG4gIH1cbiAgaWYgKHBvcy5ib3R0b20pIHtcbiAgICBjb25zdCBib3R0b20gPSBjb250YWluZXIuaGVpZ2h0IC0gcG9zLmJvdHRvbTtcbiAgICBib3gudG9wID0gYm90dG9tIC0gYm94LmhlaWdodDtcbiAgICBib3guYm90dG9tID0gYm90dG9tO1xuICAgIGN1ZUVsW1BPU0lUSU9OX09WRVJSSURFXSA9IFwiYm90dG9tXCI7XG4gIH1cbiAgaWYgKHBvcy5sZWZ0KVxuICAgIGJveC5sZWZ0ID0gcG9zLmxlZnQ7XG4gIGlmIChwb3MucmlnaHQpXG4gICAgYm94LnJpZ2h0ID0gY29udGFpbmVyLndpZHRoIC0gcG9zLnJpZ2h0O1xuICByZXR1cm4gY3JlYXRlQ1NTQm94KGNvbnRhaW5lciwgYm94KTtcbn1cbmZ1bmN0aW9uIGdldFN0eWxlZFBvc2l0aW9ucyhlbCkge1xuICBjb25zdCBwb3NpdGlvbnMgPSB7fTtcbiAgZm9yIChjb25zdCBzaWRlIG9mIEJPWF9TSURFUykge1xuICAgIHBvc2l0aW9uc1tzaWRlXSA9IHBhcnNlRmxvYXQoZWwuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShgLS1jdWUtJHtzaWRlfWApKTtcbiAgfVxuICByZXR1cm4gcG9zaXRpb25zO1xufVxuZnVuY3Rpb24gY29tcHV0ZUN1ZUxpbmUoY3VlKSB7XG4gIGlmIChjdWUubGluZSA9PT0gXCJhdXRvXCIpIHtcbiAgICBpZiAoIWN1ZS5zbmFwVG9MaW5lcykge1xuICAgICAgcmV0dXJuIDEwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3VlLmxpbmU7XG59XG5mdW5jdGlvbiBjb21wdXRlQ3VlUG9zaXRpb24oY3VlKSB7XG4gIGlmIChjdWUucG9zaXRpb24gPT09IFwiYXV0b1wiKSB7XG4gICAgc3dpdGNoIChjdWUuYWxpZ24pIHtcbiAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgcmV0dXJuIDEwMDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiA1MDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1ZS5wb3NpdGlvbjtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDdWVQb3NpdGlvbkFsaWdubWVudChjdWUsIGRpcikge1xuICBpZiAoY3VlLnBvc2l0aW9uQWxpZ24gPT09IFwiYXV0b1wiKSB7XG4gICAgc3dpdGNoIChjdWUuYWxpZ24pIHtcbiAgICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgICByZXR1cm4gZGlyID09PSBcImx0clwiID8gXCJsaW5lLWxlZnRcIiA6IFwibGluZS1yaWdodFwiO1xuICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICByZXR1cm4gZGlyID09PSBcImx0clwiID8gXCJsaW5lLXJpZ2h0XCIgOiBcImxpbmUtbGVmdFwiO1xuICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgICByZXR1cm4gXCJjZW50ZXJcIjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgbGluZS0ke2N1ZS5hbGlnbn1gO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3VlLnBvc2l0aW9uQWxpZ247XG59XG5cbmNvbnN0IFJFR0lPTl9BWElTID0gW1wiLXlcIiwgXCIreVwiLCBcIi14XCIsIFwiK3hcIl07XG5mdW5jdGlvbiBwb3NpdGlvblJlZ2lvbihjb250YWluZXIsIHJlZ2lvbiwgcmVnaW9uRWwsIGJveGVzKSB7XG4gIGxldCBjdWVzID0gQXJyYXkuZnJvbShyZWdpb25FbC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1wYXJ0PVwiY3VlLWRpc3BsYXlcIl0nKSksIGhlaWdodCA9IDAsIGxpbWl0ID0gTWF0aC5tYXgoMCwgY3Vlcy5sZW5ndGggLSByZWdpb24ubGluZXMpO1xuICBmb3IgKGxldCBpID0gY3Vlcy5sZW5ndGggLSAxOyBpID49IGxpbWl0OyBpLS0pIHtcbiAgICBoZWlnaHQgKz0gY3Vlc1tpXS5vZmZzZXRIZWlnaHQ7XG4gIH1cbiAgc2V0Q1NTVmFyKHJlZ2lvbkVsLCBcInJlZ2lvbi1oZWlnaHRcIiwgaGVpZ2h0ICsgXCJweFwiKTtcbiAgaWYgKCFyZWdpb25FbFtTVEFSVElOR19CT1hdKSB7XG4gICAgcmVnaW9uRWxbU1RBUlRJTkdfQk9YXSA9IGNyZWF0ZUNTU0JveChjb250YWluZXIsIGNyZWF0ZUJveChyZWdpb25FbCkpO1xuICB9XG4gIGxldCBib3ggPSB7IC4uLnJlZ2lvbkVsW1NUQVJUSU5HX0JPWF0gfTtcbiAgYm94ID0gcmVzb2x2ZVJlbGF0aXZlQm94KGNvbnRhaW5lciwgYm94KTtcbiAgYm94LndpZHRoID0gcmVnaW9uRWwuY2xpZW50V2lkdGg7XG4gIGJveC5oZWlnaHQgPSBoZWlnaHQ7XG4gIGJveC5yaWdodCA9IGJveC5sZWZ0ICsgYm94LndpZHRoO1xuICBib3guYm90dG9tID0gYm94LnRvcCArIGhlaWdodDtcbiAgYm94ID0gYXZvaWRCb3hDb2xsaXNpb25zKGNvbnRhaW5lciwgYm94LCBib3hlcywgUkVHSU9OX0FYSVMpO1xuICBzZXRCb3hDU1NWYXJzKHJlZ2lvbkVsLCBjb250YWluZXIsIGJveCwgXCJyZWdpb25cIik7XG4gIHJldHVybiBib3g7XG59XG5cbmNsYXNzIENhcHRpb25zUmVuZGVyZXIge1xuICBvdmVybGF5O1xuICBfb3ZlcmxheUJveDtcbiAgX2N1cnJlbnRUaW1lID0gMDtcbiAgX2RpciA9IFwibHRyXCI7XG4gIF9hY3RpdmVDdWVzID0gW107XG4gIF9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gIF9yZXNpemVPYnNlcnZlcjtcbiAgX3JlZ2lvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBfY3VlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIC8qIFRleHQgZGlyZWN0aW9uLiAqL1xuICBnZXQgZGlyKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXI7XG4gIH1cbiAgc2V0IGRpcihkaXIpIHtcbiAgICB0aGlzLl9kaXIgPSBkaXI7XG4gICAgc2V0RGF0YUF0dHIodGhpcy5vdmVybGF5LCBcImRpclwiLCBkaXIpO1xuICB9XG4gIGdldCBjdXJyZW50VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFRpbWU7XG4gIH1cbiAgc2V0IGN1cnJlbnRUaW1lKHRpbWUpIHtcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvdmVybGF5LCBpbml0KSB7XG4gICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICB0aGlzLmRpciA9IGluaXQ/LmRpciA/PyBcImx0clwiO1xuICAgIG92ZXJsYXkuc2V0QXR0cmlidXRlKFwidHJhbnNsYXRlXCIsIFwieWVzXCIpO1xuICAgIG92ZXJsYXkuc2V0QXR0cmlidXRlKFwiYXJpYS1saXZlXCIsIFwib2ZmXCIpO1xuICAgIG92ZXJsYXkuc2V0QXR0cmlidXRlKFwiYXJpYS1hdG9taWNcIiwgXCJ0cnVlXCIpO1xuICAgIHNldFBhcnRBdHRyKG92ZXJsYXksIFwiY2FwdGlvbnNcIik7XG4gICAgdGhpcy5fdXBkYXRlT3ZlcmxheSgpO1xuICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuX3Jlc2l6aW5nLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUob3ZlcmxheSk7XG4gIH1cbiAgY2hhbmdlVHJhY2soeyByZWdpb25zLCBjdWVzIH0pIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5fYnVpbGRSZWdpb25zKHJlZ2lvbnMpO1xuICAgIGZvciAoY29uc3QgY3VlIG9mIGN1ZXMpXG4gICAgICB0aGlzLl9jdWVzLnNldChjdWUsIG51bGwpO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cbiAgYWRkQ3VlKGN1ZSkge1xuICAgIHRoaXMuX2N1ZXMuc2V0KGN1ZSwgbnVsbCk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICByZW1vdmVDdWUoY3VlKSB7XG4gICAgdGhpcy5fY3Vlcy5kZWxldGUoY3VlKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIHVwZGF0ZShmb3JjZVVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5fcmVuZGVyKGZvcmNlVXBkYXRlKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9jdWVzLmNsZWFyKCk7XG4gICAgdGhpcy5fcmVnaW9ucy5jbGVhcigpO1xuICAgIHRoaXMuX2FjdGl2ZUN1ZXMgPSBbXTtcbiAgICB0aGlzLm92ZXJsYXkudGV4dENvbnRlbnQgPSBcIlwiO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgfVxuICBfcmVzaXppbmcoKSB7XG4gICAgdGhpcy5faXNSZXNpemluZyA9IHRydWU7XG4gICAgdGhpcy5fcmVzaXplKCk7XG4gIH1cbiAgX3Jlc2l6ZSA9IGRlYm91bmNlKCgpID0+IHtcbiAgICB0aGlzLl9pc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fdXBkYXRlT3ZlcmxheSgpO1xuICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5fcmVnaW9ucy52YWx1ZXMoKSkge1xuICAgICAgZWxbU1RBUlRJTkdfQk9YXSA9IG51bGw7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5fY3Vlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVsKVxuICAgICAgICBlbFtTVEFSVElOR19CT1hdID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyKHRydWUpO1xuICB9LCA1MCk7XG4gIF91cGRhdGVPdmVybGF5KCkge1xuICAgIHRoaXMuX292ZXJsYXlCb3ggPSBjcmVhdGVCb3godGhpcy5vdmVybGF5KTtcbiAgICBzZXRDU1NWYXIodGhpcy5vdmVybGF5LCBcIm92ZXJsYXktd2lkdGhcIiwgdGhpcy5fb3ZlcmxheUJveC53aWR0aCArIFwicHhcIik7XG4gICAgc2V0Q1NTVmFyKHRoaXMub3ZlcmxheSwgXCJvdmVybGF5LWhlaWdodFwiLCB0aGlzLl9vdmVybGF5Qm94LmhlaWdodCArIFwicHhcIik7XG4gIH1cbiAgX3JlbmRlcihmb3JjZVVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLl9jdWVzLnNpemUgfHwgdGhpcy5faXNSZXNpemluZylcbiAgICAgIHJldHVybjtcbiAgICBsZXQgY3VlLCBhY3RpdmVDdWVzID0gWy4uLnRoaXMuX2N1ZXMua2V5cygpXS5maWx0ZXIoKGN1ZTIpID0+IHRoaXMuX2N1cnJlbnRUaW1lID49IGN1ZTIuc3RhcnRUaW1lICYmIHRoaXMuX2N1cnJlbnRUaW1lIDw9IGN1ZTIuZW5kVGltZSkuc29ydChcbiAgICAgIChjdWVBLCBjdWVCKSA9PiBjdWVBLnN0YXJ0VGltZSAhPT0gY3VlQi5zdGFydFRpbWUgPyBjdWVBLnN0YXJ0VGltZSAtIGN1ZUIuc3RhcnRUaW1lIDogY3VlQS5lbmRUaW1lIC0gY3VlQi5lbmRUaW1lXG4gICAgKSwgYWN0aXZlUmVnaW9ucyA9IGFjdGl2ZUN1ZXMubWFwKChjdWUyKSA9PiBjdWUyLnJlZ2lvbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY3RpdmVDdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjdWUgPSB0aGlzLl9hY3RpdmVDdWVzW2ldO1xuICAgICAgaWYgKGFjdGl2ZUN1ZXNbaV0gPT09IGN1ZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoY3VlLnJlZ2lvbiAmJiAhYWN0aXZlUmVnaW9ucy5pbmNsdWRlcyhjdWUucmVnaW9uKSkge1xuICAgICAgICBjb25zdCByZWdpb25FbCA9IHRoaXMuX3JlZ2lvbnMuZ2V0KGN1ZS5yZWdpb24uaWQpO1xuICAgICAgICBpZiAocmVnaW9uRWwpIHtcbiAgICAgICAgICByZWdpb25FbC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWFjdGl2ZVwiKTtcbiAgICAgICAgICBmb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1ZUVsID0gdGhpcy5fY3Vlcy5nZXQoY3VlKTtcbiAgICAgIGlmIChjdWVFbCkge1xuICAgICAgICBjdWVFbC5yZW1vdmUoKTtcbiAgICAgICAgZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGl2ZUN1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGN1ZSA9IGFjdGl2ZUN1ZXNbaV07XG4gICAgICBsZXQgY3VlRWwgPSB0aGlzLl9jdWVzLmdldChjdWUpO1xuICAgICAgaWYgKCFjdWVFbClcbiAgICAgICAgdGhpcy5fY3Vlcy5zZXQoY3VlLCBjdWVFbCA9IHRoaXMuX2NyZWF0ZUN1ZUVsZW1lbnQoY3VlKSk7XG4gICAgICBjb25zdCByZWdpb25FbCA9IHRoaXMuX2hhc1JlZ2lvbihjdWUpICYmIHRoaXMuX3JlZ2lvbnMuZ2V0KGN1ZS5yZWdpb24uaWQpO1xuICAgICAgaWYgKHJlZ2lvbkVsICYmICFyZWdpb25FbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLWFjdGl2ZVwiKSkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gc2V0RGF0YUF0dHIocmVnaW9uRWwsIFwiYWN0aXZlXCIpKTtcbiAgICAgICAgZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFjdWVFbC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAocmVnaW9uRWwgfHwgdGhpcy5vdmVybGF5KS5hcHBlbmQoY3VlRWwpO1xuICAgICAgICBmb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmb3JjZVVwZGF0ZSkge1xuICAgICAgY29uc3QgYm94ZXMgPSBbXSwgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGxldCBpID0gYWN0aXZlQ3Vlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjdWUgPSBhY3RpdmVDdWVzW2ldO1xuICAgICAgICBpZiAoc2Vlbi5oYXMoY3VlLnJlZ2lvbiB8fCBjdWUpKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBpc1JlZ2lvbiA9IHRoaXMuX2hhc1JlZ2lvbihjdWUpLCBlbCA9IGlzUmVnaW9uID8gdGhpcy5fcmVnaW9ucy5nZXQoY3VlLnJlZ2lvbi5pZCkgOiB0aGlzLl9jdWVzLmdldChjdWUpO1xuICAgICAgICBpZiAoaXNSZWdpb24pIHtcbiAgICAgICAgICBib3hlcy5wdXNoKHBvc2l0aW9uUmVnaW9uKHRoaXMuX292ZXJsYXlCb3gsIGN1ZS5yZWdpb24sIGVsLCBib3hlcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJveGVzLnB1c2gocG9zaXRpb25DdWUodGhpcy5fb3ZlcmxheUJveCwgY3VlLCBlbCwgYm94ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZChpc1JlZ2lvbiA/IGN1ZS5yZWdpb24gOiBjdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVUaW1lZFZUVEN1ZU5vZGVzKHRoaXMub3ZlcmxheSwgdGhpcy5fY3VycmVudFRpbWUpO1xuICAgIHRoaXMuX2FjdGl2ZUN1ZXMgPSBhY3RpdmVDdWVzO1xuICB9XG4gIF9idWlsZFJlZ2lvbnMocmVnaW9ucykge1xuICAgIGlmICghcmVnaW9ucylcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiByZWdpb25zKSB7XG4gICAgICBjb25zdCBlbCA9IHRoaXMuX2NyZWF0ZVJlZ2lvbkVsZW1lbnQocmVnaW9uKTtcbiAgICAgIHRoaXMuX3JlZ2lvbnMuc2V0KHJlZ2lvbi5pZCwgZWwpO1xuICAgICAgdGhpcy5vdmVybGF5LmFwcGVuZChlbCk7XG4gICAgfVxuICB9XG4gIF9jcmVhdGVSZWdpb25FbGVtZW50KHJlZ2lvbikge1xuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzZXRQYXJ0QXR0cihlbCwgXCJyZWdpb25cIik7XG4gICAgc2V0RGF0YUF0dHIoZWwsIFwiaWRcIiwgcmVnaW9uLmlkKTtcbiAgICBzZXREYXRhQXR0cihlbCwgXCJzY3JvbGxcIiwgcmVnaW9uLnNjcm9sbCk7XG4gICAgc2V0Q1NTVmFyKGVsLCBcInJlZ2lvbi13aWR0aFwiLCByZWdpb24ud2lkdGggKyBcIiVcIik7XG4gICAgc2V0Q1NTVmFyKGVsLCBcInJlZ2lvbi1hbmNob3IteFwiLCByZWdpb24ucmVnaW9uQW5jaG9yWCk7XG4gICAgc2V0Q1NTVmFyKGVsLCBcInJlZ2lvbi1hbmNob3IteVwiLCByZWdpb24ucmVnaW9uQW5jaG9yWSk7XG4gICAgc2V0Q1NTVmFyKGVsLCBcInJlZ2lvbi12aWV3cG9ydC1hbmNob3IteFwiLCByZWdpb24udmlld3BvcnRBbmNob3JYKTtcbiAgICBzZXRDU1NWYXIoZWwsIFwicmVnaW9uLXZpZXdwb3J0LWFuY2hvci15XCIsIHJlZ2lvbi52aWV3cG9ydEFuY2hvclkpO1xuICAgIHNldENTU1ZhcihlbCwgXCJyZWdpb24tbGluZXNcIiwgcmVnaW9uLmxpbmVzKTtcbiAgICByZXR1cm4gZWw7XG4gIH1cbiAgX2NyZWF0ZUN1ZUVsZW1lbnQoY3VlKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHBvc2l0aW9uID0gY29tcHV0ZUN1ZVBvc2l0aW9uKGN1ZSksIHBvc2l0aW9uQWxpZ25tZW50ID0gY29tcHV0ZUN1ZVBvc2l0aW9uQWxpZ25tZW50KGN1ZSwgdGhpcy5fZGlyKTtcbiAgICBzZXRQYXJ0QXR0cihkaXNwbGF5LCBcImN1ZS1kaXNwbGF5XCIpO1xuICAgIGlmIChjdWUudmVydGljYWwgIT09IFwiXCIpXG4gICAgICBzZXREYXRhQXR0cihkaXNwbGF5LCBcInZlcnRpY2FsXCIpO1xuICAgIHNldENTU1ZhcihkaXNwbGF5LCBcImN1ZS10ZXh0LWFsaWduXCIsIGN1ZS5hbGlnbik7XG4gICAgaWYgKGN1ZS5zdHlsZSkge1xuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5rZXlzKGN1ZS5zdHlsZSkpIHtcbiAgICAgICAgZGlzcGxheS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBjdWUuc3R5bGVbcHJvcF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2hhc1JlZ2lvbihjdWUpKSB7XG4gICAgICBzZXRDU1NWYXIoXG4gICAgICAgIGRpc3BsYXksXG4gICAgICAgIFwiY3VlLXdyaXRpbmctbW9kZVwiLFxuICAgICAgICBjdWUudmVydGljYWwgPT09IFwiXCIgPyBcImhvcml6b250YWwtdGJcIiA6IGN1ZS52ZXJ0aWNhbCA9PT0gXCJsclwiID8gXCJ2ZXJ0aWNhbC1sclwiIDogXCJ2ZXJ0aWNhbC1ybFwiXG4gICAgICApO1xuICAgICAgaWYgKCFjdWUuc3R5bGU/LltcIi0tY3VlLXdpZHRoXCJdKSB7XG4gICAgICAgIGxldCBtYXhTaXplID0gcG9zaXRpb247XG4gICAgICAgIGlmIChwb3NpdGlvbkFsaWdubWVudCA9PT0gXCJsaW5lLWxlZnRcIikge1xuICAgICAgICAgIG1heFNpemUgPSAxMDAgLSBwb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbkFsaWdubWVudCA9PT0gXCJjZW50ZXJcIiAmJiBwb3NpdGlvbiA8PSA1MCkge1xuICAgICAgICAgIG1heFNpemUgPSBwb3NpdGlvbiAqIDI7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb25BbGlnbm1lbnQgPT09IFwiY2VudGVyXCIgJiYgcG9zaXRpb24gPiA1MCkge1xuICAgICAgICAgIG1heFNpemUgPSAoMTAwIC0gcG9zaXRpb24pICogMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaXplID0gY3VlLnNpemUgPCBtYXhTaXplID8gY3VlLnNpemUgOiBtYXhTaXplO1xuICAgICAgICBpZiAoY3VlLnZlcnRpY2FsID09PSBcIlwiKVxuICAgICAgICAgIHNldENTU1ZhcihkaXNwbGF5LCBcImN1ZS13aWR0aFwiLCBzaXplICsgXCIlXCIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc2V0Q1NTVmFyKGRpc3BsYXksIFwiY3VlLWhlaWdodFwiLCBzaXplICsgXCIlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRDU1NWYXIoXG4gICAgICAgIGRpc3BsYXksXG4gICAgICAgIFwiY3VlLW9mZnNldFwiLFxuICAgICAgICBgJHtwb3NpdGlvbiAtIChwb3NpdGlvbkFsaWdubWVudCA9PT0gXCJsaW5lLXJpZ2h0XCIgPyAxMDAgOiBwb3NpdGlvbkFsaWdubWVudCA9PT0gXCJjZW50ZXJcIiA/IDUwIDogMCl9JWBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBzZXRQYXJ0QXR0cihlbCwgXCJjdWVcIik7XG4gICAgaWYgKGN1ZS5pZClcbiAgICAgIHNldERhdGFBdHRyKGVsLCBcImlkXCIsIGN1ZS5pZCk7XG4gICAgZWwuaW5uZXJIVE1MID0gcmVuZGVyVlRUQ3VlU3RyaW5nKGN1ZSk7XG4gICAgZGlzcGxheS5hcHBlbmQoZWwpO1xuICAgIHJldHVybiBkaXNwbGF5O1xuICB9XG4gIF9oYXNSZWdpb24oY3VlKSB7XG4gICAgcmV0dXJuIGN1ZS5yZWdpb24gJiYgY3VlLnNpemUgPT09IDEwMCAmJiBjdWUudmVydGljYWwgPT09IFwiXCIgJiYgY3VlLmxpbmUgPT09IFwiYXV0b1wiO1xuICB9XG59XG5cbmV4cG9ydCB7IENhcHRpb25zUmVuZGVyZXIgYXMgQywgUGFyc2VFcnJvciBhcyBQLCBUZXh0Q3VlIGFzIFQsIFZUVFBhcnNlciBhcyBWLCBWVFRCbG9jayBhcyBhLCBWVFRDdWUgYXMgYiwgUGFyc2VFcnJvckNvZGUgYXMgYywgcGFyc2VSZXNwb25zZSBhcyBkLCBwYXJzZUJ5dGVTdHJlYW0gYXMgZSwgcGFyc2VUZXh0IGFzIGYsIHBhcnNlVGV4dFN0cmVhbSBhcyBnLCBWVFRSZWdpb24gYXMgaCwgY3JlYXRlVlRUQ3VlVGVtcGxhdGUgYXMgaSwgcmVuZGVyVlRUVG9rZW5zU3RyaW5nIGFzIGosIHBhcnNlVlRUVGltZXN0YW1wIGFzIHAsIHJlbmRlclZUVEN1ZVN0cmluZyBhcyByLCB0b2tlbml6ZVZUVEN1ZSBhcyB0LCB1cGRhdGVUaW1lZFZUVEN1ZU5vZGVzIGFzIHUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/media-captions/dist/dev/index.js\n"));

/***/ })

}]);