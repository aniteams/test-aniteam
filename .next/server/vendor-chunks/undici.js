/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/undici";
exports.ids = ["vendor-chunks/undici"];
exports.modules = {

/***/ "(rsc)/./node_modules/undici/index.js":
/*!**************************************!*\
  !*** ./node_modules/undici/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Client = __webpack_require__(/*! ./lib/dispatcher/client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst Dispatcher = __webpack_require__(/*! ./lib/dispatcher/dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst Pool = __webpack_require__(/*! ./lib/dispatcher/pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst BalancedPool = __webpack_require__(/*! ./lib/dispatcher/balanced-pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/balanced-pool.js\")\nconst Agent = __webpack_require__(/*! ./lib/dispatcher/agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst ProxyAgent = __webpack_require__(/*! ./lib/dispatcher/proxy-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js\")\nconst EnvHttpProxyAgent = __webpack_require__(/*! ./lib/dispatcher/env-http-proxy-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\")\nconst RetryAgent = __webpack_require__(/*! ./lib/dispatcher/retry-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/retry-agent.js\")\nconst errors = __webpack_require__(/*! ./lib/core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ./lib/core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError } = errors\nconst api = __webpack_require__(/*! ./lib/api */ \"(rsc)/./node_modules/undici/lib/api/index.js\")\nconst buildConnector = __webpack_require__(/*! ./lib/core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\nconst MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ \"(rsc)/./node_modules/undici/lib/mock/mock-client.js\")\nconst MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ \"(rsc)/./node_modules/undici/lib/mock/mock-agent.js\")\nconst MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ \"(rsc)/./node_modules/undici/lib/mock/mock-pool.js\")\nconst mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ \"(rsc)/./node_modules/undici/lib/mock/mock-errors.js\")\nconst RetryHandler = __webpack_require__(/*! ./lib/handler/retry-handler */ \"(rsc)/./node_modules/undici/lib/handler/retry-handler.js\")\nconst { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ \"(rsc)/./node_modules/undici/lib/global.js\")\nconst DecoratorHandler = __webpack_require__(/*! ./lib/handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\nconst RedirectHandler = __webpack_require__(/*! ./lib/handler/redirect-handler */ \"(rsc)/./node_modules/undici/lib/handler/redirect-handler.js\")\nconst createRedirectInterceptor = __webpack_require__(/*! ./lib/interceptor/redirect-interceptor */ \"(rsc)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\")\n\nObject.assign(Dispatcher.prototype, api)\n\nmodule.exports.Dispatcher = Dispatcher\nmodule.exports.Client = Client\nmodule.exports.Pool = Pool\nmodule.exports.BalancedPool = BalancedPool\nmodule.exports.Agent = Agent\nmodule.exports.ProxyAgent = ProxyAgent\nmodule.exports.EnvHttpProxyAgent = EnvHttpProxyAgent\nmodule.exports.RetryAgent = RetryAgent\nmodule.exports.RetryHandler = RetryHandler\n\nmodule.exports.DecoratorHandler = DecoratorHandler\nmodule.exports.RedirectHandler = RedirectHandler\nmodule.exports.createRedirectInterceptor = createRedirectInterceptor\nmodule.exports.interceptors = {\n  redirect: __webpack_require__(/*! ./lib/interceptor/redirect */ \"(rsc)/./node_modules/undici/lib/interceptor/redirect.js\"),\n  retry: __webpack_require__(/*! ./lib/interceptor/retry */ \"(rsc)/./node_modules/undici/lib/interceptor/retry.js\"),\n  dump: __webpack_require__(/*! ./lib/interceptor/dump */ \"(rsc)/./node_modules/undici/lib/interceptor/dump.js\"),\n  dns: __webpack_require__(/*! ./lib/interceptor/dns */ \"(rsc)/./node_modules/undici/lib/interceptor/dns.js\")\n}\n\nmodule.exports.buildConnector = buildConnector\nmodule.exports.errors = errors\nmodule.exports.util = {\n  parseHeaders: util.parseHeaders,\n  headerNameToString: util.headerNameToString\n}\n\nfunction makeDispatcher (fn) {\n  return (url, opts, handler) => {\n    if (typeof opts === 'function') {\n      handler = opts\n      opts = null\n    }\n\n    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {\n      throw new InvalidArgumentError('invalid url')\n    }\n\n    if (opts != null && typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (opts && opts.path != null) {\n      if (typeof opts.path !== 'string') {\n        throw new InvalidArgumentError('invalid opts.path')\n      }\n\n      let path = opts.path\n      if (!opts.path.startsWith('/')) {\n        path = `/${path}`\n      }\n\n      url = new URL(util.parseOrigin(url).origin + path)\n    } else {\n      if (!opts) {\n        opts = typeof url === 'object' ? url : {}\n      }\n\n      url = util.parseURL(url)\n    }\n\n    const { agent, dispatcher = getGlobalDispatcher() } = opts\n\n    if (agent) {\n      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')\n    }\n\n    return fn.call(dispatcher, {\n      ...opts,\n      origin: url.origin,\n      path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n      method: opts.method || (opts.body ? 'PUT' : 'GET')\n    }, handler)\n  }\n}\n\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher\n\nconst fetchImpl = (__webpack_require__(/*! ./lib/web/fetch */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\").fetch)\nmodule.exports.fetch = async function fetch (init, options = undefined) {\n  try {\n    return await fetchImpl(init, options)\n  } catch (err) {\n    if (err && typeof err === 'object') {\n      Error.captureStackTrace(err)\n    }\n\n    throw err\n  }\n}\nmodule.exports.Headers = __webpack_require__(/*! ./lib/web/fetch/headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\").Headers\nmodule.exports.Response = __webpack_require__(/*! ./lib/web/fetch/response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\").Response\nmodule.exports.Request = __webpack_require__(/*! ./lib/web/fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\").Request\nmodule.exports.FormData = __webpack_require__(/*! ./lib/web/fetch/formdata */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\").FormData\nmodule.exports.File = globalThis.File ?? (__webpack_require__(/*! node:buffer */ \"node:buffer\").File)\nmodule.exports.FileReader = __webpack_require__(/*! ./lib/web/fileapi/filereader */ \"(rsc)/./node_modules/undici/lib/web/fileapi/filereader.js\").FileReader\n\nconst { setGlobalOrigin, getGlobalOrigin } = __webpack_require__(/*! ./lib/web/fetch/global */ \"(rsc)/./node_modules/undici/lib/web/fetch/global.js\")\n\nmodule.exports.setGlobalOrigin = setGlobalOrigin\nmodule.exports.getGlobalOrigin = getGlobalOrigin\n\nconst { CacheStorage } = __webpack_require__(/*! ./lib/web/cache/cachestorage */ \"(rsc)/./node_modules/undici/lib/web/cache/cachestorage.js\")\nconst { kConstruct } = __webpack_require__(/*! ./lib/web/cache/symbols */ \"(rsc)/./node_modules/undici/lib/web/cache/symbols.js\")\n\n// Cache & CacheStorage are tightly coupled with fetch. Even if it may run\n// in an older version of Node, it doesn't have any use without fetch.\nmodule.exports.caches = new CacheStorage(kConstruct)\n\nconst { deleteCookie, getCookies, getSetCookies, setCookie } = __webpack_require__(/*! ./lib/web/cookies */ \"(rsc)/./node_modules/undici/lib/web/cookies/index.js\")\n\nmodule.exports.deleteCookie = deleteCookie\nmodule.exports.getCookies = getCookies\nmodule.exports.getSetCookies = getSetCookies\nmodule.exports.setCookie = setCookie\n\nconst { parseMIMEType, serializeAMimeType } = __webpack_require__(/*! ./lib/web/fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\n\nmodule.exports.parseMIMEType = parseMIMEType\nmodule.exports.serializeAMimeType = serializeAMimeType\n\nconst { CloseEvent, ErrorEvent, MessageEvent } = __webpack_require__(/*! ./lib/web/websocket/events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nmodule.exports.WebSocket = __webpack_require__(/*! ./lib/web/websocket/websocket */ \"(rsc)/./node_modules/undici/lib/web/websocket/websocket.js\").WebSocket\nmodule.exports.CloseEvent = CloseEvent\nmodule.exports.ErrorEvent = ErrorEvent\nmodule.exports.MessageEvent = MessageEvent\n\nmodule.exports.request = makeDispatcher(api.request)\nmodule.exports.stream = makeDispatcher(api.stream)\nmodule.exports.pipeline = makeDispatcher(api.pipeline)\nmodule.exports.connect = makeDispatcher(api.connect)\nmodule.exports.upgrade = makeDispatcher(api.upgrade)\n\nmodule.exports.MockClient = MockClient\nmodule.exports.MockPool = MockPool\nmodule.exports.MockAgent = MockAgent\nmodule.exports.mockErrors = mockErrors\n\nconst { EventSource } = __webpack_require__(/*! ./lib/web/eventsource/eventsource */ \"(rsc)/./node_modules/undici/lib/web/eventsource/eventsource.js\")\n\nmodule.exports.EventSource = EventSource\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxxRkFBeUI7QUFDaEQsbUJBQW1CLG1CQUFPLENBQUMsNkZBQTZCO0FBQ3hELGFBQWEsbUJBQU8sQ0FBQyxpRkFBdUI7QUFDNUMscUJBQXFCLG1CQUFPLENBQUMsbUdBQWdDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDOUMsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQThCO0FBQ3pELDBCQUEwQixtQkFBTyxDQUFDLGlIQUF1QztBQUN6RSxtQkFBbUIsbUJBQU8sQ0FBQywrRkFBOEI7QUFDekQsZUFBZSxtQkFBTyxDQUFDLHlFQUFtQjtBQUMxQyxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDLFFBQVEsdUJBQXVCO0FBQy9CLFlBQVksbUJBQU8sQ0FBQywrREFBVztBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQywyRUFBb0I7QUFDbkQsbUJBQW1CLG1CQUFPLENBQUMsbUZBQXdCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLGlGQUF1QjtBQUNqRCxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBc0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsbUZBQXdCO0FBQ25ELHFCQUFxQixtQkFBTyxDQUFDLDZGQUE2QjtBQUMxRCxRQUFRLDJDQUEyQyxFQUFFLG1CQUFPLENBQUMsK0RBQWM7QUFDM0UseUJBQXlCLG1CQUFPLENBQUMscUdBQWlDO0FBQ2xFLHdCQUF3QixtQkFBTyxDQUFDLG1HQUFnQztBQUNoRSxrQ0FBa0MsbUJBQU8sQ0FBQyxtSEFBd0M7O0FBRWxGOztBQUVBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLDJCQUEyQjtBQUMzQixvQkFBb0I7QUFDcEIseUJBQXlCO0FBQ3pCLGdDQUFnQztBQUNoQyx5QkFBeUI7QUFDekIsMkJBQTJCOztBQUUzQiwrQkFBK0I7QUFDL0IsOEJBQThCO0FBQzlCLHdDQUF3QztBQUN4QywyQkFBMkI7QUFDM0IsWUFBWSxtQkFBTyxDQUFDLDJGQUE0QjtBQUNoRCxTQUFTLG1CQUFPLENBQUMscUZBQXlCO0FBQzFDLFFBQVEsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDeEMsT0FBTyxtQkFBTyxDQUFDLGlGQUF1QjtBQUN0Qzs7QUFFQSw2QkFBNkI7QUFDN0IscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksNENBQTRDOztBQUV4RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWEsRUFBRSxXQUFXO0FBQ3REO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDLGtDQUFrQzs7QUFFbEMsa0JBQWtCLHdHQUFnQztBQUNsRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMklBQW1FO0FBQ25FLCtJQUFzRTtBQUN0RSwySUFBbUU7QUFDbkUsK0lBQXNFO0FBQ3RFLG1CQUFtQixzQkFBc0IsNERBQTJCO0FBQ3BFLDJKQUE4RTs7QUFFOUUsUUFBUSxtQ0FBbUMsRUFBRSxtQkFBTyxDQUFDLG1GQUF3Qjs7QUFFN0UsOEJBQThCO0FBQzlCLDhCQUE4Qjs7QUFFOUIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQywrRkFBOEI7QUFDL0QsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyxxRkFBeUI7O0FBRXhEO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLFFBQVEscURBQXFELEVBQUUsbUJBQU8sQ0FBQywrRUFBbUI7O0FBRTFGLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLHdCQUF3Qjs7QUFFeEIsUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHVGQUEwQjs7QUFFaEYsNEJBQTRCO0FBQzVCLGlDQUFpQzs7QUFFakMsUUFBUSx1Q0FBdUMsRUFBRSxtQkFBTyxDQUFDLDJGQUE0QjtBQUNyRiwySkFBNkU7QUFDN0UseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QiwyQkFBMkI7O0FBRTNCLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHNCQUFzQjtBQUN0QixzQkFBc0I7O0FBRXRCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLHlCQUF5Qjs7QUFFekIsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyx5R0FBbUM7O0FBRW5FLDBCQUEwQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvY2xpZW50JylcbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vbGliL2Rpc3BhdGNoZXIvcG9vbCcpXG5jb25zdCBCYWxhbmNlZFBvb2wgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL2JhbGFuY2VkLXBvb2wnKVxuY29uc3QgQWdlbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL2FnZW50JylcbmNvbnN0IFByb3h5QWdlbnQgPSByZXF1aXJlKCcuL2xpYi9kaXNwYXRjaGVyL3Byb3h5LWFnZW50JylcbmNvbnN0IEVudkh0dHBQcm94eUFnZW50ID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9lbnYtaHR0cC1wcm94eS1hZ2VudCcpXG5jb25zdCBSZXRyeUFnZW50ID0gcmVxdWlyZSgnLi9saWIvZGlzcGF0Y2hlci9yZXRyeS1hZ2VudCcpXG5jb25zdCBlcnJvcnMgPSByZXF1aXJlKCcuL2xpYi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi9saWIvY29yZS91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IGVycm9yc1xuY29uc3QgYXBpID0gcmVxdWlyZSgnLi9saWIvYXBpJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi9saWIvY29yZS9jb25uZWN0JylcbmNvbnN0IE1vY2tDbGllbnQgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stY2xpZW50JylcbmNvbnN0IE1vY2tBZ2VudCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1hZ2VudCcpXG5jb25zdCBNb2NrUG9vbCA9IHJlcXVpcmUoJy4vbGliL21vY2svbW9jay1wb29sJylcbmNvbnN0IG1vY2tFcnJvcnMgPSByZXF1aXJlKCcuL2xpYi9tb2NrL21vY2stZXJyb3JzJylcbmNvbnN0IFJldHJ5SGFuZGxlciA9IHJlcXVpcmUoJy4vbGliL2hhbmRsZXIvcmV0cnktaGFuZGxlcicpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIsIHNldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4vbGliL2dsb2JhbCcpXG5jb25zdCBEZWNvcmF0b3JIYW5kbGVyID0gcmVxdWlyZSgnLi9saWIvaGFuZGxlci9kZWNvcmF0b3ItaGFuZGxlcicpXG5jb25zdCBSZWRpcmVjdEhhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXInKVxuY29uc3QgY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL3JlZGlyZWN0LWludGVyY2VwdG9yJylcblxuT2JqZWN0LmFzc2lnbihEaXNwYXRjaGVyLnByb3RvdHlwZSwgYXBpKVxuXG5tb2R1bGUuZXhwb3J0cy5EaXNwYXRjaGVyID0gRGlzcGF0Y2hlclxubW9kdWxlLmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50XG5tb2R1bGUuZXhwb3J0cy5Qb29sID0gUG9vbFxubW9kdWxlLmV4cG9ydHMuQmFsYW5jZWRQb29sID0gQmFsYW5jZWRQb29sXG5tb2R1bGUuZXhwb3J0cy5BZ2VudCA9IEFnZW50XG5tb2R1bGUuZXhwb3J0cy5Qcm94eUFnZW50ID0gUHJveHlBZ2VudFxubW9kdWxlLmV4cG9ydHMuRW52SHR0cFByb3h5QWdlbnQgPSBFbnZIdHRwUHJveHlBZ2VudFxubW9kdWxlLmV4cG9ydHMuUmV0cnlBZ2VudCA9IFJldHJ5QWdlbnRcbm1vZHVsZS5leHBvcnRzLlJldHJ5SGFuZGxlciA9IFJldHJ5SGFuZGxlclxuXG5tb2R1bGUuZXhwb3J0cy5EZWNvcmF0b3JIYW5kbGVyID0gRGVjb3JhdG9ySGFuZGxlclxubW9kdWxlLmV4cG9ydHMuUmVkaXJlY3RIYW5kbGVyID0gUmVkaXJlY3RIYW5kbGVyXG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvclxubW9kdWxlLmV4cG9ydHMuaW50ZXJjZXB0b3JzID0ge1xuICByZWRpcmVjdDogcmVxdWlyZSgnLi9saWIvaW50ZXJjZXB0b3IvcmVkaXJlY3QnKSxcbiAgcmV0cnk6IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL3JldHJ5JyksXG4gIGR1bXA6IHJlcXVpcmUoJy4vbGliL2ludGVyY2VwdG9yL2R1bXAnKSxcbiAgZG5zOiByZXF1aXJlKCcuL2xpYi9pbnRlcmNlcHRvci9kbnMnKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5idWlsZENvbm5lY3RvciA9IGJ1aWxkQ29ubmVjdG9yXG5tb2R1bGUuZXhwb3J0cy5lcnJvcnMgPSBlcnJvcnNcbm1vZHVsZS5leHBvcnRzLnV0aWwgPSB7XG4gIHBhcnNlSGVhZGVyczogdXRpbC5wYXJzZUhlYWRlcnMsXG4gIGhlYWRlck5hbWVUb1N0cmluZzogdXRpbC5oZWFkZXJOYW1lVG9TdHJpbmdcbn1cblxuZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIgKGZuKSB7XG4gIHJldHVybiAodXJsLCBvcHRzLCBoYW5kbGVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBoYW5kbGVyID0gb3B0c1xuICAgICAgb3B0cyA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAoIXVybCB8fCAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHVybCAhPT0gJ29iamVjdCcgJiYgISh1cmwgaW5zdGFuY2VvZiBVUkwpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVybCcpXG4gICAgfVxuXG4gICAgaWYgKG9wdHMgIT0gbnVsbCAmJiB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAob3B0cyAmJiBvcHRzLnBhdGggIT0gbnVsbCkge1xuICAgICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzLnBhdGgnKVxuICAgICAgfVxuXG4gICAgICBsZXQgcGF0aCA9IG9wdHMucGF0aFxuICAgICAgaWYgKCFvcHRzLnBhdGguc3RhcnRzV2l0aCgnLycpKSB7XG4gICAgICAgIHBhdGggPSBgLyR7cGF0aH1gXG4gICAgICB9XG5cbiAgICAgIHVybCA9IG5ldyBVUkwodXRpbC5wYXJzZU9yaWdpbih1cmwpLm9yaWdpbiArIHBhdGgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghb3B0cykge1xuICAgICAgICBvcHRzID0gdHlwZW9mIHVybCA9PT0gJ29iamVjdCcgPyB1cmwgOiB7fVxuICAgICAgfVxuXG4gICAgICB1cmwgPSB1dGlsLnBhcnNlVVJMKHVybClcbiAgICB9XG5cbiAgICBjb25zdCB7IGFnZW50LCBkaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIH0gPSBvcHRzXG5cbiAgICBpZiAoYWdlbnQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgb3B0cy5hZ2VudC4gRGlkIHlvdSBtZWFuIG9wdHMuY2xpZW50PycpXG4gICAgfVxuXG4gICAgcmV0dXJuIGZuLmNhbGwoZGlzcGF0Y2hlciwge1xuICAgICAgLi4ub3B0cyxcbiAgICAgIG9yaWdpbjogdXJsLm9yaWdpbixcbiAgICAgIHBhdGg6IHVybC5zZWFyY2ggPyBgJHt1cmwucGF0aG5hbWV9JHt1cmwuc2VhcmNofWAgOiB1cmwucGF0aG5hbWUsXG4gICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8IChvcHRzLmJvZHkgPyAnUFVUJyA6ICdHRVQnKVxuICAgIH0sIGhhbmRsZXIpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuc2V0R2xvYmFsRGlzcGF0Y2hlciA9IHNldEdsb2JhbERpc3BhdGNoZXJcbm1vZHVsZS5leHBvcnRzLmdldEdsb2JhbERpc3BhdGNoZXIgPSBnZXRHbG9iYWxEaXNwYXRjaGVyXG5cbmNvbnN0IGZldGNoSW1wbCA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaCcpLmZldGNoXG5tb2R1bGUuZXhwb3J0cy5mZXRjaCA9IGFzeW5jIGZ1bmN0aW9uIGZldGNoIChpbml0LCBvcHRpb25zID0gdW5kZWZpbmVkKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGZldGNoSW1wbChpbml0LCBvcHRpb25zKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIHR5cGVvZiBlcnIgPT09ICdvYmplY3QnKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIpXG4gICAgfVxuXG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzLkhlYWRlcnMgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvaGVhZGVycycpLkhlYWRlcnNcbm1vZHVsZS5leHBvcnRzLlJlc3BvbnNlID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL3Jlc3BvbnNlJykuUmVzcG9uc2Vcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSByZXF1aXJlKCcuL2xpYi93ZWIvZmV0Y2gvcmVxdWVzdCcpLlJlcXVlc3Rcbm1vZHVsZS5leHBvcnRzLkZvcm1EYXRhID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL2Zvcm1kYXRhJykuRm9ybURhdGFcbm1vZHVsZS5leHBvcnRzLkZpbGUgPSBnbG9iYWxUaGlzLkZpbGUgPz8gcmVxdWlyZSgnbm9kZTpidWZmZXInKS5GaWxlXG5tb2R1bGUuZXhwb3J0cy5GaWxlUmVhZGVyID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZpbGVhcGkvZmlsZXJlYWRlcicpLkZpbGVSZWFkZXJcblxuY29uc3QgeyBzZXRHbG9iYWxPcmlnaW4sIGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2ZldGNoL2dsb2JhbCcpXG5cbm1vZHVsZS5leHBvcnRzLnNldEdsb2JhbE9yaWdpbiA9IHNldEdsb2JhbE9yaWdpblxubW9kdWxlLmV4cG9ydHMuZ2V0R2xvYmFsT3JpZ2luID0gZ2V0R2xvYmFsT3JpZ2luXG5cbmNvbnN0IHsgQ2FjaGVTdG9yYWdlIH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvY2FjaGUvY2FjaGVzdG9yYWdlJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi9saWIvd2ViL2NhY2hlL3N5bWJvbHMnKVxuXG4vLyBDYWNoZSAmIENhY2hlU3RvcmFnZSBhcmUgdGlnaHRseSBjb3VwbGVkIHdpdGggZmV0Y2guIEV2ZW4gaWYgaXQgbWF5IHJ1blxuLy8gaW4gYW4gb2xkZXIgdmVyc2lvbiBvZiBOb2RlLCBpdCBkb2Vzbid0IGhhdmUgYW55IHVzZSB3aXRob3V0IGZldGNoLlxubW9kdWxlLmV4cG9ydHMuY2FjaGVzID0gbmV3IENhY2hlU3RvcmFnZShrQ29uc3RydWN0KVxuXG5jb25zdCB7IGRlbGV0ZUNvb2tpZSwgZ2V0Q29va2llcywgZ2V0U2V0Q29va2llcywgc2V0Q29va2llIH0gPSByZXF1aXJlKCcuL2xpYi93ZWIvY29va2llcycpXG5cbm1vZHVsZS5leHBvcnRzLmRlbGV0ZUNvb2tpZSA9IGRlbGV0ZUNvb2tpZVxubW9kdWxlLmV4cG9ydHMuZ2V0Q29va2llcyA9IGdldENvb2tpZXNcbm1vZHVsZS5leHBvcnRzLmdldFNldENvb2tpZXMgPSBnZXRTZXRDb29raWVzXG5tb2R1bGUuZXhwb3J0cy5zZXRDb29raWUgPSBzZXRDb29raWVcblxuY29uc3QgeyBwYXJzZU1JTUVUeXBlLCBzZXJpYWxpemVBTWltZVR5cGUgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9mZXRjaC9kYXRhLXVybCcpXG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlTUlNRVR5cGUgPSBwYXJzZU1JTUVUeXBlXG5tb2R1bGUuZXhwb3J0cy5zZXJpYWxpemVBTWltZVR5cGUgPSBzZXJpYWxpemVBTWltZVR5cGVcblxuY29uc3QgeyBDbG9zZUV2ZW50LCBFcnJvckV2ZW50LCBNZXNzYWdlRXZlbnQgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi93ZWJzb2NrZXQvZXZlbnRzJylcbm1vZHVsZS5leHBvcnRzLldlYlNvY2tldCA9IHJlcXVpcmUoJy4vbGliL3dlYi93ZWJzb2NrZXQvd2Vic29ja2V0JykuV2ViU29ja2V0XG5tb2R1bGUuZXhwb3J0cy5DbG9zZUV2ZW50ID0gQ2xvc2VFdmVudFxubW9kdWxlLmV4cG9ydHMuRXJyb3JFdmVudCA9IEVycm9yRXZlbnRcbm1vZHVsZS5leHBvcnRzLk1lc3NhZ2VFdmVudCA9IE1lc3NhZ2VFdmVudFxuXG5tb2R1bGUuZXhwb3J0cy5yZXF1ZXN0ID0gbWFrZURpc3BhdGNoZXIoYXBpLnJlcXVlc3QpXG5tb2R1bGUuZXhwb3J0cy5zdHJlYW0gPSBtYWtlRGlzcGF0Y2hlcihhcGkuc3RyZWFtKVxubW9kdWxlLmV4cG9ydHMucGlwZWxpbmUgPSBtYWtlRGlzcGF0Y2hlcihhcGkucGlwZWxpbmUpXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gbWFrZURpc3BhdGNoZXIoYXBpLmNvbm5lY3QpXG5tb2R1bGUuZXhwb3J0cy51cGdyYWRlID0gbWFrZURpc3BhdGNoZXIoYXBpLnVwZ3JhZGUpXG5cbm1vZHVsZS5leHBvcnRzLk1vY2tDbGllbnQgPSBNb2NrQ2xpZW50XG5tb2R1bGUuZXhwb3J0cy5Nb2NrUG9vbCA9IE1vY2tQb29sXG5tb2R1bGUuZXhwb3J0cy5Nb2NrQWdlbnQgPSBNb2NrQWdlbnRcbm1vZHVsZS5leHBvcnRzLm1vY2tFcnJvcnMgPSBtb2NrRXJyb3JzXG5cbmNvbnN0IHsgRXZlbnRTb3VyY2UgfSA9IHJlcXVpcmUoJy4vbGliL3dlYi9ldmVudHNvdXJjZS9ldmVudHNvdXJjZScpXG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50U291cmNlID0gRXZlbnRTb3VyY2VcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/abort-signal.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/abort-signal.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { addAbortListener } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nconst kListener = Symbol('kListener')\nconst kSignal = Symbol('kSignal')\n\nfunction abort (self) {\n  if (self.abort) {\n    self.abort(self[kSignal]?.reason)\n  } else {\n    self.reason = self[kSignal]?.reason ?? new RequestAbortedError()\n  }\n  removeSignal(self)\n}\n\nfunction addSignal (self, signal) {\n  self.reason = null\n\n  self[kSignal] = null\n  self[kListener] = null\n\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    abort(self)\n    return\n  }\n\n  self[kSignal] = signal\n  self[kListener] = () => {\n    abort(self)\n  }\n\n  addAbortListener(self[kSignal], self[kListener])\n}\n\nfunction removeSignal (self) {\n  if (!self[kSignal]) {\n    return\n  }\n\n  if ('removeEventListener' in self[kSignal]) {\n    self[kSignal].removeEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].removeListener('abort', self[kListener])\n  }\n\n  self[kSignal] = null\n  self[kListener] = null\n}\n\nmodule.exports = {\n  addSignal,\n  removeSignal\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYWJvcnQtc2lnbmFsLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYztBQUNuRCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXGFib3J0LXNpZ25hbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IGFkZEFib3J0TGlzdGVuZXIgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuY29uc3Qga0xpc3RlbmVyID0gU3ltYm9sKCdrTGlzdGVuZXInKVxuY29uc3Qga1NpZ25hbCA9IFN5bWJvbCgna1NpZ25hbCcpXG5cbmZ1bmN0aW9uIGFib3J0IChzZWxmKSB7XG4gIGlmIChzZWxmLmFib3J0KSB7XG4gICAgc2VsZi5hYm9ydChzZWxmW2tTaWduYWxdPy5yZWFzb24pXG4gIH0gZWxzZSB7XG4gICAgc2VsZi5yZWFzb24gPSBzZWxmW2tTaWduYWxdPy5yZWFzb24gPz8gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICB9XG4gIHJlbW92ZVNpZ25hbChzZWxmKVxufVxuXG5mdW5jdGlvbiBhZGRTaWduYWwgKHNlbGYsIHNpZ25hbCkge1xuICBzZWxmLnJlYXNvbiA9IG51bGxcblxuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG5cbiAgaWYgKCFzaWduYWwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgIGFib3J0KHNlbGYpXG4gICAgcmV0dXJuXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gc2lnbmFsXG4gIHNlbGZba0xpc3RlbmVyXSA9ICgpID0+IHtcbiAgICBhYm9ydChzZWxmKVxuICB9XG5cbiAgYWRkQWJvcnRMaXN0ZW5lcihzZWxmW2tTaWduYWxdLCBzZWxmW2tMaXN0ZW5lcl0pXG59XG5cbmZ1bmN0aW9uIHJlbW92ZVNpZ25hbCAoc2VsZikge1xuICBpZiAoIXNlbGZba1NpZ25hbF0pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gc2VsZltrU2lnbmFsXSkge1xuICAgIHNlbGZba1NpZ25hbF0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH0gZWxzZSB7XG4gICAgc2VsZltrU2lnbmFsXS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBzZWxmW2tMaXN0ZW5lcl0pXG4gIH1cblxuICBzZWxmW2tTaWduYWxdID0gbnVsbFxuICBzZWxmW2tMaXN0ZW5lcl0gPSBudWxsXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGRTaWduYWwsXG4gIHJlbW92ZVNpZ25hbFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/abort-signal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-connect.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-connect.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders () {\n    throw new SocketError('bad connect', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n\n    let headers = rawHeaders\n    // Indicates is an HTTP2Session\n    if (headers != null) {\n      headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    }\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = connect\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLWNvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDcEQsUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFnQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQ0FBa0M7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNEJBQTRCOztBQUV4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFlBQVksbUJBQW1COztBQUUvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktY29ubmVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdub2RlOmFzeW5jX2hvb2tzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFNvY2tldEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcblxuY2xhc3MgQ29ubmVjdEhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG9wYXF1ZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9DT05ORUNUJylcblxuICAgIHRoaXMub3BhcXVlID0gb3BhcXVlIHx8IG51bGxcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcblxuICAgIGFkZFNpZ25hbCh0aGlzLCBzaWduYWwpXG4gIH1cblxuICBvbkNvbm5lY3QgKGFib3J0LCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICBhYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLmNhbGxiYWNrKVxuXG4gICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dFxuICB9XG5cbiAgb25IZWFkZXJzICgpIHtcbiAgICB0aHJvdyBuZXcgU29ja2V0RXJyb3IoJ2JhZCBjb25uZWN0JywgbnVsbClcbiAgfVxuXG4gIG9uVXBncmFkZSAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICByZW1vdmVTaWduYWwodGhpcylcblxuICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG5cbiAgICBsZXQgaGVhZGVycyA9IHJhd0hlYWRlcnNcbiAgICAvLyBJbmRpY2F0ZXMgaXMgYW4gSFRUUDJTZXNzaW9uXG4gICAgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgaGVhZGVycyA9IHRoaXMucmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICB9XG5cbiAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgc3RhdHVzQ29kZSxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBzb2NrZXQsXG4gICAgICBvcGFxdWUsXG4gICAgICBjb250ZXh0XG4gICAgfSlcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgY2FsbGJhY2ssIG9wYXF1ZSB9ID0gdGhpc1xuXG4gICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIsIHsgb3BhcXVlIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb25uZWN0IChvcHRzLCBjYWxsYmFjaykge1xuICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25uZWN0LmNhbGwodGhpcywgb3B0cywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGNvbm5lY3RIYW5kbGVyID0gbmV3IENvbm5lY3RIYW5kbGVyKG9wdHMsIGNhbGxiYWNrKVxuICAgIHRoaXMuZGlzcGF0Y2goeyAuLi5vcHRzLCBtZXRob2Q6ICdDT05ORUNUJyB9LCBjb25uZWN0SGFuZGxlcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICAgIGNvbnN0IG9wYXF1ZSA9IG9wdHM/Lm9wYXF1ZVxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKGVyciwgeyBvcGFxdWUgfSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25uZWN0XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-pipeline.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-pipeline.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque, onInfo, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.responseHeaders = responseHeaders || null\n    this.handler = handler\n    this.abort = null\n    this.context = null\n    this.onInfo = onInfo || null\n\n    this.req = new PipelineRequest().on('error', util.nop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body?.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    const { ret, res } = this\n\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(!res, 'pipeline cannot be retried')\n    assert(!ret.destroyed)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { opaque, handler, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers,\n        opaque,\n        body: this.res,\n        context\n      })\n    } catch (err) {\n      this.res.on('error', util.nop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXBpcGVsaW5lLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDcEQsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLDJFQUFnQjtBQUM1RCxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0JBQW9COztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrREFBa0Q7O0FBRTlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsTUFBTTs7QUFFdEI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLDZCQUE2Qjs7QUFFN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxjQUFjLE1BQU07O0FBRXBCO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFdBQVc7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSwyQkFBMkI7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLE1BQU07O0FBRXRCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLE1BQU07O0FBRXRCO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLE1BQU07O0FBRXRCO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9DQUFvQztBQUN4RDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktcGlwZWxpbmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgUmVhZGFibGUsXG4gIER1cGxleCxcbiAgUGFzc1Rocm91Z2hcbn0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkUmV0dXJuVmFsdWVFcnJvcixcbiAgUmVxdWVzdEFib3J0ZWRFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBBc3luY1Jlc291cmNlIH0gPSByZXF1aXJlKCdub2RlOmFzeW5jX2hvb2tzJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuY29uc3Qga1Jlc3VtZSA9IFN5bWJvbCgncmVzdW1lJylcblxuY2xhc3MgUGlwZWxpbmVSZXF1ZXN0IGV4dGVuZHMgUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoeyBhdXRvRGVzdHJveTogdHJ1ZSB9KVxuXG4gICAgdGhpc1trUmVzdW1lXSA9IG51bGxcbiAgfVxuXG4gIF9yZWFkICgpIHtcbiAgICBjb25zdCB7IFtrUmVzdW1lXTogcmVzdW1lIH0gPSB0aGlzXG5cbiAgICBpZiAocmVzdW1lKSB7XG4gICAgICB0aGlzW2tSZXN1bWVdID0gbnVsbFxuICAgICAgcmVzdW1lKClcbiAgICB9XG4gIH1cblxuICBfZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX3JlYWQoKVxuXG4gICAgY2FsbGJhY2soZXJyKVxuICB9XG59XG5cbmNsYXNzIFBpcGVsaW5lUmVzcG9uc2UgZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChyZXN1bWUpIHtcbiAgICBzdXBlcih7IGF1dG9EZXN0cm95OiB0cnVlIH0pXG4gICAgdGhpc1trUmVzdW1lXSA9IHJlc3VtZVxuICB9XG5cbiAgX3JlYWQgKCkge1xuICAgIHRoaXNba1Jlc3VtZV0oKVxuICB9XG5cbiAgX2Rlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWVyciAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgfVxuXG4gICAgY2FsbGJhY2soZXJyKVxuICB9XG59XG5cbmNsYXNzIFBpcGVsaW5lSGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBoYW5kbGVyJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgbWV0aG9kLCBvcGFxdWUsIG9uSW5mbywgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAob25JbmZvICYmIHR5cGVvZiBvbkluZm8gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkluZm8gY2FsbGJhY2snKVxuICAgIH1cblxuICAgIHN1cGVyKCdVTkRJQ0lfUElQRUxJTkUnKVxuXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG4gICAgdGhpcy5vbkluZm8gPSBvbkluZm8gfHwgbnVsbFxuXG4gICAgdGhpcy5yZXEgPSBuZXcgUGlwZWxpbmVSZXF1ZXN0KCkub24oJ2Vycm9yJywgdXRpbC5ub3ApXG5cbiAgICB0aGlzLnJldCA9IG5ldyBEdXBsZXgoe1xuICAgICAgcmVhZGFibGVPYmplY3RNb2RlOiBvcHRzLm9iamVjdE1vZGUsXG4gICAgICBhdXRvRGVzdHJveTogdHJ1ZSxcbiAgICAgIHJlYWQ6ICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBib2R5IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKGJvZHk/LnJlc3VtZSkge1xuICAgICAgICAgIGJvZHkucmVzdW1lKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHdyaXRlOiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBjb25zdCB7IHJlcSB9ID0gdGhpc1xuXG4gICAgICAgIGlmIChyZXEucHVzaChjaHVuaywgZW5jb2RpbmcpIHx8IHJlcS5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVxW2tSZXN1bWVdID0gY2FsbGJhY2tcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlc3Ryb3k6IChlcnIsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYm9keSwgcmVxLCByZXMsIHJldCwgYWJvcnQgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIWVyciAmJiAhcmV0Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWJvcnQgJiYgZXJyKSB7XG4gICAgICAgICAgYWJvcnQoKVxuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICAgICAgdXRpbC5kZXN0cm95KHJlcSwgZXJyKVxuICAgICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG5cbiAgICAgICAgcmVtb3ZlU2lnbmFsKHRoaXMpXG5cbiAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgfVxuICAgIH0pLm9uKCdwcmVmaW5pc2gnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7IHJlcSB9ID0gdGhpc1xuXG4gICAgICAvLyBOb2RlIDwgMTUgZG9lcyBub3QgY2FsbCBfZmluYWwgaW4gc2FtZSB0aWNrLlxuICAgICAgcmVxLnB1c2gobnVsbClcbiAgICB9KVxuXG4gICAgdGhpcy5yZXMgPSBudWxsXG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgcmV0LCByZXMgfSA9IHRoaXNcblxuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQoIXJlcywgJ3BpcGVsaW5lIGNhbm5vdCBiZSByZXRyaWVkJylcbiAgICBhc3NlcnQoIXJldC5kZXN0cm95ZWQpXG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSkge1xuICAgIGNvbnN0IHsgb3BhcXVlLCBoYW5kbGVyLCBjb250ZXh0IH0gPSB0aGlzXG5cbiAgICBpZiAoc3RhdHVzQ29kZSA8IDIwMCkge1xuICAgICAgaWYgKHRoaXMub25JbmZvKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnJlc3BvbnNlSGVhZGVycyA9PT0gJ3JhdycgPyB1dGlsLnBhcnNlUmF3SGVhZGVycyhyYXdIZWFkZXJzKSA6IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG4gICAgICAgIHRoaXMub25JbmZvKHsgc3RhdHVzQ29kZSwgaGVhZGVycyB9KVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5yZXMgPSBuZXcgUGlwZWxpbmVSZXNwb25zZShyZXN1bWUpXG5cbiAgICBsZXQgYm9keVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmhhbmRsZXIgPSBudWxsXG4gICAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgICAgYm9keSA9IHRoaXMucnVuSW5Bc3luY1Njb3BlKGhhbmRsZXIsIG51bGwsIHtcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgb3BhcXVlLFxuICAgICAgICBib2R5OiB0aGlzLnJlcyxcbiAgICAgICAgY29udGV4dFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMucmVzLm9uKCdlcnJvcicsIHV0aWwubm9wKVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgaWYgKCFib2R5IHx8IHR5cGVvZiBib2R5Lm9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFJldHVyblZhbHVlRXJyb3IoJ2V4cGVjdGVkIFJlYWRhYmxlJylcbiAgICB9XG5cbiAgICBib2R5XG4gICAgICAub24oJ2RhdGEnLCAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQsIGJvZHkgfSA9IHRoaXNcblxuICAgICAgICBpZiAoIXJldC5wdXNoKGNodW5rKSAmJiBib2R5LnBhdXNlKSB7XG4gICAgICAgICAgYm9keS5wYXVzZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuXG4gICAgICAgIHV0aWwuZGVzdHJveShyZXQsIGVycilcbiAgICAgIH0pXG4gICAgICAub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgeyByZXQgfSA9IHRoaXNcblxuICAgICAgICByZXQucHVzaChudWxsKVxuICAgICAgfSlcbiAgICAgIC5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmV0IH0gPSB0aGlzXG5cbiAgICAgICAgaWYgKCFyZXQuX3JlYWRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgICAgICB1dGlsLmRlc3Ryb3kocmV0LCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG4gICAgcmV0dXJuIHJlcy5wdXNoKGNodW5rKVxuICB9XG5cbiAgb25Db21wbGV0ZSAodHJhaWxlcnMpIHtcbiAgICBjb25zdCB7IHJlcyB9ID0gdGhpc1xuICAgIHJlcy5wdXNoKG51bGwpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IHJldCB9ID0gdGhpc1xuICAgIHRoaXMuaGFuZGxlciA9IG51bGxcbiAgICB1dGlsLmRlc3Ryb3kocmV0LCBlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUgKG9wdHMsIGhhbmRsZXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwaXBlbGluZUhhbmRsZXIgPSBuZXcgUGlwZWxpbmVIYW5kbGVyKG9wdHMsIGhhbmRsZXIpXG4gICAgdGhpcy5kaXNwYXRjaCh7IC4uLm9wdHMsIGJvZHk6IHBpcGVsaW5lSGFuZGxlci5yZXEgfSwgcGlwZWxpbmVIYW5kbGVyKVxuICAgIHJldHVybiBwaXBlbGluZUhhbmRsZXIucmV0XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2goKS5kZXN0cm95KGVycilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-pipeline.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-request.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-request.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { Readable } = __webpack_require__(/*! ./readable */ \"(rsc)/./node_modules/undici/lib/api/readable.js\")\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/api/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (highWaterMark && (typeof highWaterMark !== 'number' || highWaterMark < 0)) {\n        throw new InvalidArgumentError('invalid highWaterMark')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.method = method\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError\n    this.highWaterMark = highWaterMark\n    this.signal = signal\n    this.reason = null\n    this.removeAbortListener = null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    if (this.signal) {\n      if (this.signal.aborted) {\n        this.reason = this.signal.reason ?? new RequestAbortedError()\n      } else {\n        this.removeAbortListener = util.addAbortListener(this.signal, () => {\n          this.reason = this.signal.reason ?? new RequestAbortedError()\n          if (this.res) {\n            util.destroy(this.res.on('error', util.nop), this.reason)\n          } else if (this.abort) {\n            this.abort(this.reason)\n          }\n\n          if (this.removeAbortListener) {\n            this.res?.off('close', this.removeAbortListener)\n            this.removeAbortListener()\n            this.removeAbortListener = null\n          }\n        })\n      }\n    }\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n    const contentType = parsedHeaders['content-type']\n    const contentLength = parsedHeaders['content-length']\n    const res = new Readable({\n      resume,\n      abort,\n      contentType,\n      contentLength: this.method !== 'HEAD' && contentLength\n        ? Number(contentLength)\n        : null,\n      highWaterMark\n    })\n\n    if (this.removeAbortListener) {\n      res.on('close', this.removeAbortListener)\n    }\n\n    this.callback = null\n    this.res = res\n    if (callback !== null) {\n      if (this.throwOnError && statusCode >= 400) {\n        this.runInAsyncScope(getResolveErrorBodyCallback, null,\n          { callback, body: res, contentType, statusCode, statusMessage, headers }\n        )\n      } else {\n        this.runInAsyncScope(callback, null, null, {\n          statusCode,\n          headers,\n          trailers: this.trailers,\n          opaque,\n          body: res,\n          context\n        })\n      }\n    }\n  }\n\n  onData (chunk) {\n    return this.res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    util.parseHeaders(trailers, this.trailers)\n    this.res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n\n    if (this.removeAbortListener) {\n      res?.off('close', this.removeAbortListener)\n      this.removeAbortListener()\n      this.removeAbortListener = null\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\nmodule.exports.RequestHandler = RequestHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsbUVBQVk7QUFDekMsUUFBUSw0Q0FBNEMsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM5RSxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSw4QkFBOEIsRUFBRSxtQkFBTyxDQUFDLDJEQUFRO0FBQ3hELFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQywwQ0FBa0I7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxxRkFBcUY7O0FBRWpHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1FQUFtRTs7QUFFL0U7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDhCQUE4Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsUUFBUTtBQUM1RCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXGFwaS1yZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCcuL3JlYWRhYmxlJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuXG5jbGFzcyBSZXF1ZXN0SGFuZGxlciBleHRlbmRzIEFzeW5jUmVzb3VyY2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgY2FsbGJhY2spIHtcbiAgICBpZiAoIW9wdHMgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb3B0cycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG1ldGhvZCwgb3BhcXVlLCBib2R5LCBvbkluZm8sIHJlc3BvbnNlSGVhZGVycywgdGhyb3dPbkVycm9yLCBoaWdoV2F0ZXJNYXJrIH0gPSBvcHRzXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgICAgfVxuXG4gICAgICBpZiAoaGlnaFdhdGVyTWFyayAmJiAodHlwZW9mIGhpZ2hXYXRlck1hcmsgIT09ICdudW1iZXInIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGlnaFdhdGVyTWFyaycpXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgc3VwZXIoJ1VORElDSV9SRVFVRVNUJylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICAgIHV0aWwuZGVzdHJveShib2R5Lm9uKCdlcnJvcicsIHV0aWwubm9wKSwgZXJyKVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2RcbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFja1xuICAgIHRoaXMucmVzID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5ib2R5ID0gYm9keVxuICAgIHRoaXMudHJhaWxlcnMgPSB7fVxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3JcbiAgICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBoaWdoV2F0ZXJNYXJrXG4gICAgdGhpcy5zaWduYWwgPSBzaWduYWxcbiAgICB0aGlzLnJlYXNvbiA9IG51bGxcbiAgICB0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIgPSBudWxsXG5cbiAgICBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgICAgYm9keS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzLnNpZ25hbCkge1xuICAgICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgdGhpcy5yZWFzb24gPSB0aGlzLnNpZ25hbC5yZWFzb24gPz8gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyID0gdXRpbC5hZGRBYm9ydExpc3RlbmVyKHRoaXMuc2lnbmFsLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZWFzb24gPSB0aGlzLnNpZ25hbC5yZWFzb24gPz8gbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKVxuICAgICAgICAgIGlmICh0aGlzLnJlcykge1xuICAgICAgICAgICAgdXRpbC5kZXN0cm95KHRoaXMucmVzLm9uKCdlcnJvcicsIHV0aWwubm9wKSwgdGhpcy5yZWFzb24pXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICB0aGlzLmFib3J0KHRoaXMucmVhc29uKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnJlbW92ZUFib3J0TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVzPy5vZmYoJ2Nsb3NlJywgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKClcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lciA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jYWxsYmFjaylcblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHRcbiAgfVxuXG4gIG9uSGVhZGVycyAoc3RhdHVzQ29kZSwgcmF3SGVhZGVycywgcmVzdW1lLCBzdGF0dXNNZXNzYWdlKSB7XG4gICAgY29uc3QgeyBjYWxsYmFjaywgb3BhcXVlLCBhYm9ydCwgY29udGV4dCwgcmVzcG9uc2VIZWFkZXJzLCBoaWdoV2F0ZXJNYXJrIH0gPSB0aGlzXG5cbiAgICBjb25zdCBoZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwYXJzZWRIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpIDogaGVhZGVyc1xuICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcGFyc2VkSGVhZGVyc1snY29udGVudC10eXBlJ11cbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gcGFyc2VkSGVhZGVyc1snY29udGVudC1sZW5ndGgnXVxuICAgIGNvbnN0IHJlcyA9IG5ldyBSZWFkYWJsZSh7XG4gICAgICByZXN1bWUsXG4gICAgICBhYm9ydCxcbiAgICAgIGNvbnRlbnRUeXBlLFxuICAgICAgY29udGVudExlbmd0aDogdGhpcy5tZXRob2QgIT09ICdIRUFEJyAmJiBjb250ZW50TGVuZ3RoXG4gICAgICAgID8gTnVtYmVyKGNvbnRlbnRMZW5ndGgpXG4gICAgICAgIDogbnVsbCxcbiAgICAgIGhpZ2hXYXRlck1hcmtcbiAgICB9KVxuXG4gICAgaWYgKHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcikge1xuICAgICAgcmVzLm9uKCdjbG9zZScsIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcilcbiAgICB9XG5cbiAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgIHRoaXMucmVzID0gcmVzXG4gICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy50aHJvd09uRXJyb3IgJiYgc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrLCBudWxsLFxuICAgICAgICAgIHsgY2FsbGJhY2ssIGJvZHk6IHJlcywgY29udGVudFR5cGUsIHN0YXR1c0NvZGUsIHN0YXR1c01lc3NhZ2UsIGhlYWRlcnMgfVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgbnVsbCwge1xuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICB0cmFpbGVyczogdGhpcy50cmFpbGVycyxcbiAgICAgICAgICBvcGFxdWUsXG4gICAgICAgICAgYm9keTogcmVzLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvbkRhdGEgKGNodW5rKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzLnB1c2goY2h1bmspXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIHV0aWwucGFyc2VIZWFkZXJzKHRyYWlsZXJzLCB0aGlzLnRyYWlsZXJzKVxuICAgIHRoaXMucmVzLnB1c2gobnVsbClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycikge1xuICAgIGNvbnN0IHsgcmVzLCBjYWxsYmFjaywgYm9keSwgb3BhcXVlIH0gPSB0aGlzXG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIC8vIFRPRE86IERvZXMgdGhpcyBuZWVkIHF1ZXVlTWljcm90YXNrP1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHJlcykge1xuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICAvLyBFbnN1cmUgYWxsIHF1ZXVlZCBoYW5kbGVycyBhcmUgaW52b2tlZCBiZWZvcmUgZGVzdHJveWluZyByZXMuXG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHRoaXMuYm9keSA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lcikge1xuICAgICAgcmVzPy5vZmYoJ2Nsb3NlJywgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKVxuICAgICAgdGhpcy5yZW1vdmVBYm9ydExpc3RlbmVyKClcbiAgICAgIHRoaXMucmVtb3ZlQWJvcnRMaXN0ZW5lciA9IG51bGxcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdCAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmVxdWVzdC5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmRpc3BhdGNoKG9wdHMsIG5ldyBSZXF1ZXN0SGFuZGxlcihvcHRzLCBjYWxsYmFjaykpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICBjb25zdCBvcGFxdWUgPSBvcHRzPy5vcGFxdWVcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhlcnIsIHsgb3BhcXVlIH0pKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWVzdFxubW9kdWxlLmV4cG9ydHMuUmVxdWVzdEhhbmRsZXIgPSBSZXF1ZXN0SGFuZGxlclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-stream.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/api/api-stream.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { finished, PassThrough } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { InvalidArgumentError, InvalidReturnValueError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { getResolveErrorBodyCallback } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/api/util.js\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n    this.throwOnError = throwOnError || false\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const { factory, opaque, context, callback, responseHeaders } = this\n\n    const headers = responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n\n    let res\n\n    if (this.throwOnError && statusCode >= 400) {\n      const parsedHeaders = responseHeaders === 'raw' ? util.parseHeaders(rawHeaders) : headers\n      const contentType = parsedHeaders['content-type']\n      res = new PassThrough()\n\n      this.callback = null\n      this.runInAsyncScope(getResolveErrorBodyCallback, null,\n        { callback, body: res, contentType, statusCode, statusMessage, headers }\n      )\n    } else {\n      if (factory === null) {\n        return\n      }\n\n      res = this.runInAsyncScope(factory, null, {\n        statusCode,\n        headers,\n        opaque,\n        context\n      })\n\n      if (\n        !res ||\n        typeof res.write !== 'function' ||\n        typeof res.end !== 'function' ||\n        typeof res.on !== 'function'\n      ) {\n        throw new InvalidReturnValueError('expected Writable')\n      }\n\n      // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n      finished(res, { readable: false }, (err) => {\n        const { callback, res, opaque, trailers, abort } = this\n\n        this.res = null\n        if (err || !res.readable) {\n          util.destroy(res, err)\n        }\n\n        this.callback = null\n        this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n        if (err) {\n          abort()\n        }\n      })\n    }\n\n    res.on('drain', resume)\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState?.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res ? res.write(chunk) : true\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    if (!res) {\n      return\n    }\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3ZELFFBQVEsZ0RBQWdELEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDbEYsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsOEJBQThCLEVBQUUsbUJBQU8sQ0FBQywyREFBUTtBQUN4RCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ3BELFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQywyRUFBZ0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxzRUFBc0U7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHNEQUFzRDs7QUFFbEU7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDLGdCQUFnQix5Q0FBeUM7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNERBQTRELGtCQUFrQjs7QUFFOUU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNOztBQUVsQjtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksOEJBQThCOztBQUUxQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVELE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGZpbmlzaGVkLCBQYXNzVGhyb3VnaCB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW52YWxpZFJldHVyblZhbHVlRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEFzeW5jUmVzb3VyY2UgfSA9IHJlcXVpcmUoJ25vZGU6YXN5bmNfaG9va3MnKVxuY29uc3QgeyBhZGRTaWduYWwsIHJlbW92ZVNpZ25hbCB9ID0gcmVxdWlyZSgnLi9hYm9ydC1zaWduYWwnKVxuXG5jbGFzcyBTdHJlYW1IYW5kbGVyIGV4dGVuZHMgQXN5bmNSZXNvdXJjZSB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBmYWN0b3J5LCBjYWxsYmFjaykge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvcHRzJylcbiAgICB9XG5cbiAgICBjb25zdCB7IHNpZ25hbCwgbWV0aG9kLCBvcGFxdWUsIGJvZHksIG9uSW5mbywgcmVzcG9uc2VIZWFkZXJzLCB0aHJvd09uRXJyb3IgfSA9IG9wdHNcblxuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgZmFjdG9yeScpXG4gICAgICB9XG5cbiAgICAgIGlmIChzaWduYWwgJiYgdHlwZW9mIHNpZ25hbC5vbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdzaWduYWwgbXVzdCBiZSBhbiBFdmVudEVtaXR0ZXIgb3IgRXZlbnRUYXJnZXQnKVxuICAgICAgfVxuXG4gICAgICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGlmIChvbkluZm8gJiYgdHlwZW9mIG9uSW5mbyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25JbmZvIGNhbGxiYWNrJylcbiAgICAgIH1cblxuICAgICAgc3VwZXIoJ1VORElDSV9TVFJFQU0nKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KGJvZHkub24oJ2Vycm9yJywgdXRpbC5ub3ApLCBlcnIpXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG5cbiAgICB0aGlzLnJlc3BvbnNlSGVhZGVycyA9IHJlc3BvbnNlSGVhZGVycyB8fCBudWxsXG4gICAgdGhpcy5vcGFxdWUgPSBvcGFxdWUgfHwgbnVsbFxuICAgIHRoaXMuZmFjdG9yeSA9IGZhY3RvcnlcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICB0aGlzLnJlcyA9IG51bGxcbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgICB0aGlzLnRyYWlsZXJzID0gbnVsbFxuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLm9uSW5mbyA9IG9uSW5mbyB8fCBudWxsXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3IgfHwgZmFsc2VcblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKGJvZHkpKSB7XG4gICAgICBib2R5Lm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgYWRkU2lnbmFsKHRoaXMsIHNpZ25hbClcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQsIGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGFib3J0KHRoaXMucmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMuY2FsbGJhY2spXG5cbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0XG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzTWVzc2FnZSkge1xuICAgIGNvbnN0IHsgZmFjdG9yeSwgb3BhcXVlLCBjb250ZXh0LCBjYWxsYmFjaywgcmVzcG9uc2VIZWFkZXJzIH0gPSB0aGlzXG5cbiAgICBjb25zdCBoZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzID09PSAncmF3JyA/IHV0aWwucGFyc2VSYXdIZWFkZXJzKHJhd0hlYWRlcnMpIDogdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAodGhpcy5vbkluZm8pIHtcbiAgICAgICAgdGhpcy5vbkluZm8oeyBzdGF0dXNDb2RlLCBoZWFkZXJzIH0pXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmZhY3RvcnkgPSBudWxsXG5cbiAgICBsZXQgcmVzXG5cbiAgICBpZiAodGhpcy50aHJvd09uRXJyb3IgJiYgc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgIGNvbnN0IHBhcnNlZEhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycykgOiBoZWFkZXJzXG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHBhcnNlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXG4gICAgICByZXMgPSBuZXcgUGFzc1Rocm91Z2goKVxuXG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoZ2V0UmVzb2x2ZUVycm9yQm9keUNhbGxiYWNrLCBudWxsLFxuICAgICAgICB7IGNhbGxiYWNrLCBib2R5OiByZXMsIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH1cbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZhY3RvcnkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHJlcyA9IHRoaXMucnVuSW5Bc3luY1Njb3BlKGZhY3RvcnksIG51bGwsIHtcbiAgICAgICAgc3RhdHVzQ29kZSxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgb3BhcXVlLFxuICAgICAgICBjb250ZXh0XG4gICAgICB9KVxuXG4gICAgICBpZiAoXG4gICAgICAgICFyZXMgfHxcbiAgICAgICAgdHlwZW9mIHJlcy53cml0ZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2YgcmVzLmVuZCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICB0eXBlb2YgcmVzLm9uICE9PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRSZXR1cm5WYWx1ZUVycm9yKCdleHBlY3RlZCBXcml0YWJsZScpXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IEF2b2lkIGZpbmlzaGVkLiBJdCByZWdpc3RlcnMgYW4gdW5uZWNlc3NhcnkgYW1vdW50IG9mIGxpc3RlbmVycy5cbiAgICAgIGZpbmlzaGVkKHJlcywgeyByZWFkYWJsZTogZmFsc2UgfSwgKGVycikgPT4ge1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrLCByZXMsIG9wYXF1ZSwgdHJhaWxlcnMsIGFib3J0IH0gPSB0aGlzXG5cbiAgICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICAgIGlmIChlcnIgfHwgIXJlcy5yZWFkYWJsZSkge1xuICAgICAgICAgIHV0aWwuZGVzdHJveShyZXMsIGVycilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBudWxsXG4gICAgICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBlcnIgfHwgbnVsbCwgeyBvcGFxdWUsIHRyYWlsZXJzIH0pXG5cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGFib3J0KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXMub24oJ2RyYWluJywgcmVzdW1lKVxuXG4gICAgdGhpcy5yZXMgPSByZXNcblxuICAgIGNvbnN0IG5lZWREcmFpbiA9IHJlcy53cml0YWJsZU5lZWREcmFpbiAhPT0gdW5kZWZpbmVkXG4gICAgICA/IHJlcy53cml0YWJsZU5lZWREcmFpblxuICAgICAgOiByZXMuX3dyaXRhYmxlU3RhdGU/Lm5lZWREcmFpblxuXG4gICAgcmV0dXJuIG5lZWREcmFpbiAhPT0gdHJ1ZVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGNvbnN0IHsgcmVzIH0gPSB0aGlzXG5cbiAgICByZXR1cm4gcmVzID8gcmVzLndyaXRlKGNodW5rKSA6IHRydWVcbiAgfVxuXG4gIG9uQ29tcGxldGUgKHRyYWlsZXJzKSB7XG4gICAgY29uc3QgeyByZXMgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMudHJhaWxlcnMgPSB1dGlsLnBhcnNlSGVhZGVycyh0cmFpbGVycylcblxuICAgIHJlcy5lbmQoKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgY29uc3QgeyByZXMsIGNhbGxiYWNrLCBvcGFxdWUsIGJvZHkgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdGhpcy5mYWN0b3J5ID0gbnVsbFxuXG4gICAgaWYgKHJlcykge1xuICAgICAgdGhpcy5yZXMgPSBudWxsXG4gICAgICB1dGlsLmRlc3Ryb3kocmVzLCBlcnIpXG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5ydW5JbkFzeW5jU2NvcGUoY2FsbGJhY2ssIG51bGwsIGVyciwgeyBvcGFxdWUgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIHRoaXMuYm9keSA9IG51bGxcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmVhbSAob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgc3RyZWFtLmNhbGwodGhpcywgb3B0cywgZmFjdG9yeSwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB0cnkge1xuICAgIHRoaXMuZGlzcGF0Y2gob3B0cywgbmV3IFN0cmVhbUhhbmRsZXIob3B0cywgZmFjdG9yeSwgY2FsbGJhY2spKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cz8ub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmVhbVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/api-upgrade.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/api/api-upgrade.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { InvalidArgumentError, SocketError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { AsyncResource } = __webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ \"(rsc)/./node_modules/undici/lib/api/abort-signal.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque, responseHeaders } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (this.reason) {\n      abort(this.reason)\n      return\n    }\n\n    assert(this.callback)\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, rawHeaders, socket) {\n    assert(statusCode === 101)\n\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    this.runInAsyncScope(callback, null, null, {\n      headers,\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    this.dispatch({\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts?.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvYXBpLXVwZ3JhZGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQyxrRUFBYztBQUNuQyxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsMkVBQWdCO0FBQzVELGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxrQ0FBa0M7O0FBRTlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSw0QkFBNEI7O0FBRXhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsWUFBWSxtQkFBbUI7O0FBRS9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxRQUFRO0FBQzVELE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFxhcGktdXBncmFkZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgU29ja2V0RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgQXN5bmNSZXNvdXJjZSB9ID0gcmVxdWlyZSgnbm9kZTphc3luY19ob29rcycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgYWRkU2lnbmFsLCByZW1vdmVTaWduYWwgfSA9IHJlcXVpcmUoJy4vYWJvcnQtc2lnbmFsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuY2xhc3MgVXBncmFkZUhhbmRsZXIgZXh0ZW5kcyBBc3luY1Jlc291cmNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9wdHMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaWduYWwsIG9wYXF1ZSwgcmVzcG9uc2VIZWFkZXJzIH0gPSBvcHRzXG5cbiAgICBpZiAoc2lnbmFsICYmIHR5cGVvZiBzaWduYWwub24gIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEV2ZW50RW1pdHRlciBvciBFdmVudFRhcmdldCcpXG4gICAgfVxuXG4gICAgc3VwZXIoJ1VORElDSV9VUEdSQURFJylcblxuICAgIHRoaXMucmVzcG9uc2VIZWFkZXJzID0gcmVzcG9uc2VIZWFkZXJzIHx8IG51bGxcbiAgICB0aGlzLm9wYXF1ZSA9IG9wYXF1ZSB8fCBudWxsXG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gICAgdGhpcy5hYm9ydCA9IG51bGxcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsXG5cbiAgICBhZGRTaWduYWwodGhpcywgc2lnbmFsKVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCwgY29udGV4dCkge1xuICAgIGlmICh0aGlzLnJlYXNvbikge1xuICAgICAgYWJvcnQodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhc3NlcnQodGhpcy5jYWxsYmFjaylcblxuICAgIHRoaXMuYWJvcnQgPSBhYm9ydFxuICAgIHRoaXMuY29udGV4dCA9IG51bGxcbiAgfVxuXG4gIG9uSGVhZGVycyAoKSB7XG4gICAgdGhyb3cgbmV3IFNvY2tldEVycm9yKCdiYWQgdXBncmFkZScsIG51bGwpXG4gIH1cblxuICBvblVwZ3JhZGUgKHN0YXR1c0NvZGUsIHJhd0hlYWRlcnMsIHNvY2tldCkge1xuICAgIGFzc2VydChzdGF0dXNDb2RlID09PSAxMDEpXG5cbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUsIGNvbnRleHQgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgdGhpcy5jYWxsYmFjayA9IG51bGxcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5yZXNwb25zZUhlYWRlcnMgPT09ICdyYXcnID8gdXRpbC5wYXJzZVJhd0hlYWRlcnMocmF3SGVhZGVycykgOiB1dGlsLnBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKVxuICAgIHRoaXMucnVuSW5Bc3luY1Njb3BlKGNhbGxiYWNrLCBudWxsLCBudWxsLCB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgc29ja2V0LFxuICAgICAgb3BhcXVlLFxuICAgICAgY29udGV4dFxuICAgIH0pXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBjb25zdCB7IGNhbGxiYWNrLCBvcGFxdWUgfSA9IHRoaXNcblxuICAgIHJlbW92ZVNpZ25hbCh0aGlzKVxuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbFxuICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLnJ1bkluQXN5bmNTY29wZShjYWxsYmFjaywgbnVsbCwgZXJyLCB7IG9wYXF1ZSB9KVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBncmFkZSAob3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdXBncmFkZS5jYWxsKHRoaXMsIG9wdHMsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgfSlcbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB1cGdyYWRlSGFuZGxlciA9IG5ldyBVcGdyYWRlSGFuZGxlcihvcHRzLCBjYWxsYmFjaylcbiAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBtZXRob2Q6IG9wdHMubWV0aG9kIHx8ICdHRVQnLFxuICAgICAgdXBncmFkZTogb3B0cy5wcm90b2NvbCB8fCAnV2Vic29ja2V0J1xuICAgIH0sIHVwZ3JhZGVIYW5kbGVyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gICAgY29uc3Qgb3BhcXVlID0gb3B0cz8ub3BhcXVlXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2soZXJyLCB7IG9wYXF1ZSB9KSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVwZ3JhZGVcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/api-upgrade.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/index.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/api/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports.request = __webpack_require__(/*! ./api-request */ \"(rsc)/./node_modules/undici/lib/api/api-request.js\")\nmodule.exports.stream = __webpack_require__(/*! ./api-stream */ \"(rsc)/./node_modules/undici/lib/api/api-stream.js\")\nmodule.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ \"(rsc)/./node_modules/undici/lib/api/api-pipeline.js\")\nmodule.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ \"(rsc)/./node_modules/undici/lib/api/api-upgrade.js\")\nmodule.exports.connect = __webpack_require__(/*! ./api-connect */ \"(rsc)/./node_modules/undici/lib/api/api-connect.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosdUhBQWlEO0FBQ2pELG9IQUErQztBQUMvQywwSEFBbUQ7QUFDbkQsdUhBQWlEO0FBQ2pELHVIQUFpRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxhcGlcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cy5yZXF1ZXN0ID0gcmVxdWlyZSgnLi9hcGktcmVxdWVzdCcpXG5tb2R1bGUuZXhwb3J0cy5zdHJlYW0gPSByZXF1aXJlKCcuL2FwaS1zdHJlYW0nKVxubW9kdWxlLmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2FwaS1waXBlbGluZScpXG5tb2R1bGUuZXhwb3J0cy51cGdyYWRlID0gcmVxdWlyZSgnLi9hcGktdXBncmFkZScpXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gcmVxdWlyZSgnLi9hcGktY29ubmVjdCcpXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/readable.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/api/readable.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Ported from https://github.com/nodejs/undici/pull/907\n\n\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { Readable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { RequestAbortedError, NotSupportedError, InvalidArgumentError, AbortError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('kAbort')\nconst kContentType = Symbol('kContentType')\nconst kContentLength = Symbol('kContentLength')\n\nconst noop = () => {}\n\nclass BodyReadable extends Readable {\n  constructor ({\n    resume,\n    abort,\n    contentType = '',\n    contentLength,\n    highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n  }) {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n    this[kContentLength] = contentLength\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  _destroy (err, callback) {\n    // Workaround for Node \"bug\". If the stream is destroyed in same\n    // tick as it is created, then a user who is waiting for a\n    // promise (i.e micro tick) for installing a 'error' listener will\n    // never get a chance and will always encounter an unhandled exception.\n    if (!this[kReading]) {\n      setImmediate(() => {\n        callback(err)\n      })\n    } else {\n      callback(err)\n    }\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bytes\n  async bytes () {\n    return consume(this, 'bytes')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  async dump (opts) {\n    let limit = Number.isFinite(opts?.limit) ? opts.limit : 128 * 1024\n    const signal = opts?.signal\n\n    if (signal != null && (typeof signal !== 'object' || !('aborted' in signal))) {\n      throw new InvalidArgumentError('signal must be an AbortSignal')\n    }\n\n    signal?.throwIfAborted()\n\n    if (this._readableState.closeEmitted) {\n      return null\n    }\n\n    return await new Promise((resolve, reject) => {\n      if (this[kContentLength] > limit) {\n        this.destroy(new AbortError())\n      }\n\n      const onAbort = () => {\n        this.destroy(signal.reason ?? new AbortError())\n      }\n      signal?.addEventListener('abort', onAbort)\n\n      this\n        .on('close', function () {\n          signal?.removeEventListener('abort', onAbort)\n          if (signal?.aborted) {\n            reject(signal.reason ?? new AbortError())\n          } else {\n            resolve(null)\n          }\n        })\n        .on('error', noop)\n        .on('data', function (chunk) {\n          limit -= chunk.length\n          if (limit <= 0) {\n            this.destroy()\n          }\n        })\n        .resume()\n    })\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    if (isUnusable(stream)) {\n      const rState = stream._readableState\n      if (rState.destroyed && rState.closeEmitted === false) {\n        stream\n          .on('error', err => {\n            reject(err)\n          })\n          .on('close', () => {\n            reject(new TypeError('unusable'))\n          })\n      } else {\n        reject(rState.errored ?? new TypeError('unusable'))\n      }\n    } else {\n      queueMicrotask(() => {\n        stream[kConsume] = {\n          type,\n          stream,\n          resolve,\n          reject,\n          length: 0,\n          body: []\n        }\n\n        stream\n          .on('error', function (err) {\n            consumeFinish(this[kConsume], err)\n          })\n          .on('close', function () {\n            if (this[kConsume].body !== null) {\n              consumeFinish(this[kConsume], new RequestAbortedError())\n            }\n          })\n\n        consumeStart(stream[kConsume])\n      })\n    }\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  if (state.bufferIndex) {\n    const start = state.bufferIndex\n    const end = state.buffer.length\n    for (let n = start; n < end; n++) {\n      consumePush(consume, state.buffer[n])\n    }\n  } else {\n    for (const chunk of state.buffer) {\n      consumePush(consume, chunk)\n    }\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n */\nfunction chunksDecode (chunks, length) {\n  if (chunks.length === 0 || length === 0) {\n    return ''\n  }\n  const buffer = chunks.length === 1 ? chunks[0] : Buffer.concat(chunks, length)\n  const bufferLength = buffer.length\n\n  // Skip BOM.\n  const start =\n    bufferLength > 2 &&\n    buffer[0] === 0xef &&\n    buffer[1] === 0xbb &&\n    buffer[2] === 0xbf\n      ? 3\n      : 0\n  return buffer.utf8Slice(start, bufferLength)\n}\n\n/**\n * @param {Buffer[]} chunks\n * @param {number} length\n * @returns {Uint8Array}\n */\nfunction chunksConcat (chunks, length) {\n  if (chunks.length === 0 || length === 0) {\n    return new Uint8Array(0)\n  }\n  if (chunks.length === 1) {\n    // fast-path\n    return new Uint8Array(chunks[0])\n  }\n  const buffer = new Uint8Array(Buffer.allocUnsafeSlow(length).buffer)\n\n  let offset = 0\n  for (let i = 0; i < chunks.length; ++i) {\n    const chunk = chunks[i]\n    buffer.set(chunk, offset)\n    offset += chunk.length\n  }\n\n  return buffer\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(chunksDecode(body, length))\n    } else if (type === 'json') {\n      resolve(JSON.parse(chunksDecode(body, length)))\n    } else if (type === 'arrayBuffer') {\n      resolve(chunksConcat(body, length).buffer)\n    } else if (type === 'blob') {\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    } else if (type === 'bytes') {\n      resolve(chunksConcat(body, length))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n\nmodule.exports = { Readable: BodyReadable, chunksDecode }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvcmVhZGFibGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDMUMsUUFBUSwyRUFBMkUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM3RyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLGtFQUFjOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx3QkFBd0I7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxzQ0FBc0M7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTiwrQkFBK0IsNEJBQTRCO0FBQzNELE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGFwaVxccmVhZGFibGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvcHVsbC85MDdcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgUmVxdWVzdEFib3J0ZWRFcnJvciwgTm90U3VwcG9ydGVkRXJyb3IsIEludmFsaWRBcmd1bWVudEVycm9yLCBBYm9ydEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgUmVhZGFibGVTdHJlYW1Gcm9tIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5jb25zdCBrQ29uc3VtZSA9IFN5bWJvbCgna0NvbnN1bWUnKVxuY29uc3Qga1JlYWRpbmcgPSBTeW1ib2woJ2tSZWFkaW5nJylcbmNvbnN0IGtCb2R5ID0gU3ltYm9sKCdrQm9keScpXG5jb25zdCBrQWJvcnQgPSBTeW1ib2woJ2tBYm9ydCcpXG5jb25zdCBrQ29udGVudFR5cGUgPSBTeW1ib2woJ2tDb250ZW50VHlwZScpXG5jb25zdCBrQ29udGVudExlbmd0aCA9IFN5bWJvbCgna0NvbnRlbnRMZW5ndGgnKVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cblxuY2xhc3MgQm9keVJlYWRhYmxlIGV4dGVuZHMgUmVhZGFibGUge1xuICBjb25zdHJ1Y3RvciAoe1xuICAgIHJlc3VtZSxcbiAgICBhYm9ydCxcbiAgICBjb250ZW50VHlwZSA9ICcnLFxuICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgaGlnaFdhdGVyTWFyayA9IDY0ICogMTAyNCAvLyBTYW1lIGFzIG5vZGVqcyBmcyBzdHJlYW1zLlxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgYXV0b0Rlc3Ryb3k6IHRydWUsXG4gICAgICByZWFkOiByZXN1bWUsXG4gICAgICBoaWdoV2F0ZXJNYXJrXG4gICAgfSlcblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGF0YUVtaXR0ZWQgPSBmYWxzZVxuXG4gICAgdGhpc1trQWJvcnRdID0gYWJvcnRcbiAgICB0aGlzW2tDb25zdW1lXSA9IG51bGxcbiAgICB0aGlzW2tCb2R5XSA9IG51bGxcbiAgICB0aGlzW2tDb250ZW50VHlwZV0gPSBjb250ZW50VHlwZVxuICAgIHRoaXNba0NvbnRlbnRMZW5ndGhdID0gY29udGVudExlbmd0aFxuXG4gICAgLy8gSXMgc3RyZWFtIGJlaW5nIGNvbnN1bWVkIHRocm91Z2ggUmVhZGFibGUgQVBJP1xuICAgIC8vIFRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHNvIHRoYXQgd2UgYXZvaWQgY2hlY2tpbmdcbiAgICAvLyBmb3IgJ2RhdGEnIGFuZCAncmVhZGFibGUnIGxpc3RlbmVycyBpbiB0aGUgaG90IHBhdGhcbiAgICAvLyBpbnNpZGUgcHVzaCgpLlxuICAgIHRoaXNba1JlYWRpbmddID0gZmFsc2VcbiAgfVxuXG4gIGRlc3Ryb3kgKGVycikge1xuICAgIGlmICghZXJyICYmICF0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgIGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICB0aGlzW2tBYm9ydF0oKVxuICAgIH1cblxuICAgIHJldHVybiBzdXBlci5kZXN0cm95KGVycilcbiAgfVxuXG4gIF9kZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgTm9kZSBcImJ1Z1wiLiBJZiB0aGUgc3RyZWFtIGlzIGRlc3Ryb3llZCBpbiBzYW1lXG4gICAgLy8gdGljayBhcyBpdCBpcyBjcmVhdGVkLCB0aGVuIGEgdXNlciB3aG8gaXMgd2FpdGluZyBmb3IgYVxuICAgIC8vIHByb21pc2UgKGkuZSBtaWNybyB0aWNrKSBmb3IgaW5zdGFsbGluZyBhICdlcnJvcicgbGlzdGVuZXIgd2lsbFxuICAgIC8vIG5ldmVyIGdldCBhIGNoYW5jZSBhbmQgd2lsbCBhbHdheXMgZW5jb3VudGVyIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgaWYgKCF0aGlzW2tSZWFkaW5nXSkge1xuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZXJyKVxuICAgIH1cbiAgfVxuXG4gIG9uIChldiwgLi4uYXJncykge1xuICAgIGlmIChldiA9PT0gJ2RhdGEnIHx8IGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgICB0aGlzW2tSZWFkaW5nXSA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLm9uKGV2LCAuLi5hcmdzKVxuICB9XG5cbiAgYWRkTGlzdGVuZXIgKGV2LCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXYsIC4uLmFyZ3MpXG4gIH1cblxuICBvZmYgKGV2LCAuLi5hcmdzKSB7XG4gICAgY29uc3QgcmV0ID0gc3VwZXIub2ZmKGV2LCAuLi5hcmdzKVxuICAgIGlmIChldiA9PT0gJ2RhdGEnIHx8IGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgICB0aGlzW2tSZWFkaW5nXSA9IChcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50KCdkYXRhJykgPiAwIHx8XG4gICAgICAgIHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDBcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgcmVtb3ZlTGlzdGVuZXIgKGV2LCAuLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMub2ZmKGV2LCAuLi5hcmdzKVxuICB9XG5cbiAgcHVzaCAoY2h1bmspIHtcbiAgICBpZiAodGhpc1trQ29uc3VtZV0gJiYgY2h1bmsgIT09IG51bGwpIHtcbiAgICAgIGNvbnN1bWVQdXNoKHRoaXNba0NvbnN1bWVdLCBjaHVuaylcbiAgICAgIHJldHVybiB0aGlzW2tSZWFkaW5nXSA/IHN1cGVyLnB1c2goY2h1bmspIDogdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucHVzaChjaHVuaylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS10ZXh0XG4gIGFzeW5jIHRleHQgKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICd0ZXh0JylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1qc29uXG4gIGFzeW5jIGpzb24gKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdqc29uJylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ibG9iXG4gIGFzeW5jIGJsb2IgKCkge1xuICAgIHJldHVybiBjb25zdW1lKHRoaXMsICdibG9iJylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1ieXRlc1xuICBhc3luYyBieXRlcyAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2J5dGVzJylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1hcnJheWJ1ZmZlclxuICBhc3luYyBhcnJheUJ1ZmZlciAoKSB7XG4gICAgcmV0dXJuIGNvbnN1bWUodGhpcywgJ2FycmF5QnVmZmVyJylcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tYm9keS1mb3JtZGF0YVxuICBhc3luYyBmb3JtRGF0YSAoKSB7XG4gICAgLy8gVE9ETzogSW1wbGVtZW50LlxuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcigpXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWJvZHktYm9keXVzZWRcbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICByZXR1cm4gdXRpbC5pc0Rpc3R1cmJlZCh0aGlzKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1ib2R5LWJvZHlcbiAgZ2V0IGJvZHkgKCkge1xuICAgIGlmICghdGhpc1trQm9keV0pIHtcbiAgICAgIHRoaXNba0JvZHldID0gUmVhZGFibGVTdHJlYW1Gcm9tKHRoaXMpXG4gICAgICBpZiAodGhpc1trQ29uc3VtZV0pIHtcbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyB0aGUgYmVzdCB3YXkgdG8gZm9yY2UgYSBsb2NrP1xuICAgICAgICB0aGlzW2tCb2R5XS5nZXRSZWFkZXIoKSAvLyBFbnN1cmUgc3RyZWFtIGlzIGxvY2tlZC5cbiAgICAgICAgYXNzZXJ0KHRoaXNba0JvZHldLmxvY2tlZClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNba0JvZHldXG4gIH1cblxuICBhc3luYyBkdW1wIChvcHRzKSB7XG4gICAgbGV0IGxpbWl0ID0gTnVtYmVyLmlzRmluaXRlKG9wdHM/LmxpbWl0KSA/IG9wdHMubGltaXQgOiAxMjggKiAxMDI0XG4gICAgY29uc3Qgc2lnbmFsID0gb3B0cz8uc2lnbmFsXG5cbiAgICBpZiAoc2lnbmFsICE9IG51bGwgJiYgKHR5cGVvZiBzaWduYWwgIT09ICdvYmplY3QnIHx8ICEoJ2Fib3J0ZWQnIGluIHNpZ25hbCkpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3NpZ25hbCBtdXN0IGJlIGFuIEFib3J0U2lnbmFsJylcbiAgICB9XG5cbiAgICBzaWduYWw/LnRocm93SWZBYm9ydGVkKClcblxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmNsb3NlRW1pdHRlZCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXNba0NvbnRlbnRMZW5ndGhdID4gbGltaXQpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95KG5ldyBBYm9ydEVycm9yKCkpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9uQWJvcnQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuZGVzdHJveShzaWduYWwucmVhc29uID8/IG5ldyBBYm9ydEVycm9yKCkpXG4gICAgICB9XG4gICAgICBzaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25BYm9ydClcblxuICAgICAgdGhpc1xuICAgICAgICAub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNpZ25hbD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkFib3J0KVxuICAgICAgICAgIGlmIChzaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgIHJlamVjdChzaWduYWwucmVhc29uID8/IG5ldyBBYm9ydEVycm9yKCkpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUobnVsbClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZXJyb3InLCBub29wKVxuICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICBsaW1pdCAtPSBjaHVuay5sZW5ndGhcbiAgICAgICAgICBpZiAobGltaXQgPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5yZXN1bWUoKVxuICAgIH0pXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZGFibGVzdHJlYW0tbG9ja2VkXG5mdW5jdGlvbiBpc0xvY2tlZCAoc2VsZikge1xuICAvLyBDb25zdW1lIGlzIGFuIGltcGxpY2l0IGxvY2suXG4gIHJldHVybiAoc2VsZltrQm9keV0gJiYgc2VsZltrQm9keV0ubG9ja2VkID09PSB0cnVlKSB8fCBzZWxmW2tDb25zdW1lXVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keS11bnVzYWJsZVxuZnVuY3Rpb24gaXNVbnVzYWJsZSAoc2VsZikge1xuICByZXR1cm4gdXRpbC5pc0Rpc3R1cmJlZChzZWxmKSB8fCBpc0xvY2tlZChzZWxmKVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lIChzdHJlYW0sIHR5cGUpIHtcbiAgYXNzZXJ0KCFzdHJlYW1ba0NvbnN1bWVdKVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKGlzVW51c2FibGUoc3RyZWFtKSkge1xuICAgICAgY29uc3QgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlXG4gICAgICBpZiAoclN0YXRlLmRlc3Ryb3llZCAmJiByU3RhdGUuY2xvc2VFbWl0dGVkID09PSBmYWxzZSkge1xuICAgICAgICBzdHJlYW1cbiAgICAgICAgICAub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ3VudXNhYmxlJykpXG4gICAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChyU3RhdGUuZXJyb3JlZCA/PyBuZXcgVHlwZUVycm9yKCd1bnVzYWJsZScpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHN0cmVhbVtrQ29uc3VtZV0gPSB7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBzdHJlYW0sXG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgbGVuZ3RoOiAwLFxuICAgICAgICAgIGJvZHk6IFtdXG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW1cbiAgICAgICAgICAub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc3VtZUZpbmlzaCh0aGlzW2tDb25zdW1lXSwgZXJyKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2tDb25zdW1lXS5ib2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN1bWVGaW5pc2godGhpc1trQ29uc3VtZV0sIG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKCkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICBjb25zdW1lU3RhcnQoc3RyZWFtW2tDb25zdW1lXSlcbiAgICAgIH0pXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBjb25zdW1lU3RhcnQgKGNvbnN1bWUpIHtcbiAgaWYgKGNvbnN1bWUuYm9keSA9PT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgY29uc3QgeyBfcmVhZGFibGVTdGF0ZTogc3RhdGUgfSA9IGNvbnN1bWUuc3RyZWFtXG5cbiAgaWYgKHN0YXRlLmJ1ZmZlckluZGV4KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzdGF0ZS5idWZmZXJJbmRleFxuICAgIGNvbnN0IGVuZCA9IHN0YXRlLmJ1ZmZlci5sZW5ndGhcbiAgICBmb3IgKGxldCBuID0gc3RhcnQ7IG4gPCBlbmQ7IG4rKykge1xuICAgICAgY29uc3VtZVB1c2goY29uc3VtZSwgc3RhdGUuYnVmZmVyW25dKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGNodW5rIG9mIHN0YXRlLmJ1ZmZlcikge1xuICAgICAgY29uc3VtZVB1c2goY29uc3VtZSwgY2h1bmspXG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBjb25zdW1lRW5kKHRoaXNba0NvbnN1bWVdKVxuICB9IGVsc2Uge1xuICAgIGNvbnN1bWUuc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdW1lRW5kKHRoaXNba0NvbnN1bWVdKVxuICAgIH0pXG4gIH1cblxuICBjb25zdW1lLnN0cmVhbS5yZXN1bWUoKVxuXG4gIHdoaWxlIChjb25zdW1lLnN0cmVhbS5yZWFkKCkgIT0gbnVsbCkge1xuICAgIC8vIExvb3BcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyW119IGNodW5rc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICovXG5mdW5jdGlvbiBjaHVua3NEZWNvZGUgKGNodW5rcywgbGVuZ3RoKSB7XG4gIGlmIChjaHVua3MubGVuZ3RoID09PSAwIHx8IGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IGNodW5rcy5sZW5ndGggPT09IDEgPyBjaHVua3NbMF0gOiBCdWZmZXIuY29uY2F0KGNodW5rcywgbGVuZ3RoKVxuICBjb25zdCBidWZmZXJMZW5ndGggPSBidWZmZXIubGVuZ3RoXG5cbiAgLy8gU2tpcCBCT00uXG4gIGNvbnN0IHN0YXJ0ID1cbiAgICBidWZmZXJMZW5ndGggPiAyICYmXG4gICAgYnVmZmVyWzBdID09PSAweGVmICYmXG4gICAgYnVmZmVyWzFdID09PSAweGJiICYmXG4gICAgYnVmZmVyWzJdID09PSAweGJmXG4gICAgICA/IDNcbiAgICAgIDogMFxuICByZXR1cm4gYnVmZmVyLnV0ZjhTbGljZShzdGFydCwgYnVmZmVyTGVuZ3RoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyW119IGNodW5rc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNodW5rc0NvbmNhdCAoY2h1bmtzLCBsZW5ndGgpIHtcbiAgaWYgKGNodW5rcy5sZW5ndGggPT09IDAgfHwgbGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApXG4gIH1cbiAgaWYgKGNodW5rcy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBmYXN0LXBhdGhcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY2h1bmtzWzBdKVxuICB9XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cobGVuZ3RoKS5idWZmZXIpXG5cbiAgbGV0IG9mZnNldCA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3MubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpXVxuICAgIGJ1ZmZlci5zZXQoY2h1bmssIG9mZnNldClcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVFbmQgKGNvbnN1bWUpIHtcbiAgY29uc3QgeyB0eXBlLCBib2R5LCByZXNvbHZlLCBzdHJlYW0sIGxlbmd0aCB9ID0gY29uc3VtZVxuXG4gIHRyeSB7XG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgcmVzb2x2ZShjaHVua3NEZWNvZGUoYm9keSwgbGVuZ3RoKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdqc29uJykge1xuICAgICAgcmVzb2x2ZShKU09OLnBhcnNlKGNodW5rc0RlY29kZShib2R5LCBsZW5ndGgpKSlcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdhcnJheUJ1ZmZlcicpIHtcbiAgICAgIHJlc29sdmUoY2h1bmtzQ29uY2F0KGJvZHksIGxlbmd0aCkuYnVmZmVyKVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgICByZXNvbHZlKG5ldyBCbG9iKGJvZHksIHsgdHlwZTogc3RyZWFtW2tDb250ZW50VHlwZV0gfSkpXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICByZXNvbHZlKGNodW5rc0NvbmNhdChib2R5LCBsZW5ndGgpKVxuICAgIH1cblxuICAgIGNvbnN1bWVGaW5pc2goY29uc3VtZSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgc3RyZWFtLmRlc3Ryb3koZXJyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVQdXNoIChjb25zdW1lLCBjaHVuaykge1xuICBjb25zdW1lLmxlbmd0aCArPSBjaHVuay5sZW5ndGhcbiAgY29uc3VtZS5ib2R5LnB1c2goY2h1bmspXG59XG5cbmZ1bmN0aW9uIGNvbnN1bWVGaW5pc2ggKGNvbnN1bWUsIGVycikge1xuICBpZiAoY29uc3VtZS5ib2R5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZXJyKSB7XG4gICAgY29uc3VtZS5yZWplY3QoZXJyKVxuICB9IGVsc2Uge1xuICAgIGNvbnN1bWUucmVzb2x2ZSgpXG4gIH1cblxuICBjb25zdW1lLnR5cGUgPSBudWxsXG4gIGNvbnN1bWUuc3RyZWFtID0gbnVsbFxuICBjb25zdW1lLnJlc29sdmUgPSBudWxsXG4gIGNvbnN1bWUucmVqZWN0ID0gbnVsbFxuICBjb25zdW1lLmxlbmd0aCA9IDBcbiAgY29uc3VtZS5ib2R5ID0gbnVsbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgUmVhZGFibGU6IEJvZHlSZWFkYWJsZSwgY2h1bmtzRGVjb2RlIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/readable.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/api/util.js":
/*!*********************************************!*\
  !*** ./node_modules/undici/lib/api/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst {\n  ResponseStatusCodeError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nconst { chunksDecode } = __webpack_require__(/*! ./readable */ \"(rsc)/./node_modules/undici/lib/api/readable.js\")\nconst CHUNK_LIMIT = 128 * 1024\n\nasync function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {\n  assert(body)\n\n  let chunks = []\n  let length = 0\n\n  try {\n    for await (const chunk of body) {\n      chunks.push(chunk)\n      length += chunk.length\n      if (length > CHUNK_LIMIT) {\n        chunks = []\n        length = 0\n        break\n      }\n    }\n  } catch {\n    chunks = []\n    length = 0\n    // Do nothing....\n  }\n\n  const message = `Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`\n\n  if (statusCode === 204 || !contentType || !length) {\n    queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers)))\n    return\n  }\n\n  const stackTraceLimit = Error.stackTraceLimit\n  Error.stackTraceLimit = 0\n  let payload\n\n  try {\n    if (isContentTypeApplicationJson(contentType)) {\n      payload = JSON.parse(chunksDecode(chunks, length))\n    } else if (isContentTypeText(contentType)) {\n      payload = chunksDecode(chunks, length)\n    }\n  } catch {\n    // process in a callback to avoid throwing in the microtask queue\n  } finally {\n    Error.stackTraceLimit = stackTraceLimit\n  }\n  queueMicrotask(() => callback(new ResponseStatusCodeError(message, statusCode, headers, payload)))\n}\n\nconst isContentTypeApplicationJson = (contentType) => {\n  return (\n    contentType.length > 15 &&\n    contentType[11] === '/' &&\n    contentType[0] === 'a' &&\n    contentType[1] === 'p' &&\n    contentType[2] === 'p' &&\n    contentType[3] === 'l' &&\n    contentType[4] === 'i' &&\n    contentType[5] === 'c' &&\n    contentType[6] === 'a' &&\n    contentType[7] === 't' &&\n    contentType[8] === 'i' &&\n    contentType[9] === 'o' &&\n    contentType[10] === 'n' &&\n    contentType[12] === 'j' &&\n    contentType[13] === 's' &&\n    contentType[14] === 'o' &&\n    contentType[15] === 'n'\n  )\n}\n\nconst isContentTypeText = (contentType) => {\n  return (\n    contentType.length > 4 &&\n    contentType[4] === '/' &&\n    contentType[0] === 't' &&\n    contentType[1] === 'e' &&\n    contentType[2] === 'x' &&\n    contentType[3] === 't'\n  )\n}\n\nmodule.exports = {\n  getResolveErrorBodyCallback,\n  isContentTypeApplicationJson,\n  isContentTypeText\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9hcGkvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEM7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjs7QUFFNUIsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyxtRUFBWTtBQUM3Qzs7QUFFQSw4Q0FBOEMsaUVBQWlFO0FBQy9HOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFdBQVcsRUFBRSxxQkFBcUIsY0FBYyxPQUFPOztBQUVqRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcYXBpXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHtcbiAgUmVzcG9uc2VTdGF0dXNDb2RlRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmNvbnN0IHsgY2h1bmtzRGVjb2RlIH0gPSByZXF1aXJlKCcuL3JlYWRhYmxlJylcbmNvbnN0IENIVU5LX0xJTUlUID0gMTI4ICogMTAyNFxuXG5hc3luYyBmdW5jdGlvbiBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2sgKHsgY2FsbGJhY2ssIGJvZHksIGNvbnRlbnRUeXBlLCBzdGF0dXNDb2RlLCBzdGF0dXNNZXNzYWdlLCBoZWFkZXJzIH0pIHtcbiAgYXNzZXJ0KGJvZHkpXG5cbiAgbGV0IGNodW5rcyA9IFtdXG4gIGxldCBsZW5ndGggPSAwXG5cbiAgdHJ5IHtcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIGJvZHkpIHtcbiAgICAgIGNodW5rcy5wdXNoKGNodW5rKVxuICAgICAgbGVuZ3RoICs9IGNodW5rLmxlbmd0aFxuICAgICAgaWYgKGxlbmd0aCA+IENIVU5LX0xJTUlUKSB7XG4gICAgICAgIGNodW5rcyA9IFtdXG4gICAgICAgIGxlbmd0aCA9IDBcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2gge1xuICAgIGNodW5rcyA9IFtdXG4gICAgbGVuZ3RoID0gMFxuICAgIC8vIERvIG5vdGhpbmcuLi4uXG4gIH1cblxuICBjb25zdCBtZXNzYWdlID0gYFJlc3BvbnNlIHN0YXR1cyBjb2RlICR7c3RhdHVzQ29kZX0ke3N0YXR1c01lc3NhZ2UgPyBgOiAke3N0YXR1c01lc3NhZ2V9YCA6ICcnfWBcblxuICBpZiAoc3RhdHVzQ29kZSA9PT0gMjA0IHx8ICFjb250ZW50VHlwZSB8fCAhbGVuZ3RoKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gY2FsbGJhY2sobmV3IFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGhlYWRlcnMpKSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IHN0YWNrVHJhY2VMaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdFxuICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSAwXG4gIGxldCBwYXlsb2FkXG5cbiAgdHJ5IHtcbiAgICBpZiAoaXNDb250ZW50VHlwZUFwcGxpY2F0aW9uSnNvbihjb250ZW50VHlwZSkpIHtcbiAgICAgIHBheWxvYWQgPSBKU09OLnBhcnNlKGNodW5rc0RlY29kZShjaHVua3MsIGxlbmd0aCkpXG4gICAgfSBlbHNlIGlmIChpc0NvbnRlbnRUeXBlVGV4dChjb250ZW50VHlwZSkpIHtcbiAgICAgIHBheWxvYWQgPSBjaHVua3NEZWNvZGUoY2h1bmtzLCBsZW5ndGgpXG4gICAgfVxuICB9IGNhdGNoIHtcbiAgICAvLyBwcm9jZXNzIGluIGEgY2FsbGJhY2sgdG8gYXZvaWQgdGhyb3dpbmcgaW4gdGhlIG1pY3JvdGFzayBxdWV1ZVxuICB9IGZpbmFsbHkge1xuICAgIEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IHN0YWNrVHJhY2VMaW1pdFxuICB9XG4gIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG5ldyBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcihtZXNzYWdlLCBzdGF0dXNDb2RlLCBoZWFkZXJzLCBwYXlsb2FkKSkpXG59XG5cbmNvbnN0IGlzQ29udGVudFR5cGVBcHBsaWNhdGlvbkpzb24gPSAoY29udGVudFR5cGUpID0+IHtcbiAgcmV0dXJuIChcbiAgICBjb250ZW50VHlwZS5sZW5ndGggPiAxNSAmJlxuICAgIGNvbnRlbnRUeXBlWzExXSA9PT0gJy8nICYmXG4gICAgY29udGVudFR5cGVbMF0gPT09ICdhJyAmJlxuICAgIGNvbnRlbnRUeXBlWzFdID09PSAncCcgJiZcbiAgICBjb250ZW50VHlwZVsyXSA9PT0gJ3AnICYmXG4gICAgY29udGVudFR5cGVbM10gPT09ICdsJyAmJlxuICAgIGNvbnRlbnRUeXBlWzRdID09PSAnaScgJiZcbiAgICBjb250ZW50VHlwZVs1XSA9PT0gJ2MnICYmXG4gICAgY29udGVudFR5cGVbNl0gPT09ICdhJyAmJlxuICAgIGNvbnRlbnRUeXBlWzddID09PSAndCcgJiZcbiAgICBjb250ZW50VHlwZVs4XSA9PT0gJ2knICYmXG4gICAgY29udGVudFR5cGVbOV0gPT09ICdvJyAmJlxuICAgIGNvbnRlbnRUeXBlWzEwXSA9PT0gJ24nICYmXG4gICAgY29udGVudFR5cGVbMTJdID09PSAnaicgJiZcbiAgICBjb250ZW50VHlwZVsxM10gPT09ICdzJyAmJlxuICAgIGNvbnRlbnRUeXBlWzE0XSA9PT0gJ28nICYmXG4gICAgY29udGVudFR5cGVbMTVdID09PSAnbidcbiAgKVxufVxuXG5jb25zdCBpc0NvbnRlbnRUeXBlVGV4dCA9IChjb250ZW50VHlwZSkgPT4ge1xuICByZXR1cm4gKFxuICAgIGNvbnRlbnRUeXBlLmxlbmd0aCA+IDQgJiZcbiAgICBjb250ZW50VHlwZVs0XSA9PT0gJy8nICYmXG4gICAgY29udGVudFR5cGVbMF0gPT09ICd0JyAmJlxuICAgIGNvbnRlbnRUeXBlWzFdID09PSAnZScgJiZcbiAgICBjb250ZW50VHlwZVsyXSA9PT0gJ3gnICYmXG4gICAgY29udGVudFR5cGVbM10gPT09ICd0J1xuICApXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSZXNvbHZlRXJyb3JCb2R5Q2FsbGJhY2ssXG4gIGlzQ29udGVudFR5cGVBcHBsaWNhdGlvbkpzb24sXG4gIGlzQ29udGVudFR5cGVUZXh0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/api/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/connect.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/connect.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst timers = __webpack_require__(/*! ../util/timers */ \"(rsc)/./node_modules/undici/lib/util/timers.js\")\n\nfunction noop () {}\n\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nlet SessionCache\n// FIXME: remove workaround when the Node bug is fixed\n// https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\nif (global.FinalizationRegistry && !(process.env.NODE_V8_COVERAGE || process.env.UNDICI_NO_FG)) {\n  SessionCache = class WeakSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n      this._sessionRegistry = new global.FinalizationRegistry((key) => {\n        if (this._sessionCache.size < this._maxCachedSessions) {\n          return\n        }\n\n        const ref = this._sessionCache.get(key)\n        if (ref !== undefined && ref.deref() === undefined) {\n          this._sessionCache.delete(key)\n        }\n      })\n    }\n\n    get (sessionKey) {\n      const ref = this._sessionCache.get(sessionKey)\n      return ref ? ref.deref() : null\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      this._sessionCache.set(sessionKey, new WeakRef(session))\n      this._sessionRegistry.register(session, sessionKey)\n    }\n  }\n} else {\n  SessionCache = class SimpleSessionCache {\n    constructor (maxCachedSessions) {\n      this._maxCachedSessions = maxCachedSessions\n      this._sessionCache = new Map()\n    }\n\n    get (sessionKey) {\n      return this._sessionCache.get(sessionKey)\n    }\n\n    set (sessionKey, session) {\n      if (this._maxCachedSessions === 0) {\n        return\n      }\n\n      if (this._sessionCache.size >= this._maxCachedSessions) {\n        // remove the oldest session\n        const { value: oldestKey } = this._sessionCache.keys().next()\n        this._sessionCache.delete(oldestKey)\n      }\n\n      this._sessionCache.set(sessionKey, session)\n    }\n  }\n}\n\nfunction buildConnector ({ allowH2, maxCachedSessions, socketPath, timeout, session: customSession, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions)\n  timeout = timeout == null ? 10e3 : timeout\n  allowH2 = allowH2 != null ? allowH2 : false\n  return function connect ({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = __webpack_require__(/*! node:tls */ \"node:tls\")\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      assert(sessionKey)\n\n      const session = customSession || sessionCache.get(sessionKey) || null\n\n      port = port || 443\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        localAddress,\n        // TODO(HTTP/2): Add support for h2c\n        ALPNProtocols: allowH2 ? ['http/1.1', 'h2'] : ['http/1.1'],\n        socket: httpSocket, // upgrade socket connection\n        port,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // TODO (fix): Can a session become invalid once established? Don't think so?\n          sessionCache.set(sessionKey, session)\n        })\n    } else {\n      assert(!httpSocket, 'httpSocket can only be sent on TLS update')\n\n      port = port || 80\n\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        localAddress,\n        port,\n        host: hostname\n      })\n    }\n\n    // Set TCP keep alive options on the socket here instead of in connect() for the case of assigning the socket\n    if (options.keepAlive == null || options.keepAlive) {\n      const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60e3 : options.keepAliveInitialDelay\n      socket.setKeepAlive(true, keepAliveInitialDelay)\n    }\n\n    const clearConnectTimeout = setupConnectTimeout(new WeakRef(socket), { timeout, hostname, port })\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        queueMicrotask(clearConnectTimeout)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        queueMicrotask(clearConnectTimeout)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\n/**\n * @param {WeakRef<net.Socket>} socketWeakRef\n * @param {object} opts\n * @param {number} opts.timeout\n * @param {string} opts.hostname\n * @param {number} opts.port\n * @returns {() => void}\n */\nconst setupConnectTimeout = process.platform === 'win32'\n  ? (socketWeakRef, opts) => {\n      if (!opts.timeout) {\n        return noop\n      }\n\n      let s1 = null\n      let s2 = null\n      const fastTimer = timers.setFastTimeout(() => {\n      // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(() => {\n        // Windows needs an extra setImmediate probably due to implementation differences in the socket logic\n          s2 = setImmediate(() => onConnectTimeout(socketWeakRef.deref(), opts))\n        })\n      }, opts.timeout)\n      return () => {\n        timers.clearFastTimeout(fastTimer)\n        clearImmediate(s1)\n        clearImmediate(s2)\n      }\n    }\n  : (socketWeakRef, opts) => {\n      if (!opts.timeout) {\n        return noop\n      }\n\n      let s1 = null\n      const fastTimer = timers.setFastTimeout(() => {\n      // setImmediate is added to make sure that we prioritize socket error events over timeouts\n        s1 = setImmediate(() => {\n          onConnectTimeout(socketWeakRef.deref(), opts)\n        })\n      }, opts.timeout)\n      return () => {\n        timers.clearFastTimeout(fastTimer)\n        clearImmediate(s1)\n      }\n    }\n\n/**\n * @param {net.Socket} socket\n * @param {object} opts\n * @param {number} opts.timeout\n * @param {string} opts.hostname\n * @param {number} opts.port\n */\nfunction onConnectTimeout (socket, opts) {\n  // The socket could be already garbage collected\n  if (socket == null) {\n    return\n  }\n\n  let message = 'Connect Timeout Error'\n  if (Array.isArray(socket.autoSelectFamilyAttemptedAddresses)) {\n    message += ` (attempted addresses: ${socket.autoSelectFamilyAttemptedAddresses.join(', ')},`\n  } else {\n    message += ` (attempted address: ${opts.hostname}:${opts.port},`\n  }\n\n  message += ` timeout: ${opts.timeout}ms)`\n\n  util.destroy(socket, new ConnectTimeoutError(message))\n}\n\nmodule.exports = buildConnector\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Nvbm5lY3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosWUFBWSxtQkFBTyxDQUFDLDBCQUFVO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsNERBQVE7QUFDN0IsUUFBUSw0Q0FBNEMsRUFBRSxtQkFBTyxDQUFDLGdFQUFVO0FBQ3hFLGVBQWUsbUJBQU8sQ0FBQyxzRUFBZ0I7O0FBRXZDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixrRkFBa0Y7QUFDN0c7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0VBQXNFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQywwQkFBVTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJFQUEyRSx5QkFBeUI7O0FBRXBHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUMscURBQXFEO0FBQzlGLElBQUk7QUFDSix1Q0FBdUMsY0FBYyxHQUFHLFVBQVU7QUFDbEU7O0FBRUEsMEJBQTBCLGFBQWE7O0FBRXZDO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcY29yZVxcY29ubmVjdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgbmV0ID0gcmVxdWlyZSgnbm9kZTpuZXQnKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yLCBDb25uZWN0VGltZW91dEVycm9yIH0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5jb25zdCB0aW1lcnMgPSByZXF1aXJlKCcuLi91dGlsL3RpbWVycycpXG5cbmZ1bmN0aW9uIG5vb3AgKCkge31cblxubGV0IHRscyAvLyBpbmNsdWRlIHRscyBjb25kaXRpb25hbGx5IHNpbmNlIGl0IGlzIG5vdCBhbHdheXMgYXZhaWxhYmxlXG5cbi8vIFRPRE86IHNlc3Npb24gcmUtdXNlIGRvZXMgbm90IHdhaXQgZm9yIHRoZSBmaXJzdFxuLy8gY29ubmVjdGlvbiB0byByZXNvbHZlIHRoZSBzZXNzaW9uIGFuZCBtaWdodCB0aGVyZWZvcmVcbi8vIHJlc29sdmUgdGhlIHNhbWUgc2VydmVybmFtZSBtdWx0aXBsZSB0aW1lcyBldmVuIHdoZW5cbi8vIHJlLXVzZSBpcyBlbmFibGVkLlxuXG5sZXQgU2Vzc2lvbkNhY2hlXG4vLyBGSVhNRTogcmVtb3ZlIHdvcmthcm91bmQgd2hlbiB0aGUgTm9kZSBidWcgaXMgZml4ZWRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvNDkzNDQjaXNzdWVjb21tZW50LTE3NDE3NzYzMDhcbmlmIChnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgIShwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFIHx8IHByb2Nlc3MuZW52LlVORElDSV9OT19GRykpIHtcbiAgU2Vzc2lvbkNhY2hlID0gY2xhc3MgV2Vha1Nlc3Npb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3IgKG1heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICAgIHRoaXMuX3Nlc3Npb25SZWdpc3RyeSA9IG5ldyBnbG9iYWwuRmluYWxpemF0aW9uUmVnaXN0cnkoKGtleSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc2Vzc2lvbkNhY2hlLnNpemUgPCB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmdldChrZXkpXG4gICAgICAgIGlmIChyZWYgIT09IHVuZGVmaW5lZCAmJiByZWYuZGVyZWYoKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShrZXkpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZ2V0IChzZXNzaW9uS2V5KSB7XG4gICAgICBjb25zdCByZWYgPSB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpXG4gICAgICByZXR1cm4gcmVmID8gcmVmLmRlcmVmKCkgOiBudWxsXG4gICAgfVxuXG4gICAgc2V0IChzZXNzaW9uS2V5LCBzZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgbmV3IFdlYWtSZWYoc2Vzc2lvbikpXG4gICAgICB0aGlzLl9zZXNzaW9uUmVnaXN0cnkucmVnaXN0ZXIoc2Vzc2lvbiwgc2Vzc2lvbktleSlcbiAgICB9XG4gIH1cbn0gZWxzZSB7XG4gIFNlc3Npb25DYWNoZSA9IGNsYXNzIFNpbXBsZVNlc3Npb25DYWNoZSB7XG4gICAgY29uc3RydWN0b3IgKG1heENhY2hlZFNlc3Npb25zKSB7XG4gICAgICB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucyA9IG1heENhY2hlZFNlc3Npb25zXG4gICAgICB0aGlzLl9zZXNzaW9uQ2FjaGUgPSBuZXcgTWFwKClcbiAgICB9XG5cbiAgICBnZXQgKHNlc3Npb25LZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpXG4gICAgfVxuXG4gICAgc2V0IChzZXNzaW9uS2V5LCBzZXNzaW9uKSB7XG4gICAgICBpZiAodGhpcy5fbWF4Q2FjaGVkU2Vzc2lvbnMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9zZXNzaW9uQ2FjaGUuc2l6ZSA+PSB0aGlzLl9tYXhDYWNoZWRTZXNzaW9ucykge1xuICAgICAgICAvLyByZW1vdmUgdGhlIG9sZGVzdCBzZXNzaW9uXG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IG9sZGVzdEtleSB9ID0gdGhpcy5fc2Vzc2lvbkNhY2hlLmtleXMoKS5uZXh0KClcbiAgICAgICAgdGhpcy5fc2Vzc2lvbkNhY2hlLmRlbGV0ZShvbGRlc3RLZXkpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Nlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRDb25uZWN0b3IgKHsgYWxsb3dIMiwgbWF4Q2FjaGVkU2Vzc2lvbnMsIHNvY2tldFBhdGgsIHRpbWVvdXQsIHNlc3Npb246IGN1c3RvbVNlc3Npb24sIC4uLm9wdHMgfSkge1xuICBpZiAobWF4Q2FjaGVkU2Vzc2lvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4Q2FjaGVkU2Vzc2lvbnMpIHx8IG1heENhY2hlZFNlc3Npb25zIDwgMCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heENhY2hlZFNlc3Npb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICB9XG5cbiAgY29uc3Qgb3B0aW9ucyA9IHsgcGF0aDogc29ja2V0UGF0aCwgLi4ub3B0cyB9XG4gIGNvbnN0IHNlc3Npb25DYWNoZSA9IG5ldyBTZXNzaW9uQ2FjaGUobWF4Q2FjaGVkU2Vzc2lvbnMgPT0gbnVsbCA/IDEwMCA6IG1heENhY2hlZFNlc3Npb25zKVxuICB0aW1lb3V0ID0gdGltZW91dCA9PSBudWxsID8gMTBlMyA6IHRpbWVvdXRcbiAgYWxsb3dIMiA9IGFsbG93SDIgIT0gbnVsbCA/IGFsbG93SDIgOiBmYWxzZVxuICByZXR1cm4gZnVuY3Rpb24gY29ubmVjdCAoeyBob3N0bmFtZSwgaG9zdCwgcHJvdG9jb2wsIHBvcnQsIHNlcnZlcm5hbWUsIGxvY2FsQWRkcmVzcywgaHR0cFNvY2tldCB9LCBjYWxsYmFjaykge1xuICAgIGxldCBzb2NrZXRcbiAgICBpZiAocHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICBpZiAoIXRscykge1xuICAgICAgICB0bHMgPSByZXF1aXJlKCdub2RlOnRscycpXG4gICAgICB9XG4gICAgICBzZXJ2ZXJuYW1lID0gc2VydmVybmFtZSB8fCBvcHRpb25zLnNlcnZlcm5hbWUgfHwgdXRpbC5nZXRTZXJ2ZXJOYW1lKGhvc3QpIHx8IG51bGxcblxuICAgICAgY29uc3Qgc2Vzc2lvbktleSA9IHNlcnZlcm5hbWUgfHwgaG9zdG5hbWVcbiAgICAgIGFzc2VydChzZXNzaW9uS2V5KVxuXG4gICAgICBjb25zdCBzZXNzaW9uID0gY3VzdG9tU2Vzc2lvbiB8fCBzZXNzaW9uQ2FjaGUuZ2V0KHNlc3Npb25LZXkpIHx8IG51bGxcblxuICAgICAgcG9ydCA9IHBvcnQgfHwgNDQzXG5cbiAgICAgIHNvY2tldCA9IHRscy5jb25uZWN0KHtcbiAgICAgICAgaGlnaFdhdGVyTWFyazogMTYzODQsIC8vIFRMUyBpbiBub2RlIGNhbid0IGhhdmUgYmlnZ2VyIEhXTSBhbnl3YXkuLi5cbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2VydmVybmFtZSxcbiAgICAgICAgc2Vzc2lvbixcbiAgICAgICAgbG9jYWxBZGRyZXNzLFxuICAgICAgICAvLyBUT0RPKEhUVFAvMik6IEFkZCBzdXBwb3J0IGZvciBoMmNcbiAgICAgICAgQUxQTlByb3RvY29sczogYWxsb3dIMiA/IFsnaHR0cC8xLjEnLCAnaDInXSA6IFsnaHR0cC8xLjEnXSxcbiAgICAgICAgc29ja2V0OiBodHRwU29ja2V0LCAvLyB1cGdyYWRlIHNvY2tldCBjb25uZWN0aW9uXG4gICAgICAgIHBvcnQsXG4gICAgICAgIGhvc3Q6IGhvc3RuYW1lXG4gICAgICB9KVxuXG4gICAgICBzb2NrZXRcbiAgICAgICAgLm9uKCdzZXNzaW9uJywgZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBDYW4gYSBzZXNzaW9uIGJlY29tZSBpbnZhbGlkIG9uY2UgZXN0YWJsaXNoZWQ/IERvbid0IHRoaW5rIHNvP1xuICAgICAgICAgIHNlc3Npb25DYWNoZS5zZXQoc2Vzc2lvbktleSwgc2Vzc2lvbilcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KCFodHRwU29ja2V0LCAnaHR0cFNvY2tldCBjYW4gb25seSBiZSBzZW50IG9uIFRMUyB1cGRhdGUnKVxuXG4gICAgICBwb3J0ID0gcG9ydCB8fCA4MFxuXG4gICAgICBzb2NrZXQgPSBuZXQuY29ubmVjdCh7XG4gICAgICAgIGhpZ2hXYXRlck1hcms6IDY0ICogMTAyNCwgLy8gU2FtZSBhcyBub2RlanMgZnMgc3RyZWFtcy5cbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgbG9jYWxBZGRyZXNzLFxuICAgICAgICBwb3J0LFxuICAgICAgICBob3N0OiBob3N0bmFtZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBTZXQgVENQIGtlZXAgYWxpdmUgb3B0aW9ucyBvbiB0aGUgc29ja2V0IGhlcmUgaW5zdGVhZCBvZiBpbiBjb25uZWN0KCkgZm9yIHRoZSBjYXNlIG9mIGFzc2lnbmluZyB0aGUgc29ja2V0XG4gICAgaWYgKG9wdGlvbnMua2VlcEFsaXZlID09IG51bGwgfHwgb3B0aW9ucy5rZWVwQWxpdmUpIHtcbiAgICAgIGNvbnN0IGtlZXBBbGl2ZUluaXRpYWxEZWxheSA9IG9wdGlvbnMua2VlcEFsaXZlSW5pdGlhbERlbGF5ID09PSB1bmRlZmluZWQgPyA2MGUzIDogb3B0aW9ucy5rZWVwQWxpdmVJbml0aWFsRGVsYXlcbiAgICAgIHNvY2tldC5zZXRLZWVwQWxpdmUodHJ1ZSwga2VlcEFsaXZlSW5pdGlhbERlbGF5KVxuICAgIH1cblxuICAgIGNvbnN0IGNsZWFyQ29ubmVjdFRpbWVvdXQgPSBzZXR1cENvbm5lY3RUaW1lb3V0KG5ldyBXZWFrUmVmKHNvY2tldCksIHsgdGltZW91dCwgaG9zdG5hbWUsIHBvcnQgfSlcblxuICAgIHNvY2tldFxuICAgICAgLnNldE5vRGVsYXkodHJ1ZSlcbiAgICAgIC5vbmNlKHByb3RvY29sID09PSAnaHR0cHM6JyA/ICdzZWN1cmVDb25uZWN0JyA6ICdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjbGVhckNvbm5lY3RUaW1lb3V0KVxuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IG51bGxcbiAgICAgICAgICBjYihudWxsLCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2xlYXJDb25uZWN0VGltZW91dClcblxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjb25zdCBjYiA9IGNhbGxiYWNrXG4gICAgICAgICAgY2FsbGJhY2sgPSBudWxsXG4gICAgICAgICAgY2IoZXJyKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgcmV0dXJuIHNvY2tldFxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWFrUmVmPG5ldC5Tb2NrZXQ+fSBzb2NrZXRXZWFrUmVmXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMudGltZW91dFxuICogQHBhcmFtIHtzdHJpbmd9IG9wdHMuaG9zdG5hbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRzLnBvcnRcbiAqIEByZXR1cm5zIHsoKSA9PiB2b2lkfVxuICovXG5jb25zdCBzZXR1cENvbm5lY3RUaW1lb3V0ID0gcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuICA/IChzb2NrZXRXZWFrUmVmLCBvcHRzKSA9PiB7XG4gICAgICBpZiAoIW9wdHMudGltZW91dCkge1xuICAgICAgICByZXR1cm4gbm9vcFxuICAgICAgfVxuXG4gICAgICBsZXQgczEgPSBudWxsXG4gICAgICBsZXQgczIgPSBudWxsXG4gICAgICBjb25zdCBmYXN0VGltZXIgPSB0aW1lcnMuc2V0RmFzdFRpbWVvdXQoKCkgPT4ge1xuICAgICAgLy8gc2V0SW1tZWRpYXRlIGlzIGFkZGVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdlIHByaW9yaXRpemUgc29ja2V0IGVycm9yIGV2ZW50cyBvdmVyIHRpbWVvdXRzXG4gICAgICAgIHMxID0gc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgLy8gV2luZG93cyBuZWVkcyBhbiBleHRyYSBzZXRJbW1lZGlhdGUgcHJvYmFibHkgZHVlIHRvIGltcGxlbWVudGF0aW9uIGRpZmZlcmVuY2VzIGluIHRoZSBzb2NrZXQgbG9naWNcbiAgICAgICAgICBzMiA9IHNldEltbWVkaWF0ZSgoKSA9PiBvbkNvbm5lY3RUaW1lb3V0KHNvY2tldFdlYWtSZWYuZGVyZWYoKSwgb3B0cykpXG4gICAgICAgIH0pXG4gICAgICB9LCBvcHRzLnRpbWVvdXQpXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aW1lcnMuY2xlYXJGYXN0VGltZW91dChmYXN0VGltZXIpXG4gICAgICAgIGNsZWFySW1tZWRpYXRlKHMxKVxuICAgICAgICBjbGVhckltbWVkaWF0ZShzMilcbiAgICAgIH1cbiAgICB9XG4gIDogKHNvY2tldFdlYWtSZWYsIG9wdHMpID0+IHtcbiAgICAgIGlmICghb3B0cy50aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBub29wXG4gICAgICB9XG5cbiAgICAgIGxldCBzMSA9IG51bGxcbiAgICAgIGNvbnN0IGZhc3RUaW1lciA9IHRpbWVycy5zZXRGYXN0VGltZW91dCgoKSA9PiB7XG4gICAgICAvLyBzZXRJbW1lZGlhdGUgaXMgYWRkZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2UgcHJpb3JpdGl6ZSBzb2NrZXQgZXJyb3IgZXZlbnRzIG92ZXIgdGltZW91dHNcbiAgICAgICAgczEgPSBzZXRJbW1lZGlhdGUoKCkgPT4ge1xuICAgICAgICAgIG9uQ29ubmVjdFRpbWVvdXQoc29ja2V0V2Vha1JlZi5kZXJlZigpLCBvcHRzKVxuICAgICAgICB9KVxuICAgICAgfSwgb3B0cy50aW1lb3V0KVxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdGltZXJzLmNsZWFyRmFzdFRpbWVvdXQoZmFzdFRpbWVyKVxuICAgICAgICBjbGVhckltbWVkaWF0ZShzMSlcbiAgICAgIH1cbiAgICB9XG5cbi8qKlxuICogQHBhcmFtIHtuZXQuU29ja2V0fSBzb2NrZXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gKiBAcGFyYW0ge251bWJlcn0gb3B0cy50aW1lb3V0XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0cy5ob3N0bmFtZVxuICogQHBhcmFtIHtudW1iZXJ9IG9wdHMucG9ydFxuICovXG5mdW5jdGlvbiBvbkNvbm5lY3RUaW1lb3V0IChzb2NrZXQsIG9wdHMpIHtcbiAgLy8gVGhlIHNvY2tldCBjb3VsZCBiZSBhbHJlYWR5IGdhcmJhZ2UgY29sbGVjdGVkXG4gIGlmIChzb2NrZXQgPT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IG1lc3NhZ2UgPSAnQ29ubmVjdCBUaW1lb3V0IEVycm9yJ1xuICBpZiAoQXJyYXkuaXNBcnJheShzb2NrZXQuYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRlZEFkZHJlc3NlcykpIHtcbiAgICBtZXNzYWdlICs9IGAgKGF0dGVtcHRlZCBhZGRyZXNzZXM6ICR7c29ja2V0LmF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0ZWRBZGRyZXNzZXMuam9pbignLCAnKX0sYFxuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UgKz0gYCAoYXR0ZW1wdGVkIGFkZHJlc3M6ICR7b3B0cy5ob3N0bmFtZX06JHtvcHRzLnBvcnR9LGBcbiAgfVxuXG4gIG1lc3NhZ2UgKz0gYCB0aW1lb3V0OiAke29wdHMudGltZW91dH1tcylgXG5cbiAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IENvbm5lY3RUaW1lb3V0RXJyb3IobWVzc2FnZSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRDb25uZWN0b3JcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/core/constants.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/** @type {Record<string, string | undefined>} */\nconst headerNameLowerCasedRecord = {}\n\n// https://developer.mozilla.org/docs/Web/HTTP/Headers\nconst wellknownHeaderNames = [\n  'Accept',\n  'Accept-Encoding',\n  'Accept-Language',\n  'Accept-Ranges',\n  'Access-Control-Allow-Credentials',\n  'Access-Control-Allow-Headers',\n  'Access-Control-Allow-Methods',\n  'Access-Control-Allow-Origin',\n  'Access-Control-Expose-Headers',\n  'Access-Control-Max-Age',\n  'Access-Control-Request-Headers',\n  'Access-Control-Request-Method',\n  'Age',\n  'Allow',\n  'Alt-Svc',\n  'Alt-Used',\n  'Authorization',\n  'Cache-Control',\n  'Clear-Site-Data',\n  'Connection',\n  'Content-Disposition',\n  'Content-Encoding',\n  'Content-Language',\n  'Content-Length',\n  'Content-Location',\n  'Content-Range',\n  'Content-Security-Policy',\n  'Content-Security-Policy-Report-Only',\n  'Content-Type',\n  'Cookie',\n  'Cross-Origin-Embedder-Policy',\n  'Cross-Origin-Opener-Policy',\n  'Cross-Origin-Resource-Policy',\n  'Date',\n  'Device-Memory',\n  'Downlink',\n  'ECT',\n  'ETag',\n  'Expect',\n  'Expect-CT',\n  'Expires',\n  'Forwarded',\n  'From',\n  'Host',\n  'If-Match',\n  'If-Modified-Since',\n  'If-None-Match',\n  'If-Range',\n  'If-Unmodified-Since',\n  'Keep-Alive',\n  'Last-Modified',\n  'Link',\n  'Location',\n  'Max-Forwards',\n  'Origin',\n  'Permissions-Policy',\n  'Pragma',\n  'Proxy-Authenticate',\n  'Proxy-Authorization',\n  'RTT',\n  'Range',\n  'Referer',\n  'Referrer-Policy',\n  'Refresh',\n  'Retry-After',\n  'Sec-WebSocket-Accept',\n  'Sec-WebSocket-Extensions',\n  'Sec-WebSocket-Key',\n  'Sec-WebSocket-Protocol',\n  'Sec-WebSocket-Version',\n  'Server',\n  'Server-Timing',\n  'Service-Worker-Allowed',\n  'Service-Worker-Navigation-Preload',\n  'Set-Cookie',\n  'SourceMap',\n  'Strict-Transport-Security',\n  'Supports-Loading-Mode',\n  'TE',\n  'Timing-Allow-Origin',\n  'Trailer',\n  'Transfer-Encoding',\n  'Upgrade',\n  'Upgrade-Insecure-Requests',\n  'User-Agent',\n  'Vary',\n  'Via',\n  'WWW-Authenticate',\n  'X-Content-Type-Options',\n  'X-DNS-Prefetch-Control',\n  'X-Frame-Options',\n  'X-Permitted-Cross-Domain-Policies',\n  'X-Powered-By',\n  'X-Requested-With',\n  'X-XSS-Protection'\n]\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = wellknownHeaderNames[i]\n  const lowerCasedKey = key.toLowerCase()\n  headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] =\n    lowerCasedKey\n}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(headerNameLowerCasedRecord, null)\n\nmodule.exports = {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixXQUFXLG9DQUFvQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQ0FBaUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGNvcmVcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+fSAqL1xuY29uc3QgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmQgPSB7fVxuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9IVFRQL0hlYWRlcnNcbmNvbnN0IHdlbGxrbm93bkhlYWRlck5hbWVzID0gW1xuICAnQWNjZXB0JyxcbiAgJ0FjY2VwdC1FbmNvZGluZycsXG4gICdBY2NlcHQtTGFuZ3VhZ2UnLFxuICAnQWNjZXB0LVJhbmdlcycsXG4gICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFscycsXG4gICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHMnLFxuICAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJyxcbiAgJ0FjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLU1heC1BZ2UnLFxuICAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1IZWFkZXJzJyxcbiAgJ0FjY2Vzcy1Db250cm9sLVJlcXVlc3QtTWV0aG9kJyxcbiAgJ0FnZScsXG4gICdBbGxvdycsXG4gICdBbHQtU3ZjJyxcbiAgJ0FsdC1Vc2VkJyxcbiAgJ0F1dGhvcml6YXRpb24nLFxuICAnQ2FjaGUtQ29udHJvbCcsXG4gICdDbGVhci1TaXRlLURhdGEnLFxuICAnQ29ubmVjdGlvbicsXG4gICdDb250ZW50LURpc3Bvc2l0aW9uJyxcbiAgJ0NvbnRlbnQtRW5jb2RpbmcnLFxuICAnQ29udGVudC1MYW5ndWFnZScsXG4gICdDb250ZW50LUxlbmd0aCcsXG4gICdDb250ZW50LUxvY2F0aW9uJyxcbiAgJ0NvbnRlbnQtUmFuZ2UnLFxuICAnQ29udGVudC1TZWN1cml0eS1Qb2xpY3knLFxuICAnQ29udGVudC1TZWN1cml0eS1Qb2xpY3ktUmVwb3J0LU9ubHknLFxuICAnQ29udGVudC1UeXBlJyxcbiAgJ0Nvb2tpZScsXG4gICdDcm9zcy1PcmlnaW4tRW1iZWRkZXItUG9saWN5JyxcbiAgJ0Nyb3NzLU9yaWdpbi1PcGVuZXItUG9saWN5JyxcbiAgJ0Nyb3NzLU9yaWdpbi1SZXNvdXJjZS1Qb2xpY3knLFxuICAnRGF0ZScsXG4gICdEZXZpY2UtTWVtb3J5JyxcbiAgJ0Rvd25saW5rJyxcbiAgJ0VDVCcsXG4gICdFVGFnJyxcbiAgJ0V4cGVjdCcsXG4gICdFeHBlY3QtQ1QnLFxuICAnRXhwaXJlcycsXG4gICdGb3J3YXJkZWQnLFxuICAnRnJvbScsXG4gICdIb3N0JyxcbiAgJ0lmLU1hdGNoJyxcbiAgJ0lmLU1vZGlmaWVkLVNpbmNlJyxcbiAgJ0lmLU5vbmUtTWF0Y2gnLFxuICAnSWYtUmFuZ2UnLFxuICAnSWYtVW5tb2RpZmllZC1TaW5jZScsXG4gICdLZWVwLUFsaXZlJyxcbiAgJ0xhc3QtTW9kaWZpZWQnLFxuICAnTGluaycsXG4gICdMb2NhdGlvbicsXG4gICdNYXgtRm9yd2FyZHMnLFxuICAnT3JpZ2luJyxcbiAgJ1Blcm1pc3Npb25zLVBvbGljeScsXG4gICdQcmFnbWEnLFxuICAnUHJveHktQXV0aGVudGljYXRlJyxcbiAgJ1Byb3h5LUF1dGhvcml6YXRpb24nLFxuICAnUlRUJyxcbiAgJ1JhbmdlJyxcbiAgJ1JlZmVyZXInLFxuICAnUmVmZXJyZXItUG9saWN5JyxcbiAgJ1JlZnJlc2gnLFxuICAnUmV0cnktQWZ0ZXInLFxuICAnU2VjLVdlYlNvY2tldC1BY2NlcHQnLFxuICAnU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJyxcbiAgJ1NlYy1XZWJTb2NrZXQtS2V5JyxcbiAgJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnLFxuICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJyxcbiAgJ1NlcnZlcicsXG4gICdTZXJ2ZXItVGltaW5nJyxcbiAgJ1NlcnZpY2UtV29ya2VyLUFsbG93ZWQnLFxuICAnU2VydmljZS1Xb3JrZXItTmF2aWdhdGlvbi1QcmVsb2FkJyxcbiAgJ1NldC1Db29raWUnLFxuICAnU291cmNlTWFwJyxcbiAgJ1N0cmljdC1UcmFuc3BvcnQtU2VjdXJpdHknLFxuICAnU3VwcG9ydHMtTG9hZGluZy1Nb2RlJyxcbiAgJ1RFJyxcbiAgJ1RpbWluZy1BbGxvdy1PcmlnaW4nLFxuICAnVHJhaWxlcicsXG4gICdUcmFuc2Zlci1FbmNvZGluZycsXG4gICdVcGdyYWRlJyxcbiAgJ1VwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHMnLFxuICAnVXNlci1BZ2VudCcsXG4gICdWYXJ5JyxcbiAgJ1ZpYScsXG4gICdXV1ctQXV0aGVudGljYXRlJyxcbiAgJ1gtQ29udGVudC1UeXBlLU9wdGlvbnMnLFxuICAnWC1ETlMtUHJlZmV0Y2gtQ29udHJvbCcsXG4gICdYLUZyYW1lLU9wdGlvbnMnLFxuICAnWC1QZXJtaXR0ZWQtQ3Jvc3MtRG9tYWluLVBvbGljaWVzJyxcbiAgJ1gtUG93ZXJlZC1CeScsXG4gICdYLVJlcXVlc3RlZC1XaXRoJyxcbiAgJ1gtWFNTLVByb3RlY3Rpb24nXG5dXG5cbmZvciAobGV0IGkgPSAwOyBpIDwgd2VsbGtub3duSGVhZGVyTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgY29uc3Qga2V5ID0gd2VsbGtub3duSGVhZGVyTmFtZXNbaV1cbiAgY29uc3QgbG93ZXJDYXNlZEtleSA9IGtleS50b0xvd2VyQ2FzZSgpXG4gIGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkW2tleV0gPSBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFtsb3dlckNhc2VkS2V5XSA9XG4gICAgbG93ZXJDYXNlZEtleVxufVxuXG4vLyBOb3RlOiBvYmplY3QgcHJvdG90eXBlcyBzaG91bGQgbm90IGJlIGFibGUgdG8gYmUgcmVmZXJlbmNlZC4gZS5nLiBgT2JqZWN0I2hhc093blByb3BlcnR5YC5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCwgbnVsbClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdlbGxrbm93bkhlYWRlck5hbWVzLFxuICBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/diagnostics.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/core/diagnostics.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst diagnosticsChannel = __webpack_require__(/*! node:diagnostics_channel */ \"node:diagnostics_channel\")\nconst util = __webpack_require__(/*! node:util */ \"node:util\")\n\nconst undiciDebugLog = util.debuglog('undici')\nconst fetchDebuglog = util.debuglog('fetch')\nconst websocketDebuglog = util.debuglog('websocket')\nlet isClientSet = false\nconst channels = {\n  // Client\n  beforeConnect: diagnosticsChannel.channel('undici:client:beforeConnect'),\n  connected: diagnosticsChannel.channel('undici:client:connected'),\n  connectError: diagnosticsChannel.channel('undici:client:connectError'),\n  sendHeaders: diagnosticsChannel.channel('undici:client:sendHeaders'),\n  // Request\n  create: diagnosticsChannel.channel('undici:request:create'),\n  bodySent: diagnosticsChannel.channel('undici:request:bodySent'),\n  headers: diagnosticsChannel.channel('undici:request:headers'),\n  trailers: diagnosticsChannel.channel('undici:request:trailers'),\n  error: diagnosticsChannel.channel('undici:request:error'),\n  // WebSocket\n  open: diagnosticsChannel.channel('undici:websocket:open'),\n  close: diagnosticsChannel.channel('undici:websocket:close'),\n  socketError: diagnosticsChannel.channel('undici:websocket:socket_error'),\n  ping: diagnosticsChannel.channel('undici:websocket:ping'),\n  pong: diagnosticsChannel.channel('undici:websocket:pong')\n}\n\nif (undiciDebugLog.enabled || fetchDebuglog.enabled) {\n  const debuglog = fetchDebuglog.enabled ? fetchDebuglog : undiciDebugLog\n\n  // Track all Client events\n  diagnosticsChannel.channel('undici:client:beforeConnect').subscribe(evt => {\n    const {\n      connectParams: { version, protocol, port, host }\n    } = evt\n    debuglog(\n      'connecting to %s using %s%s',\n      `${host}${port ? `:${port}` : ''}`,\n      protocol,\n      version\n    )\n  })\n\n  diagnosticsChannel.channel('undici:client:connected').subscribe(evt => {\n    const {\n      connectParams: { version, protocol, port, host }\n    } = evt\n    debuglog(\n      'connected to %s using %s%s',\n      `${host}${port ? `:${port}` : ''}`,\n      protocol,\n      version\n    )\n  })\n\n  diagnosticsChannel.channel('undici:client:connectError').subscribe(evt => {\n    const {\n      connectParams: { version, protocol, port, host },\n      error\n    } = evt\n    debuglog(\n      'connection to %s using %s%s errored - %s',\n      `${host}${port ? `:${port}` : ''}`,\n      protocol,\n      version,\n      error.message\n    )\n  })\n\n  diagnosticsChannel.channel('undici:client:sendHeaders').subscribe(evt => {\n    const {\n      request: { method, path, origin }\n    } = evt\n    debuglog('sending request to %s %s/%s', method, origin, path)\n  })\n\n  // Track Request events\n  diagnosticsChannel.channel('undici:request:headers').subscribe(evt => {\n    const {\n      request: { method, path, origin },\n      response: { statusCode }\n    } = evt\n    debuglog(\n      'received response to %s %s/%s - HTTP %d',\n      method,\n      origin,\n      path,\n      statusCode\n    )\n  })\n\n  diagnosticsChannel.channel('undici:request:trailers').subscribe(evt => {\n    const {\n      request: { method, path, origin }\n    } = evt\n    debuglog('trailers received from %s %s/%s', method, origin, path)\n  })\n\n  diagnosticsChannel.channel('undici:request:error').subscribe(evt => {\n    const {\n      request: { method, path, origin },\n      error\n    } = evt\n    debuglog(\n      'request to %s %s/%s errored - %s',\n      method,\n      origin,\n      path,\n      error.message\n    )\n  })\n\n  isClientSet = true\n}\n\nif (websocketDebuglog.enabled) {\n  if (!isClientSet) {\n    const debuglog = undiciDebugLog.enabled ? undiciDebugLog : websocketDebuglog\n    diagnosticsChannel.channel('undici:client:beforeConnect').subscribe(evt => {\n      const {\n        connectParams: { version, protocol, port, host }\n      } = evt\n      debuglog(\n        'connecting to %s%s using %s%s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version\n      )\n    })\n\n    diagnosticsChannel.channel('undici:client:connected').subscribe(evt => {\n      const {\n        connectParams: { version, protocol, port, host }\n      } = evt\n      debuglog(\n        'connected to %s%s using %s%s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version\n      )\n    })\n\n    diagnosticsChannel.channel('undici:client:connectError').subscribe(evt => {\n      const {\n        connectParams: { version, protocol, port, host },\n        error\n      } = evt\n      debuglog(\n        'connection to %s%s using %s%s errored - %s',\n        host,\n        port ? `:${port}` : '',\n        protocol,\n        version,\n        error.message\n      )\n    })\n\n    diagnosticsChannel.channel('undici:client:sendHeaders').subscribe(evt => {\n      const {\n        request: { method, path, origin }\n      } = evt\n      debuglog('sending request to %s %s/%s', method, origin, path)\n    })\n  }\n\n  // Track all WebSocket events\n  diagnosticsChannel.channel('undici:websocket:open').subscribe(evt => {\n    const {\n      address: { address, port }\n    } = evt\n    websocketDebuglog('connection opened %s%s', address, port ? `:${port}` : '')\n  })\n\n  diagnosticsChannel.channel('undici:websocket:close').subscribe(evt => {\n    const { websocket, code, reason } = evt\n    websocketDebuglog(\n      'closed connection to %s - %s %s',\n      websocket.url,\n      code,\n      reason\n    )\n  })\n\n  diagnosticsChannel.channel('undici:websocket:socket_error').subscribe(err => {\n    websocketDebuglog('connection errored - %s', err.message)\n  })\n\n  diagnosticsChannel.channel('undici:websocket:ping').subscribe(evt => {\n    websocketDebuglog('ping received')\n  })\n\n  diagnosticsChannel.channel('undici:websocket:pong').subscribe(evt => {\n    websocketDebuglog('pong received')\n  })\n}\n\nmodule.exports = {\n  channels\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2RpYWdub3N0aWNzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osMkJBQTJCLG1CQUFPLENBQUMsMERBQTBCO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVMsS0FBSyxFQUFFLFdBQVcsS0FBSyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVMsS0FBSyxFQUFFLFdBQVcsS0FBSyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFNBQVMsS0FBSyxFQUFFLFdBQVcsS0FBSyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QyxrQkFBa0I7QUFDbEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixLQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFFBQVE7QUFDUjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLG9FQUFvRSxLQUFLO0FBQ3pFLEdBQUc7O0FBRUg7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGNvcmVcXGRpYWdub3N0aWNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgZGlhZ25vc3RpY3NDaGFubmVsID0gcmVxdWlyZSgnbm9kZTpkaWFnbm9zdGljc19jaGFubmVsJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuXG5jb25zdCB1bmRpY2lEZWJ1Z0xvZyA9IHV0aWwuZGVidWdsb2coJ3VuZGljaScpXG5jb25zdCBmZXRjaERlYnVnbG9nID0gdXRpbC5kZWJ1Z2xvZygnZmV0Y2gnKVxuY29uc3Qgd2Vic29ja2V0RGVidWdsb2cgPSB1dGlsLmRlYnVnbG9nKCd3ZWJzb2NrZXQnKVxubGV0IGlzQ2xpZW50U2V0ID0gZmFsc2VcbmNvbnN0IGNoYW5uZWxzID0ge1xuICAvLyBDbGllbnRcbiAgYmVmb3JlQ29ubmVjdDogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6YmVmb3JlQ29ubmVjdCcpLFxuICBjb25uZWN0ZWQ6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmNvbm5lY3RlZCcpLFxuICBjb25uZWN0RXJyb3I6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OmNvbm5lY3RFcnJvcicpLFxuICBzZW5kSGVhZGVyczogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6c2VuZEhlYWRlcnMnKSxcbiAgLy8gUmVxdWVzdFxuICBjcmVhdGU6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpjcmVhdGUnKSxcbiAgYm9keVNlbnQ6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6cmVxdWVzdDpib2R5U2VudCcpLFxuICBoZWFkZXJzOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6aGVhZGVycycpLFxuICB0cmFpbGVyczogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OnRyYWlsZXJzJyksXG4gIGVycm9yOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6ZXJyb3InKSxcbiAgLy8gV2ViU29ja2V0XG4gIG9wZW46IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0Om9wZW4nKSxcbiAgY2xvc2U6IGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6d2Vic29ja2V0OmNsb3NlJyksXG4gIHNvY2tldEVycm9yOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpzb2NrZXRfZXJyb3InKSxcbiAgcGluZzogZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6cGluZycpLFxuICBwb25nOiBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpwb25nJylcbn1cblxuaWYgKHVuZGljaURlYnVnTG9nLmVuYWJsZWQgfHwgZmV0Y2hEZWJ1Z2xvZy5lbmFibGVkKSB7XG4gIGNvbnN0IGRlYnVnbG9nID0gZmV0Y2hEZWJ1Z2xvZy5lbmFibGVkID8gZmV0Y2hEZWJ1Z2xvZyA6IHVuZGljaURlYnVnTG9nXG5cbiAgLy8gVHJhY2sgYWxsIENsaWVudCBldmVudHNcbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6YmVmb3JlQ29ubmVjdCcpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbm5lY3RQYXJhbXM6IHsgdmVyc2lvbiwgcHJvdG9jb2wsIHBvcnQsIGhvc3QgfVxuICAgIH0gPSBldnRcbiAgICBkZWJ1Z2xvZyhcbiAgICAgICdjb25uZWN0aW5nIHRvICVzIHVzaW5nICVzJXMnLFxuICAgICAgYCR7aG9zdH0ke3BvcnQgPyBgOiR7cG9ydH1gIDogJyd9YCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgdmVyc2lvblxuICAgIClcbiAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0ZWQnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjb25uZWN0UGFyYW1zOiB7IHZlcnNpb24sIHByb3RvY29sLCBwb3J0LCBob3N0IH1cbiAgICB9ID0gZXZ0XG4gICAgZGVidWdsb2coXG4gICAgICAnY29ubmVjdGVkIHRvICVzIHVzaW5nICVzJXMnLFxuICAgICAgYCR7aG9zdH0ke3BvcnQgPyBgOiR7cG9ydH1gIDogJyd9YCxcbiAgICAgIHByb3RvY29sLFxuICAgICAgdmVyc2lvblxuICAgIClcbiAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0RXJyb3InKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjb25uZWN0UGFyYW1zOiB7IHZlcnNpb24sIHByb3RvY29sLCBwb3J0LCBob3N0IH0sXG4gICAgICBlcnJvclxuICAgIH0gPSBldnRcbiAgICBkZWJ1Z2xvZyhcbiAgICAgICdjb25uZWN0aW9uIHRvICVzIHVzaW5nICVzJXMgZXJyb3JlZCAtICVzJyxcbiAgICAgIGAke2hvc3R9JHtwb3J0ID8gYDoke3BvcnR9YCA6ICcnfWAsXG4gICAgICBwcm90b2NvbCxcbiAgICAgIHZlcnNpb24sXG4gICAgICBlcnJvci5tZXNzYWdlXG4gICAgKVxuICB9KVxuXG4gIGRpYWdub3N0aWNzQ2hhbm5lbC5jaGFubmVsKCd1bmRpY2k6Y2xpZW50OnNlbmRIZWFkZXJzJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVxdWVzdDogeyBtZXRob2QsIHBhdGgsIG9yaWdpbiB9XG4gICAgfSA9IGV2dFxuICAgIGRlYnVnbG9nKCdzZW5kaW5nIHJlcXVlc3QgdG8gJXMgJXMvJXMnLCBtZXRob2QsIG9yaWdpbiwgcGF0aClcbiAgfSlcblxuICAvLyBUcmFjayBSZXF1ZXN0IGV2ZW50c1xuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOnJlcXVlc3Q6aGVhZGVycycpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kLCBwYXRoLCBvcmlnaW4gfSxcbiAgICAgIHJlc3BvbnNlOiB7IHN0YXR1c0NvZGUgfVxuICAgIH0gPSBldnRcbiAgICBkZWJ1Z2xvZyhcbiAgICAgICdyZWNlaXZlZCByZXNwb25zZSB0byAlcyAlcy8lcyAtIEhUVFAgJWQnLFxuICAgICAgbWV0aG9kLFxuICAgICAgb3JpZ2luLFxuICAgICAgcGF0aCxcbiAgICAgIHN0YXR1c0NvZGVcbiAgICApXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OnRyYWlsZXJzJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVxdWVzdDogeyBtZXRob2QsIHBhdGgsIG9yaWdpbiB9XG4gICAgfSA9IGV2dFxuICAgIGRlYnVnbG9nKCd0cmFpbGVycyByZWNlaXZlZCBmcm9tICVzICVzLyVzJywgbWV0aG9kLCBvcmlnaW4sIHBhdGgpXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpyZXF1ZXN0OmVycm9yJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcmVxdWVzdDogeyBtZXRob2QsIHBhdGgsIG9yaWdpbiB9LFxuICAgICAgZXJyb3JcbiAgICB9ID0gZXZ0XG4gICAgZGVidWdsb2coXG4gICAgICAncmVxdWVzdCB0byAlcyAlcy8lcyBlcnJvcmVkIC0gJXMnLFxuICAgICAgbWV0aG9kLFxuICAgICAgb3JpZ2luLFxuICAgICAgcGF0aCxcbiAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICApXG4gIH0pXG5cbiAgaXNDbGllbnRTZXQgPSB0cnVlXG59XG5cbmlmICh3ZWJzb2NrZXREZWJ1Z2xvZy5lbmFibGVkKSB7XG4gIGlmICghaXNDbGllbnRTZXQpIHtcbiAgICBjb25zdCBkZWJ1Z2xvZyA9IHVuZGljaURlYnVnTG9nLmVuYWJsZWQgPyB1bmRpY2lEZWJ1Z0xvZyA6IHdlYnNvY2tldERlYnVnbG9nXG4gICAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTpjbGllbnQ6YmVmb3JlQ29ubmVjdCcpLnN1YnNjcmliZShldnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25uZWN0UGFyYW1zOiB7IHZlcnNpb24sIHByb3RvY29sLCBwb3J0LCBob3N0IH1cbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnbG9nKFxuICAgICAgICAnY29ubmVjdGluZyB0byAlcyVzIHVzaW5nICVzJXMnLFxuICAgICAgICBob3N0LFxuICAgICAgICBwb3J0ID8gYDoke3BvcnR9YCA6ICcnLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgdmVyc2lvblxuICAgICAgKVxuICAgIH0pXG5cbiAgICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0ZWQnKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29ubmVjdFBhcmFtczogeyB2ZXJzaW9uLCBwcm90b2NvbCwgcG9ydCwgaG9zdCB9XG4gICAgICB9ID0gZXZ0XG4gICAgICBkZWJ1Z2xvZyhcbiAgICAgICAgJ2Nvbm5lY3RlZCB0byAlcyVzIHVzaW5nICVzJXMnLFxuICAgICAgICBob3N0LFxuICAgICAgICBwb3J0ID8gYDoke3BvcnR9YCA6ICcnLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgdmVyc2lvblxuICAgICAgKVxuICAgIH0pXG5cbiAgICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpjb25uZWN0RXJyb3InKS5zdWJzY3JpYmUoZXZ0ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29ubmVjdFBhcmFtczogeyB2ZXJzaW9uLCBwcm90b2NvbCwgcG9ydCwgaG9zdCB9LFxuICAgICAgICBlcnJvclxuICAgICAgfSA9IGV2dFxuICAgICAgZGVidWdsb2coXG4gICAgICAgICdjb25uZWN0aW9uIHRvICVzJXMgdXNpbmcgJXMlcyBlcnJvcmVkIC0gJXMnLFxuICAgICAgICBob3N0LFxuICAgICAgICBwb3J0ID8gYDoke3BvcnR9YCA6ICcnLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgZXJyb3IubWVzc2FnZVxuICAgICAgKVxuICAgIH0pXG5cbiAgICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOmNsaWVudDpzZW5kSGVhZGVycycpLnN1YnNjcmliZShldnQgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0OiB7IG1ldGhvZCwgcGF0aCwgb3JpZ2luIH1cbiAgICAgIH0gPSBldnRcbiAgICAgIGRlYnVnbG9nKCdzZW5kaW5nIHJlcXVlc3QgdG8gJXMgJXMvJXMnLCBtZXRob2QsIG9yaWdpbiwgcGF0aClcbiAgICB9KVxuICB9XG5cbiAgLy8gVHJhY2sgYWxsIFdlYlNvY2tldCBldmVudHNcbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6b3BlbicpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJlc3M6IHsgYWRkcmVzcywgcG9ydCB9XG4gICAgfSA9IGV2dFxuICAgIHdlYnNvY2tldERlYnVnbG9nKCdjb25uZWN0aW9uIG9wZW5lZCAlcyVzJywgYWRkcmVzcywgcG9ydCA/IGA6JHtwb3J0fWAgOiAnJylcbiAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpjbG9zZScpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIGNvbnN0IHsgd2Vic29ja2V0LCBjb2RlLCByZWFzb24gfSA9IGV2dFxuICAgIHdlYnNvY2tldERlYnVnbG9nKFxuICAgICAgJ2Nsb3NlZCBjb25uZWN0aW9uIHRvICVzIC0gJXMgJXMnLFxuICAgICAgd2Vic29ja2V0LnVybCxcbiAgICAgIGNvZGUsXG4gICAgICByZWFzb25cbiAgICApXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6c29ja2V0X2Vycm9yJykuc3Vic2NyaWJlKGVyciA9PiB7XG4gICAgd2Vic29ja2V0RGVidWdsb2coJ2Nvbm5lY3Rpb24gZXJyb3JlZCAtICVzJywgZXJyLm1lc3NhZ2UpXG4gIH0pXG5cbiAgZGlhZ25vc3RpY3NDaGFubmVsLmNoYW5uZWwoJ3VuZGljaTp3ZWJzb2NrZXQ6cGluZycpLnN1YnNjcmliZShldnQgPT4ge1xuICAgIHdlYnNvY2tldERlYnVnbG9nKCdwaW5nIHJlY2VpdmVkJylcbiAgfSlcblxuICBkaWFnbm9zdGljc0NoYW5uZWwuY2hhbm5lbCgndW5kaWNpOndlYnNvY2tldDpwb25nJykuc3Vic2NyaWJlKGV2dCA9PiB7XG4gICAgd2Vic29ja2V0RGVidWdsb2coJ3BvbmcgcmVjZWl2ZWQnKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2hhbm5lbHNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/diagnostics.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/errors.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/core/errors.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nclass UndiciError extends Error {\n  constructor (message) {\n    super(message)\n    this.name = 'UndiciError'\n    this.code = 'UND_ERR'\n  }\n}\n\nclass ConnectTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ConnectTimeoutError'\n    this.message = message || 'Connect Timeout Error'\n    this.code = 'UND_ERR_CONNECT_TIMEOUT'\n  }\n}\n\nclass HeadersTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'HeadersTimeoutError'\n    this.message = message || 'Headers Timeout Error'\n    this.code = 'UND_ERR_HEADERS_TIMEOUT'\n  }\n}\n\nclass HeadersOverflowError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'HeadersOverflowError'\n    this.message = message || 'Headers Overflow Error'\n    this.code = 'UND_ERR_HEADERS_OVERFLOW'\n  }\n}\n\nclass BodyTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'BodyTimeoutError'\n    this.message = message || 'Body Timeout Error'\n    this.code = 'UND_ERR_BODY_TIMEOUT'\n  }\n}\n\nclass ResponseStatusCodeError extends UndiciError {\n  constructor (message, statusCode, headers, body) {\n    super(message)\n    this.name = 'ResponseStatusCodeError'\n    this.message = message || 'Response Status Code Error'\n    this.code = 'UND_ERR_RESPONSE_STATUS_CODE'\n    this.body = body\n    this.status = statusCode\n    this.statusCode = statusCode\n    this.headers = headers\n  }\n}\n\nclass InvalidArgumentError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InvalidArgumentError'\n    this.message = message || 'Invalid Argument Error'\n    this.code = 'UND_ERR_INVALID_ARG'\n  }\n}\n\nclass InvalidReturnValueError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InvalidReturnValueError'\n    this.message = message || 'Invalid Return Value Error'\n    this.code = 'UND_ERR_INVALID_RETURN_VALUE'\n  }\n}\n\nclass AbortError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'AbortError'\n    this.message = message || 'The operation was aborted'\n  }\n}\n\nclass RequestAbortedError extends AbortError {\n  constructor (message) {\n    super(message)\n    this.name = 'AbortError'\n    this.message = message || 'Request aborted'\n    this.code = 'UND_ERR_ABORTED'\n  }\n}\n\nclass InformationalError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'InformationalError'\n    this.message = message || 'Request information'\n    this.code = 'UND_ERR_INFO'\n  }\n}\n\nclass RequestContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'RequestContentLengthMismatchError'\n    this.message = message || 'Request body length does not match content-length header'\n    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass ResponseContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ResponseContentLengthMismatchError'\n    this.message = message || 'Response body length does not match content-length header'\n    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass ClientDestroyedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ClientDestroyedError'\n    this.message = message || 'The client is destroyed'\n    this.code = 'UND_ERR_DESTROYED'\n  }\n}\n\nclass ClientClosedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ClientClosedError'\n    this.message = message || 'The client is closed'\n    this.code = 'UND_ERR_CLOSED'\n  }\n}\n\nclass SocketError extends UndiciError {\n  constructor (message, socket) {\n    super(message)\n    this.name = 'SocketError'\n    this.message = message || 'Socket error'\n    this.code = 'UND_ERR_SOCKET'\n    this.socket = socket\n  }\n}\n\nclass NotSupportedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'NotSupportedError'\n    this.message = message || 'Not supported error'\n    this.code = 'UND_ERR_NOT_SUPPORTED'\n  }\n}\n\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'MissingUpstreamError'\n    this.message = message || 'No upstream has been added to the BalancedPool'\n    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'\n  }\n}\n\nclass HTTPParserError extends Error {\n  constructor (message, code, data) {\n    super(message)\n    this.name = 'HTTPParserError'\n    this.code = code ? `HPE_${code}` : undefined\n    this.data = data ? data.toString() : undefined\n  }\n}\n\nclass ResponseExceededMaxSizeError extends UndiciError {\n  constructor (message) {\n    super(message)\n    this.name = 'ResponseExceededMaxSizeError'\n    this.message = message || 'Response content exceeded max size'\n    this.code = 'UND_ERR_RES_EXCEEDED_MAX_SIZE'\n  }\n}\n\nclass RequestRetryError extends UndiciError {\n  constructor (message, code, { headers, data }) {\n    super(message)\n    this.name = 'RequestRetryError'\n    this.message = message || 'Request retry error'\n    this.code = 'UND_ERR_REQ_RETRY'\n    this.statusCode = code\n    this.data = data\n    this.headers = headers\n  }\n}\n\nclass ResponseError extends UndiciError {\n  constructor (message, code, { headers, data }) {\n    super(message)\n    this.name = 'ResponseError'\n    this.message = message || 'Response error'\n    this.code = 'UND_ERR_RESPONSE'\n    this.statusCode = code\n    this.data = data\n    this.headers = headers\n  }\n}\n\nclass SecureProxyConnectionError extends UndiciError {\n  constructor (cause, message, options) {\n    super(message, { cause, ...(options ?? {}) })\n    this.name = 'SecureProxyConnectionError'\n    this.message = message || 'Secure Proxy Connection failed'\n    this.code = 'UND_ERR_PRX_TLS'\n    this.cause = cause\n  }\n}\n\nmodule.exports = {\n  AbortError,\n  HTTPParserError,\n  UndiciError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  BodyTimeoutError,\n  RequestContentLengthMismatchError,\n  ConnectTimeoutError,\n  ResponseStatusCodeError,\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError,\n  ClientDestroyedError,\n  ClientClosedError,\n  InformationalError,\n  SocketError,\n  NotSupportedError,\n  ResponseContentLengthMismatchError,\n  BalancedPoolMissingUpstreamError,\n  ResponseExceededMaxSizeError,\n  RequestRetryError,\n  ResponseError,\n  SecureProxyConnectionError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsd0JBQXdCLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGNvcmVcXGVycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY2xhc3MgVW5kaWNpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnVW5kaWNpRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlInXG4gIH1cbn1cblxuY2xhc3MgQ29ubmVjdFRpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdDb25uZWN0VGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0Nvbm5lY3QgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9DT05ORUNUX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc1RpbWVvdXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdIZWFkZXJzVGltZW91dEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0hlYWRlcnMgVGltZW91dCBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX1RJTUVPVVQnXG4gIH1cbn1cblxuY2xhc3MgSGVhZGVyc092ZXJmbG93RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSGVhZGVyc092ZXJmbG93RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSGVhZGVycyBPdmVyZmxvdyBFcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9IRUFERVJTX09WRVJGTE9XJ1xuICB9XG59XG5cbmNsYXNzIEJvZHlUaW1lb3V0RXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQm9keVRpbWVvdXRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdCb2R5IFRpbWVvdXQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfQk9EWV9USU1FT1VUJ1xuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlU3RhdHVzQ29kZUVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSwgc3RhdHVzQ29kZSwgaGVhZGVycywgYm9keSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1Jlc3BvbnNlU3RhdHVzQ29kZUVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIFN0YXR1cyBDb2RlIEVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU1BPTlNFX1NUQVRVU19DT0RFJ1xuICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1c0NvZGVcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlXG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVyc1xuICB9XG59XG5cbmNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRBcmd1bWVudEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ0ludmFsaWQgQXJndW1lbnQgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9BUkcnXG4gIH1cbn1cblxuY2xhc3MgSW52YWxpZFJldHVyblZhbHVlRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFJldHVyblZhbHVlRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnSW52YWxpZCBSZXR1cm4gVmFsdWUgRXJyb3InXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfSU5WQUxJRF9SRVRVUk5fVkFMVUUnXG4gIH1cbn1cblxuY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdBYm9ydEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQnXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdEFib3J0ZWRFcnJvciBleHRlbmRzIEFib3J0RXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0Fib3J0RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCBhYm9ydGVkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0FCT1JURUQnXG4gIH1cbn1cblxuY2xhc3MgSW5mb3JtYXRpb25hbEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0luZm9ybWF0aW9uYWxFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGluZm9ybWF0aW9uJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0lORk8nXG4gIH1cbn1cblxuY2xhc3MgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1JlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXF1ZXN0IGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1Jlc3BvbnNlIGJvZHkgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVNfQ09OVEVOVF9MRU5HVEhfTUlTTUFUQ0gnXG4gIH1cbn1cblxuY2xhc3MgQ2xpZW50RGVzdHJveWVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnQ2xpZW50RGVzdHJveWVkRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnVGhlIGNsaWVudCBpcyBkZXN0cm95ZWQnXG4gICAgdGhpcy5jb2RlID0gJ1VORF9FUlJfREVTVFJPWUVEJ1xuICB9XG59XG5cbmNsYXNzIENsaWVudENsb3NlZEVycm9yIGV4dGVuZHMgVW5kaWNpRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ0NsaWVudENsb3NlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSBjbGllbnQgaXMgY2xvc2VkJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX0NMT1NFRCdcbiAgfVxufVxuXG5jbGFzcyBTb2NrZXRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIHNvY2tldCkge1xuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5uYW1lID0gJ1NvY2tldEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1NvY2tldCBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9TT0NLRVQnXG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgfVxufVxuXG5jbGFzcyBOb3RTdXBwb3J0ZWRFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKVxuICAgIHRoaXMubmFtZSA9ICdOb3RTdXBwb3J0ZWRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdOb3Qgc3VwcG9ydGVkIGVycm9yJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX05PVF9TVVBQT1JURUQnXG4gIH1cbn1cblxuY2xhc3MgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnTWlzc2luZ1Vwc3RyZWFtRXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnTm8gdXBzdHJlYW0gaGFzIGJlZW4gYWRkZWQgdG8gdGhlIEJhbGFuY2VkUG9vbCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9CUExfTUlTU0lOR19VUFNUUkVBTSdcbiAgfVxufVxuXG5jbGFzcyBIVFRQUGFyc2VyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlLCBjb2RlLCBkYXRhKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnSFRUUFBhcnNlckVycm9yJ1xuICAgIHRoaXMuY29kZSA9IGNvZGUgPyBgSFBFXyR7Y29kZX1gIDogdW5kZWZpbmVkXG4gICAgdGhpcy5kYXRhID0gZGF0YSA/IGRhdGEudG9TdHJpbmcoKSA6IHVuZGVmaW5lZFxuICB9XG59XG5cbmNsYXNzIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXNwb25zZSBjb250ZW50IGV4Y2VlZGVkIG1heCBzaXplJ1xuICAgIHRoaXMuY29kZSA9ICdVTkRfRVJSX1JFU19FWENFRURFRF9NQVhfU0laRSdcbiAgfVxufVxuXG5jbGFzcyBSZXF1ZXN0UmV0cnlFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGNvZGUsIHsgaGVhZGVycywgZGF0YSB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVxdWVzdFJldHJ5RXJyb3InXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnUmVxdWVzdCByZXRyeSBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVFfUkVUUlknXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gY29kZVxuICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG4gIH1cbn1cblxuY2xhc3MgUmVzcG9uc2VFcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKG1lc3NhZ2UsIGNvZGUsIHsgaGVhZGVycywgZGF0YSB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICB0aGlzLm5hbWUgPSAnUmVzcG9uc2VFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICdSZXNwb25zZSBlcnJvcidcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9SRVNQT05TRSdcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBjb2RlXG4gICAgdGhpcy5kYXRhID0gZGF0YVxuICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnNcbiAgfVxufVxuXG5jbGFzcyBTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvciBleHRlbmRzIFVuZGljaUVycm9yIHtcbiAgY29uc3RydWN0b3IgKGNhdXNlLCBtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSwgLi4uKG9wdGlvbnMgPz8ge30pIH0pXG4gICAgdGhpcy5uYW1lID0gJ1NlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1NlY3VyZSBQcm94eSBDb25uZWN0aW9uIGZhaWxlZCdcbiAgICB0aGlzLmNvZGUgPSAnVU5EX0VSUl9QUlhfVExTJ1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBYm9ydEVycm9yLFxuICBIVFRQUGFyc2VyRXJyb3IsXG4gIFVuZGljaUVycm9yLFxuICBIZWFkZXJzVGltZW91dEVycm9yLFxuICBIZWFkZXJzT3ZlcmZsb3dFcnJvcixcbiAgQm9keVRpbWVvdXRFcnJvcixcbiAgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBDb25uZWN0VGltZW91dEVycm9yLFxuICBSZXNwb25zZVN0YXR1c0NvZGVFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWRSZXR1cm5WYWx1ZUVycm9yLFxuICBSZXF1ZXN0QWJvcnRlZEVycm9yLFxuICBDbGllbnREZXN0cm95ZWRFcnJvcixcbiAgQ2xpZW50Q2xvc2VkRXJyb3IsXG4gIEluZm9ybWF0aW9uYWxFcnJvcixcbiAgU29ja2V0RXJyb3IsXG4gIE5vdFN1cHBvcnRlZEVycm9yLFxuICBSZXNwb25zZUNvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yLFxuICBCYWxhbmNlZFBvb2xNaXNzaW5nVXBzdHJlYW1FcnJvcixcbiAgUmVzcG9uc2VFeGNlZWRlZE1heFNpemVFcnJvcixcbiAgUmVxdWVzdFJldHJ5RXJyb3IsXG4gIFJlc3BvbnNlRXJyb3IsXG4gIFNlY3VyZVByb3h5Q29ubmVjdGlvbkVycm9yXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/request.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst {\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isStream,\n  destroy,\n  isBuffer,\n  isFormDataLike,\n  isIterable,\n  isBlobLike,\n  buildURL,\n  validateHandler,\n  getServerName,\n  normalizedMethodRecords\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { channels } = __webpack_require__(/*! ./diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/core/constants.js\")\n\n// Verifies that a given path is valid does not contain control chars \\x00 to \\x20\nconst invalidPathRegex = /[^\\u0021-\\u00ff]/\n\nconst kHandler = Symbol('handler')\n\nclass Request {\n  constructor (origin, {\n    path,\n    method,\n    body,\n    headers,\n    query,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout,\n    reset,\n    throwOnError,\n    expectContinue,\n    servername\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string')\n    } else if (\n      path[0] !== '/' &&\n      !(path.startsWith('http://') || path.startsWith('https://')) &&\n      method !== 'CONNECT'\n    ) {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')\n    } else if (invalidPathRegex.test(path)) {\n      throw new InvalidArgumentError('invalid request path')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    } else if (normalizedMethodRecords[method] === undefined && !isValidHTTPToken(method)) {\n      throw new InvalidArgumentError('invalid request method')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout')\n    }\n\n    if (reset != null && typeof reset !== 'boolean') {\n      throw new InvalidArgumentError('invalid reset')\n    }\n\n    if (expectContinue != null && typeof expectContinue !== 'boolean') {\n      throw new InvalidArgumentError('invalid expectContinue')\n    }\n\n    this.headersTimeout = headersTimeout\n\n    this.bodyTimeout = bodyTimeout\n\n    this.throwOnError = throwOnError === true\n\n    this.method = method\n\n    this.abort = null\n\n    if (body == null) {\n      this.body = null\n    } else if (isStream(body)) {\n      this.body = body\n\n      const rState = this.body._readableState\n      if (!rState || !rState.autoDestroy) {\n        this.endHandler = function autoDestroy () {\n          destroy(this)\n        }\n        this.body.on('end', this.endHandler)\n      }\n\n      this.errorHandler = err => {\n        if (this.abort) {\n          this.abort(err)\n        } else {\n          this.error = err\n        }\n      }\n      this.body.on('error', this.errorHandler)\n    } else if (isBuffer(body)) {\n      this.body = body.byteLength ? body : null\n    } else if (ArrayBuffer.isView(body)) {\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null\n    } else if (body instanceof ArrayBuffer) {\n      this.body = body.byteLength ? Buffer.from(body) : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else if (isFormDataLike(body) || isIterable(body) || isBlobLike(body)) {\n      this.body = body\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')\n    }\n\n    this.completed = false\n\n    this.aborted = false\n\n    this.upgrade = upgrade || null\n\n    this.path = query ? buildURL(path, query) : path\n\n    this.origin = origin\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.blocking = blocking == null ? false : blocking\n\n    this.reset = reset == null ? null : reset\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.contentType = null\n\n    this.headers = []\n\n    // Only for H2\n    this.expectContinue = expectContinue != null ? expectContinue : false\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      if (headers[Symbol.iterator]) {\n        for (const header of headers) {\n          if (!Array.isArray(header) || header.length !== 2) {\n            throw new InvalidArgumentError('headers must be in key-value pair format')\n          }\n          processHeader(this, header[0], header[1])\n        }\n      } else {\n        const keys = Object.keys(headers)\n        for (let i = 0; i < keys.length; ++i) {\n          processHeader(this, keys[i], headers[keys[i]])\n        }\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    validateHandler(handler, method, upgrade)\n\n    this.servername = servername || getServerName(this.host)\n\n    this[kHandler] = handler\n\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({ request: this })\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this[kHandler].onBodySent) {\n      try {\n        return this[kHandler].onBodySent(chunk)\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onRequestSent () {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({ request: this })\n    }\n\n    if (this[kHandler].onRequestSent) {\n      try {\n        return this[kHandler].onRequestSent()\n      } catch (err) {\n        this.abort(err)\n      }\n    }\n  }\n\n  onConnect (abort) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (this.error) {\n      abort(this.error)\n    } else {\n      this.abort = abort\n      return this[kHandler].onConnect(abort)\n    }\n  }\n\n  onResponseStarted () {\n    return this[kHandler].onResponseStarted?.()\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })\n    }\n\n    try {\n      return this[kHandler].onHeaders(statusCode, headers, resume, statusText)\n    } catch (err) {\n      this.abort(err)\n    }\n  }\n\n  onData (chunk) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    try {\n      return this[kHandler].onData(chunk)\n    } catch (err) {\n      this.abort(err)\n      return false\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    this.onFinally()\n\n    assert(!this.aborted)\n\n    this.completed = true\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({ request: this, trailers })\n    }\n\n    try {\n      return this[kHandler].onComplete(trailers)\n    } catch (err) {\n      // TODO (fix): This might be a bad idea?\n      this.onError(err)\n    }\n  }\n\n  onError (error) {\n    this.onFinally()\n\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({ request: this, error })\n    }\n\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n\n    return this[kHandler].onError(error)\n  }\n\n  onFinally () {\n    if (this.errorHandler) {\n      this.body.off('error', this.errorHandler)\n      this.errorHandler = null\n    }\n\n    if (this.endHandler) {\n      this.body.off('end', this.endHandler)\n      this.endHandler = null\n    }\n  }\n\n  addHeader (key, value) {\n    processHeader(this, key, value)\n    return this\n  }\n}\n\nfunction processHeader (request, key, val) {\n  if (val && (typeof val === 'object' && !Array.isArray(val))) {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  let headerName = headerNameLowerCasedRecord[key]\n\n  if (headerName === undefined) {\n    headerName = key.toLowerCase()\n    if (headerNameLowerCasedRecord[headerName] === undefined && !isValidHTTPToken(headerName)) {\n      throw new InvalidArgumentError('invalid header key')\n    }\n  }\n\n  if (Array.isArray(val)) {\n    const arr = []\n    for (let i = 0; i < val.length; i++) {\n      if (typeof val[i] === 'string') {\n        if (!isValidHeaderValue(val[i])) {\n          throw new InvalidArgumentError(`invalid ${key} header`)\n        }\n        arr.push(val[i])\n      } else if (val[i] === null) {\n        arr.push('')\n      } else if (typeof val[i] === 'object') {\n        throw new InvalidArgumentError(`invalid ${key} header`)\n      } else {\n        arr.push(`${val[i]}`)\n      }\n    }\n    val = arr\n  } else if (typeof val === 'string') {\n    if (!isValidHeaderValue(val)) {\n      throw new InvalidArgumentError(`invalid ${key} header`)\n    }\n  } else if (val === null) {\n    val = ''\n  } else {\n    val = `${val}`\n  }\n\n  if (request.host === null && headerName === 'host') {\n    if (typeof val !== 'string') {\n      throw new InvalidArgumentError('invalid host header')\n    }\n    // Consumed by Client\n    request.host = val\n  } else if (request.contentLength === null && headerName === 'content-length') {\n    request.contentLength = parseInt(val, 10)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (request.contentType === null && headerName === 'content-type') {\n    request.contentType = val\n    request.headers.push(key, val)\n  } else if (headerName === 'transfer-encoding' || headerName === 'keep-alive' || headerName === 'upgrade') {\n    throw new InvalidArgumentError(`invalid ${headerName} header`)\n  } else if (headerName === 'connection') {\n    const value = typeof val === 'string' ? val.toLowerCase() : null\n    if (value !== 'close' && value !== 'keep-alive') {\n      throw new InvalidArgumentError('invalid connection header')\n    }\n\n    if (value === 'close') {\n      request.reset = true\n    }\n  } else if (headerName === 'expect') {\n    throw new NotSupportedError('expect header not supported')\n  } else {\n    request.headers.push(key, val)\n  }\n}\n\nmodule.exports = Request\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3JlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsZ0VBQVU7QUFDdEIsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNERBQVE7QUFDcEIsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyw2RUFBa0I7QUFDL0MsUUFBUSw2QkFBNkIsRUFBRSxtQkFBTyxDQUFDLHNFQUFhOztBQUU1RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsZ0NBQWdDLGVBQWU7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLGVBQWU7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsMkJBQTJCLG1DQUFtQztBQUMvRjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLGtEQUFrRCxLQUFLO0FBQ3ZELFFBQVE7QUFDUixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnREFBZ0QsS0FBSztBQUNyRDtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixhQUFhLElBQUk7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osOENBQThDLFlBQVk7QUFDMUQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcY29yZVxccmVxdWVzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgTm90U3VwcG9ydGVkRXJyb3Jcbn0gPSByZXF1aXJlKCcuL2Vycm9ycycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7XG4gIGlzVmFsaWRIVFRQVG9rZW4sXG4gIGlzVmFsaWRIZWFkZXJWYWx1ZSxcbiAgaXNTdHJlYW0sXG4gIGRlc3Ryb3ksXG4gIGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhTGlrZSxcbiAgaXNJdGVyYWJsZSxcbiAgaXNCbG9iTGlrZSxcbiAgYnVpbGRVUkwsXG4gIHZhbGlkYXRlSGFuZGxlcixcbiAgZ2V0U2VydmVyTmFtZSxcbiAgbm9ybWFsaXplZE1ldGhvZFJlY29yZHNcbn0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBjaGFubmVscyB9ID0gcmVxdWlyZSgnLi9kaWFnbm9zdGljcy5qcycpXG5jb25zdCB7IGhlYWRlck5hbWVMb3dlckNhc2VkUmVjb3JkIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbi8vIFZlcmlmaWVzIHRoYXQgYSBnaXZlbiBwYXRoIGlzIHZhbGlkIGRvZXMgbm90IGNvbnRhaW4gY29udHJvbCBjaGFycyBcXHgwMCB0byBcXHgyMFxuY29uc3QgaW52YWxpZFBhdGhSZWdleCA9IC9bXlxcdTAwMjEtXFx1MDBmZl0vXG5cbmNvbnN0IGtIYW5kbGVyID0gU3ltYm9sKCdoYW5kbGVyJylcblxuY2xhc3MgUmVxdWVzdCB7XG4gIGNvbnN0cnVjdG9yIChvcmlnaW4sIHtcbiAgICBwYXRoLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcXVlcnksXG4gICAgaWRlbXBvdGVudCxcbiAgICBibG9ja2luZyxcbiAgICB1cGdyYWRlLFxuICAgIGhlYWRlcnNUaW1lb3V0LFxuICAgIGJvZHlUaW1lb3V0LFxuICAgIHJlc2V0LFxuICAgIHRocm93T25FcnJvcixcbiAgICBleHBlY3RDb250aW51ZSxcbiAgICBzZXJ2ZXJuYW1lXG4gIH0sIGhhbmRsZXIpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3BhdGggbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHBhdGhbMF0gIT09ICcvJyAmJlxuICAgICAgIShwYXRoLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCBwYXRoLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpICYmXG4gICAgICBtZXRob2QgIT09ICdDT05ORUNUJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdwYXRoIG11c3QgYmUgYW4gYWJzb2x1dGUgVVJMIG9yIHN0YXJ0IHdpdGggYSBzbGFzaCcpXG4gICAgfSBlbHNlIGlmIChpbnZhbGlkUGF0aFJlZ2V4LnRlc3QocGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCByZXF1ZXN0IHBhdGgnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtZXRob2QgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkTWV0aG9kUmVjb3Jkc1ttZXRob2RdID09PSB1bmRlZmluZWQgJiYgIWlzVmFsaWRIVFRQVG9rZW4obWV0aG9kKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlcXVlc3QgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSAmJiB0eXBlb2YgdXBncmFkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndXBncmFkZSBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG5cbiAgICBpZiAoaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShoZWFkZXJzVGltZW91dCkgfHwgaGVhZGVyc1RpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGhlYWRlcnNUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAoYm9keVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGJvZHlUaW1lb3V0JylcbiAgICB9XG5cbiAgICBpZiAocmVzZXQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzZXQgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHJlc2V0JylcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0Q29udGludWUgIT0gbnVsbCAmJiB0eXBlb2YgZXhwZWN0Q29udGludWUgIT09ICdib29sZWFuJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGV4cGVjdENvbnRpbnVlJylcbiAgICB9XG5cbiAgICB0aGlzLmhlYWRlcnNUaW1lb3V0ID0gaGVhZGVyc1RpbWVvdXRcblxuICAgIHRoaXMuYm9keVRpbWVvdXQgPSBib2R5VGltZW91dFxuXG4gICAgdGhpcy50aHJvd09uRXJyb3IgPSB0aHJvd09uRXJyb3IgPT09IHRydWVcblxuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kXG5cbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuXG4gICAgaWYgKGJvZHkgPT0gbnVsbCkge1xuICAgICAgdGhpcy5ib2R5ID0gbnVsbFxuICAgIH0gZWxzZSBpZiAoaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHlcblxuICAgICAgY29uc3QgclN0YXRlID0gdGhpcy5ib2R5Ll9yZWFkYWJsZVN0YXRlXG4gICAgICBpZiAoIXJTdGF0ZSB8fCAhclN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIHRoaXMuZW5kSGFuZGxlciA9IGZ1bmN0aW9uIGF1dG9EZXN0cm95ICgpIHtcbiAgICAgICAgICBkZXN0cm95KHRoaXMpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ib2R5Lm9uKCdlbmQnLCB0aGlzLmVuZEhhbmRsZXIpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gZXJyID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICB0aGlzLmFib3J0KGVycilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmVycm9yID0gZXJyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYm9keS5vbignZXJyb3InLCB0aGlzLmVycm9ySGFuZGxlcilcbiAgICB9IGVsc2UgaWYgKGlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ5dGVMZW5ndGggPyBib2R5IDogbnVsbFxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG4gICAgICB0aGlzLmJvZHkgPSBib2R5LmJ1ZmZlci5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keS5idWZmZXIsIGJvZHkuYnl0ZU9mZnNldCwgYm9keS5ieXRlTGVuZ3RoKSA6IG51bGxcbiAgICB9IGVsc2UgaWYgKGJvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdGhpcy5ib2R5ID0gYm9keS5ieXRlTGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHkubGVuZ3RoID8gQnVmZmVyLmZyb20oYm9keSkgOiBudWxsXG4gICAgfSBlbHNlIGlmIChpc0Zvcm1EYXRhTGlrZShib2R5KSB8fCBpc0l0ZXJhYmxlKGJvZHkpIHx8IGlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICAgIHRoaXMuYm9keSA9IGJvZHlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdib2R5IG11c3QgYmUgYSBzdHJpbmcsIGEgQnVmZmVyLCBhIFJlYWRhYmxlIHN0cmVhbSwgYW4gaXRlcmFibGUsIG9yIGFuIGFzeW5jIGl0ZXJhYmxlJylcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBsZXRlZCA9IGZhbHNlXG5cbiAgICB0aGlzLmFib3J0ZWQgPSBmYWxzZVxuXG4gICAgdGhpcy51cGdyYWRlID0gdXBncmFkZSB8fCBudWxsXG5cbiAgICB0aGlzLnBhdGggPSBxdWVyeSA/IGJ1aWxkVVJMKHBhdGgsIHF1ZXJ5KSA6IHBhdGhcblxuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luXG5cbiAgICB0aGlzLmlkZW1wb3RlbnQgPSBpZGVtcG90ZW50ID09IG51bGxcbiAgICAgID8gbWV0aG9kID09PSAnSEVBRCcgfHwgbWV0aG9kID09PSAnR0VUJ1xuICAgICAgOiBpZGVtcG90ZW50XG5cbiAgICB0aGlzLmJsb2NraW5nID0gYmxvY2tpbmcgPT0gbnVsbCA/IGZhbHNlIDogYmxvY2tpbmdcblxuICAgIHRoaXMucmVzZXQgPSByZXNldCA9PSBudWxsID8gbnVsbCA6IHJlc2V0XG5cbiAgICB0aGlzLmhvc3QgPSBudWxsXG5cbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSBudWxsXG5cbiAgICB0aGlzLmNvbnRlbnRUeXBlID0gbnVsbFxuXG4gICAgdGhpcy5oZWFkZXJzID0gW11cblxuICAgIC8vIE9ubHkgZm9yIEgyXG4gICAgdGhpcy5leHBlY3RDb250aW51ZSA9IGV4cGVjdENvbnRpbnVlICE9IG51bGwgPyBleHBlY3RDb250aW51ZSA6IGZhbHNlXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaWYgKGhlYWRlcnMubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnMgYXJyYXkgbXVzdCBiZSBldmVuJylcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGhlYWRlcnNbaV0sIGhlYWRlcnNbaSArIDFdKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGVhZGVycyAmJiB0eXBlb2YgaGVhZGVycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChoZWFkZXJzW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVycykge1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZWFkZXIpIHx8IGhlYWRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBtdXN0IGJlIGluIGtleS12YWx1ZSBwYWlyIGZvcm1hdCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHByb2Nlc3NIZWFkZXIodGhpcywgaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGtleXNbaV0sIGhlYWRlcnNba2V5c1tpXV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5JylcbiAgICB9XG5cbiAgICB2YWxpZGF0ZUhhbmRsZXIoaGFuZGxlciwgbWV0aG9kLCB1cGdyYWRlKVxuXG4gICAgdGhpcy5zZXJ2ZXJuYW1lID0gc2VydmVybmFtZSB8fCBnZXRTZXJ2ZXJOYW1lKHRoaXMuaG9zdClcblxuICAgIHRoaXNba0hhbmRsZXJdID0gaGFuZGxlclxuXG4gICAgaWYgKGNoYW5uZWxzLmNyZWF0ZS5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuY3JlYXRlLnB1Ymxpc2goeyByZXF1ZXN0OiB0aGlzIH0pXG4gICAgfVxuICB9XG5cbiAgb25Cb2R5U2VudCAoY2h1bmspIHtcbiAgICBpZiAodGhpc1trSGFuZGxlcl0ub25Cb2R5U2VudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQm9keVNlbnQoY2h1bmspXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25SZXF1ZXN0U2VudCAoKSB7XG4gICAgaWYgKGNoYW5uZWxzLmJvZHlTZW50Lmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5ib2R5U2VudC5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcyB9KVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tIYW5kbGVyXS5vblJlcXVlc3RTZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25SZXF1ZXN0U2VudCgpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgYWJvcnQodGhpcy5lcnJvcilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hYm9ydCA9IGFib3J0XG4gICAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25Db25uZWN0KGFib3J0KVxuICAgIH1cbiAgfVxuXG4gIG9uUmVzcG9uc2VTdGFydGVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trSGFuZGxlcl0ub25SZXNwb25zZVN0YXJ0ZWQ/LigpXG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICBpZiAoY2hhbm5lbHMuaGVhZGVycy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgY2hhbm5lbHMuaGVhZGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZSwgaGVhZGVycywgc3RhdHVzVGV4dCB9IH0pXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzW2tIYW5kbGVyXS5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5hYm9ydChlcnIpXG4gICAgfVxuICB9XG5cbiAgb25EYXRhIChjaHVuaykge1xuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuICAgIGFzc2VydCghdGhpcy5jb21wbGV0ZWQpXG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uRGF0YShjaHVuaylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRoaXMuYWJvcnQoZXJyKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBhc3NlcnQoIXRoaXMuYWJvcnRlZClcbiAgICBhc3NlcnQoIXRoaXMuY29tcGxldGVkKVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIHRoaXMub25GaW5hbGx5KClcblxuICAgIGFzc2VydCghdGhpcy5hYm9ydGVkKVxuXG4gICAgdGhpcy5jb21wbGV0ZWQgPSB0cnVlXG4gICAgaWYgKGNoYW5uZWxzLnRyYWlsZXJzLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy50cmFpbGVycy5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgdHJhaWxlcnMgfSlcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uQ29tcGxldGUodHJhaWxlcnMpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBUT0RPIChmaXgpOiBUaGlzIG1pZ2h0IGJlIGEgYmFkIGlkZWE/XG4gICAgICB0aGlzLm9uRXJyb3IoZXJyKVxuICAgIH1cbiAgfVxuXG4gIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgdGhpcy5vbkZpbmFsbHkoKVxuXG4gICAgaWYgKGNoYW5uZWxzLmVycm9yLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5lcnJvci5wdWJsaXNoKHsgcmVxdWVzdDogdGhpcywgZXJyb3IgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hYm9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5hYm9ydGVkID0gdHJ1ZVxuXG4gICAgcmV0dXJuIHRoaXNba0hhbmRsZXJdLm9uRXJyb3IoZXJyb3IpXG4gIH1cblxuICBvbkZpbmFsbHkgKCkge1xuICAgIGlmICh0aGlzLmVycm9ySGFuZGxlcikge1xuICAgICAgdGhpcy5ib2R5Lm9mZignZXJyb3InLCB0aGlzLmVycm9ySGFuZGxlcilcbiAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh0aGlzLmVuZEhhbmRsZXIpIHtcbiAgICAgIHRoaXMuYm9keS5vZmYoJ2VuZCcsIHRoaXMuZW5kSGFuZGxlcilcbiAgICAgIHRoaXMuZW5kSGFuZGxlciA9IG51bGxcbiAgICB9XG4gIH1cblxuICBhZGRIZWFkZXIgKGtleSwgdmFsdWUpIHtcbiAgICBwcm9jZXNzSGVhZGVyKHRoaXMsIGtleSwgdmFsdWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzSGVhZGVyIChyZXF1ZXN0LCBrZXksIHZhbCkge1xuICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWwpKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcihgaW52YWxpZCAke2tleX0gaGVhZGVyYClcbiAgfSBlbHNlIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGhlYWRlck5hbWUgPSBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFtrZXldXG5cbiAgaWYgKGhlYWRlck5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIGhlYWRlck5hbWUgPSBrZXkudG9Mb3dlckNhc2UoKVxuICAgIGlmIChoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFtoZWFkZXJOYW1lXSA9PT0gdW5kZWZpbmVkICYmICFpc1ZhbGlkSFRUUFRva2VuKGhlYWRlck5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaGVhZGVyIGtleScpXG4gICAgfVxuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGNvbnN0IGFyciA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsW2ldID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWxbaV0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7a2V5fSBoZWFkZXJgKVxuICAgICAgICB9XG4gICAgICAgIGFyci5wdXNoKHZhbFtpXSlcbiAgICAgIH0gZWxzZSBpZiAodmFsW2ldID09PSBudWxsKSB7XG4gICAgICAgIGFyci5wdXNoKCcnKVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnIucHVzaChgJHt2YWxbaV19YClcbiAgICAgIH1cbiAgICB9XG4gICAgdmFsID0gYXJyXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWwpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoYGludmFsaWQgJHtrZXl9IGhlYWRlcmApXG4gICAgfVxuICB9IGVsc2UgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHZhbCA9ICcnXG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYCR7dmFsfWBcbiAgfVxuXG4gIGlmIChyZXF1ZXN0Lmhvc3QgPT09IG51bGwgJiYgaGVhZGVyTmFtZSA9PT0gJ2hvc3QnKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgaG9zdCBoZWFkZXInKVxuICAgIH1cbiAgICAvLyBDb25zdW1lZCBieSBDbGllbnRcbiAgICByZXF1ZXN0Lmhvc3QgPSB2YWxcbiAgfSBlbHNlIGlmIChyZXF1ZXN0LmNvbnRlbnRMZW5ndGggPT09IG51bGwgJiYgaGVhZGVyTmFtZSA9PT0gJ2NvbnRlbnQtbGVuZ3RoJykge1xuICAgIHJlcXVlc3QuY29udGVudExlbmd0aCA9IHBhcnNlSW50KHZhbCwgMTApXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUocmVxdWVzdC5jb250ZW50TGVuZ3RoKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIGNvbnRlbnQtbGVuZ3RoIGhlYWRlcicpXG4gICAgfVxuICB9IGVsc2UgaWYgKHJlcXVlc3QuY29udGVudFR5cGUgPT09IG51bGwgJiYgaGVhZGVyTmFtZSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICByZXF1ZXN0LmNvbnRlbnRUeXBlID0gdmFsXG4gICAgcmVxdWVzdC5oZWFkZXJzLnB1c2goa2V5LCB2YWwpXG4gIH0gZWxzZSBpZiAoaGVhZGVyTmFtZSA9PT0gJ3RyYW5zZmVyLWVuY29kaW5nJyB8fCBoZWFkZXJOYW1lID09PSAna2VlcC1hbGl2ZScgfHwgaGVhZGVyTmFtZSA9PT0gJ3VwZ3JhZGUnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKGBpbnZhbGlkICR7aGVhZGVyTmFtZX0gaGVhZGVyYClcbiAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAnY29ubmVjdGlvbicpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gdmFsLnRvTG93ZXJDYXNlKCkgOiBudWxsXG4gICAgaWYgKHZhbHVlICE9PSAnY2xvc2UnICYmIHZhbHVlICE9PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0aW9uIGhlYWRlcicpXG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSAnY2xvc2UnKSB7XG4gICAgICByZXF1ZXN0LnJlc2V0ID0gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIGlmIChoZWFkZXJOYW1lID09PSAnZXhwZWN0Jykge1xuICAgIHRocm93IG5ldyBOb3RTdXBwb3J0ZWRFcnJvcignZXhwZWN0IGhlYWRlciBub3Qgc3VwcG9ydGVkJylcbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LmhlYWRlcnMucHVzaChrZXksIHZhbClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/symbols.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/core/symbols.js ***!
  \*************************************************/
/***/ ((module) => {

eval("module.exports = {\n  kClose: Symbol('close'),\n  kDestroy: Symbol('destroy'),\n  kDispatch: Symbol('dispatch'),\n  kUrl: Symbol('url'),\n  kWriting: Symbol('writing'),\n  kResuming: Symbol('resuming'),\n  kQueue: Symbol('queue'),\n  kConnect: Symbol('connect'),\n  kConnecting: Symbol('connecting'),\n  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),\n  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),\n  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),\n  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),\n  kKeepAlive: Symbol('keep alive'),\n  kHeadersTimeout: Symbol('headers timeout'),\n  kBodyTimeout: Symbol('body timeout'),\n  kServerName: Symbol('server name'),\n  kLocalAddress: Symbol('local address'),\n  kHost: Symbol('host'),\n  kNoRef: Symbol('no ref'),\n  kBodyUsed: Symbol('used'),\n  kBody: Symbol('abstracted request body'),\n  kRunning: Symbol('running'),\n  kBlocking: Symbol('blocking'),\n  kPending: Symbol('pending'),\n  kSize: Symbol('size'),\n  kBusy: Symbol('busy'),\n  kQueued: Symbol('queued'),\n  kFree: Symbol('free'),\n  kConnected: Symbol('connected'),\n  kClosed: Symbol('closed'),\n  kNeedDrain: Symbol('need drain'),\n  kReset: Symbol('reset'),\n  kDestroyed: Symbol.for('nodejs.stream.destroyed'),\n  kResume: Symbol('resume'),\n  kOnError: Symbol('on error'),\n  kMaxHeadersSize: Symbol('max headers size'),\n  kRunningIdx: Symbol('running index'),\n  kPendingIdx: Symbol('pending index'),\n  kError: Symbol('error'),\n  kClients: Symbol('clients'),\n  kClient: Symbol('client'),\n  kParser: Symbol('parser'),\n  kOnDestroyed: Symbol('destroy callbacks'),\n  kPipelining: Symbol('pipelining'),\n  kSocket: Symbol('socket'),\n  kHostHeader: Symbol('host header'),\n  kConnector: Symbol('connector'),\n  kStrictContentLength: Symbol('strict content length'),\n  kMaxRedirections: Symbol('maxRedirections'),\n  kMaxRequests: Symbol('maxRequestsPerClient'),\n  kProxy: Symbol('proxy agent options'),\n  kCounter: Symbol('socket request counter'),\n  kInterceptors: Symbol('dispatch interceptors'),\n  kMaxResponseSize: Symbol('max response size'),\n  kHTTP2Session: Symbol('http2Session'),\n  kHTTP2SessionState: Symbol('http2Session state'),\n  kRetryHandlerDefaultRetry: Symbol('retry agent default retry'),\n  kConstruct: Symbol('constructable'),\n  kListeners: Symbol('listeners'),\n  kHTTPContext: Symbol('http context'),\n  kMaxConcurrentStreams: Symbol('max concurrent streams'),\n  kNoProxyAgent: Symbol('no proxy agent'),\n  kHttpProxyAgent: Symbol('http proxy agent'),\n  kHttpsProxyAgent: Symbol('https proxy agent')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcY29yZVxcc3ltYm9scy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcbiAga0Nsb3NlOiBTeW1ib2woJ2Nsb3NlJyksXG4gIGtEZXN0cm95OiBTeW1ib2woJ2Rlc3Ryb3knKSxcbiAga0Rpc3BhdGNoOiBTeW1ib2woJ2Rpc3BhdGNoJyksXG4gIGtVcmw6IFN5bWJvbCgndXJsJyksXG4gIGtXcml0aW5nOiBTeW1ib2woJ3dyaXRpbmcnKSxcbiAga1Jlc3VtaW5nOiBTeW1ib2woJ3Jlc3VtaW5nJyksXG4gIGtRdWV1ZTogU3ltYm9sKCdxdWV1ZScpLFxuICBrQ29ubmVjdDogU3ltYm9sKCdjb25uZWN0JyksXG4gIGtDb25uZWN0aW5nOiBTeW1ib2woJ2Nvbm5lY3RpbmcnKSxcbiAga0tlZXBBbGl2ZURlZmF1bHRUaW1lb3V0OiBTeW1ib2woJ2RlZmF1bHQga2VlcCBhbGl2ZSB0aW1lb3V0JyksXG4gIGtLZWVwQWxpdmVNYXhUaW1lb3V0OiBTeW1ib2woJ21heCBrZWVwIGFsaXZlIHRpbWVvdXQnKSxcbiAga0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQ6IFN5bWJvbCgna2VlcCBhbGl2ZSB0aW1lb3V0IHRocmVzaG9sZCcpLFxuICBrS2VlcEFsaXZlVGltZW91dFZhbHVlOiBTeW1ib2woJ2tlZXAgYWxpdmUgdGltZW91dCcpLFxuICBrS2VlcEFsaXZlOiBTeW1ib2woJ2tlZXAgYWxpdmUnKSxcbiAga0hlYWRlcnNUaW1lb3V0OiBTeW1ib2woJ2hlYWRlcnMgdGltZW91dCcpLFxuICBrQm9keVRpbWVvdXQ6IFN5bWJvbCgnYm9keSB0aW1lb3V0JyksXG4gIGtTZXJ2ZXJOYW1lOiBTeW1ib2woJ3NlcnZlciBuYW1lJyksXG4gIGtMb2NhbEFkZHJlc3M6IFN5bWJvbCgnbG9jYWwgYWRkcmVzcycpLFxuICBrSG9zdDogU3ltYm9sKCdob3N0JyksXG4gIGtOb1JlZjogU3ltYm9sKCdubyByZWYnKSxcbiAga0JvZHlVc2VkOiBTeW1ib2woJ3VzZWQnKSxcbiAga0JvZHk6IFN5bWJvbCgnYWJzdHJhY3RlZCByZXF1ZXN0IGJvZHknKSxcbiAga1J1bm5pbmc6IFN5bWJvbCgncnVubmluZycpLFxuICBrQmxvY2tpbmc6IFN5bWJvbCgnYmxvY2tpbmcnKSxcbiAga1BlbmRpbmc6IFN5bWJvbCgncGVuZGluZycpLFxuICBrU2l6ZTogU3ltYm9sKCdzaXplJyksXG4gIGtCdXN5OiBTeW1ib2woJ2J1c3knKSxcbiAga1F1ZXVlZDogU3ltYm9sKCdxdWV1ZWQnKSxcbiAga0ZyZWU6IFN5bWJvbCgnZnJlZScpLFxuICBrQ29ubmVjdGVkOiBTeW1ib2woJ2Nvbm5lY3RlZCcpLFxuICBrQ2xvc2VkOiBTeW1ib2woJ2Nsb3NlZCcpLFxuICBrTmVlZERyYWluOiBTeW1ib2woJ25lZWQgZHJhaW4nKSxcbiAga1Jlc2V0OiBTeW1ib2woJ3Jlc2V0JyksXG4gIGtEZXN0cm95ZWQ6IFN5bWJvbC5mb3IoJ25vZGVqcy5zdHJlYW0uZGVzdHJveWVkJyksXG4gIGtSZXN1bWU6IFN5bWJvbCgncmVzdW1lJyksXG4gIGtPbkVycm9yOiBTeW1ib2woJ29uIGVycm9yJyksXG4gIGtNYXhIZWFkZXJzU2l6ZTogU3ltYm9sKCdtYXggaGVhZGVycyBzaXplJyksXG4gIGtSdW5uaW5nSWR4OiBTeW1ib2woJ3J1bm5pbmcgaW5kZXgnKSxcbiAga1BlbmRpbmdJZHg6IFN5bWJvbCgncGVuZGluZyBpbmRleCcpLFxuICBrRXJyb3I6IFN5bWJvbCgnZXJyb3InKSxcbiAga0NsaWVudHM6IFN5bWJvbCgnY2xpZW50cycpLFxuICBrQ2xpZW50OiBTeW1ib2woJ2NsaWVudCcpLFxuICBrUGFyc2VyOiBTeW1ib2woJ3BhcnNlcicpLFxuICBrT25EZXN0cm95ZWQ6IFN5bWJvbCgnZGVzdHJveSBjYWxsYmFja3MnKSxcbiAga1BpcGVsaW5pbmc6IFN5bWJvbCgncGlwZWxpbmluZycpLFxuICBrU29ja2V0OiBTeW1ib2woJ3NvY2tldCcpLFxuICBrSG9zdEhlYWRlcjogU3ltYm9sKCdob3N0IGhlYWRlcicpLFxuICBrQ29ubmVjdG9yOiBTeW1ib2woJ2Nvbm5lY3RvcicpLFxuICBrU3RyaWN0Q29udGVudExlbmd0aDogU3ltYm9sKCdzdHJpY3QgY29udGVudCBsZW5ndGgnKSxcbiAga01heFJlZGlyZWN0aW9uczogU3ltYm9sKCdtYXhSZWRpcmVjdGlvbnMnKSxcbiAga01heFJlcXVlc3RzOiBTeW1ib2woJ21heFJlcXVlc3RzUGVyQ2xpZW50JyksXG4gIGtQcm94eTogU3ltYm9sKCdwcm94eSBhZ2VudCBvcHRpb25zJyksXG4gIGtDb3VudGVyOiBTeW1ib2woJ3NvY2tldCByZXF1ZXN0IGNvdW50ZXInKSxcbiAga0ludGVyY2VwdG9yczogU3ltYm9sKCdkaXNwYXRjaCBpbnRlcmNlcHRvcnMnKSxcbiAga01heFJlc3BvbnNlU2l6ZTogU3ltYm9sKCdtYXggcmVzcG9uc2Ugc2l6ZScpLFxuICBrSFRUUDJTZXNzaW9uOiBTeW1ib2woJ2h0dHAyU2Vzc2lvbicpLFxuICBrSFRUUDJTZXNzaW9uU3RhdGU6IFN5bWJvbCgnaHR0cDJTZXNzaW9uIHN0YXRlJyksXG4gIGtSZXRyeUhhbmRsZXJEZWZhdWx0UmV0cnk6IFN5bWJvbCgncmV0cnkgYWdlbnQgZGVmYXVsdCByZXRyeScpLFxuICBrQ29uc3RydWN0OiBTeW1ib2woJ2NvbnN0cnVjdGFibGUnKSxcbiAga0xpc3RlbmVyczogU3ltYm9sKCdsaXN0ZW5lcnMnKSxcbiAga0hUVFBDb250ZXh0OiBTeW1ib2woJ2h0dHAgY29udGV4dCcpLFxuICBrTWF4Q29uY3VycmVudFN0cmVhbXM6IFN5bWJvbCgnbWF4IGNvbmN1cnJlbnQgc3RyZWFtcycpLFxuICBrTm9Qcm94eUFnZW50OiBTeW1ib2woJ25vIHByb3h5IGFnZW50JyksXG4gIGtIdHRwUHJveHlBZ2VudDogU3ltYm9sKCdodHRwIHByb3h5IGFnZW50JyksXG4gIGtIdHRwc1Byb3h5QWdlbnQ6IFN5bWJvbCgnaHR0cHMgcHJveHkgYWdlbnQnKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/tree.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/tree.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  wellknownHeaderNames,\n  headerNameLowerCasedRecord\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/core/constants.js\")\n\nclass TstNode {\n  /** @type {any} */\n  value = null\n  /** @type {null | TstNode} */\n  left = null\n  /** @type {null | TstNode} */\n  middle = null\n  /** @type {null | TstNode} */\n  right = null\n  /** @type {number} */\n  code\n  /**\n   * @param {string} key\n   * @param {any} value\n   * @param {number} index\n   */\n  constructor (key, value, index) {\n    if (index === undefined || index >= key.length) {\n      throw new TypeError('Unreachable')\n    }\n    const code = this.code = key.charCodeAt(index)\n    // check code is ascii string\n    if (code > 0x7F) {\n      throw new TypeError('key must be ascii string')\n    }\n    if (key.length !== ++index) {\n      this.middle = new TstNode(key, value, index)\n    } else {\n      this.value = value\n    }\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   */\n  add (key, value) {\n    const length = key.length\n    if (length === 0) {\n      throw new TypeError('Unreachable')\n    }\n    let index = 0\n    let node = this\n    while (true) {\n      const code = key.charCodeAt(index)\n      // check code is ascii string\n      if (code > 0x7F) {\n        throw new TypeError('key must be ascii string')\n      }\n      if (node.code === code) {\n        if (length === ++index) {\n          node.value = value\n          break\n        } else if (node.middle !== null) {\n          node = node.middle\n        } else {\n          node.middle = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.code < code) {\n        if (node.left !== null) {\n          node = node.left\n        } else {\n          node.left = new TstNode(key, value, index)\n          break\n        }\n      } else if (node.right !== null) {\n        node = node.right\n      } else {\n        node.right = new TstNode(key, value, index)\n        break\n      }\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @return {TstNode | null}\n   */\n  search (key) {\n    const keylength = key.length\n    let index = 0\n    let node = this\n    while (node !== null && index < keylength) {\n      let code = key[index]\n      // A-Z\n      // First check if it is bigger than 0x5a.\n      // Lowercase letters have higher char codes than uppercase ones.\n      // Also we assume that headers will mostly contain lowercase characters.\n      if (code <= 0x5a && code >= 0x41) {\n        // Lowercase for uppercase.\n        code |= 32\n      }\n      while (node !== null) {\n        if (code === node.code) {\n          if (keylength === ++index) {\n            // Returns Node since it is the last key.\n            return node\n          }\n          node = node.middle\n          break\n        }\n        node = node.code < code ? node.left : node.right\n      }\n    }\n    return null\n  }\n}\n\nclass TernarySearchTree {\n  /** @type {TstNode | null} */\n  node = null\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   * */\n  insert (key, value) {\n    if (this.node === null) {\n      this.node = new TstNode(key, value, 0)\n    } else {\n      this.node.add(key, value)\n    }\n  }\n\n  /**\n   * @param {Uint8Array} key\n   * @return {any}\n   */\n  lookup (key) {\n    return this.node?.search(key)?.value ?? null\n  }\n}\n\nconst tree = new TernarySearchTree()\n\nfor (let i = 0; i < wellknownHeaderNames.length; ++i) {\n  const key = headerNameLowerCasedRecord[wellknownHeaderNames[i]]\n  tree.insert(key, key)\n}\n\nmodule.exports = {\n  TernarySearchTree,\n  tree\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3RyZWUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0VBQWE7O0FBRXpCO0FBQ0EsYUFBYSxLQUFLO0FBQ2xCO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxLQUFLO0FBQ2xCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLGlDQUFpQztBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcY29yZVxcdHJlZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICB3ZWxsa25vd25IZWFkZXJOYW1lcyxcbiAgaGVhZGVyTmFtZUxvd2VyQ2FzZWRSZWNvcmRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmNsYXNzIFRzdE5vZGUge1xuICAvKiogQHR5cGUge2FueX0gKi9cbiAgdmFsdWUgPSBudWxsXG4gIC8qKiBAdHlwZSB7bnVsbCB8IFRzdE5vZGV9ICovXG4gIGxlZnQgPSBudWxsXG4gIC8qKiBAdHlwZSB7bnVsbCB8IFRzdE5vZGV9ICovXG4gIG1pZGRsZSA9IG51bGxcbiAgLyoqIEB0eXBlIHtudWxsIHwgVHN0Tm9kZX0gKi9cbiAgcmlnaHQgPSBudWxsXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICBjb2RlXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICovXG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID49IGtleS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVhY2hhYmxlJylcbiAgICB9XG4gICAgY29uc3QgY29kZSA9IHRoaXMuY29kZSA9IGtleS5jaGFyQ29kZUF0KGluZGV4KVxuICAgIC8vIGNoZWNrIGNvZGUgaXMgYXNjaWkgc3RyaW5nXG4gICAgaWYgKGNvZGUgPiAweDdGKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZXkgbXVzdCBiZSBhc2NpaSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAoa2V5Lmxlbmd0aCAhPT0gKytpbmRleCkge1xuICAgICAgdGhpcy5taWRkbGUgPSBuZXcgVHN0Tm9kZShrZXksIHZhbHVlLCBpbmRleClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IHZhbHVlXG4gICAqL1xuICBhZGQgKGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBsZW5ndGggPSBrZXkubGVuZ3RoXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5yZWFjaGFibGUnKVxuICAgIH1cbiAgICBsZXQgaW5kZXggPSAwXG4gICAgbGV0IG5vZGUgPSB0aGlzXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBrZXkuY2hhckNvZGVBdChpbmRleClcbiAgICAgIC8vIGNoZWNrIGNvZGUgaXMgYXNjaWkgc3RyaW5nXG4gICAgICBpZiAoY29kZSA+IDB4N0YpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5IG11c3QgYmUgYXNjaWkgc3RyaW5nJylcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmNvZGUgPT09IGNvZGUpIHtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gKytpbmRleCkge1xuICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5taWRkbGUgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlID0gbm9kZS5taWRkbGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLm1pZGRsZSA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jb2RlIDwgY29kZSkge1xuICAgICAgICBpZiAobm9kZS5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZSA9IG5vZGUubGVmdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUubGVmdCA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbm9kZS5yaWdodFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yaWdodCA9IG5ldyBUc3ROb2RlKGtleSwgdmFsdWUsIGluZGV4KVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGtleVxuICAgKiBAcmV0dXJuIHtUc3ROb2RlIHwgbnVsbH1cbiAgICovXG4gIHNlYXJjaCAoa2V5KSB7XG4gICAgY29uc3Qga2V5bGVuZ3RoID0ga2V5Lmxlbmd0aFxuICAgIGxldCBpbmRleCA9IDBcbiAgICBsZXQgbm9kZSA9IHRoaXNcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBpbmRleCA8IGtleWxlbmd0aCkge1xuICAgICAgbGV0IGNvZGUgPSBrZXlbaW5kZXhdXG4gICAgICAvLyBBLVpcbiAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIGl0IGlzIGJpZ2dlciB0aGFuIDB4NWEuXG4gICAgICAvLyBMb3dlcmNhc2UgbGV0dGVycyBoYXZlIGhpZ2hlciBjaGFyIGNvZGVzIHRoYW4gdXBwZXJjYXNlIG9uZXMuXG4gICAgICAvLyBBbHNvIHdlIGFzc3VtZSB0aGF0IGhlYWRlcnMgd2lsbCBtb3N0bHkgY29udGFpbiBsb3dlcmNhc2UgY2hhcmFjdGVycy5cbiAgICAgIGlmIChjb2RlIDw9IDB4NWEgJiYgY29kZSA+PSAweDQxKSB7XG4gICAgICAgIC8vIExvd2VyY2FzZSBmb3IgdXBwZXJjYXNlLlxuICAgICAgICBjb2RlIHw9IDMyXG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoY29kZSA9PT0gbm9kZS5jb2RlKSB7XG4gICAgICAgICAgaWYgKGtleWxlbmd0aCA9PT0gKytpbmRleCkge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBOb2RlIHNpbmNlIGl0IGlzIHRoZSBsYXN0IGtleS5cbiAgICAgICAgICAgIHJldHVybiBub2RlXG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLm1pZGRsZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUuY29kZSA8IGNvZGUgPyBub2RlLmxlZnQgOiBub2RlLnJpZ2h0XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuY2xhc3MgVGVybmFyeVNlYXJjaFRyZWUge1xuICAvKiogQHR5cGUge1RzdE5vZGUgfCBudWxsfSAqL1xuICBub2RlID0gbnVsbFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKiAqL1xuICBpbnNlcnQgKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5ub2RlID09PSBudWxsKSB7XG4gICAgICB0aGlzLm5vZGUgPSBuZXcgVHN0Tm9kZShrZXksIHZhbHVlLCAwKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vZGUuYWRkKGtleSwgdmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0ga2V5XG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGxvb2t1cCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZT8uc2VhcmNoKGtleSk/LnZhbHVlID8/IG51bGxcbiAgfVxufVxuXG5jb25zdCB0cmVlID0gbmV3IFRlcm5hcnlTZWFyY2hUcmVlKClcblxuZm9yIChsZXQgaSA9IDA7IGkgPCB3ZWxsa25vd25IZWFkZXJOYW1lcy5sZW5ndGg7ICsraSkge1xuICBjb25zdCBrZXkgPSBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFt3ZWxsa25vd25IZWFkZXJOYW1lc1tpXV1cbiAgdHJlZS5pbnNlcnQoa2V5LCBrZXkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBUZXJuYXJ5U2VhcmNoVHJlZSxcbiAgdHJlZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/tree.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/core/util.js":
/*!**********************************************!*\
  !*** ./node_modules/undici/lib/core/util.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { kDestroyed, kBodyUsed, kListeners, kBody } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { IncomingMessage } = __webpack_require__(/*! node:http */ \"node:http\")\nconst stream = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst { Blob } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\nconst { stringify } = __webpack_require__(/*! node:querystring */ \"node:querystring\")\nconst { EventEmitter: EE } = __webpack_require__(/*! node:events */ \"node:events\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { headerNameLowerCasedRecord } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/core/constants.js\")\nconst { tree } = __webpack_require__(/*! ./tree */ \"(rsc)/./node_modules/undici/lib/core/tree.js\")\n\nconst [nodeMajor, nodeMinor] = process.versions.node.split('.').map(v => Number(v))\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nfunction wrapRequestBody (body) {\n  if (isStream(body)) {\n    // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n    // so that it can be dispatched again?\n    // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n    if (bodyLength(body) === 0) {\n      body\n        .on('data', function () {\n          assert(false)\n        })\n    }\n\n    if (typeof body.readableDidRead !== 'boolean') {\n      body[kBodyUsed] = false\n      EE.prototype.on.call(body, 'data', function () {\n        this[kBodyUsed] = true\n      })\n    }\n\n    return body\n  } else if (body && typeof body.pipeTo === 'function') {\n    // TODO (fix): We can't access ReadableStream internal state\n    // to determine whether or not it has been disturbed. This is just\n    // a workaround.\n    return new BodyAsyncIterable(body)\n  } else if (\n    body &&\n    typeof body !== 'string' &&\n    !ArrayBuffer.isView(body) &&\n    isIterable(body)\n  ) {\n    // TODO: Should we allow re-using iterable if !this.opts.idempotent\n    // or through some other flag?\n    return new BodyAsyncIterable(body)\n  } else {\n    return body\n  }\n}\n\nfunction nop () {}\n\nfunction isStream (obj) {\n  return obj && typeof obj === 'object' && typeof obj.pipe === 'function' && typeof obj.on === 'function'\n}\n\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike (object) {\n  if (object === null) {\n    return false\n  } else if (object instanceof Blob) {\n    return true\n  } else if (typeof object !== 'object') {\n    return false\n  } else {\n    const sTag = object[Symbol.toStringTag]\n\n    return (sTag === 'Blob' || sTag === 'File') && (\n      ('stream' in object && typeof object.stream === 'function') ||\n      ('arrayBuffer' in object && typeof object.arrayBuffer === 'function')\n    )\n  }\n}\n\nfunction buildURL (url, queryParams) {\n  if (url.includes('?') || url.includes('#')) {\n    throw new Error('Query params cannot be passed when url already contains \"?\" or \"#\".')\n  }\n\n  const stringified = stringify(queryParams)\n\n  if (stringified) {\n    url += '?' + stringified\n  }\n\n  return url\n}\n\nfunction isValidPort (port) {\n  const value = parseInt(port, 10)\n  return (\n    value === Number(port) &&\n    value >= 0 &&\n    value <= 65535\n  )\n}\n\nfunction isHttpOrHttpsPrefixed (value) {\n  return (\n    value != null &&\n    value[0] === 'h' &&\n    value[1] === 't' &&\n    value[2] === 't' &&\n    value[3] === 'p' &&\n    (\n      value[4] === ':' ||\n      (\n        value[4] === 's' &&\n        value[5] === ':'\n      )\n    )\n  )\n}\n\nfunction parseURL (url) {\n  if (typeof url === 'string') {\n    url = new URL(url)\n\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    return url\n  }\n\n  if (!url || typeof url !== 'object') {\n    throw new InvalidArgumentError('Invalid URL: The URL argument must be a non-null object.')\n  }\n\n  if (!(url instanceof URL)) {\n    if (url.port != null && url.port !== '' && isValidPort(url.port) === false) {\n      throw new InvalidArgumentError('Invalid URL: port must be a valid integer or a string representation of an integer.')\n    }\n\n    if (url.path != null && typeof url.path !== 'string') {\n      throw new InvalidArgumentError('Invalid URL path: the path must be a string or null/undefined.')\n    }\n\n    if (url.pathname != null && typeof url.pathname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL pathname: the pathname must be a string or null/undefined.')\n    }\n\n    if (url.hostname != null && typeof url.hostname !== 'string') {\n      throw new InvalidArgumentError('Invalid URL hostname: the hostname must be a string or null/undefined.')\n    }\n\n    if (url.origin != null && typeof url.origin !== 'string') {\n      throw new InvalidArgumentError('Invalid URL origin: the origin must be a string or null/undefined.')\n    }\n\n    if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n      throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n    }\n\n    const port = url.port != null\n      ? url.port\n      : (url.protocol === 'https:' ? 443 : 80)\n    let origin = url.origin != null\n      ? url.origin\n      : `${url.protocol || ''}//${url.hostname || ''}:${port}`\n    let path = url.path != null\n      ? url.path\n      : `${url.pathname || ''}${url.search || ''}`\n\n    if (origin[origin.length - 1] === '/') {\n      origin = origin.slice(0, origin.length - 1)\n    }\n\n    if (path && path[0] !== '/') {\n      path = `/${path}`\n    }\n    // new URL(path, origin) is unsafe when `path` contains an absolute URL\n    // From https://developer.mozilla.org/en-US/docs/Web/API/URL/URL:\n    // If first parameter is a relative URL, second param is required, and will be used as the base URL.\n    // If first parameter is an absolute URL, a given second param will be ignored.\n    return new URL(`${origin}${path}`)\n  }\n\n  if (!isHttpOrHttpsPrefixed(url.origin || url.protocol)) {\n    throw new InvalidArgumentError('Invalid URL protocol: the URL must start with `http:` or `https:`.')\n  }\n\n  return url\n}\n\nfunction parseOrigin (url) {\n  url = parseURL(url)\n\n  if (url.pathname !== '/' || url.search || url.hash) {\n    throw new InvalidArgumentError('invalid url')\n  }\n\n  return url\n}\n\nfunction getHostname (host) {\n  if (host[0] === '[') {\n    const idx = host.indexOf(']')\n\n    assert(idx !== -1)\n    return host.substring(1, idx)\n  }\n\n  const idx = host.indexOf(':')\n  if (idx === -1) return host\n\n  return host.substring(0, idx)\n}\n\n// IP addresses are not valid server names per RFC6066\n// > Currently, the only server names supported are DNS hostnames\nfunction getServerName (host) {\n  if (!host) {\n    return null\n  }\n\n  assert(typeof host === 'string')\n\n  const servername = getHostname(host)\n  if (net.isIP(servername)) {\n    return ''\n  }\n\n  return servername\n}\n\nfunction deepClone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\nfunction isAsyncIterable (obj) {\n  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')\n}\n\nfunction isIterable (obj) {\n  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))\n}\n\nfunction bodyLength (body) {\n  if (body == null) {\n    return 0\n  } else if (isStream(body)) {\n    const state = body._readableState\n    return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length)\n      ? state.length\n      : null\n  } else if (isBlobLike(body)) {\n    return body.size != null ? body.size : null\n  } else if (isBuffer(body)) {\n    return body.byteLength\n  }\n\n  return null\n}\n\nfunction isDestroyed (body) {\n  return body && !!(body.destroyed || body[kDestroyed] || (stream.isDestroyed?.(body)))\n}\n\nfunction destroy (stream, err) {\n  if (stream == null || !isStream(stream) || isDestroyed(stream)) {\n    return\n  }\n\n  if (typeof stream.destroy === 'function') {\n    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n      // See: https://github.com/nodejs/node/pull/38505/files\n      stream.socket = null\n    }\n\n    stream.destroy(err)\n  } else if (err) {\n    queueMicrotask(() => {\n      stream.emit('error', err)\n    })\n  }\n\n  if (stream.destroyed !== true) {\n    stream[kDestroyed] = true\n  }\n}\n\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/\nfunction parseKeepAliveTimeout (val) {\n  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR)\n  return m ? parseInt(m[1], 10) * 1000 : null\n}\n\n/**\n * Retrieves a header name and returns its lowercase value.\n * @param {string | Buffer} value Header name\n * @returns {string}\n */\nfunction headerNameToString (value) {\n  return typeof value === 'string'\n    ? headerNameLowerCasedRecord[value] ?? value.toLowerCase()\n    : tree.lookup(value) ?? value.toString('latin1').toLowerCase()\n}\n\n/**\n * Receive the buffer as a string and return its lowercase value.\n * @param {Buffer} value Header name\n * @returns {string}\n */\nfunction bufferToLowerCasedHeaderName (value) {\n  return tree.lookup(value) ?? value.toString('latin1').toLowerCase()\n}\n\n/**\n * @param {Record<string, string | string[]> | (Buffer | string | (Buffer | string)[])[]} headers\n * @param {Record<string, string | string[]>} [obj]\n * @returns {Record<string, string | string[]>}\n */\nfunction parseHeaders (headers, obj) {\n  if (obj === undefined) obj = {}\n  for (let i = 0; i < headers.length; i += 2) {\n    const key = headerNameToString(headers[i])\n    let val = obj[key]\n\n    if (val) {\n      if (typeof val === 'string') {\n        val = [val]\n        obj[key] = val\n      }\n      val.push(headers[i + 1].toString('utf8'))\n    } else {\n      const headersValue = headers[i + 1]\n      if (typeof headersValue === 'string') {\n        obj[key] = headersValue\n      } else {\n        obj[key] = Array.isArray(headersValue) ? headersValue.map(x => x.toString('utf8')) : headersValue.toString('utf8')\n      }\n    }\n  }\n\n  // See https://github.com/nodejs/node/pull/46528\n  if ('content-length' in obj && 'content-disposition' in obj) {\n    obj['content-disposition'] = Buffer.from(obj['content-disposition']).toString('latin1')\n  }\n\n  return obj\n}\n\nfunction parseRawHeaders (headers) {\n  const len = headers.length\n  const ret = new Array(len)\n\n  let hasContentLength = false\n  let contentDispositionIdx = -1\n  let key\n  let val\n  let kLen = 0\n\n  for (let n = 0; n < headers.length; n += 2) {\n    key = headers[n]\n    val = headers[n + 1]\n\n    typeof key !== 'string' && (key = key.toString())\n    typeof val !== 'string' && (val = val.toString('utf8'))\n\n    kLen = key.length\n    if (kLen === 14 && key[7] === '-' && (key === 'content-length' || key.toLowerCase() === 'content-length')) {\n      hasContentLength = true\n    } else if (kLen === 19 && key[7] === '-' && (key === 'content-disposition' || key.toLowerCase() === 'content-disposition')) {\n      contentDispositionIdx = n + 1\n    }\n    ret[n] = key\n    ret[n + 1] = val\n  }\n\n  // See https://github.com/nodejs/node/pull/46528\n  if (hasContentLength && contentDispositionIdx !== -1) {\n    ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString('latin1')\n  }\n\n  return ret\n}\n\nfunction isBuffer (buffer) {\n  // See, https://github.com/mcollina/undici/pull/319\n  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)\n}\n\nfunction validateHandler (handler, method, upgrade) {\n  if (!handler || typeof handler !== 'object') {\n    throw new InvalidArgumentError('handler must be an object')\n  }\n\n  if (typeof handler.onConnect !== 'function') {\n    throw new InvalidArgumentError('invalid onConnect method')\n  }\n\n  if (typeof handler.onError !== 'function') {\n    throw new InvalidArgumentError('invalid onError method')\n  }\n\n  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {\n    throw new InvalidArgumentError('invalid onBodySent method')\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    if (typeof handler.onUpgrade !== 'function') {\n      throw new InvalidArgumentError('invalid onUpgrade method')\n    }\n  } else {\n    if (typeof handler.onHeaders !== 'function') {\n      throw new InvalidArgumentError('invalid onHeaders method')\n    }\n\n    if (typeof handler.onData !== 'function') {\n      throw new InvalidArgumentError('invalid onData method')\n    }\n\n    if (typeof handler.onComplete !== 'function') {\n      throw new InvalidArgumentError('invalid onComplete method')\n    }\n  }\n}\n\n// A body is disturbed if it has been read from and it cannot\n// be re-used without losing state or data.\nfunction isDisturbed (body) {\n  // TODO (fix): Why is body[kBodyUsed] needed?\n  return !!(body && (stream.isDisturbed(body) || body[kBodyUsed]))\n}\n\nfunction isErrored (body) {\n  return !!(body && stream.isErrored(body))\n}\n\nfunction isReadable (body) {\n  return !!(body && stream.isReadable(body))\n}\n\nfunction getSocketInfo (socket) {\n  return {\n    localAddress: socket.localAddress,\n    localPort: socket.localPort,\n    remoteAddress: socket.remoteAddress,\n    remotePort: socket.remotePort,\n    remoteFamily: socket.remoteFamily,\n    timeout: socket.timeout,\n    bytesWritten: socket.bytesWritten,\n    bytesRead: socket.bytesRead\n  }\n}\n\n/** @type {globalThis['ReadableStream']} */\nfunction ReadableStreamFrom (iterable) {\n  // We cannot use ReadableStream.from here because it does not return a byte stream.\n\n  let iterator\n  return new ReadableStream(\n    {\n      async start () {\n        iterator = iterable[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { done, value } = await iterator.next()\n        if (done) {\n          queueMicrotask(() => {\n            controller.close()\n            controller.byobRequest?.respond(0)\n          })\n        } else {\n          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)\n          if (buf.byteLength) {\n            controller.enqueue(new Uint8Array(buf))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: 'bytes'\n    }\n  )\n}\n\n// The chunk should be a FormData instance and contains\n// all the required methods.\nfunction isFormDataLike (object) {\n  return (\n    object &&\n    typeof object === 'object' &&\n    typeof object.append === 'function' &&\n    typeof object.delete === 'function' &&\n    typeof object.get === 'function' &&\n    typeof object.getAll === 'function' &&\n    typeof object.has === 'function' &&\n    typeof object.set === 'function' &&\n    object[Symbol.toStringTag] === 'FormData'\n  )\n}\n\nfunction addAbortListener (signal, listener) {\n  if ('addEventListener' in signal) {\n    signal.addEventListener('abort', listener, { once: true })\n    return () => signal.removeEventListener('abort', listener)\n  }\n  signal.addListener('abort', listener)\n  return () => signal.removeListener('abort', listener)\n}\n\nconst hasToWellFormed = typeof String.prototype.toWellFormed === 'function'\nconst hasIsWellFormed = typeof String.prototype.isWellFormed === 'function'\n\n/**\n * @param {string} val\n */\nfunction toUSVString (val) {\n  return hasToWellFormed ? `${val}`.toWellFormed() : nodeUtil.toUSVString(val)\n}\n\n/**\n * @param {string} val\n */\n// TODO: move this to webidl\nfunction isUSVString (val) {\n  return hasIsWellFormed ? `${val}`.isWellFormed() : toUSVString(val) === `${val}`\n}\n\n/**\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n * @param {number} c\n */\nfunction isTokenCharCode (c) {\n  switch (c) {\n    case 0x22:\n    case 0x28:\n    case 0x29:\n    case 0x2c:\n    case 0x2f:\n    case 0x3a:\n    case 0x3b:\n    case 0x3c:\n    case 0x3d:\n    case 0x3e:\n    case 0x3f:\n    case 0x40:\n    case 0x5b:\n    case 0x5c:\n    case 0x5d:\n    case 0x7b:\n    case 0x7d:\n      // DQUOTE and \"(),/:;<=>?@[\\]{}\"\n      return false\n    default:\n      // VCHAR %x21-7E\n      return c >= 0x21 && c <= 0x7e\n  }\n}\n\n/**\n * @param {string} characters\n */\nfunction isValidHTTPToken (characters) {\n  if (characters.length === 0) {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    if (!isTokenCharCode(characters.charCodeAt(i))) {\n      return false\n    }\n  }\n  return true\n}\n\n// headerCharRegex have been lifted from\n// https://github.com/nodejs/node/blob/main/lib/_http_common.js\n\n/**\n * Matches if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/\n\n/**\n * @param {string} characters\n */\nfunction isValidHeaderValue (characters) {\n  return !headerCharRegex.test(characters)\n}\n\n// Parsed accordingly to RFC 9110\n// https://www.rfc-editor.org/rfc/rfc9110#field.content-range\nfunction parseRangeHeader (range) {\n  if (range == null || range === '') return { start: 0, end: null, size: null }\n\n  const m = range ? range.match(/^bytes (\\d+)-(\\d+)\\/(\\d+)?$/) : null\n  return m\n    ? {\n        start: parseInt(m[1]),\n        end: m[2] ? parseInt(m[2]) : null,\n        size: m[3] ? parseInt(m[3]) : null\n      }\n    : null\n}\n\nfunction addListener (obj, name, listener) {\n  const listeners = (obj[kListeners] ??= [])\n  listeners.push([name, listener])\n  obj.on(name, listener)\n  return obj\n}\n\nfunction removeAllListeners (obj) {\n  for (const [name, listener] of obj[kListeners] ?? []) {\n    obj.removeListener(name, listener)\n  }\n  obj[kListeners] = null\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nconst kEnumerableProperty = Object.create(null)\nkEnumerableProperty.enumerable = true\n\nconst normalizedMethodRecordsBase = {\n  delete: 'DELETE',\n  DELETE: 'DELETE',\n  get: 'GET',\n  GET: 'GET',\n  head: 'HEAD',\n  HEAD: 'HEAD',\n  options: 'OPTIONS',\n  OPTIONS: 'OPTIONS',\n  post: 'POST',\n  POST: 'POST',\n  put: 'PUT',\n  PUT: 'PUT'\n}\n\nconst normalizedMethodRecords = {\n  ...normalizedMethodRecordsBase,\n  patch: 'patch',\n  PATCH: 'PATCH'\n}\n\n// Note: object prototypes should not be able to be referenced. e.g. `Object#hasOwnProperty`.\nObject.setPrototypeOf(normalizedMethodRecordsBase, null)\nObject.setPrototypeOf(normalizedMethodRecords, null)\n\nmodule.exports = {\n  kEnumerableProperty,\n  nop,\n  isDisturbed,\n  isErrored,\n  isReadable,\n  toUSVString,\n  isUSVString,\n  isBlobLike,\n  parseOrigin,\n  parseURL,\n  getServerName,\n  isStream,\n  isIterable,\n  isAsyncIterable,\n  isDestroyed,\n  headerNameToString,\n  bufferToLowerCasedHeaderName,\n  addListener,\n  removeAllListeners,\n  errorRequest,\n  parseRawHeaders,\n  parseHeaders,\n  parseKeepAliveTimeout,\n  destroy,\n  bodyLength,\n  deepClone,\n  ReadableStreamFrom,\n  isBuffer,\n  validateHandler,\n  getSocketInfo,\n  isFormDataLike,\n  buildURL,\n  addAbortListener,\n  isValidHTTPToken,\n  isValidHeaderValue,\n  isTokenCharCode,\n  parseRangeHeader,\n  normalizedMethodRecordsBase,\n  normalizedMethodRecords,\n  isValidPort,\n  isHttpOrHttpsPrefixed,\n  nodeMajor,\n  nodeMinor,\n  safeHTTPMethods: ['GET', 'HEAD', 'OPTIONS', 'TRACE'],\n  wrapRequestBody\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9jb3JlL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQyxrRUFBVztBQUN4RSxRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDL0MsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFlBQVksbUJBQU8sQ0FBQywwQkFBVTtBQUM5QixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLDRCQUFXO0FBQ3BDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsMENBQWtCO0FBQ2hELFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNsRCxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsZ0VBQVU7QUFDbkQsUUFBUSw2QkFBNkIsRUFBRSxtQkFBTyxDQUFDLHNFQUFhO0FBQzVELFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsNERBQVE7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQixJQUFJLG1CQUFtQixHQUFHLEtBQUs7QUFDN0Q7QUFDQTtBQUNBLFdBQVcsbUJBQW1CLEVBQUUsaUJBQWlCOztBQUVqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU8sRUFBRSxLQUFLO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLCtFQUErRTtBQUMxRixXQUFXLG1DQUFtQztBQUM5QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyw4QkFBOEI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELFlBQVk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQzs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSSwyQ0FBMkMsSUFBSTtBQUNqRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcY29yZVxcdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBrRGVzdHJveWVkLCBrQm9keVVzZWQsIGtMaXN0ZW5lcnMsIGtCb2R5IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBJbmNvbWluZ01lc3NhZ2UgfSA9IHJlcXVpcmUoJ25vZGU6aHR0cCcpXG5jb25zdCBzdHJlYW0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCBuZXQgPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCB7IEJsb2IgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcbmNvbnN0IG5vZGVVdGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCdub2RlOnF1ZXJ5c3RyaW5nJylcbmNvbnN0IHsgRXZlbnRFbWl0dGVyOiBFRSB9ID0gcmVxdWlyZSgnbm9kZTpldmVudHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9lcnJvcnMnKVxuY29uc3QgeyBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZCB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyB0cmVlIH0gPSByZXF1aXJlKCcuL3RyZWUnKVxuXG5jb25zdCBbbm9kZU1ham9yLCBub2RlTWlub3JdID0gcHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJykubWFwKHYgPT4gTnVtYmVyKHYpKVxuXG5jbGFzcyBCb2R5QXN5bmNJdGVyYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChib2R5KSB7XG4gICAgdGhpc1trQm9keV0gPSBib2R5XG4gICAgdGhpc1trQm9keVVzZWRdID0gZmFsc2VcbiAgfVxuXG4gIGFzeW5jICogW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgYXNzZXJ0KCF0aGlzW2tCb2R5VXNlZF0sICdkaXN0dXJiZWQnKVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICB5aWVsZCAqIHRoaXNba0JvZHldXG4gIH1cbn1cblxuZnVuY3Rpb24gd3JhcFJlcXVlc3RCb2R5IChib2R5KSB7XG4gIGlmIChpc1N0cmVhbShib2R5KSkge1xuICAgIC8vIFRPRE8gKGZpeCk6IFByb3ZpZGUgc29tZSB3YXkgZm9yIHRoZSB1c2VyIHRvIGNhY2hlIHRoZSBmaWxlIHRvIGUuZy4gL3RtcFxuICAgIC8vIHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYWdhaW4/XG4gICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCAxMDAtZXhwZWN0IHN1cHBvcnQgdG8gcHJvdmlkZSBhIHdheSB0byBkbyB0aGlzIHByb3Blcmx5P1xuICAgIGlmIChib2R5TGVuZ3RoKGJvZHkpID09PSAwKSB7XG4gICAgICBib2R5XG4gICAgICAgIC5vbignZGF0YScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhc3NlcnQoZmFsc2UpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBib2R5LnJlYWRhYmxlRGlkUmVhZCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBib2R5W2tCb2R5VXNlZF0gPSBmYWxzZVxuICAgICAgRUUucHJvdG90eXBlLm9uLmNhbGwoYm9keSwgJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIGJvZHlcbiAgfSBlbHNlIGlmIChib2R5ICYmIHR5cGVvZiBib2R5LnBpcGVUbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRPRE8gKGZpeCk6IFdlIGNhbid0IGFjY2VzcyBSZWFkYWJsZVN0cmVhbSBpbnRlcm5hbCBzdGF0ZVxuICAgIC8vIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCBpdCBoYXMgYmVlbiBkaXN0dXJiZWQuIFRoaXMgaXMganVzdFxuICAgIC8vIGEgd29ya2Fyb3VuZC5cbiAgICByZXR1cm4gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKGJvZHkpXG4gIH0gZWxzZSBpZiAoXG4gICAgYm9keSAmJlxuICAgIHR5cGVvZiBib2R5ICE9PSAnc3RyaW5nJyAmJlxuICAgICFBcnJheUJ1ZmZlci5pc1ZpZXcoYm9keSkgJiZcbiAgICBpc0l0ZXJhYmxlKGJvZHkpXG4gICkge1xuICAgIC8vIFRPRE86IFNob3VsZCB3ZSBhbGxvdyByZS11c2luZyBpdGVyYWJsZSBpZiAhdGhpcy5vcHRzLmlkZW1wb3RlbnRcbiAgICAvLyBvciB0aHJvdWdoIHNvbWUgb3RoZXIgZmxhZz9cbiAgICByZXR1cm4gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKGJvZHkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJvZHlcbiAgfVxufVxuXG5mdW5jdGlvbiBub3AgKCkge31cblxuZnVuY3Rpb24gaXNTdHJlYW0gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmoucGlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLm9uID09PSAnZnVuY3Rpb24nXG59XG5cbi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlLWZldGNoL2ZldGNoLWJsb2IvYmxvYi84YWI1ODdkMzQwODBkZTk0MTQwYjU0ZjA3MTY4NDUxZTdkMGI2NTVlL2luZGV4LmpzI0wyMjktTDI0MSAoTUlUIExpY2Vuc2UpXG5mdW5jdGlvbiBpc0Jsb2JMaWtlIChvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc1RhZyA9IG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddXG5cbiAgICByZXR1cm4gKHNUYWcgPT09ICdCbG9iJyB8fCBzVGFnID09PSAnRmlsZScpICYmIChcbiAgICAgICgnc3RyZWFtJyBpbiBvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5zdHJlYW0gPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAoJ2FycmF5QnVmZmVyJyBpbiBvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRVUkwgKHVybCwgcXVlcnlQYXJhbXMpIHtcbiAgaWYgKHVybC5pbmNsdWRlcygnPycpIHx8IHVybC5pbmNsdWRlcygnIycpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdRdWVyeSBwYXJhbXMgY2Fubm90IGJlIHBhc3NlZCB3aGVuIHVybCBhbHJlYWR5IGNvbnRhaW5zIFwiP1wiIG9yIFwiI1wiLicpXG4gIH1cblxuICBjb25zdCBzdHJpbmdpZmllZCA9IHN0cmluZ2lmeShxdWVyeVBhcmFtcylcblxuICBpZiAoc3RyaW5naWZpZWQpIHtcbiAgICB1cmwgKz0gJz8nICsgc3RyaW5naWZpZWRcbiAgfVxuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFBvcnQgKHBvcnQpIHtcbiAgY29uc3QgdmFsdWUgPSBwYXJzZUludChwb3J0LCAxMClcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSA9PT0gTnVtYmVyKHBvcnQpICYmXG4gICAgdmFsdWUgPj0gMCAmJlxuICAgIHZhbHVlIDw9IDY1NTM1XG4gIClcbn1cblxuZnVuY3Rpb24gaXNIdHRwT3JIdHRwc1ByZWZpeGVkICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICB2YWx1ZVswXSA9PT0gJ2gnICYmXG4gICAgdmFsdWVbMV0gPT09ICd0JyAmJlxuICAgIHZhbHVlWzJdID09PSAndCcgJiZcbiAgICB2YWx1ZVszXSA9PT0gJ3AnICYmXG4gICAgKFxuICAgICAgdmFsdWVbNF0gPT09ICc6JyB8fFxuICAgICAgKFxuICAgICAgICB2YWx1ZVs0XSA9PT0gJ3MnICYmXG4gICAgICAgIHZhbHVlWzVdID09PSAnOidcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gcGFyc2VVUkwgKHVybCkge1xuICBpZiAodHlwZW9mIHVybCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybClcblxuICAgIGlmICghaXNIdHRwT3JIdHRwc1ByZWZpeGVkKHVybC5vcmlnaW4gfHwgdXJsLnByb3RvY29sKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwcm90b2NvbDogdGhlIFVSTCBtdXN0IHN0YXJ0IHdpdGggYGh0dHA6YCBvciBgaHR0cHM6YC4nKVxuICAgIH1cblxuICAgIHJldHVybiB1cmxcbiAgfVxuXG4gIGlmICghdXJsIHx8IHR5cGVvZiB1cmwgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTDogVGhlIFVSTCBhcmd1bWVudCBtdXN0IGJlIGEgbm9uLW51bGwgb2JqZWN0LicpXG4gIH1cblxuICBpZiAoISh1cmwgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgaWYgKHVybC5wb3J0ICE9IG51bGwgJiYgdXJsLnBvcnQgIT09ICcnICYmIGlzVmFsaWRQb3J0KHVybC5wb3J0KSA9PT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkw6IHBvcnQgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgb3IgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlci4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aCAhPSBudWxsICYmIHR5cGVvZiB1cmwucGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcGF0aDogdGhlIHBhdGggbXVzdCBiZSBhIHN0cmluZyBvciBudWxsL3VuZGVmaW5lZC4nKVxuICAgIH1cblxuICAgIGlmICh1cmwucGF0aG5hbWUgIT0gbnVsbCAmJiB0eXBlb2YgdXJsLnBhdGhuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIFVSTCBwYXRobmFtZTogdGhlIHBhdGhuYW1lIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAodXJsLmhvc3RuYW1lICE9IG51bGwgJiYgdHlwZW9mIHVybC5ob3N0bmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgaG9zdG5hbWU6IHRoZSBob3N0bmFtZSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bGwvdW5kZWZpbmVkLicpXG4gICAgfVxuXG4gICAgaWYgKHVybC5vcmlnaW4gIT0gbnVsbCAmJiB0eXBlb2YgdXJsLm9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgb3JpZ2luOiB0aGUgb3JpZ2luIG11c3QgYmUgYSBzdHJpbmcgb3IgbnVsbC91bmRlZmluZWQuJylcbiAgICB9XG5cbiAgICBpZiAoIWlzSHR0cE9ySHR0cHNQcmVmaXhlZCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBVUkwgcHJvdG9jb2w6IHRoZSBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJylcbiAgICB9XG5cbiAgICBjb25zdCBwb3J0ID0gdXJsLnBvcnQgIT0gbnVsbFxuICAgICAgPyB1cmwucG9ydFxuICAgICAgOiAodXJsLnByb3RvY29sID09PSAnaHR0cHM6JyA/IDQ0MyA6IDgwKVxuICAgIGxldCBvcmlnaW4gPSB1cmwub3JpZ2luICE9IG51bGxcbiAgICAgID8gdXJsLm9yaWdpblxuICAgICAgOiBgJHt1cmwucHJvdG9jb2wgfHwgJyd9Ly8ke3VybC5ob3N0bmFtZSB8fCAnJ306JHtwb3J0fWBcbiAgICBsZXQgcGF0aCA9IHVybC5wYXRoICE9IG51bGxcbiAgICAgID8gdXJsLnBhdGhcbiAgICAgIDogYCR7dXJsLnBhdGhuYW1lIHx8ICcnfSR7dXJsLnNlYXJjaCB8fCAnJ31gXG5cbiAgICBpZiAob3JpZ2luW29yaWdpbi5sZW5ndGggLSAxXSA9PT0gJy8nKSB7XG4gICAgICBvcmlnaW4gPSBvcmlnaW4uc2xpY2UoMCwgb3JpZ2luLmxlbmd0aCAtIDEpXG4gICAgfVxuXG4gICAgaWYgKHBhdGggJiYgcGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICBwYXRoID0gYC8ke3BhdGh9YFxuICAgIH1cbiAgICAvLyBuZXcgVVJMKHBhdGgsIG9yaWdpbikgaXMgdW5zYWZlIHdoZW4gYHBhdGhgIGNvbnRhaW5zIGFuIGFic29sdXRlIFVSTFxuICAgIC8vIEZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTC9VUkw6XG4gICAgLy8gSWYgZmlyc3QgcGFyYW1ldGVyIGlzIGEgcmVsYXRpdmUgVVJMLCBzZWNvbmQgcGFyYW0gaXMgcmVxdWlyZWQsIGFuZCB3aWxsIGJlIHVzZWQgYXMgdGhlIGJhc2UgVVJMLlxuICAgIC8vIElmIGZpcnN0IHBhcmFtZXRlciBpcyBhbiBhYnNvbHV0ZSBVUkwsIGEgZ2l2ZW4gc2Vjb25kIHBhcmFtIHdpbGwgYmUgaWdub3JlZC5cbiAgICByZXR1cm4gbmV3IFVSTChgJHtvcmlnaW59JHtwYXRofWApXG4gIH1cblxuICBpZiAoIWlzSHR0cE9ySHR0cHNQcmVmaXhlZCh1cmwub3JpZ2luIHx8IHVybC5wcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0ludmFsaWQgVVJMIHByb3RvY29sOiB0aGUgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIHBhcnNlT3JpZ2luICh1cmwpIHtcbiAgdXJsID0gcGFyc2VVUkwodXJsKVxuXG4gIGlmICh1cmwucGF0aG5hbWUgIT09ICcvJyB8fCB1cmwuc2VhcmNoIHx8IHVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIHVybCcpXG4gIH1cblxuICByZXR1cm4gdXJsXG59XG5cbmZ1bmN0aW9uIGdldEhvc3RuYW1lIChob3N0KSB7XG4gIGlmIChob3N0WzBdID09PSAnWycpIHtcbiAgICBjb25zdCBpZHggPSBob3N0LmluZGV4T2YoJ10nKVxuXG4gICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG4gICAgcmV0dXJuIGhvc3Quc3Vic3RyaW5nKDEsIGlkeClcbiAgfVxuXG4gIGNvbnN0IGlkeCA9IGhvc3QuaW5kZXhPZignOicpXG4gIGlmIChpZHggPT09IC0xKSByZXR1cm4gaG9zdFxuXG4gIHJldHVybiBob3N0LnN1YnN0cmluZygwLCBpZHgpXG59XG5cbi8vIElQIGFkZHJlc3NlcyBhcmUgbm90IHZhbGlkIHNlcnZlciBuYW1lcyBwZXIgUkZDNjA2NlxuLy8gPiBDdXJyZW50bHksIHRoZSBvbmx5IHNlcnZlciBuYW1lcyBzdXBwb3J0ZWQgYXJlIEROUyBob3N0bmFtZXNcbmZ1bmN0aW9uIGdldFNlcnZlck5hbWUgKGhvc3QpIHtcbiAgaWYgKCFob3N0KSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGFzc2VydCh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycpXG5cbiAgY29uc3Qgc2VydmVybmFtZSA9IGdldEhvc3RuYW1lKGhvc3QpXG4gIGlmIChuZXQuaXNJUChzZXJ2ZXJuYW1lKSkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgcmV0dXJuIHNlcnZlcm5hbWVcbn1cblxuZnVuY3Rpb24gZGVlcENsb25lIChvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSlcbn1cblxuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlIChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKVxufVxuXG5mdW5jdGlvbiBpc0l0ZXJhYmxlIChvYmopIHtcbiAgcmV0dXJuICEhKG9iaiAhPSBudWxsICYmICh0eXBlb2Ygb2JqW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpKVxufVxuXG5mdW5jdGlvbiBib2R5TGVuZ3RoIChib2R5KSB7XG4gIGlmIChib2R5ID09IG51bGwpIHtcbiAgICByZXR1cm4gMFxuICB9IGVsc2UgaWYgKGlzU3RyZWFtKGJvZHkpKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBib2R5Ll9yZWFkYWJsZVN0YXRlXG4gICAgcmV0dXJuIHN0YXRlICYmIHN0YXRlLm9iamVjdE1vZGUgPT09IGZhbHNlICYmIHN0YXRlLmVuZGVkID09PSB0cnVlICYmIE51bWJlci5pc0Zpbml0ZShzdGF0ZS5sZW5ndGgpXG4gICAgICA/IHN0YXRlLmxlbmd0aFxuICAgICAgOiBudWxsXG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShib2R5KSkge1xuICAgIHJldHVybiBib2R5LnNpemUgIT0gbnVsbCA/IGJvZHkuc2l6ZSA6IG51bGxcbiAgfSBlbHNlIGlmIChpc0J1ZmZlcihib2R5KSkge1xuICAgIHJldHVybiBib2R5LmJ5dGVMZW5ndGhcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIGlzRGVzdHJveWVkIChib2R5KSB7XG4gIHJldHVybiBib2R5ICYmICEhKGJvZHkuZGVzdHJveWVkIHx8IGJvZHlba0Rlc3Ryb3llZF0gfHwgKHN0cmVhbS5pc0Rlc3Ryb3llZD8uKGJvZHkpKSlcbn1cblxuZnVuY3Rpb24gZGVzdHJveSAoc3RyZWFtLCBlcnIpIHtcbiAgaWYgKHN0cmVhbSA9PSBudWxsIHx8ICFpc1N0cmVhbShzdHJlYW0pIHx8IGlzRGVzdHJveWVkKHN0cmVhbSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHN0cmVhbSkuY29uc3RydWN0b3IgPT09IEluY29taW5nTWVzc2FnZSkge1xuICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvcHVsbC8zODUwNS9maWxlc1xuICAgICAgc3RyZWFtLnNvY2tldCA9IG51bGxcbiAgICB9XG5cbiAgICBzdHJlYW0uZGVzdHJveShlcnIpXG4gIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH0pXG4gIH1cblxuICBpZiAoc3RyZWFtLmRlc3Ryb3llZCAhPT0gdHJ1ZSkge1xuICAgIHN0cmVhbVtrRGVzdHJveWVkXSA9IHRydWVcbiAgfVxufVxuXG5jb25zdCBLRUVQQUxJVkVfVElNRU9VVF9FWFBSID0gL3RpbWVvdXQ9KFxcZCspL1xuZnVuY3Rpb24gcGFyc2VLZWVwQWxpdmVUaW1lb3V0ICh2YWwpIHtcbiAgY29uc3QgbSA9IHZhbC50b1N0cmluZygpLm1hdGNoKEtFRVBBTElWRV9USU1FT1VUX0VYUFIpXG4gIHJldHVybiBtID8gcGFyc2VJbnQobVsxXSwgMTApICogMTAwMCA6IG51bGxcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBoZWFkZXIgbmFtZSBhbmQgcmV0dXJucyBpdHMgbG93ZXJjYXNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmcgfCBCdWZmZXJ9IHZhbHVlIEhlYWRlciBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoZWFkZXJOYW1lVG9TdHJpbmcgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgPyBoZWFkZXJOYW1lTG93ZXJDYXNlZFJlY29yZFt2YWx1ZV0gPz8gdmFsdWUudG9Mb3dlckNhc2UoKVxuICAgIDogdHJlZS5sb29rdXAodmFsdWUpID8/IHZhbHVlLnRvU3RyaW5nKCdsYXRpbjEnKS50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogUmVjZWl2ZSB0aGUgYnVmZmVyIGFzIGEgc3RyaW5nIGFuZCByZXR1cm4gaXRzIGxvd2VyY2FzZSB2YWx1ZS5cbiAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBIZWFkZXIgbmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9Mb3dlckNhc2VkSGVhZGVyTmFtZSAodmFsdWUpIHtcbiAgcmV0dXJuIHRyZWUubG9va3VwKHZhbHVlKSA/PyB2YWx1ZS50b1N0cmluZygnbGF0aW4xJykudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+IHwgKEJ1ZmZlciB8IHN0cmluZyB8IChCdWZmZXIgfCBzdHJpbmcpW10pW119IGhlYWRlcnNcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+fSBbb2JqXVxuICogQHJldHVybnMge1JlY29yZDxzdHJpbmcsIHN0cmluZyB8IHN0cmluZ1tdPn1cbiAqL1xuZnVuY3Rpb24gcGFyc2VIZWFkZXJzIChoZWFkZXJzLCBvYmopIHtcbiAgaWYgKG9iaiA9PT0gdW5kZWZpbmVkKSBvYmogPSB7fVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBjb25zdCBrZXkgPSBoZWFkZXJOYW1lVG9TdHJpbmcoaGVhZGVyc1tpXSlcbiAgICBsZXQgdmFsID0gb2JqW2tleV1cblxuICAgIGlmICh2YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YWwgPSBbdmFsXVxuICAgICAgICBvYmpba2V5XSA9IHZhbFxuICAgICAgfVxuICAgICAgdmFsLnB1c2goaGVhZGVyc1tpICsgMV0udG9TdHJpbmcoJ3V0ZjgnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVhZGVyc1ZhbHVlID0gaGVhZGVyc1tpICsgMV1cbiAgICAgIGlmICh0eXBlb2YgaGVhZGVyc1ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBvYmpba2V5XSA9IGhlYWRlcnNWYWx1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqW2tleV0gPSBBcnJheS5pc0FycmF5KGhlYWRlcnNWYWx1ZSkgPyBoZWFkZXJzVmFsdWUubWFwKHggPT4geC50b1N0cmluZygndXRmOCcpKSA6IGhlYWRlcnNWYWx1ZS50b1N0cmluZygndXRmOCcpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzQ2NTI4XG4gIGlmICgnY29udGVudC1sZW5ndGgnIGluIG9iaiAmJiAnY29udGVudC1kaXNwb3NpdGlvbicgaW4gb2JqKSB7XG4gICAgb2JqWydjb250ZW50LWRpc3Bvc2l0aW9uJ10gPSBCdWZmZXIuZnJvbShvYmpbJ2NvbnRlbnQtZGlzcG9zaXRpb24nXSkudG9TdHJpbmcoJ2xhdGluMScpXG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIHBhcnNlUmF3SGVhZGVycyAoaGVhZGVycykge1xuICBjb25zdCBsZW4gPSBoZWFkZXJzLmxlbmd0aFxuICBjb25zdCByZXQgPSBuZXcgQXJyYXkobGVuKVxuXG4gIGxldCBoYXNDb250ZW50TGVuZ3RoID0gZmFsc2VcbiAgbGV0IGNvbnRlbnREaXNwb3NpdGlvbklkeCA9IC0xXG4gIGxldCBrZXlcbiAgbGV0IHZhbFxuICBsZXQga0xlbiA9IDBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICBrZXkgPSBoZWFkZXJzW25dXG4gICAgdmFsID0gaGVhZGVyc1tuICsgMV1cblxuICAgIHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnICYmIChrZXkgPSBrZXkudG9TdHJpbmcoKSlcbiAgICB0eXBlb2YgdmFsICE9PSAnc3RyaW5nJyAmJiAodmFsID0gdmFsLnRvU3RyaW5nKCd1dGY4JykpXG5cbiAgICBrTGVuID0ga2V5Lmxlbmd0aFxuICAgIGlmIChrTGVuID09PSAxNCAmJiBrZXlbN10gPT09ICctJyAmJiAoa2V5ID09PSAnY29udGVudC1sZW5ndGgnIHx8IGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC1sZW5ndGgnKSkge1xuICAgICAgaGFzQ29udGVudExlbmd0aCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKGtMZW4gPT09IDE5ICYmIGtleVs3XSA9PT0gJy0nICYmIChrZXkgPT09ICdjb250ZW50LWRpc3Bvc2l0aW9uJyB8fCBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtZGlzcG9zaXRpb24nKSkge1xuICAgICAgY29udGVudERpc3Bvc2l0aW9uSWR4ID0gbiArIDFcbiAgICB9XG4gICAgcmV0W25dID0ga2V5XG4gICAgcmV0W24gKyAxXSA9IHZhbFxuICB9XG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9wdWxsLzQ2NTI4XG4gIGlmIChoYXNDb250ZW50TGVuZ3RoICYmIGNvbnRlbnREaXNwb3NpdGlvbklkeCAhPT0gLTEpIHtcbiAgICByZXRbY29udGVudERpc3Bvc2l0aW9uSWR4XSA9IEJ1ZmZlci5mcm9tKHJldFtjb250ZW50RGlzcG9zaXRpb25JZHhdKS50b1N0cmluZygnbGF0aW4xJylcbiAgfVxuXG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKGJ1ZmZlcikge1xuICAvLyBTZWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9tY29sbGluYS91bmRpY2kvcHVsbC8zMTlcbiAgcmV0dXJuIGJ1ZmZlciBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVIYW5kbGVyIChoYW5kbGVyLCBtZXRob2QsIHVwZ3JhZGUpIHtcbiAgaWYgKCFoYW5kbGVyIHx8IHR5cGVvZiBoYW5kbGVyICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdCcpXG4gIH1cblxuICBpZiAodHlwZW9mIGhhbmRsZXIub25Db25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG9uQ29ubmVjdCBtZXRob2QnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25FcnJvciBtZXRob2QnKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQm9keVNlbnQgIT09ICdmdW5jdGlvbicgJiYgaGFuZGxlci5vbkJvZHlTZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25Cb2R5U2VudCBtZXRob2QnKVxuICB9XG5cbiAgaWYgKHVwZ3JhZGUgfHwgbWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25VcGdyYWRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25VcGdyYWRlIG1ldGhvZCcpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkhlYWRlcnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkhlYWRlcnMgbWV0aG9kJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGhhbmRsZXIub25EYXRhICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgb25EYXRhIG1ldGhvZCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyLm9uQ29tcGxldGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkNvbXBsZXRlIG1ldGhvZCcpXG4gICAgfVxuICB9XG59XG5cbi8vIEEgYm9keSBpcyBkaXN0dXJiZWQgaWYgaXQgaGFzIGJlZW4gcmVhZCBmcm9tIGFuZCBpdCBjYW5ub3Rcbi8vIGJlIHJlLXVzZWQgd2l0aG91dCBsb3Npbmcgc3RhdGUgb3IgZGF0YS5cbmZ1bmN0aW9uIGlzRGlzdHVyYmVkIChib2R5KSB7XG4gIC8vIFRPRE8gKGZpeCk6IFdoeSBpcyBib2R5W2tCb2R5VXNlZF0gbmVlZGVkP1xuICByZXR1cm4gISEoYm9keSAmJiAoc3RyZWFtLmlzRGlzdHVyYmVkKGJvZHkpIHx8IGJvZHlba0JvZHlVc2VkXSkpXG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JlZCAoYm9keSkge1xuICByZXR1cm4gISEoYm9keSAmJiBzdHJlYW0uaXNFcnJvcmVkKGJvZHkpKVxufVxuXG5mdW5jdGlvbiBpc1JlYWRhYmxlIChib2R5KSB7XG4gIHJldHVybiAhIShib2R5ICYmIHN0cmVhbS5pc1JlYWRhYmxlKGJvZHkpKVxufVxuXG5mdW5jdGlvbiBnZXRTb2NrZXRJbmZvIChzb2NrZXQpIHtcbiAgcmV0dXJuIHtcbiAgICBsb2NhbEFkZHJlc3M6IHNvY2tldC5sb2NhbEFkZHJlc3MsXG4gICAgbG9jYWxQb3J0OiBzb2NrZXQubG9jYWxQb3J0LFxuICAgIHJlbW90ZUFkZHJlc3M6IHNvY2tldC5yZW1vdGVBZGRyZXNzLFxuICAgIHJlbW90ZVBvcnQ6IHNvY2tldC5yZW1vdGVQb3J0LFxuICAgIHJlbW90ZUZhbWlseTogc29ja2V0LnJlbW90ZUZhbWlseSxcbiAgICB0aW1lb3V0OiBzb2NrZXQudGltZW91dCxcbiAgICBieXRlc1dyaXR0ZW46IHNvY2tldC5ieXRlc1dyaXR0ZW4sXG4gICAgYnl0ZXNSZWFkOiBzb2NrZXQuYnl0ZXNSZWFkXG4gIH1cbn1cblxuLyoqIEB0eXBlIHtnbG9iYWxUaGlzWydSZWFkYWJsZVN0cmVhbSddfSAqL1xuZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1Gcm9tIChpdGVyYWJsZSkge1xuICAvLyBXZSBjYW5ub3QgdXNlIFJlYWRhYmxlU3RyZWFtLmZyb20gaGVyZSBiZWNhdXNlIGl0IGRvZXMgbm90IHJldHVybiBhIGJ5dGUgc3RyZWFtLlxuXG4gIGxldCBpdGVyYXRvclxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKFxuICAgIHtcbiAgICAgIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgICAgICAgICBjb250cm9sbGVyLmJ5b2JSZXF1ZXN0Py5yZXNwb25kKDApXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBidWYgPSBCdWZmZXIuaXNCdWZmZXIodmFsdWUpID8gdmFsdWUgOiBCdWZmZXIuZnJvbSh2YWx1ZSlcbiAgICAgICAgICBpZiAoYnVmLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShuZXcgVWludDhBcnJheShidWYpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5kZXNpcmVkU2l6ZSA+IDBcbiAgICAgIH0sXG4gICAgICBhc3luYyBjYW5jZWwgKHJlYXNvbikge1xuICAgICAgICBhd2FpdCBpdGVyYXRvci5yZXR1cm4oKVxuICAgICAgfSxcbiAgICAgIHR5cGU6ICdieXRlcydcbiAgICB9XG4gIClcbn1cblxuLy8gVGhlIGNodW5rIHNob3VsZCBiZSBhIEZvcm1EYXRhIGluc3RhbmNlIGFuZCBjb250YWluc1xuLy8gYWxsIHRoZSByZXF1aXJlZCBtZXRob2RzLlxuZnVuY3Rpb24gaXNGb3JtRGF0YUxpa2UgKG9iamVjdCkge1xuICByZXR1cm4gKFxuICAgIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5hcHBlbmQgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmRlbGV0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3QuZ2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIG9iamVjdC5nZXRBbGwgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2Ygb2JqZWN0LmhhcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBvYmplY3Quc2V0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgb2JqZWN0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdGb3JtRGF0YSdcbiAgKVxufVxuXG5mdW5jdGlvbiBhZGRBYm9ydExpc3RlbmVyIChzaWduYWwsIGxpc3RlbmVyKSB7XG4gIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gc2lnbmFsKSB7XG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KVxuICAgIHJldHVybiAoKSA9PiBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBsaXN0ZW5lcilcbiAgfVxuICBzaWduYWwuYWRkTGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG4gIHJldHVybiAoKSA9PiBzaWduYWwucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0JywgbGlzdGVuZXIpXG59XG5cbmNvbnN0IGhhc1RvV2VsbEZvcm1lZCA9IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRvV2VsbEZvcm1lZCA9PT0gJ2Z1bmN0aW9uJ1xuY29uc3QgaGFzSXNXZWxsRm9ybWVkID0gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUuaXNXZWxsRm9ybWVkID09PSAnZnVuY3Rpb24nXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICovXG5mdW5jdGlvbiB0b1VTVlN0cmluZyAodmFsKSB7XG4gIHJldHVybiBoYXNUb1dlbGxGb3JtZWQgPyBgJHt2YWx9YC50b1dlbGxGb3JtZWQoKSA6IG5vZGVVdGlsLnRvVVNWU3RyaW5nKHZhbClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKi9cbi8vIFRPRE86IG1vdmUgdGhpcyB0byB3ZWJpZGxcbmZ1bmN0aW9uIGlzVVNWU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIGhhc0lzV2VsbEZvcm1lZCA/IGAke3ZhbH1gLmlzV2VsbEZvcm1lZCgpIDogdG9VU1ZTdHJpbmcodmFsKSA9PT0gYCR7dmFsfWBcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4yLjZcbiAqIEBwYXJhbSB7bnVtYmVyfSBjXG4gKi9cbmZ1bmN0aW9uIGlzVG9rZW5DaGFyQ29kZSAoYykge1xuICBzd2l0Y2ggKGMpIHtcbiAgICBjYXNlIDB4MjI6XG4gICAgY2FzZSAweDI4OlxuICAgIGNhc2UgMHgyOTpcbiAgICBjYXNlIDB4MmM6XG4gICAgY2FzZSAweDJmOlxuICAgIGNhc2UgMHgzYTpcbiAgICBjYXNlIDB4M2I6XG4gICAgY2FzZSAweDNjOlxuICAgIGNhc2UgMHgzZDpcbiAgICBjYXNlIDB4M2U6XG4gICAgY2FzZSAweDNmOlxuICAgIGNhc2UgMHg0MDpcbiAgICBjYXNlIDB4NWI6XG4gICAgY2FzZSAweDVjOlxuICAgIGNhc2UgMHg1ZDpcbiAgICBjYXNlIDB4N2I6XG4gICAgY2FzZSAweDdkOlxuICAgICAgLy8gRFFVT1RFIGFuZCBcIigpLC86Ozw9Pj9AW1xcXXt9XCJcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBWQ0hBUiAleDIxLTdFXG4gICAgICByZXR1cm4gYyA+PSAweDIxICYmIGMgPD0gMHg3ZVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlcnNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEhUVFBUb2tlbiAoY2hhcmFjdGVycykge1xuICBpZiAoY2hhcmFjdGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYXJhY3RlcnMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIWlzVG9rZW5DaGFyQ29kZShjaGFyYWN0ZXJzLmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gaGVhZGVyQ2hhclJlZ2V4IGhhdmUgYmVlbiBsaWZ0ZWQgZnJvbVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvbWFpbi9saWIvX2h0dHBfY29tbW9uLmpzXG5cbi8qKlxuICogTWF0Y2hlcyBpZiB2YWwgY29udGFpbnMgYW4gaW52YWxpZCBmaWVsZC12Y2hhclxuICogIGZpZWxkLXZhbHVlICAgID0gKiggZmllbGQtY29udGVudCAvIG9icy1mb2xkIClcbiAqICBmaWVsZC1jb250ZW50ICA9IGZpZWxkLXZjaGFyIFsgMSooIFNQIC8gSFRBQiApIGZpZWxkLXZjaGFyIF1cbiAqICBmaWVsZC12Y2hhciAgICA9IFZDSEFSIC8gb2JzLXRleHRcbiAqL1xuY29uc3QgaGVhZGVyQ2hhclJlZ2V4ID0gL1teXFx0XFx4MjAtXFx4N2VcXHg4MC1cXHhmZl0vXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlcnNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEhlYWRlclZhbHVlIChjaGFyYWN0ZXJzKSB7XG4gIHJldHVybiAhaGVhZGVyQ2hhclJlZ2V4LnRlc3QoY2hhcmFjdGVycylcbn1cblxuLy8gUGFyc2VkIGFjY29yZGluZ2x5IHRvIFJGQyA5MTEwXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTExMCNmaWVsZC5jb250ZW50LXJhbmdlXG5mdW5jdGlvbiBwYXJzZVJhbmdlSGVhZGVyIChyYW5nZSkge1xuICBpZiAocmFuZ2UgPT0gbnVsbCB8fCByYW5nZSA9PT0gJycpIHJldHVybiB7IHN0YXJ0OiAwLCBlbmQ6IG51bGwsIHNpemU6IG51bGwgfVxuXG4gIGNvbnN0IG0gPSByYW5nZSA/IHJhbmdlLm1hdGNoKC9eYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKT8kLykgOiBudWxsXG4gIHJldHVybiBtXG4gICAgPyB7XG4gICAgICAgIHN0YXJ0OiBwYXJzZUludChtWzFdKSxcbiAgICAgICAgZW5kOiBtWzJdID8gcGFyc2VJbnQobVsyXSkgOiBudWxsLFxuICAgICAgICBzaXplOiBtWzNdID8gcGFyc2VJbnQobVszXSkgOiBudWxsXG4gICAgICB9XG4gICAgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGFkZExpc3RlbmVyIChvYmosIG5hbWUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGxpc3RlbmVycyA9IChvYmpba0xpc3RlbmVyc10gPz89IFtdKVxuICBsaXN0ZW5lcnMucHVzaChbbmFtZSwgbGlzdGVuZXJdKVxuICBvYmoub24obmFtZSwgbGlzdGVuZXIpXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzIChvYmopIHtcbiAgZm9yIChjb25zdCBbbmFtZSwgbGlzdGVuZXJdIG9mIG9ialtrTGlzdGVuZXJzXSA/PyBbXSkge1xuICAgIG9iai5yZW1vdmVMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcilcbiAgfVxuICBvYmpba0xpc3RlbmVyc10gPSBudWxsXG59XG5cbmZ1bmN0aW9uIGVycm9yUmVxdWVzdCAoY2xpZW50LCByZXF1ZXN0LCBlcnIpIHtcbiAgdHJ5IHtcbiAgICByZXF1ZXN0Lm9uRXJyb3IoZXJyKVxuICAgIGFzc2VydChyZXF1ZXN0LmFib3J0ZWQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNsaWVudC5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxufVxuXG5jb25zdCBrRW51bWVyYWJsZVByb3BlcnR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKVxua0VudW1lcmFibGVQcm9wZXJ0eS5lbnVtZXJhYmxlID0gdHJ1ZVxuXG5jb25zdCBub3JtYWxpemVkTWV0aG9kUmVjb3Jkc0Jhc2UgPSB7XG4gIGRlbGV0ZTogJ0RFTEVURScsXG4gIERFTEVURTogJ0RFTEVURScsXG4gIGdldDogJ0dFVCcsXG4gIEdFVDogJ0dFVCcsXG4gIGhlYWQ6ICdIRUFEJyxcbiAgSEVBRDogJ0hFQUQnLFxuICBvcHRpb25zOiAnT1BUSU9OUycsXG4gIE9QVElPTlM6ICdPUFRJT05TJyxcbiAgcG9zdDogJ1BPU1QnLFxuICBQT1NUOiAnUE9TVCcsXG4gIHB1dDogJ1BVVCcsXG4gIFBVVDogJ1BVVCdcbn1cblxuY29uc3Qgbm9ybWFsaXplZE1ldGhvZFJlY29yZHMgPSB7XG4gIC4uLm5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSxcbiAgcGF0Y2g6ICdwYXRjaCcsXG4gIFBBVENIOiAnUEFUQ0gnXG59XG5cbi8vIE5vdGU6IG9iamVjdCBwcm90b3R5cGVzIHNob3VsZCBub3QgYmUgYWJsZSB0byBiZSByZWZlcmVuY2VkLiBlLmcuIGBPYmplY3QjaGFzT3duUHJvcGVydHlgLlxuT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSwgbnVsbClcbk9iamVjdC5zZXRQcm90b3R5cGVPZihub3JtYWxpemVkTWV0aG9kUmVjb3JkcywgbnVsbClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG5vcCxcbiAgaXNEaXN0dXJiZWQsXG4gIGlzRXJyb3JlZCxcbiAgaXNSZWFkYWJsZSxcbiAgdG9VU1ZTdHJpbmcsXG4gIGlzVVNWU3RyaW5nLFxuICBpc0Jsb2JMaWtlLFxuICBwYXJzZU9yaWdpbixcbiAgcGFyc2VVUkwsXG4gIGdldFNlcnZlck5hbWUsXG4gIGlzU3RyZWFtLFxuICBpc0l0ZXJhYmxlLFxuICBpc0FzeW5jSXRlcmFibGUsXG4gIGlzRGVzdHJveWVkLFxuICBoZWFkZXJOYW1lVG9TdHJpbmcsXG4gIGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUsXG4gIGFkZExpc3RlbmVyLFxuICByZW1vdmVBbGxMaXN0ZW5lcnMsXG4gIGVycm9yUmVxdWVzdCxcbiAgcGFyc2VSYXdIZWFkZXJzLFxuICBwYXJzZUhlYWRlcnMsXG4gIHBhcnNlS2VlcEFsaXZlVGltZW91dCxcbiAgZGVzdHJveSxcbiAgYm9keUxlbmd0aCxcbiAgZGVlcENsb25lLFxuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIGlzQnVmZmVyLFxuICB2YWxpZGF0ZUhhbmRsZXIsXG4gIGdldFNvY2tldEluZm8sXG4gIGlzRm9ybURhdGFMaWtlLFxuICBidWlsZFVSTCxcbiAgYWRkQWJvcnRMaXN0ZW5lcixcbiAgaXNWYWxpZEhUVFBUb2tlbixcbiAgaXNWYWxpZEhlYWRlclZhbHVlLFxuICBpc1Rva2VuQ2hhckNvZGUsXG4gIHBhcnNlUmFuZ2VIZWFkZXIsXG4gIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSxcbiAgbm9ybWFsaXplZE1ldGhvZFJlY29yZHMsXG4gIGlzVmFsaWRQb3J0LFxuICBpc0h0dHBPckh0dHBzUHJlZml4ZWQsXG4gIG5vZGVNYWpvcixcbiAgbm9kZU1pbm9yLFxuICBzYWZlSFRUUE1ldGhvZHM6IFsnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdUUkFDRSddLFxuICB3cmFwUmVxdWVzdEJvZHlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/core/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/agent.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/agent.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst createRedirectInterceptor = __webpack_require__(/*! ../interceptor/redirect-interceptor */ \"(rsc)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\")\n\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends DispatcherBase {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kInterceptors] = options.interceptors?.Agent && Array.isArray(options.interceptors.Agent)\n      ? options.interceptors.Agent\n      : [createRedirectInterceptor({ maxRedirections })]\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n\n    this[kOnDrain] = (origin, targets) => {\n      this.emit('drain', origin, [this, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      this.emit('connect', origin, [this, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      this.emit('disconnect', origin, [this, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      this.emit('connectionError', origin, [this, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const client of this[kClients].values()) {\n      ret += client[kRunning]\n    }\n    return ret\n  }\n\n  [kDispatch] (opts, handler) {\n    let key\n    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n      key = String(opts.origin)\n    } else {\n      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n    }\n\n    let dispatcher = this[kClients].get(key)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](opts.origin, this[kOptions])\n        .on('drain', this[kOnDrain])\n        .on('connect', this[kOnConnect])\n        .on('disconnect', this[kOnDisconnect])\n        .on('connectionError', this[kOnConnectionError])\n\n      // This introduces a tiny memory leak, as dispatchers are never removed from the map.\n      // TODO(mcollina): remove te timer when the client/pool do not have any more\n      // active connections.\n      this[kClients].set(key, dispatcher)\n    }\n\n    return dispatcher.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    const closePromises = []\n    for (const client of this[kClients].values()) {\n      closePromises.push(client.close())\n    }\n    this[kClients].clear()\n\n    await Promise.all(closePromises)\n  }\n\n  async [kDestroy] (err) {\n    const destroyPromises = []\n    for (const client of this[kClients].values()) {\n      destroyPromises.push(client.destroy(err))\n    }\n    this[kClients].clear()\n\n    await Promise.all(destroyPromises)\n  }\n}\n\nmodule.exports = Agent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDekQsUUFBUSxpRUFBaUUsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUNwRyx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLGVBQWUsbUJBQU8sQ0FBQyxzRUFBVTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0VBQWM7QUFDbkMsa0NBQWtDLG1CQUFPLENBQUMsZ0hBQXFDOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHFFQUFxRSxJQUFJO0FBQzFGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQSxxQ0FBcUMsaUJBQWlCOztBQUV0RCx1QkFBdUI7QUFDdkI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsga0NsaWVudHMsIGtSdW5uaW5nLCBrQ2xvc2UsIGtEZXN0cm95LCBrRGlzcGF0Y2gsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBEaXNwYXRjaGVyQmFzZSA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci1iYXNlJylcbmNvbnN0IFBvb2wgPSByZXF1aXJlKCcuL3Bvb2wnKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi9jbGllbnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCBjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJjZXB0b3IvcmVkaXJlY3QtaW50ZXJjZXB0b3InKVxuXG5jb25zdCBrT25Db25uZWN0ID0gU3ltYm9sKCdvbkNvbm5lY3QnKVxuY29uc3Qga09uRGlzY29ubmVjdCA9IFN5bWJvbCgnb25EaXNjb25uZWN0JylcbmNvbnN0IGtPbkNvbm5lY3Rpb25FcnJvciA9IFN5bWJvbCgnb25Db25uZWN0aW9uRXJyb3InKVxuY29uc3Qga01heFJlZGlyZWN0aW9ucyA9IFN5bWJvbCgnbWF4UmVkaXJlY3Rpb25zJylcbmNvbnN0IGtPbkRyYWluID0gU3ltYm9sKCdvbkRyYWluJylcbmNvbnN0IGtGYWN0b3J5ID0gU3ltYm9sKCdmYWN0b3J5JylcbmNvbnN0IGtPcHRpb25zID0gU3ltYm9sKCdvcHRpb25zJylcblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gb3B0cyAmJiBvcHRzLmNvbm5lY3Rpb25zID09PSAxXG4gICAgPyBuZXcgQ2xpZW50KG9yaWdpbiwgb3B0cylcbiAgICA6IG5ldyBQb29sKG9yaWdpbiwgb3B0cylcbn1cblxuY2xhc3MgQWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yICh7IGZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSwgbWF4UmVkaXJlY3Rpb25zID0gMCwgY29ubmVjdCwgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAodHlwZW9mIGZhY3RvcnkgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignZmFjdG9yeSBtdXN0IGJlIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZWRpcmVjdGlvbnMpIHx8IG1heFJlZGlyZWN0aW9ucyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0geyAuLi5jb25uZWN0IH1cbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0aW9ucy5pbnRlcmNlcHRvcnM/LkFnZW50ICYmIEFycmF5LmlzQXJyYXkob3B0aW9ucy5pbnRlcmNlcHRvcnMuQWdlbnQpXG4gICAgICA/IG9wdGlvbnMuaW50ZXJjZXB0b3JzLkFnZW50XG4gICAgICA6IFtjcmVhdGVSZWRpcmVjdEludGVyY2VwdG9yKHsgbWF4UmVkaXJlY3Rpb25zIH0pXVxuXG4gICAgdGhpc1trT3B0aW9uc10gPSB7IC4uLnV0aWwuZGVlcENsb25lKG9wdGlvbnMpLCBjb25uZWN0IH1cbiAgICB0aGlzW2tPcHRpb25zXS5pbnRlcmNlcHRvcnMgPSBvcHRpb25zLmludGVyY2VwdG9yc1xuICAgICAgPyB7IC4uLm9wdGlvbnMuaW50ZXJjZXB0b3JzIH1cbiAgICAgIDogdW5kZWZpbmVkXG4gICAgdGhpc1trTWF4UmVkaXJlY3Rpb25zXSA9IG1heFJlZGlyZWN0aW9uc1xuICAgIHRoaXNba0ZhY3RvcnldID0gZmFjdG9yeVxuICAgIHRoaXNba0NsaWVudHNdID0gbmV3IE1hcCgpXG5cbiAgICB0aGlzW2tPbkRyYWluXSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nLCBvcmlnaW4sIFt0aGlzLCAuLi50YXJnZXRzXSlcbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3RdID0gKG9yaWdpbiwgdGFyZ2V0cykgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdjb25uZWN0Jywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10pXG4gICAgfVxuXG4gICAgdGhpc1trT25EaXNjb25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMsIGVycikgPT4ge1xuICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0Jywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG5cbiAgICB0aGlzW2tPbkNvbm5lY3Rpb25FcnJvcl0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIHRoaXMuZW1pdCgnY29ubmVjdGlvbkVycm9yJywgb3JpZ2luLCBbdGhpcywgLi4udGFyZ2V0c10sIGVycilcbiAgICB9XG4gIH1cblxuICBnZXQgW2tSdW5uaW5nXSAoKSB7XG4gICAgbGV0IHJldCA9IDBcbiAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzW2tDbGllbnRzXS52YWx1ZXMoKSkge1xuICAgICAgcmV0ICs9IGNsaWVudFtrUnVubmluZ11cbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgW2tEaXNwYXRjaF0gKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBsZXQga2V5XG4gICAgaWYgKG9wdHMub3JpZ2luICYmICh0eXBlb2Ygb3B0cy5vcmlnaW4gPT09ICdzdHJpbmcnIHx8IG9wdHMub3JpZ2luIGluc3RhbmNlb2YgVVJMKSkge1xuICAgICAga2V5ID0gU3RyaW5nKG9wdHMub3JpZ2luKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMub3JpZ2luIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nIG9yIFVSTC4nKVxuICAgIH1cblxuICAgIGxldCBkaXNwYXRjaGVyID0gdGhpc1trQ2xpZW50c10uZ2V0KGtleSlcblxuICAgIGlmICghZGlzcGF0Y2hlcikge1xuICAgICAgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKG9wdHMub3JpZ2luLCB0aGlzW2tPcHRpb25zXSlcbiAgICAgICAgLm9uKCdkcmFpbicsIHRoaXNba09uRHJhaW5dKVxuICAgICAgICAub24oJ2Nvbm5lY3QnLCB0aGlzW2tPbkNvbm5lY3RdKVxuICAgICAgICAub24oJ2Rpc2Nvbm5lY3QnLCB0aGlzW2tPbkRpc2Nvbm5lY3RdKVxuICAgICAgICAub24oJ2Nvbm5lY3Rpb25FcnJvcicsIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSlcblxuICAgICAgLy8gVGhpcyBpbnRyb2R1Y2VzIGEgdGlueSBtZW1vcnkgbGVhaywgYXMgZGlzcGF0Y2hlcnMgYXJlIG5ldmVyIHJlbW92ZWQgZnJvbSB0aGUgbWFwLlxuICAgICAgLy8gVE9ETyhtY29sbGluYSk6IHJlbW92ZSB0ZSB0aW1lciB3aGVuIHRoZSBjbGllbnQvcG9vbCBkbyBub3QgaGF2ZSBhbnkgbW9yZVxuICAgICAgLy8gYWN0aXZlIGNvbm5lY3Rpb25zLlxuICAgICAgdGhpc1trQ2xpZW50c10uc2V0KGtleSwgZGlzcGF0Y2hlcilcbiAgICB9XG5cbiAgICByZXR1cm4gZGlzcGF0Y2hlci5kaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGNvbnN0IGNsb3NlUHJvbWlzZXMgPSBbXVxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICBjbG9zZVByb21pc2VzLnB1c2goY2xpZW50LmNsb3NlKCkpXG4gICAgfVxuICAgIHRoaXNba0NsaWVudHNdLmNsZWFyKClcblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGNsb3NlUHJvbWlzZXMpXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICBjb25zdCBkZXN0cm95UHJvbWlzZXMgPSBbXVxuICAgIGZvciAoY29uc3QgY2xpZW50IG9mIHRoaXNba0NsaWVudHNdLnZhbHVlcygpKSB7XG4gICAgICBkZXN0cm95UHJvbWlzZXMucHVzaChjbGllbnQuZGVzdHJveShlcnIpKVxuICAgIH1cbiAgICB0aGlzW2tDbGllbnRzXS5jbGVhcigpXG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChkZXN0cm95UHJvbWlzZXMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBZ2VudFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/balanced-pool.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/balanced-pool.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  BalancedPoolMissingUpstreamError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = __webpack_require__(/*! ./pool-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { parseOrigin } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst kFactory = Symbol('factory')\n\nconst kOptions = Symbol('options')\nconst kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')\nconst kCurrentWeight = Symbol('kCurrentWeight')\nconst kIndex = Symbol('kIndex')\nconst kWeight = Symbol('kWeight')\nconst kMaxWeightPerServer = Symbol('kMaxWeightPerServer')\nconst kErrorPenalty = Symbol('kErrorPenalty')\n\n/**\n * Calculate the greatest common divisor of two numbers by\n * using the Euclidean algorithm.\n *\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction getGreatestCommonDivisor (a, b) {\n  if (a === 0) return b\n\n  while (b !== 0) {\n    const t = b\n    b = a % b\n    a = t\n  }\n  return a\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {\n    super()\n\n    this[kOptions] = opts\n    this[kIndex] = -1\n    this[kCurrentWeight] = 0\n\n    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100\n    this[kErrorPenalty] = this[kOptions].errorPenalty || 15\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    this[kInterceptors] = opts.interceptors?.BalancedPool && Array.isArray(opts.interceptors.BalancedPool)\n      ? opts.interceptors.BalancedPool\n      : []\n    this[kFactory] = factory\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n    this._updateBalancedPoolStats()\n  }\n\n  addUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))\n\n    this[kAddClient](pool)\n    pool.on('connect', () => {\n      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])\n    })\n\n    pool.on('connectionError', () => {\n      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n      this._updateBalancedPoolStats()\n    })\n\n    pool.on('disconnect', (...args) => {\n      const err = args[2]\n      if (err && err.code === 'UND_ERR_SOCKET') {\n        // decrease the weight of the pool.\n        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])\n        this._updateBalancedPoolStats()\n      }\n    })\n\n    for (const client of this[kClients]) {\n      client[kWeight] = this[kMaxWeightPerServer]\n    }\n\n    this._updateBalancedPoolStats()\n\n    return this\n  }\n\n  _updateBalancedPoolStats () {\n    let result = 0\n    for (let i = 0; i < this[kClients].length; i++) {\n      result = getGreatestCommonDivisor(this[kClients][i][kWeight], result)\n    }\n\n    this[kGreatestCommonDivisor] = result\n  }\n\n  removeUpstream (upstream) {\n    const upstreamOrigin = parseOrigin(upstream).origin\n\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstreamOrigin &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)\n\n    if (allClientsBusy) {\n      return\n    }\n\n    let counter = 0\n\n    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])\n\n    while (counter++ < this[kClients].length) {\n      this[kIndex] = (this[kIndex] + 1) % this[kClients].length\n      const pool = this[kClients][this[kIndex]]\n\n      // find pool index with the largest weight\n      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {\n        maxWeightIndex = this[kIndex]\n      }\n\n      // decrease the current weight every `this[kClients].length`.\n      if (this[kIndex] === 0) {\n        // Set the current weight to the next lower weight.\n        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]\n\n        if (this[kCurrentWeight] <= 0) {\n          this[kCurrentWeight] = this[kMaxWeightPerServer]\n        }\n      }\n      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {\n        return pool\n      }\n    }\n\n    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]\n    this[kIndex] = maxWeightIndex\n    return this[kClients][maxWeightIndex]\n  }\n}\n\nmodule.exports = BalancedPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2JhbGFuY2VkLXBvb2wuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWE7QUFDekIsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDekQsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsb0NBQW9DLElBQUk7QUFDekU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGJhbGFuY2VkLXBvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgQmFsYW5jZWRQb29sTWlzc2luZ1Vwc3RyZWFtRXJyb3IsXG4gIEludmFsaWRBcmd1bWVudEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3Qge1xuICBQb29sQmFzZSxcbiAga0NsaWVudHMsXG4gIGtOZWVkRHJhaW4sXG4gIGtBZGRDbGllbnQsXG4gIGtSZW1vdmVDbGllbnQsXG4gIGtHZXREaXNwYXRjaGVyXG59ID0gcmVxdWlyZSgnLi9wb29sLWJhc2UnKVxuY29uc3QgUG9vbCA9IHJlcXVpcmUoJy4vcG9vbCcpXG5jb25zdCB7IGtVcmwsIGtJbnRlcmNlcHRvcnMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IHBhcnNlT3JpZ2luIH0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3Qga0ZhY3RvcnkgPSBTeW1ib2woJ2ZhY3RvcnknKVxuXG5jb25zdCBrT3B0aW9ucyA9IFN5bWJvbCgnb3B0aW9ucycpXG5jb25zdCBrR3JlYXRlc3RDb21tb25EaXZpc29yID0gU3ltYm9sKCdrR3JlYXRlc3RDb21tb25EaXZpc29yJylcbmNvbnN0IGtDdXJyZW50V2VpZ2h0ID0gU3ltYm9sKCdrQ3VycmVudFdlaWdodCcpXG5jb25zdCBrSW5kZXggPSBTeW1ib2woJ2tJbmRleCcpXG5jb25zdCBrV2VpZ2h0ID0gU3ltYm9sKCdrV2VpZ2h0JylcbmNvbnN0IGtNYXhXZWlnaHRQZXJTZXJ2ZXIgPSBTeW1ib2woJ2tNYXhXZWlnaHRQZXJTZXJ2ZXInKVxuY29uc3Qga0Vycm9yUGVuYWx0eSA9IFN5bWJvbCgna0Vycm9yUGVuYWx0eScpXG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBncmVhdGVzdCBjb21tb24gZGl2aXNvciBvZiB0d28gbnVtYmVycyBieVxuICogdXNpbmcgdGhlIEV1Y2xpZGVhbiBhbGdvcml0aG0uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBiXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRHcmVhdGVzdENvbW1vbkRpdmlzb3IgKGEsIGIpIHtcbiAgaWYgKGEgPT09IDApIHJldHVybiBiXG5cbiAgd2hpbGUgKGIgIT09IDApIHtcbiAgICBjb25zdCB0ID0gYlxuICAgIGIgPSBhICUgYlxuICAgIGEgPSB0XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEZhY3RvcnkgKG9yaWdpbiwgb3B0cykge1xuICByZXR1cm4gbmV3IFBvb2wob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBCYWxhbmNlZFBvb2wgZXh0ZW5kcyBQb29sQmFzZSB7XG4gIGNvbnN0cnVjdG9yICh1cHN0cmVhbXMgPSBbXSwgeyBmYWN0b3J5ID0gZGVmYXVsdEZhY3RvcnksIC4uLm9wdHMgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trT3B0aW9uc10gPSBvcHRzXG4gICAgdGhpc1trSW5kZXhdID0gLTFcbiAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IDBcblxuICAgIHRoaXNba01heFdlaWdodFBlclNlcnZlcl0gPSB0aGlzW2tPcHRpb25zXS5tYXhXZWlnaHRQZXJTZXJ2ZXIgfHwgMTAwXG4gICAgdGhpc1trRXJyb3JQZW5hbHR5XSA9IHRoaXNba09wdGlvbnNdLmVycm9yUGVuYWx0eSB8fCAxNVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHVwc3RyZWFtcykpIHtcbiAgICAgIHVwc3RyZWFtcyA9IFt1cHN0cmVhbXNdXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmYWN0b3J5ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdHMuaW50ZXJjZXB0b3JzPy5CYWxhbmNlZFBvb2wgJiYgQXJyYXkuaXNBcnJheShvcHRzLmludGVyY2VwdG9ycy5CYWxhbmNlZFBvb2wpXG4gICAgICA/IG9wdHMuaW50ZXJjZXB0b3JzLkJhbGFuY2VkUG9vbFxuICAgICAgOiBbXVxuICAgIHRoaXNba0ZhY3RvcnldID0gZmFjdG9yeVxuXG4gICAgZm9yIChjb25zdCB1cHN0cmVhbSBvZiB1cHN0cmVhbXMpIHtcbiAgICAgIHRoaXMuYWRkVXBzdHJlYW0odXBzdHJlYW0pXG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcbiAgfVxuXG4gIGFkZFVwc3RyZWFtICh1cHN0cmVhbSkge1xuICAgIGNvbnN0IHVwc3RyZWFtT3JpZ2luID0gcGFyc2VPcmlnaW4odXBzdHJlYW0pLm9yaWdpblxuXG4gICAgaWYgKHRoaXNba0NsaWVudHNdLmZpbmQoKHBvb2wpID0+IChcbiAgICAgIHBvb2xba1VybF0ub3JpZ2luID09PSB1cHN0cmVhbU9yaWdpbiAmJlxuICAgICAgcG9vbC5jbG9zZWQgIT09IHRydWUgJiZcbiAgICAgIHBvb2wuZGVzdHJveWVkICE9PSB0cnVlXG4gICAgKSkpIHtcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGNvbnN0IHBvb2wgPSB0aGlzW2tGYWN0b3J5XSh1cHN0cmVhbU9yaWdpbiwgT2JqZWN0LmFzc2lnbih7fSwgdGhpc1trT3B0aW9uc10pKVxuXG4gICAgdGhpc1trQWRkQ2xpZW50XShwb29sKVxuICAgIHBvb2wub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBwb29sW2tXZWlnaHRdID0gTWF0aC5taW4odGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXSwgcG9vbFtrV2VpZ2h0XSArIHRoaXNba0Vycm9yUGVuYWx0eV0pXG4gICAgfSlcblxuICAgIHBvb2wub24oJ2Nvbm5lY3Rpb25FcnJvcicsICgpID0+IHtcbiAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1heCgxLCBwb29sW2tXZWlnaHRdIC0gdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcbiAgICB9KVxuXG4gICAgcG9vbC5vbignZGlzY29ubmVjdCcsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSBhcmdzWzJdXG4gICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnVU5EX0VSUl9TT0NLRVQnKSB7XG4gICAgICAgIC8vIGRlY3JlYXNlIHRoZSB3ZWlnaHQgb2YgdGhlIHBvb2wuXG4gICAgICAgIHBvb2xba1dlaWdodF0gPSBNYXRoLm1heCgxLCBwb29sW2tXZWlnaHRdIC0gdGhpc1trRXJyb3JQZW5hbHR5XSlcbiAgICAgICAgdGhpcy5fdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgY2xpZW50W2tXZWlnaHRdID0gdGhpc1trTWF4V2VpZ2h0UGVyU2VydmVyXVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZUJhbGFuY2VkUG9vbFN0YXRzKClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBfdXBkYXRlQmFsYW5jZWRQb29sU3RhdHMgKCkge1xuICAgIGxldCByZXN1bHQgPSAwXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzW2tDbGllbnRzXS5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0ID0gZ2V0R3JlYXRlc3RDb21tb25EaXZpc29yKHRoaXNba0NsaWVudHNdW2ldW2tXZWlnaHRdLCByZXN1bHQpXG4gICAgfVxuXG4gICAgdGhpc1trR3JlYXRlc3RDb21tb25EaXZpc29yXSA9IHJlc3VsdFxuICB9XG5cbiAgcmVtb3ZlVXBzdHJlYW0gKHVwc3RyZWFtKSB7XG4gICAgY29uc3QgdXBzdHJlYW1PcmlnaW4gPSBwYXJzZU9yaWdpbih1cHN0cmVhbSkub3JpZ2luXG5cbiAgICBjb25zdCBwb29sID0gdGhpc1trQ2xpZW50c10uZmluZCgocG9vbCkgPT4gKFxuICAgICAgcG9vbFtrVXJsXS5vcmlnaW4gPT09IHVwc3RyZWFtT3JpZ2luICYmXG4gICAgICBwb29sLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgcG9vbC5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuXG4gICAgaWYgKHBvb2wpIHtcbiAgICAgIHRoaXNba1JlbW92ZUNsaWVudF0ocG9vbClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IHVwc3RyZWFtcyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0NsaWVudHNdXG4gICAgICAuZmlsdGVyKGRpc3BhdGNoZXIgPT4gZGlzcGF0Y2hlci5jbG9zZWQgIT09IHRydWUgJiYgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWUpXG4gICAgICAubWFwKChwKSA9PiBwW2tVcmxdLm9yaWdpbilcbiAgfVxuXG4gIFtrR2V0RGlzcGF0Y2hlcl0gKCkge1xuICAgIC8vIFdlIHZhbGlkYXRlIHRoYXQgcG9vbHMgaXMgZ3JlYXRlciB0aGFuIDAsXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdvdWxkIGhhdmUgdG8gd2FpdCB1bnRpbCBhbiB1cHN0cmVhbVxuICAgIC8vIGlzIGFkZGVkLCB3aGljaCBtaWdodCBuZXZlciBoYXBwZW4uXG4gICAgaWYgKHRoaXNba0NsaWVudHNdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEJhbGFuY2VkUG9vbE1pc3NpbmdVcHN0cmVhbUVycm9yKClcbiAgICB9XG5cbiAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trQ2xpZW50c10uZmluZChkaXNwYXRjaGVyID0+IChcbiAgICAgICFkaXNwYXRjaGVyW2tOZWVkRHJhaW5dICYmXG4gICAgICBkaXNwYXRjaGVyLmNsb3NlZCAhPT0gdHJ1ZSAmJlxuICAgICAgZGlzcGF0Y2hlci5kZXN0cm95ZWQgIT09IHRydWVcbiAgICApKVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBhbGxDbGllbnRzQnVzeSA9IHRoaXNba0NsaWVudHNdLm1hcChwb29sID0+IHBvb2xba05lZWREcmFpbl0pLnJlZHVjZSgoYSwgYikgPT4gYSAmJiBiLCB0cnVlKVxuXG4gICAgaWYgKGFsbENsaWVudHNCdXN5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgY291bnRlciA9IDBcblxuICAgIGxldCBtYXhXZWlnaHRJbmRleCA9IHRoaXNba0NsaWVudHNdLmZpbmRJbmRleChwb29sID0+ICFwb29sW2tOZWVkRHJhaW5dKVxuXG4gICAgd2hpbGUgKGNvdW50ZXIrKyA8IHRoaXNba0NsaWVudHNdLmxlbmd0aCkge1xuICAgICAgdGhpc1trSW5kZXhdID0gKHRoaXNba0luZGV4XSArIDEpICUgdGhpc1trQ2xpZW50c10ubGVuZ3RoXG4gICAgICBjb25zdCBwb29sID0gdGhpc1trQ2xpZW50c11bdGhpc1trSW5kZXhdXVxuXG4gICAgICAvLyBmaW5kIHBvb2wgaW5kZXggd2l0aCB0aGUgbGFyZ2VzdCB3ZWlnaHRcbiAgICAgIGlmIChwb29sW2tXZWlnaHRdID4gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdW2tXZWlnaHRdICYmICFwb29sW2tOZWVkRHJhaW5dKSB7XG4gICAgICAgIG1heFdlaWdodEluZGV4ID0gdGhpc1trSW5kZXhdXG4gICAgICB9XG5cbiAgICAgIC8vIGRlY3JlYXNlIHRoZSBjdXJyZW50IHdlaWdodCBldmVyeSBgdGhpc1trQ2xpZW50c10ubGVuZ3RoYC5cbiAgICAgIGlmICh0aGlzW2tJbmRleF0gPT09IDApIHtcbiAgICAgICAgLy8gU2V0IHRoZSBjdXJyZW50IHdlaWdodCB0byB0aGUgbmV4dCBsb3dlciB3ZWlnaHQuXG4gICAgICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trQ3VycmVudFdlaWdodF0gLSB0aGlzW2tHcmVhdGVzdENvbW1vbkRpdmlzb3JdXG5cbiAgICAgICAgaWYgKHRoaXNba0N1cnJlbnRXZWlnaHRdIDw9IDApIHtcbiAgICAgICAgICB0aGlzW2tDdXJyZW50V2VpZ2h0XSA9IHRoaXNba01heFdlaWdodFBlclNlcnZlcl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBvb2xba1dlaWdodF0gPj0gdGhpc1trQ3VycmVudFdlaWdodF0gJiYgKCFwb29sW2tOZWVkRHJhaW5dKSkge1xuICAgICAgICByZXR1cm4gcG9vbFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNba0N1cnJlbnRXZWlnaHRdID0gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdW2tXZWlnaHRdXG4gICAgdGhpc1trSW5kZXhdID0gbWF4V2VpZ2h0SW5kZXhcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c11bbWF4V2VpZ2h0SW5kZXhdXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYWxhbmNlZFBvb2xcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/balanced-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/client-h1.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h1.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n/* global WebAssembly */\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst timers = __webpack_require__(/*! ../util/timers.js */ \"(rsc)/./node_modules/undici/lib/util/timers.js\")\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kParser,\n  kBlocking,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kMaxRequests,\n  kCounter,\n  kMaxResponseSize,\n  kOnError,\n  kResume,\n  kHTTPContext\n} = __webpack_require__(/*! ../core/symbols.js */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nconst constants = __webpack_require__(/*! ../llhttp/constants.js */ \"(rsc)/./node_modules/undici/lib/llhttp/constants.js\")\nconst EMPTY_BUF = Buffer.alloc(0)\nconst FastBuffer = Buffer[Symbol.species]\nconst addListener = util.addListener\nconst removeAllListeners = util.removeAllListeners\n\nlet extractBody\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\") : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(__webpack_require__(/*! ../llhttp/llhttp_simd-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\"))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(llhttpWasmData || __webpack_require__(/*! ../llhttp/llhttp-wasm.js */ \"(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\"))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert(currentParser.ptr === p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert(currentParser.ptr === p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\nllhttpPromise.catch()\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst USE_NATIVE_TIMER = 0\nconst USE_FAST_TIMER = 1\n\n// Use fast timers for headers and body to take eventual event loop\n// latency into account.\nconst TIMEOUT_HEADERS = 2 | USE_FAST_TIMER\nconst TIMEOUT_BODY = 4 | USE_FAST_TIMER\n\n// Use native timers to ignore event loop latency for keep-alive\n// handling.\nconst TIMEOUT_KEEP_ALIVE = 8 | USE_NATIVE_TIMER\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (delay, type) {\n    // If the existing timer and the new timer are of different timer type\n    // (fast or native) or have different delay, we need to clear the existing\n    // timer and set a new one.\n    if (\n      delay !== this.timeoutValue ||\n      (type & USE_FAST_TIMER) ^ (this.timeoutType & USE_FAST_TIMER)\n    ) {\n      // If a timeout is already set, clear it with clearTimeout of the fast\n      // timer implementation, as it can clear fast and native timers.\n      if (this.timeout) {\n        timers.clearTimeout(this.timeout)\n        this.timeout = null\n      }\n\n      if (delay) {\n        if (type & USE_FAST_TIMER) {\n          this.timeout = timers.setFastTimeout(onParserTimeout, delay, new WeakRef(this))\n        } else {\n          this.timeout = setTimeout(onParserTimeout, delay, new WeakRef(this))\n          this.timeout.unref()\n        }\n      }\n\n      this.timeoutValue = delay\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.timeoutType = type\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message =\n            'Response does not match the HTTP/1.1 protocol (' +\n            Buffer.from(llhttp.memory.buffer, ptr, len).toString() +\n            ')'\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    this.timeout && timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n    request.onResponseStarted()\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10) {\n      const headerName = util.bufferToLowerCasedHeaderName(key)\n      if (headerName === 'keep-alive') {\n        this.keepAlive += buf.toString()\n      } else if (headerName === 'connection') {\n        this.connection += buf.toString()\n      }\n    } else if (key.length === 14 && util.bufferToLowerCasedHeaderName(key) === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n    assert(client[kSocket] === socket)\n    assert(!socket.destroyed)\n    assert(!this.paused)\n    assert((headers.length & 1) === 0)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n\n    removeAllListeners(socket)\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    client[kResume]()\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert(this.timeoutType === TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert((this.headers.length & 1) === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n\n    if (request.aborted) {\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      client[kResume]()\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    if (request.onData(buf) === false) {\n      return constants.ERROR.PAUSED\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    assert(statusCode >= 100)\n    assert((this.headers.length & 1) === 0)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    request.onComplete(headers)\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert(client[kRunning] === 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] == null || client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(() => client[kResume]())\n    } else {\n      client[kResume]()\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client, paused } = parser.deref()\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_KEEP_ALIVE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nasync function connectH1 (client, socket) {\n  client[kSocket] = socket\n\n  if (!llhttpInstance) {\n    llhttpInstance = await llhttpPromise\n    llhttpPromise = null\n  }\n\n  socket[kNoRef] = false\n  socket[kWriting] = false\n  socket[kReset] = false\n  socket[kBlocking] = false\n  socket[kParser] = new Parser(client, socket, llhttpInstance)\n\n  addListener(socket, 'error', function (err) {\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n    const parser = this[kParser]\n\n    // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n    // to the user.\n    if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so for as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n\n    this[kError] = err\n\n    this[kClient][kOnError](err)\n  })\n  addListener(socket, 'readable', function () {\n    const parser = this[kParser]\n\n    if (parser) {\n      parser.readMore()\n    }\n  })\n  addListener(socket, 'end', function () {\n    const parser = this[kParser]\n\n    if (parser.statusCode && !parser.shouldKeepAlive) {\n      // We treat all incoming data so far as a valid response.\n      parser.onMessageComplete()\n      return\n    }\n\n    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n  })\n  addListener(socket, 'close', function () {\n    const client = this[kClient]\n    const parser = this[kParser]\n\n    if (parser) {\n      if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {\n        // We treat all incoming data so far as a valid response.\n        parser.onMessageComplete()\n      }\n\n      this[kParser].destroy()\n      this[kParser] = null\n    }\n\n    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n    client[kSocket] = null\n    client[kHTTPContext] = null // TODO (fix): This is hacky...\n\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n\n      // Fail entire queue.\n      const requests = client[kQueue].splice(client[kRunningIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(client, request, err)\n      }\n    } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n      // Fail head of pipeline.\n      const request = client[kQueue][client[kRunningIdx]]\n      client[kQueue][client[kRunningIdx]++] = null\n\n      util.errorRequest(client, request, err)\n    }\n\n    client[kPendingIdx] = client[kRunningIdx]\n\n    assert(client[kRunning] === 0)\n\n    client.emit('disconnect', client[kUrl], [client], err)\n\n    client[kResume]()\n  })\n\n  let closed = false\n  socket.on('close', () => {\n    closed = true\n  })\n\n  return {\n    version: 'h1',\n    defaultPipelining: 1,\n    write (...args) {\n      return writeH1(client, ...args)\n    },\n    resume () {\n      resumeH1(client)\n    },\n    destroy (err, callback) {\n      if (closed) {\n        queueMicrotask(callback)\n      } else {\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    get destroyed () {\n      return socket.destroyed\n    },\n    busy (request) {\n      if (socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n        return true\n      }\n\n      if (request) {\n        if (client[kRunning] > 0 && !request.idempotent) {\n          // Non-idempotent request cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n\n        if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n          // Don't dispatch an upgrade until all preceding requests have completed.\n          // A misbehaving server might upgrade the connection before all pipelined\n          // request has completed.\n          return true\n        }\n\n        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 &&\n          (util.isStream(request.body) || util.isAsyncIterable(request.body) || util.isFormDataLike(request.body))) {\n          // Request with stream or iterator body can error while other requests\n          // are inflight and indirectly error those as well.\n          // Ensure this doesn't happen by waiting for inflight\n          // to complete before dispatching.\n\n          // Request with stream or iterator body cannot be retried.\n          // Ensure that no other requests are inflight and\n          // could cause failure.\n          return true\n        }\n      }\n\n      return false\n    }\n  }\n}\n\nfunction resumeH1 (client) {\n  const socket = client[kSocket]\n\n  if (socket && !socket.destroyed) {\n    if (client[kSize] === 0) {\n      if (!socket[kNoRef] && socket.unref) {\n        socket.unref()\n        socket[kNoRef] = true\n      }\n    } else if (socket[kNoRef] && socket.ref) {\n      socket.ref()\n      socket[kNoRef] = false\n    }\n\n    if (client[kSize] === 0) {\n      if (socket[kParser].timeoutType !== TIMEOUT_KEEP_ALIVE) {\n        socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_KEEP_ALIVE)\n      }\n    } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n      if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n        const request = client[kQueue][client[kRunningIdx]]\n        const headersTimeout = request.headersTimeout != null\n          ? request.headersTimeout\n          : client[kHeadersTimeout]\n        socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n      }\n    }\n  }\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH1 (client, request) {\n  const { method, path, host, upgrade, blocking, reset } = request\n\n  let { body, headers, contentLength } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH' ||\n    method === 'QUERY' ||\n    method === 'PROPFIND' ||\n    method === 'PROPPATCH'\n  )\n\n  if (util.isFormDataLike(body)) {\n    if (!extractBody) {\n      extractBody = (__webpack_require__(/*! ../web/fetch/body.js */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\").extractBody)\n    }\n\n    const [bodyStream, contentType] = extractBody(body)\n    if (request.contentType == null) {\n      headers.push('content-type', contentType)\n    }\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  } else if (util.isBlobLike(body) && request.contentType == null && body.type) {\n    headers.push('content-type', body.type)\n  }\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  const bodyLength = util.bodyLength(body)\n\n  contentLength = bodyLength ?? contentLength\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    util.errorRequest(client, request, err || new RequestAbortedError())\n\n    util.destroy(body)\n    util.destroy(socket, new InformationalError('aborted'))\n  }\n\n  try {\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (Array.isArray(headers)) {\n    for (let n = 0; n < headers.length; n += 2) {\n      const key = headers[n + 0]\n      const val = headers[n + 1]\n\n      if (Array.isArray(val)) {\n        for (let i = 0; i < val.length; i++) {\n          header += `${key}: ${val[i]}\\r\\n`\n        }\n      } else {\n        header += `${key}: ${val}\\r\\n`\n      }\n    }\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body || bodyLength === 0) {\n    writeBuffer(abort, null, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBuffer(body)) {\n    writeBuffer(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable(abort, body.stream(), client, request, socket, contentLength, header, expectsPayload)\n    } else {\n      writeBlob(abort, body, client, request, socket, contentLength, header, expectsPayload)\n    }\n  } else if (util.isStream(body)) {\n    writeStream(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else if (util.isIterable(body)) {\n    writeIterable(abort, body, client, request, socket, contentLength, header, expectsPayload)\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    if (finished) {\n      return\n    }\n\n    try {\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    if (finished) {\n      return\n    }\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onClose = function () {\n    // 'close' might be emitted *before* 'error' for\n    // broken streams. Wait a tick to avoid this case.\n    queueMicrotask(() => {\n      // It's only safe to remove 'error' listener after\n      // 'close'.\n      body.removeListener('error', onFinished)\n    })\n\n    if (!finished) {\n      const err = new RequestAbortedError()\n      queueMicrotask(() => onFinished(err))\n    }\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('close', onClose)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onClose)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n\n  if (body.errorEmitted ?? body.errored) {\n    setImmediate(() => onFinished(body.errored))\n  } else if (body.endEmitted ?? body.readableEnded) {\n    setImmediate(() => onFinished(null))\n  }\n\n  if (body.closeEmitted ?? body.closed) {\n    setImmediate(onClose)\n  }\n}\n\nfunction writeBuffer (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  try {\n    if (!body) {\n      if (contentLength === 0) {\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        assert(contentLength === null, 'no body must not have content length')\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n      socket.cork()\n      socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      socket.write(body)\n      socket.uncork()\n      request.onBodySent(body)\n\n      if (!expectsPayload && request.reset !== false) {\n        socket[kReset] = true\n      }\n    }\n    request.onRequestSent()\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeBlob (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload && request.reset !== false) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, body, client, request, socket, contentLength, header, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ abort, socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ abort, socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n    this.abort = abort\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    socket.cork()\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload && request.reset !== false) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'latin1')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'latin1')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    socket.uncork()\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'latin1')\n      } else {\n        socket.write(`${header}\\r\\n`, 'latin1')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'latin1')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    client[kResume]()\n  }\n\n  destroy (err) {\n    const { socket, client, abort } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      abort(err)\n    }\n  }\n}\n\nmodule.exports = connectH1\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQSxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0QyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUF3QjtBQUNyRCxlQUFlLG1CQUFPLENBQUMseUVBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjs7QUFFaEMsa0JBQWtCLG1CQUFPLENBQUMsbUZBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esc0RBQXNELG1CQUFPLENBQUMsdUZBQTBCOztBQUV4RjtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFPLENBQUMsaUdBQStCO0FBQzNFLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxtQkFBTyxDQUFDLHVGQUEwQjtBQUN4Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsU0FBUztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGlCQUFpQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGlCQUFpQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0NBQStDOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHNDQUFzQzs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksOENBQThDOztBQUUxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksMEZBQTBGOztBQUV0RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxzQ0FBc0M7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsK0NBQStDOztBQUV6RCxRQUFRLCtCQUErQjs7QUFFdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixrSEFBMkM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFFBQVEsRUFBRSxNQUFNOztBQUVsQztBQUNBLHVCQUF1QixLQUFLO0FBQzVCLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDLHVCQUF1QixJQUFJLElBQUksT0FBTztBQUN0QztBQUNBLFFBQVE7QUFDUixxQkFBcUIsSUFBSSxJQUFJLElBQUk7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLGtDQUFrQztBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1DQUFtQyx1RUFBdUU7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0IsUUFBUTtBQUNSO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxzQkFBc0IsT0FBTyxrQkFBa0IsY0FBYztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPLGtCQUFrQixjQUFjO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyx1RUFBdUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUVBQXVFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0VBQStFOztBQUUzRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLFFBQVE7QUFDUix3QkFBd0IsT0FBTyxrQkFBa0IsY0FBYztBQUMvRDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLCtFQUErRTtBQUMzRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsT0FBTztBQUMvQixRQUFRO0FBQ1Isd0JBQXdCLE9BQU87QUFDL0I7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx3QkFBd0I7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxjbGllbnQtaDEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qIGdsb2JhbCBXZWJBc3NlbWJseSAqL1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsLmpzJylcbmNvbnN0IHsgY2hhbm5lbHMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZGlhZ25vc3RpY3MuanMnKVxuY29uc3QgdGltZXJzID0gcmVxdWlyZSgnLi4vdXRpbC90aW1lcnMuanMnKVxuY29uc3Qge1xuICBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gIFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIEhlYWRlcnNUaW1lb3V0RXJyb3IsXG4gIEhlYWRlcnNPdmVyZmxvd0Vycm9yLFxuICBTb2NrZXRFcnJvcixcbiAgSW5mb3JtYXRpb25hbEVycm9yLFxuICBCb2R5VGltZW91dEVycm9yLFxuICBIVFRQUGFyc2VyRXJyb3IsXG4gIFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycy5qcycpXG5jb25zdCB7XG4gIGtVcmwsXG4gIGtSZXNldCxcbiAga0NsaWVudCxcbiAga1BhcnNlcixcbiAga0Jsb2NraW5nLFxuICBrUnVubmluZyxcbiAga1BlbmRpbmcsXG4gIGtTaXplLFxuICBrV3JpdGluZyxcbiAga1F1ZXVlLFxuICBrTm9SZWYsXG4gIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCxcbiAga0hvc3RIZWFkZXIsXG4gIGtQZW5kaW5nSWR4LFxuICBrUnVubmluZ0lkeCxcbiAga0Vycm9yLFxuICBrUGlwZWxpbmluZyxcbiAga1NvY2tldCxcbiAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSxcbiAga01heEhlYWRlcnNTaXplLFxuICBrS2VlcEFsaXZlTWF4VGltZW91dCxcbiAga0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQsXG4gIGtIZWFkZXJzVGltZW91dCxcbiAga0JvZHlUaW1lb3V0LFxuICBrU3RyaWN0Q29udGVudExlbmd0aCxcbiAga01heFJlcXVlc3RzLFxuICBrQ291bnRlcixcbiAga01heFJlc3BvbnNlU2l6ZSxcbiAga09uRXJyb3IsXG4gIGtSZXN1bWUsXG4gIGtIVFRQQ29udGV4dFxufSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scy5qcycpXG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2xsaHR0cC9jb25zdGFudHMuanMnKVxuY29uc3QgRU1QVFlfQlVGID0gQnVmZmVyLmFsbG9jKDApXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXVxuY29uc3QgYWRkTGlzdGVuZXIgPSB1dGlsLmFkZExpc3RlbmVyXG5jb25zdCByZW1vdmVBbGxMaXN0ZW5lcnMgPSB1dGlsLnJlbW92ZUFsbExpc3RlbmVyc1xuXG5sZXQgZXh0cmFjdEJvZHlcblxuYXN5bmMgZnVuY3Rpb24gbGF6eWxsaHR0cCAoKSB7XG4gIGNvbnN0IGxsaHR0cFdhc21EYXRhID0gcHJvY2Vzcy5lbnYuSkVTVF9XT1JLRVJfSUQgPyByZXF1aXJlKCcuLi9sbGh0dHAvbGxodHRwLXdhc20uanMnKSA6IHVuZGVmaW5lZFxuXG4gIGxldCBtb2RcbiAgdHJ5IHtcbiAgICBtb2QgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHJlcXVpcmUoJy4uL2xsaHR0cC9sbGh0dHBfc2ltZC13YXNtLmpzJykpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gICAgLy8gV2UgY291bGQgY2hlY2sgaWYgdGhlIGVycm9yIHdhcyBjYXVzZWQgYnkgdGhlIHNpbWQgb3B0aW9uIG5vdFxuICAgIC8vIGJlaW5nIGVuYWJsZWQsIGJ1dCB0aGUgb2NjdXJyaW5nIG9mIHRoaXMgb3RoZXIgZXJyb3JcbiAgICAvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lbXNjcmlwdGVuLWNvcmUvZW1zY3JpcHRlbi9pc3N1ZXMvMTE0OTVcbiAgICAvLyBnb3QgbWUgdG8gcmVtb3ZlIHRoYXQgY2hlY2sgdG8gYXZvaWQgYnJlYWtpbmcgTm9kZSAxMi5cbiAgICBtb2QgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKGxsaHR0cFdhc21EYXRhIHx8IHJlcXVpcmUoJy4uL2xsaHR0cC9sbGh0dHAtd2FzbS5qcycpKVxuICB9XG5cbiAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKG1vZCwge1xuICAgIGVudjoge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG5cbiAgICAgIHdhc21fb25fdXJsOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fc3RhdHVzOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQoY3VycmVudFBhcnNlci5wdHIgPT09IHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uU3RhdHVzKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25fbWVzc2FnZV9iZWdpbjogKHApID0+IHtcbiAgICAgICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIucHRyID09PSBwKVxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbk1lc3NhZ2VCZWdpbigpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX2hlYWRlcl9maWVsZDogKHAsIGF0LCBsZW4pID0+IHtcbiAgICAgICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIucHRyID09PSBwKVxuICAgICAgICBjb25zdCBzdGFydCA9IGF0IC0gY3VycmVudEJ1ZmZlclB0ciArIGN1cnJlbnRCdWZmZXJSZWYuYnl0ZU9mZnNldFxuICAgICAgICByZXR1cm4gY3VycmVudFBhcnNlci5vbkhlYWRlckZpZWxkKG5ldyBGYXN0QnVmZmVyKGN1cnJlbnRCdWZmZXJSZWYuYnVmZmVyLCBzdGFydCwgbGVuKSkgfHwgMFxuICAgICAgfSxcbiAgICAgIHdhc21fb25faGVhZGVyX3ZhbHVlOiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQoY3VycmVudFBhcnNlci5wdHIgPT09IHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uSGVhZGVyVmFsdWUobmV3IEZhc3RCdWZmZXIoY3VycmVudEJ1ZmZlclJlZi5idWZmZXIsIHN0YXJ0LCBsZW4pKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9oZWFkZXJzX2NvbXBsZXRlOiAocCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgc2hvdWxkS2VlcEFsaXZlKSA9PiB7XG4gICAgICAgIGFzc2VydChjdXJyZW50UGFyc2VyLnB0ciA9PT0gcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25IZWFkZXJzQ29tcGxldGUoc3RhdHVzQ29kZSwgQm9vbGVhbih1cGdyYWRlKSwgQm9vbGVhbihzaG91bGRLZWVwQWxpdmUpKSB8fCAwXG4gICAgICB9LFxuICAgICAgd2FzbV9vbl9ib2R5OiAocCwgYXQsIGxlbikgPT4ge1xuICAgICAgICBhc3NlcnQoY3VycmVudFBhcnNlci5wdHIgPT09IHApXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gYXQgLSBjdXJyZW50QnVmZmVyUHRyICsgY3VycmVudEJ1ZmZlclJlZi5ieXRlT2Zmc2V0XG4gICAgICAgIHJldHVybiBjdXJyZW50UGFyc2VyLm9uQm9keShuZXcgRmFzdEJ1ZmZlcihjdXJyZW50QnVmZmVyUmVmLmJ1ZmZlciwgc3RhcnQsIGxlbikpIHx8IDBcbiAgICAgIH0sXG4gICAgICB3YXNtX29uX21lc3NhZ2VfY29tcGxldGU6IChwKSA9PiB7XG4gICAgICAgIGFzc2VydChjdXJyZW50UGFyc2VyLnB0ciA9PT0gcClcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRQYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKSB8fCAwXG4gICAgICB9XG5cbiAgICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgfVxuICB9KVxufVxuXG5sZXQgbGxodHRwSW5zdGFuY2UgPSBudWxsXG5sZXQgbGxodHRwUHJvbWlzZSA9IGxhenlsbGh0dHAoKVxubGxodHRwUHJvbWlzZS5jYXRjaCgpXG5cbmxldCBjdXJyZW50UGFyc2VyID0gbnVsbFxubGV0IGN1cnJlbnRCdWZmZXJSZWYgPSBudWxsXG5sZXQgY3VycmVudEJ1ZmZlclNpemUgPSAwXG5sZXQgY3VycmVudEJ1ZmZlclB0ciA9IG51bGxcblxuY29uc3QgVVNFX05BVElWRV9USU1FUiA9IDBcbmNvbnN0IFVTRV9GQVNUX1RJTUVSID0gMVxuXG4vLyBVc2UgZmFzdCB0aW1lcnMgZm9yIGhlYWRlcnMgYW5kIGJvZHkgdG8gdGFrZSBldmVudHVhbCBldmVudCBsb29wXG4vLyBsYXRlbmN5IGludG8gYWNjb3VudC5cbmNvbnN0IFRJTUVPVVRfSEVBREVSUyA9IDIgfCBVU0VfRkFTVF9USU1FUlxuY29uc3QgVElNRU9VVF9CT0RZID0gNCB8IFVTRV9GQVNUX1RJTUVSXG5cbi8vIFVzZSBuYXRpdmUgdGltZXJzIHRvIGlnbm9yZSBldmVudCBsb29wIGxhdGVuY3kgZm9yIGtlZXAtYWxpdmVcbi8vIGhhbmRsaW5nLlxuY29uc3QgVElNRU9VVF9LRUVQX0FMSVZFID0gOCB8IFVTRV9OQVRJVkVfVElNRVJcblxuY2xhc3MgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IgKGNsaWVudCwgc29ja2V0LCB7IGV4cG9ydHMgfSkge1xuICAgIGFzc2VydChOdW1iZXIuaXNGaW5pdGUoY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV0pICYmIGNsaWVudFtrTWF4SGVhZGVyc1NpemVdID4gMClcblxuICAgIHRoaXMubGxodHRwID0gZXhwb3J0c1xuICAgIHRoaXMucHRyID0gdGhpcy5sbGh0dHAubGxodHRwX2FsbG9jKGNvbnN0YW50cy5UWVBFLlJFU1BPTlNFKVxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VmFsdWUgPSBudWxsXG4gICAgdGhpcy50aW1lb3V0VHlwZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLnVwZ3JhZGUgPSBmYWxzZVxuICAgIHRoaXMuaGVhZGVycyA9IFtdXG4gICAgdGhpcy5oZWFkZXJzU2l6ZSA9IDBcbiAgICB0aGlzLmhlYWRlcnNNYXhTaXplID0gY2xpZW50W2tNYXhIZWFkZXJzU2l6ZV1cbiAgICB0aGlzLnNob3VsZEtlZXBBbGl2ZSA9IGZhbHNlXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICAgIHRoaXMucmVzdW1lID0gdGhpcy5yZXN1bWUuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5ieXRlc1JlYWQgPSAwXG5cbiAgICB0aGlzLmtlZXBBbGl2ZSA9ICcnXG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gJydcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSAnJ1xuICAgIHRoaXMubWF4UmVzcG9uc2VTaXplID0gY2xpZW50W2tNYXhSZXNwb25zZVNpemVdXG4gIH1cblxuICBzZXRUaW1lb3V0IChkZWxheSwgdHlwZSkge1xuICAgIC8vIElmIHRoZSBleGlzdGluZyB0aW1lciBhbmQgdGhlIG5ldyB0aW1lciBhcmUgb2YgZGlmZmVyZW50IHRpbWVyIHR5cGVcbiAgICAvLyAoZmFzdCBvciBuYXRpdmUpIG9yIGhhdmUgZGlmZmVyZW50IGRlbGF5LCB3ZSBuZWVkIHRvIGNsZWFyIHRoZSBleGlzdGluZ1xuICAgIC8vIHRpbWVyIGFuZCBzZXQgYSBuZXcgb25lLlxuICAgIGlmIChcbiAgICAgIGRlbGF5ICE9PSB0aGlzLnRpbWVvdXRWYWx1ZSB8fFxuICAgICAgKHR5cGUgJiBVU0VfRkFTVF9USU1FUikgXiAodGhpcy50aW1lb3V0VHlwZSAmIFVTRV9GQVNUX1RJTUVSKVxuICAgICkge1xuICAgICAgLy8gSWYgYSB0aW1lb3V0IGlzIGFscmVhZHkgc2V0LCBjbGVhciBpdCB3aXRoIGNsZWFyVGltZW91dCBvZiB0aGUgZmFzdFxuICAgICAgLy8gdGltZXIgaW1wbGVtZW50YXRpb24sIGFzIGl0IGNhbiBjbGVhciBmYXN0IGFuZCBuYXRpdmUgdGltZXJzLlxuICAgICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgICB0aW1lcnMuY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dClcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgaWYgKHR5cGUgJiBVU0VfRkFTVF9USU1FUikge1xuICAgICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVycy5zZXRGYXN0VGltZW91dChvblBhcnNlclRpbWVvdXQsIGRlbGF5LCBuZXcgV2Vha1JlZih0aGlzKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KG9uUGFyc2VyVGltZW91dCwgZGVsYXksIG5ldyBXZWFrUmVmKHRoaXMpKVxuICAgICAgICAgIHRoaXMudGltZW91dC51bnJlZigpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy50aW1lb3V0VmFsdWUgPSBkZWxheVxuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnRpbWVvdXRUeXBlID0gdHlwZVxuICB9XG5cbiAgcmVzdW1lICgpIHtcbiAgICBpZiAodGhpcy5zb2NrZXQuZGVzdHJveWVkIHx8ICF0aGlzLnBhdXNlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbClcblxuICAgIHRoaXMubGxodHRwLmxsaHR0cF9yZXN1bWUodGhpcy5wdHIpXG5cbiAgICBhc3NlcnQodGhpcy50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9CT0RZKVxuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICBpZiAodGhpcy50aW1lb3V0LnJlZnJlc2gpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgICB0aGlzLmV4ZWN1dGUodGhpcy5zb2NrZXQucmVhZCgpIHx8IEVNUFRZX0JVRikgLy8gRmx1c2ggcGFyc2VyLlxuICAgIHRoaXMucmVhZE1vcmUoKVxuICB9XG5cbiAgcmVhZE1vcmUgKCkge1xuICAgIHdoaWxlICghdGhpcy5wYXVzZWQgJiYgdGhpcy5wdHIpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5zb2NrZXQucmVhZCgpXG4gICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0ZShjaHVuaylcbiAgICB9XG4gIH1cblxuICBleGVjdXRlIChkYXRhKSB7XG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbClcbiAgICBhc3NlcnQoIXRoaXMucGF1c2VkKVxuXG4gICAgY29uc3QgeyBzb2NrZXQsIGxsaHR0cCB9ID0gdGhpc1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gY3VycmVudEJ1ZmZlclNpemUpIHtcbiAgICAgIGlmIChjdXJyZW50QnVmZmVyUHRyKSB7XG4gICAgICAgIGxsaHR0cC5mcmVlKGN1cnJlbnRCdWZmZXJQdHIpXG4gICAgICB9XG4gICAgICBjdXJyZW50QnVmZmVyU2l6ZSA9IE1hdGguY2VpbChkYXRhLmxlbmd0aCAvIDQwOTYpICogNDA5NlxuICAgICAgY3VycmVudEJ1ZmZlclB0ciA9IGxsaHR0cC5tYWxsb2MoY3VycmVudEJ1ZmZlclNpemUpXG4gICAgfVxuXG4gICAgbmV3IFVpbnQ4QXJyYXkobGxodHRwLm1lbW9yeS5idWZmZXIsIGN1cnJlbnRCdWZmZXJQdHIsIGN1cnJlbnRCdWZmZXJTaXplKS5zZXQoZGF0YSlcblxuICAgIC8vIENhbGwgYGV4ZWN1dGVgIG9uIHRoZSB3YXNtIHBhcnNlci5cbiAgICAvLyBXZSBwYXNzIHRoZSBgbGxodHRwX3BhcnNlcmAgcG9pbnRlciBhZGRyZXNzLCB0aGUgcG9pbnRlciBhZGRyZXNzIG9mIGJ1ZmZlciB2aWV3IGRhdGEsXG4gICAgLy8gYW5kIGZpbmFsbHkgdGhlIGxlbmd0aCBvZiBieXRlcyB0byBwYXJzZS5cbiAgICAvLyBUaGUgcmV0dXJuIHZhbHVlIGlzIGFuIGVycm9yIGNvZGUgb3IgYGNvbnN0YW50cy5FUlJPUi5PS2AuXG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXRcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY3VycmVudEJ1ZmZlclJlZiA9IGRhdGFcbiAgICAgICAgY3VycmVudFBhcnNlciA9IHRoaXNcbiAgICAgICAgcmV0ID0gbGxodHRwLmxsaHR0cF9leGVjdXRlKHRoaXMucHRyLCBjdXJyZW50QnVmZmVyUHRyLCBkYXRhLmxlbmd0aClcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2F0Y2ggKi9cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY3VycmVudFBhcnNlciA9IG51bGxcbiAgICAgICAgY3VycmVudEJ1ZmZlclJlZiA9IG51bGxcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2Zmc2V0ID0gbGxodHRwLmxsaHR0cF9nZXRfZXJyb3JfcG9zKHRoaXMucHRyKSAtIGN1cnJlbnRCdWZmZXJQdHJcblxuICAgICAgaWYgKHJldCA9PT0gY29uc3RhbnRzLkVSUk9SLlBBVVNFRF9VUEdSQURFKSB7XG4gICAgICAgIHRoaXMub25VcGdyYWRlKGRhdGEuc2xpY2Uob2Zmc2V0KSlcbiAgICAgIH0gZWxzZSBpZiAocmV0ID09PSBjb25zdGFudHMuRVJST1IuUEFVU0VEKSB7XG4gICAgICAgIHRoaXMucGF1c2VkID0gdHJ1ZVxuICAgICAgICBzb2NrZXQudW5zaGlmdChkYXRhLnNsaWNlKG9mZnNldCkpXG4gICAgICB9IGVsc2UgaWYgKHJldCAhPT0gY29uc3RhbnRzLkVSUk9SLk9LKSB7XG4gICAgICAgIGNvbnN0IHB0ciA9IGxsaHR0cC5sbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbih0aGlzLnB0cilcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSAnJ1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgICAgIGlmIChwdHIpIHtcbiAgICAgICAgICBjb25zdCBsZW4gPSBuZXcgVWludDhBcnJheShsbGh0dHAubWVtb3J5LmJ1ZmZlciwgcHRyKS5pbmRleE9mKDApXG4gICAgICAgICAgbWVzc2FnZSA9XG4gICAgICAgICAgICAnUmVzcG9uc2UgZG9lcyBub3QgbWF0Y2ggdGhlIEhUVFAvMS4xIHByb3RvY29sICgnICtcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGxsaHR0cC5tZW1vcnkuYnVmZmVyLCBwdHIsIGxlbikudG9TdHJpbmcoKSArXG4gICAgICAgICAgICAnKSdcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgSFRUUFBhcnNlckVycm9yKG1lc3NhZ2UsIGNvbnN0YW50cy5FUlJPUltyZXRdLCBkYXRhLnNsaWNlKG9mZnNldCkpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucHRyICE9IG51bGwpXG4gICAgYXNzZXJ0KGN1cnJlbnRQYXJzZXIgPT0gbnVsbClcblxuICAgIHRoaXMubGxodHRwLmxsaHR0cF9mcmVlKHRoaXMucHRyKVxuICAgIHRoaXMucHRyID0gbnVsbFxuXG4gICAgdGhpcy50aW1lb3V0ICYmIHRpbWVycy5jbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KVxuICAgIHRoaXMudGltZW91dCA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRWYWx1ZSA9IG51bGxcbiAgICB0aGlzLnRpbWVvdXRUeXBlID0gbnVsbFxuXG4gICAgdGhpcy5wYXVzZWQgPSBmYWxzZVxuICB9XG5cbiAgb25TdGF0dXMgKGJ1Zikge1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IGJ1Zi50b1N0cmluZygpXG4gIH1cblxuICBvbk1lc3NhZ2VCZWdpbiAoKSB7XG4gICAgY29uc3QgeyBzb2NrZXQsIGNsaWVudCB9ID0gdGhpc1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXF1ZXN0Lm9uUmVzcG9uc2VTdGFydGVkKClcbiAgfVxuXG4gIG9uSGVhZGVyRmllbGQgKGJ1Zikge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuaGVhZGVycy5sZW5ndGhcblxuICAgIGlmICgobGVuICYgMSkgPT09IDApIHtcbiAgICAgIHRoaXMuaGVhZGVycy5wdXNoKGJ1ZilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWFkZXJzW2xlbiAtIDFdID0gQnVmZmVyLmNvbmNhdChbdGhpcy5oZWFkZXJzW2xlbiAtIDFdLCBidWZdKVxuICAgIH1cblxuICAgIHRoaXMudHJhY2tIZWFkZXIoYnVmLmxlbmd0aClcbiAgfVxuXG4gIG9uSGVhZGVyVmFsdWUgKGJ1Zikge1xuICAgIGxldCBsZW4gPSB0aGlzLmhlYWRlcnMubGVuZ3RoXG5cbiAgICBpZiAoKGxlbiAmIDEpID09PSAxKSB7XG4gICAgICB0aGlzLmhlYWRlcnMucHVzaChidWYpXG4gICAgICBsZW4gKz0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlYWRlcnNbbGVuIC0gMV0gPSBCdWZmZXIuY29uY2F0KFt0aGlzLmhlYWRlcnNbbGVuIC0gMV0sIGJ1Zl0pXG4gICAgfVxuXG4gICAgY29uc3Qga2V5ID0gdGhpcy5oZWFkZXJzW2xlbiAtIDJdXG4gICAgaWYgKGtleS5sZW5ndGggPT09IDEwKSB7XG4gICAgICBjb25zdCBoZWFkZXJOYW1lID0gdXRpbC5idWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lKGtleSlcbiAgICAgIGlmIChoZWFkZXJOYW1lID09PSAna2VlcC1hbGl2ZScpIHtcbiAgICAgICAgdGhpcy5rZWVwQWxpdmUgKz0gYnVmLnRvU3RyaW5nKClcbiAgICAgIH0gZWxzZSBpZiAoaGVhZGVyTmFtZSA9PT0gJ2Nvbm5lY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiArPSBidWYudG9TdHJpbmcoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoa2V5Lmxlbmd0aCA9PT0gMTQgJiYgdXRpbC5idWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lKGtleSkgPT09ICdjb250ZW50LWxlbmd0aCcpIHtcbiAgICAgIHRoaXMuY29udGVudExlbmd0aCArPSBidWYudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIHRoaXMudHJhY2tIZWFkZXIoYnVmLmxlbmd0aClcbiAgfVxuXG4gIHRyYWNrSGVhZGVyIChsZW4pIHtcbiAgICB0aGlzLmhlYWRlcnNTaXplICs9IGxlblxuICAgIGlmICh0aGlzLmhlYWRlcnNTaXplID49IHRoaXMuaGVhZGVyc01heFNpemUpIHtcbiAgICAgIHV0aWwuZGVzdHJveSh0aGlzLnNvY2tldCwgbmV3IEhlYWRlcnNPdmVyZmxvd0Vycm9yKCkpXG4gICAgfVxuICB9XG5cbiAgb25VcGdyYWRlIChoZWFkKSB7XG4gICAgY29uc3QgeyB1cGdyYWRlLCBjbGllbnQsIHNvY2tldCwgaGVhZGVycywgc3RhdHVzQ29kZSB9ID0gdGhpc1xuXG4gICAgYXNzZXJ0KHVwZ3JhZGUpXG4gICAgYXNzZXJ0KGNsaWVudFtrU29ja2V0XSA9PT0gc29ja2V0KVxuICAgIGFzc2VydCghc29ja2V0LmRlc3Ryb3llZClcbiAgICBhc3NlcnQoIXRoaXMucGF1c2VkKVxuICAgIGFzc2VydCgoaGVhZGVycy5sZW5ndGggJiAxKSA9PT0gMClcblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGFzc2VydChyZXF1ZXN0KVxuICAgIGFzc2VydChyZXF1ZXN0LnVwZ3JhZGUgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJylcblxuICAgIHRoaXMuc3RhdHVzQ29kZSA9IG51bGxcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnJ1xuICAgIHRoaXMuc2hvdWxkS2VlcEFsaXZlID0gbnVsbFxuXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgc29ja2V0LnVuc2hpZnQoaGVhZClcblxuICAgIHNvY2tldFtrUGFyc2VyXS5kZXN0cm95KClcbiAgICBzb2NrZXRba1BhcnNlcl0gPSBudWxsXG5cbiAgICBzb2NrZXRba0NsaWVudF0gPSBudWxsXG4gICAgc29ja2V0W2tFcnJvcl0gPSBudWxsXG5cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoc29ja2V0KVxuXG4gICAgY2xpZW50W2tTb2NrZXRdID0gbnVsbFxuICAgIGNsaWVudFtrSFRUUENvbnRleHRdID0gbnVsbCAvLyBUT0RPIChmaXgpOiBUaGlzIGlzIGhhY2t5Li4uXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcbiAgICBjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0sIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3VwZ3JhZGUnKSlcblxuICAgIHRyeSB7XG4gICAgICByZXF1ZXN0Lm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBlcnIpXG4gICAgfVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfVxuXG4gIG9uSGVhZGVyc0NvbXBsZXRlIChzdGF0dXNDb2RlLCB1cGdyYWRlLCBzaG91bGRLZWVwQWxpdmUpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBoZWFkZXJzLCBzdGF0dXNUZXh0IH0gPSB0aGlzXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogZGlmZmljdWx0IHRvIG1ha2UgYSB0ZXN0IGNhc2UgZm9yICovXG4gICAgaWYgKHNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRpZmZpY3VsdCB0byBtYWtlIGEgdGVzdCBjYXNlIGZvciAqL1xuICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgYXNzZXJ0KCF0aGlzLnVwZ3JhZGUpXG4gICAgYXNzZXJ0KHRoaXMuc3RhdHVzQ29kZSA8IDIwMClcblxuICAgIGlmIChzdGF0dXNDb2RlID09PSAxMDApIHtcbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBTb2NrZXRFcnJvcignYmFkIHJlc3BvbnNlJywgdXRpbC5nZXRTb2NrZXRJbmZvKHNvY2tldCkpKVxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuXG4gICAgLyogdGhpcyBjYW4gb25seSBoYXBwZW4gaWYgc2VydmVyIGlzIG1pc2JlaGF2aW5nICovXG4gICAgaWYgKHVwZ3JhZGUgJiYgIXJlcXVlc3QudXBncmFkZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFNvY2tldEVycm9yKCdiYWQgdXBncmFkZScsIHV0aWwuZ2V0U29ja2V0SW5mbyhzb2NrZXQpKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGFzc2VydCh0aGlzLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0hFQURFUlMpXG5cbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlXG4gICAgdGhpcy5zaG91bGRLZWVwQWxpdmUgPSAoXG4gICAgICBzaG91bGRLZWVwQWxpdmUgfHxcbiAgICAgIC8vIE92ZXJyaWRlIGxsaHR0cCB2YWx1ZSB3aGljaCBkb2VzIG5vdCBhbGxvdyBrZWVwQWxpdmUgZm9yIEhFQUQuXG4gICAgICAocmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJyAmJiAhc29ja2V0W2tSZXNldF0gJiYgdGhpcy5jb25uZWN0aW9uLnRvTG93ZXJDYXNlKCkgPT09ICdrZWVwLWFsaXZlJylcbiAgICApXG5cbiAgICBpZiAodGhpcy5zdGF0dXNDb2RlID49IDIwMCkge1xuICAgICAgY29uc3QgYm9keVRpbWVvdXQgPSByZXF1ZXN0LmJvZHlUaW1lb3V0ICE9IG51bGxcbiAgICAgICAgPyByZXF1ZXN0LmJvZHlUaW1lb3V0XG4gICAgICAgIDogY2xpZW50W2tCb2R5VGltZW91dF1cbiAgICAgIHRoaXMuc2V0VGltZW91dChib2R5VGltZW91dCwgVElNRU9VVF9CT0RZKVxuICAgIH0gZWxzZSBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogb25seSBmb3IgamVzdFxuICAgICAgaWYgKHRoaXMudGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHRoaXMudGltZW91dC5yZWZyZXNoKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJykge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDEpXG4gICAgICB0aGlzLnVwZ3JhZGUgPSB0cnVlXG4gICAgICByZXR1cm4gMlxuICAgIH1cblxuICAgIGlmICh1cGdyYWRlKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMSlcbiAgICAgIHRoaXMudXBncmFkZSA9IHRydWVcbiAgICAgIHJldHVybiAyXG4gICAgfVxuXG4gICAgYXNzZXJ0KCh0aGlzLmhlYWRlcnMubGVuZ3RoICYgMSkgPT09IDApXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgaWYgKHRoaXMuc2hvdWxkS2VlcEFsaXZlICYmIGNsaWVudFtrUGlwZWxpbmluZ10pIHtcbiAgICAgIGNvbnN0IGtlZXBBbGl2ZVRpbWVvdXQgPSB0aGlzLmtlZXBBbGl2ZSA/IHV0aWwucGFyc2VLZWVwQWxpdmVUaW1lb3V0KHRoaXMua2VlcEFsaXZlKSA6IG51bGxcblxuICAgICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gTWF0aC5taW4oXG4gICAgICAgICAga2VlcEFsaXZlVGltZW91dCAtIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFRocmVzaG9sZF0sXG4gICAgICAgICAgY2xpZW50W2tLZWVwQWxpdmVNYXhUaW1lb3V0XVxuICAgICAgICApXG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0gPSB0aW1lb3V0XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsaWVudFtrS2VlcEFsaXZlVGltZW91dFZhbHVlXSA9IGNsaWVudFtrS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0b3AgbW9yZSByZXF1ZXN0cyBmcm9tIGJlaW5nIGRpc3BhdGNoZWQuXG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBwYXVzZSA9IHJlcXVlc3Qub25IZWFkZXJzKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHRoaXMucmVzdW1lLCBzdGF0dXNUZXh0KSA9PT0gZmFsc2VcblxuICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGlmIChzdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba0Jsb2NraW5nXSkge1xuICAgICAgc29ja2V0W2tCbG9ja2luZ10gPSBmYWxzZVxuICAgICAgY2xpZW50W2tSZXN1bWVdKClcbiAgICB9XG5cbiAgICByZXR1cm4gcGF1c2UgPyBjb25zdGFudHMuRVJST1IuUEFVU0VEIDogMFxuICB9XG5cbiAgb25Cb2R5IChidWYpIHtcbiAgICBjb25zdCB7IGNsaWVudCwgc29ja2V0LCBzdGF0dXNDb2RlLCBtYXhSZXNwb25zZVNpemUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0ID0gY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XV1cbiAgICBhc3NlcnQocmVxdWVzdClcblxuICAgIGFzc2VydCh0aGlzLnRpbWVvdXRUeXBlID09PSBUSU1FT1VUX0JPRFkpXG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmICh0aGlzLnRpbWVvdXQucmVmcmVzaCkge1xuICAgICAgICB0aGlzLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXNzZXJ0KHN0YXR1c0NvZGUgPj0gMjAwKVxuXG4gICAgaWYgKG1heFJlc3BvbnNlU2l6ZSA+IC0xICYmIHRoaXMuYnl0ZXNSZWFkICsgYnVmLmxlbmd0aCA+IG1heFJlc3BvbnNlU2l6ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlRXhjZWVkZWRNYXhTaXplRXJyb3IoKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNSZWFkICs9IGJ1Zi5sZW5ndGhcblxuICAgIGlmIChyZXF1ZXN0Lm9uRGF0YShidWYpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGNvbnN0YW50cy5FUlJPUi5QQVVTRURcbiAgICB9XG4gIH1cblxuICBvbk1lc3NhZ2VDb21wbGV0ZSAoKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIHNvY2tldCwgc3RhdHVzQ29kZSwgdXBncmFkZSwgaGVhZGVycywgY29udGVudExlbmd0aCwgYnl0ZXNSZWFkLCBzaG91bGRLZWVwQWxpdmUgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXQuZGVzdHJveWVkICYmICghc3RhdHVzQ29kZSB8fCBzaG91bGRLZWVwQWxpdmUpKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgYXNzZXJ0KHN0YXR1c0NvZGUgPj0gMTAwKVxuICAgIGFzc2VydCgodGhpcy5oZWFkZXJzLmxlbmd0aCAmIDEpID09PSAwKVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgYXNzZXJ0KHJlcXVlc3QpXG5cbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBudWxsXG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gJydcbiAgICB0aGlzLmJ5dGVzUmVhZCA9IDBcbiAgICB0aGlzLmNvbnRlbnRMZW5ndGggPSAnJ1xuICAgIHRoaXMua2VlcEFsaXZlID0gJydcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSAnJ1xuXG4gICAgdGhpcy5oZWFkZXJzID0gW11cbiAgICB0aGlzLmhlYWRlcnNTaXplID0gMFxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPCAyMDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgYmUgaGFuZGxlZCBieSBsbGh0dHA/ICovXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnSEVBRCcgJiYgY29udGVudExlbmd0aCAmJiBieXRlc1JlYWQgIT09IHBhcnNlSW50KGNvbnRlbnRMZW5ndGgsIDEwKSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IFJlc3BvbnNlQ29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiAtMVxuICAgIH1cblxuICAgIHJlcXVlc3Qub25Db21wbGV0ZShoZWFkZXJzKVxuXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgIGlmIChzb2NrZXRba1dyaXRpbmddKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcbiAgICAgIC8vIFJlc3BvbnNlIGNvbXBsZXRlZCBiZWZvcmUgcmVxdWVzdC5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoIXNob3VsZEtlZXBBbGl2ZSkge1xuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEluZm9ybWF0aW9uYWxFcnJvcigncmVzZXQnKSlcbiAgICAgIHJldHVybiBjb25zdGFudHMuRVJST1IuUEFVU0VEXG4gICAgfSBlbHNlIGlmIChzb2NrZXRba1Jlc2V0XSAmJiBjbGllbnRba1J1bm5pbmddID09PSAwKSB7XG4gICAgICAvLyBEZXN0cm95IHNvY2tldCBvbmNlIGFsbCByZXF1ZXN0cyBoYXZlIGNvbXBsZXRlZC5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGF0IHRoZSB0YWlsIG9mIHRoZSBwaXBlbGluZSBpcyB0aGUgb25lXG4gICAgICAvLyB0aGF0IHJlcXVlc3RlZCByZXNldCBhbmQgbm8gZnVydGhlciByZXF1ZXN0cyBzaG91bGRcbiAgICAgIC8vIGhhdmUgYmVlbiBxdWV1ZWQgc2luY2UgdGhlbi5cbiAgICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3Jlc2V0JykpXG4gICAgICByZXR1cm4gY29uc3RhbnRzLkVSUk9SLlBBVVNFRFxuICAgIH0gZWxzZSBpZiAoY2xpZW50W2tQaXBlbGluaW5nXSA9PSBudWxsIHx8IGNsaWVudFtrUGlwZWxpbmluZ10gPT09IDEpIHtcbiAgICAgIC8vIFdlIG11c3Qgd2FpdCBhIGZ1bGwgZXZlbnQgbG9vcCBjeWNsZSB0byByZXVzZSB0aGlzIHNvY2tldCB0byBtYWtlIHN1cmVcbiAgICAgIC8vIHRoYXQgbm9uLXNwZWMgY29tcGxpYW50IHNlcnZlcnMgYXJlIG5vdCBjbG9zaW5nIHRoZSBjb25uZWN0aW9uIGV2ZW4gaWYgdGhleVxuICAgICAgLy8gc2FpZCB0aGV5IHdvbid0LlxuICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IGNsaWVudFtrUmVzdW1lXSgpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblBhcnNlclRpbWVvdXQgKHBhcnNlcikge1xuICBjb25zdCB7IHNvY2tldCwgdGltZW91dFR5cGUsIGNsaWVudCwgcGF1c2VkIH0gPSBwYXJzZXIuZGVyZWYoKVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgaWYgKCFzb2NrZXRba1dyaXRpbmddIHx8IHNvY2tldC53cml0YWJsZU5lZWREcmFpbiB8fCBjbGllbnRba1J1bm5pbmddID4gMSkge1xuICAgICAgYXNzZXJ0KCFwYXVzZWQsICdjYW5ub3QgYmUgcGF1c2VkIHdoaWxlIHdhaXRpbmcgZm9yIGhlYWRlcnMnKVxuICAgICAgdXRpbC5kZXN0cm95KHNvY2tldCwgbmV3IEhlYWRlcnNUaW1lb3V0RXJyb3IoKSlcbiAgICB9XG4gIH0gZWxzZSBpZiAodGltZW91dFR5cGUgPT09IFRJTUVPVVRfQk9EWSkge1xuICAgIGlmICghcGF1c2VkKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0LCBuZXcgQm9keVRpbWVvdXRFcnJvcigpKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9LRUVQX0FMSVZFKSB7XG4gICAgYXNzZXJ0KGNsaWVudFtrUnVubmluZ10gPT09IDAgJiYgY2xpZW50W2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdKVxuICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ3NvY2tldCBpZGxlIHRpbWVvdXQnKSlcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0SDEgKGNsaWVudCwgc29ja2V0KSB7XG4gIGNsaWVudFtrU29ja2V0XSA9IHNvY2tldFxuXG4gIGlmICghbGxodHRwSW5zdGFuY2UpIHtcbiAgICBsbGh0dHBJbnN0YW5jZSA9IGF3YWl0IGxsaHR0cFByb21pc2VcbiAgICBsbGh0dHBQcm9taXNlID0gbnVsbFxuICB9XG5cbiAgc29ja2V0W2tOb1JlZl0gPSBmYWxzZVxuICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcbiAgc29ja2V0W2tSZXNldF0gPSBmYWxzZVxuICBzb2NrZXRba0Jsb2NraW5nXSA9IGZhbHNlXG4gIHNvY2tldFtrUGFyc2VyXSA9IG5ldyBQYXJzZXIoY2xpZW50LCBzb2NrZXQsIGxsaHR0cEluc3RhbmNlKVxuXG4gIGFkZExpc3RlbmVyKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgIGFzc2VydChlcnIuY29kZSAhPT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKVxuXG4gICAgY29uc3QgcGFyc2VyID0gdGhpc1trUGFyc2VyXVxuXG4gICAgLy8gT24gTWFjIE9TLCB3ZSBnZXQgYW4gRUNPTk5SRVNFVCBldmVuIGlmIHRoZXJlIGlzIGEgZnVsbCBib2R5IHRvIGJlIGZvcndhcmRlZFxuICAgIC8vIHRvIHRoZSB1c2VyLlxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VDT05OUkVTRVQnICYmIHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAvLyBXZSB0cmVhdCBhbGwgaW5jb21pbmcgZGF0YSBzbyBmb3IgYXMgYSB2YWxpZCByZXNwb25zZS5cbiAgICAgIHBhcnNlci5vbk1lc3NhZ2VDb21wbGV0ZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzW2tFcnJvcl0gPSBlcnJcblxuICAgIHRoaXNba0NsaWVudF1ba09uRXJyb3JdKGVycilcbiAgfSlcbiAgYWRkTGlzdGVuZXIoc29ja2V0LCAncmVhZGFibGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcGFyc2VyID0gdGhpc1trUGFyc2VyXVxuXG4gICAgaWYgKHBhcnNlcikge1xuICAgICAgcGFyc2VyLnJlYWRNb3JlKClcbiAgICB9XG4gIH0pXG4gIGFkZExpc3RlbmVyKHNvY2tldCwgJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBwYXJzZXIgPSB0aGlzW2tQYXJzZXJdXG5cbiAgICBpZiAocGFyc2VyLnN0YXR1c0NvZGUgJiYgIXBhcnNlci5zaG91bGRLZWVwQWxpdmUpIHtcbiAgICAgIC8vIFdlIHRyZWF0IGFsbCBpbmNvbWluZyBkYXRhIHNvIGZhciBhcyBhIHZhbGlkIHJlc3BvbnNlLlxuICAgICAgcGFyc2VyLm9uTWVzc2FnZUNvbXBsZXRlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHV0aWwuZGVzdHJveSh0aGlzLCBuZXcgU29ja2V0RXJyb3IoJ290aGVyIHNpZGUgY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHRoaXMpKSlcbiAgfSlcbiAgYWRkTGlzdGVuZXIoc29ja2V0LCAnY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgY2xpZW50ID0gdGhpc1trQ2xpZW50XVxuICAgIGNvbnN0IHBhcnNlciA9IHRoaXNba1BhcnNlcl1cblxuICAgIGlmIChwYXJzZXIpIHtcbiAgICAgIGlmICghdGhpc1trRXJyb3JdICYmIHBhcnNlci5zdGF0dXNDb2RlICYmICFwYXJzZXIuc2hvdWxkS2VlcEFsaXZlKSB7XG4gICAgICAgIC8vIFdlIHRyZWF0IGFsbCBpbmNvbWluZyBkYXRhIHNvIGZhciBhcyBhIHZhbGlkIHJlc3BvbnNlLlxuICAgICAgICBwYXJzZXIub25NZXNzYWdlQ29tcGxldGUoKVxuICAgICAgfVxuXG4gICAgICB0aGlzW2tQYXJzZXJdLmRlc3Ryb3koKVxuICAgICAgdGhpc1trUGFyc2VyXSA9IG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBlcnIgPSB0aGlzW2tFcnJvcl0gfHwgbmV3IFNvY2tldEVycm9yKCdjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpXG5cbiAgICBjbGllbnRba1NvY2tldF0gPSBudWxsXG4gICAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBudWxsIC8vIFRPRE8gKGZpeCk6IFRoaXMgaXMgaGFja3kuLi5cblxuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nXSA9PT0gMClcblxuICAgICAgLy8gRmFpbCBlbnRpcmUgcXVldWUuXG4gICAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiBlcnIuY29kZSAhPT0gJ1VORF9FUlJfSU5GTycpIHtcbiAgICAgIC8vIEZhaWwgaGVhZCBvZiBwaXBlbGluZS5cbiAgICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcblxuICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgfVxuXG4gICAgY2xpZW50W2tQZW5kaW5nSWR4XSA9IGNsaWVudFtrUnVubmluZ0lkeF1cblxuICAgIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKVxuXG4gICAgY2xpZW50LmVtaXQoJ2Rpc2Nvbm5lY3QnLCBjbGllbnRba1VybF0sIFtjbGllbnRdLCBlcnIpXG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9KVxuXG4gIGxldCBjbG9zZWQgPSBmYWxzZVxuICBzb2NrZXQub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgIGNsb3NlZCA9IHRydWVcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIHZlcnNpb246ICdoMScsXG4gICAgZGVmYXVsdFBpcGVsaW5pbmc6IDEsXG4gICAgd3JpdGUgKC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiB3cml0ZUgxKGNsaWVudCwgLi4uYXJncylcbiAgICB9LFxuICAgIHJlc3VtZSAoKSB7XG4gICAgICByZXN1bWVIMShjbGllbnQpXG4gICAgfSxcbiAgICBkZXN0cm95IChlcnIsIGNhbGxiYWNrKSB7XG4gICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0LmRlc3Ryb3koZXJyKS5vbignY2xvc2UnLCBjYWxsYmFjaylcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBkZXN0cm95ZWQgKCkge1xuICAgICAgcmV0dXJuIHNvY2tldC5kZXN0cm95ZWRcbiAgICB9LFxuICAgIGJ1c3kgKHJlcXVlc3QpIHtcbiAgICAgIGlmIChzb2NrZXRba1dyaXRpbmddIHx8IHNvY2tldFtrUmVzZXRdIHx8IHNvY2tldFtrQmxvY2tpbmddKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCAmJiAhcmVxdWVzdC5pZGVtcG90ZW50KSB7XG4gICAgICAgICAgLy8gTm9uLWlkZW1wb3RlbnQgcmVxdWVzdCBjYW5ub3QgYmUgcmV0cmllZC5cbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBubyBvdGhlciByZXF1ZXN0cyBhcmUgaW5mbGlnaHQgYW5kXG4gICAgICAgICAgLy8gY291bGQgY2F1c2UgZmFpbHVyZS5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIChyZXF1ZXN0LnVwZ3JhZGUgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdDT05ORUNUJykpIHtcbiAgICAgICAgICAvLyBEb24ndCBkaXNwYXRjaCBhbiB1cGdyYWRlIHVudGlsIGFsbCBwcmVjZWRpbmcgcmVxdWVzdHMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICAgICAgLy8gQSBtaXNiZWhhdmluZyBzZXJ2ZXIgbWlnaHQgdXBncmFkZSB0aGUgY29ubmVjdGlvbiBiZWZvcmUgYWxsIHBpcGVsaW5lZFxuICAgICAgICAgIC8vIHJlcXVlc3QgaGFzIGNvbXBsZXRlZC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIHV0aWwuYm9keUxlbmd0aChyZXF1ZXN0LmJvZHkpICE9PSAwICYmXG4gICAgICAgICAgKHV0aWwuaXNTdHJlYW0ocmVxdWVzdC5ib2R5KSB8fCB1dGlsLmlzQXN5bmNJdGVyYWJsZShyZXF1ZXN0LmJvZHkpIHx8IHV0aWwuaXNGb3JtRGF0YUxpa2UocmVxdWVzdC5ib2R5KSkpIHtcbiAgICAgICAgICAvLyBSZXF1ZXN0IHdpdGggc3RyZWFtIG9yIGl0ZXJhdG9yIGJvZHkgY2FuIGVycm9yIHdoaWxlIG90aGVyIHJlcXVlc3RzXG4gICAgICAgICAgLy8gYXJlIGluZmxpZ2h0IGFuZCBpbmRpcmVjdGx5IGVycm9yIHRob3NlIGFzIHdlbGwuXG4gICAgICAgICAgLy8gRW5zdXJlIHRoaXMgZG9lc24ndCBoYXBwZW4gYnkgd2FpdGluZyBmb3IgaW5mbGlnaHRcbiAgICAgICAgICAvLyB0byBjb21wbGV0ZSBiZWZvcmUgZGlzcGF0Y2hpbmcuXG5cbiAgICAgICAgICAvLyBSZXF1ZXN0IHdpdGggc3RyZWFtIG9yIGl0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHJldHJpZWQuXG4gICAgICAgICAgLy8gRW5zdXJlIHRoYXQgbm8gb3RoZXIgcmVxdWVzdHMgYXJlIGluZmxpZ2h0IGFuZFxuICAgICAgICAgIC8vIGNvdWxkIGNhdXNlIGZhaWx1cmUuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lSDEgKGNsaWVudCkge1xuICBjb25zdCBzb2NrZXQgPSBjbGllbnRba1NvY2tldF1cblxuICBpZiAoc29ja2V0ICYmICFzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgaWYgKGNsaWVudFtrU2l6ZV0gPT09IDApIHtcbiAgICAgIGlmICghc29ja2V0W2tOb1JlZl0gJiYgc29ja2V0LnVucmVmKSB7XG4gICAgICAgIHNvY2tldC51bnJlZigpXG4gICAgICAgIHNvY2tldFtrTm9SZWZdID0gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc29ja2V0W2tOb1JlZl0gJiYgc29ja2V0LnJlZikge1xuICAgICAgc29ja2V0LnJlZigpXG4gICAgICBzb2NrZXRba05vUmVmXSA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrU2l6ZV0gPT09IDApIHtcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgIT09IFRJTUVPVVRfS0VFUF9BTElWRSkge1xuICAgICAgICBzb2NrZXRba1BhcnNlcl0uc2V0VGltZW91dChjbGllbnRba0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZV0sIFRJTUVPVVRfS0VFUF9BTElWRSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNsaWVudFtrUnVubmluZ10gPiAwICYmIHNvY2tldFtrUGFyc2VyXS5zdGF0dXNDb2RlIDwgMjAwKSB7XG4gICAgICBpZiAoc29ja2V0W2tQYXJzZXJdLnRpbWVvdXRUeXBlICE9PSBUSU1FT1VUX0hFQURFUlMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF1dXG4gICAgICAgIGNvbnN0IGhlYWRlcnNUaW1lb3V0ID0gcmVxdWVzdC5oZWFkZXJzVGltZW91dCAhPSBudWxsXG4gICAgICAgICAgPyByZXF1ZXN0LmhlYWRlcnNUaW1lb3V0XG4gICAgICAgICAgOiBjbGllbnRba0hlYWRlcnNUaW1lb3V0XVxuICAgICAgICBzb2NrZXRba1BhcnNlcl0uc2V0VGltZW91dChoZWFkZXJzVGltZW91dCwgVElNRU9VVF9IRUFERVJTKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG5mdW5jdGlvbiBzaG91bGRTZW5kQ29udGVudExlbmd0aCAobWV0aG9kKSB7XG4gIHJldHVybiBtZXRob2QgIT09ICdHRVQnICYmIG1ldGhvZCAhPT0gJ0hFQUQnICYmIG1ldGhvZCAhPT0gJ09QVElPTlMnICYmIG1ldGhvZCAhPT0gJ1RSQUNFJyAmJiBtZXRob2QgIT09ICdDT05ORUNUJ1xufVxuXG5mdW5jdGlvbiB3cml0ZUgxIChjbGllbnQsIHJlcXVlc3QpIHtcbiAgY29uc3QgeyBtZXRob2QsIHBhdGgsIGhvc3QsIHVwZ3JhZGUsIGJsb2NraW5nLCByZXNldCB9ID0gcmVxdWVzdFxuXG4gIGxldCB7IGJvZHksIGhlYWRlcnMsIGNvbnRlbnRMZW5ndGggfSA9IHJlcXVlc3RcblxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4xXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjJcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuNVxuXG4gIC8vIFNlbmRpbmcgYSBwYXlsb2FkIGJvZHkgb24gYSByZXF1ZXN0IHRoYXQgZG9lcyBub3RcbiAgLy8gZXhwZWN0IGl0IGNhbiBjYXVzZSB1bmRlZmluZWQgYmVoYXZpb3Igb24gc29tZVxuICAvLyBzZXJ2ZXJzIGFuZCBjb3JydXB0IGNvbm5lY3Rpb24gc3RhdGUuIERvIG5vdFxuICAvLyByZS11c2UgdGhlIGNvbm5lY3Rpb24gZm9yIGZ1cnRoZXIgcmVxdWVzdHMuXG5cbiAgY29uc3QgZXhwZWN0c1BheWxvYWQgPSAoXG4gICAgbWV0aG9kID09PSAnUFVUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BPU1QnIHx8XG4gICAgbWV0aG9kID09PSAnUEFUQ0gnIHx8XG4gICAgbWV0aG9kID09PSAnUVVFUlknIHx8XG4gICAgbWV0aG9kID09PSAnUFJPUEZJTkQnIHx8XG4gICAgbWV0aG9kID09PSAnUFJPUFBBVENIJ1xuICApXG5cbiAgaWYgKHV0aWwuaXNGb3JtRGF0YUxpa2UoYm9keSkpIHtcbiAgICBpZiAoIWV4dHJhY3RCb2R5KSB7XG4gICAgICBleHRyYWN0Qm9keSA9IHJlcXVpcmUoJy4uL3dlYi9mZXRjaC9ib2R5LmpzJykuZXh0cmFjdEJvZHlcbiAgICB9XG5cbiAgICBjb25zdCBbYm9keVN0cmVhbSwgY29udGVudFR5cGVdID0gZXh0cmFjdEJvZHkoYm9keSlcbiAgICBpZiAocmVxdWVzdC5jb250ZW50VHlwZSA9PSBudWxsKSB7XG4gICAgICBoZWFkZXJzLnB1c2goJ2NvbnRlbnQtdHlwZScsIGNvbnRlbnRUeXBlKVxuICAgIH1cbiAgICBib2R5ID0gYm9keVN0cmVhbS5zdHJlYW1cbiAgICBjb250ZW50TGVuZ3RoID0gYm9keVN0cmVhbS5sZW5ndGhcbiAgfSBlbHNlIGlmICh1dGlsLmlzQmxvYkxpa2UoYm9keSkgJiYgcmVxdWVzdC5jb250ZW50VHlwZSA9PSBudWxsICYmIGJvZHkudHlwZSkge1xuICAgIGhlYWRlcnMucHVzaCgnY29udGVudC10eXBlJywgYm9keS50eXBlKVxuICB9XG5cbiAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRyeSB0byByZWFkIEVPRiBpbiBvcmRlciB0byBnZXQgbGVuZ3RoLlxuICAgIGJvZHkucmVhZCgwKVxuICB9XG5cbiAgY29uc3QgYm9keUxlbmd0aCA9IHV0aWwuYm9keUxlbmd0aChib2R5KVxuXG4gIGNvbnRlbnRMZW5ndGggPSBib2R5TGVuZ3RoID8/IGNvbnRlbnRMZW5ndGhcblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgIGNvbnRlbnRMZW5ndGggPSByZXF1ZXN0LmNvbnRlbnRMZW5ndGhcbiAgfVxuXG4gIGlmIChjb250ZW50TGVuZ3RoID09PSAwICYmICFleHBlY3RzUGF5bG9hZCkge1xuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAvLyBBIHVzZXIgYWdlbnQgU0hPVUxEIE5PVCBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIGZpZWxkIHdoZW5cbiAgICAvLyB0aGUgcmVxdWVzdCBtZXNzYWdlIGRvZXMgbm90IGNvbnRhaW4gYSBwYXlsb2FkIGJvZHkgYW5kIHRoZSBtZXRob2RcbiAgICAvLyBzZW1hbnRpY3MgZG8gbm90IGFudGljaXBhdGUgc3VjaCBhIGJvZHkuXG5cbiAgICBjb250ZW50TGVuZ3RoID0gbnVsbFxuICB9XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzIwNDZcbiAgLy8gQSB1c2VyIGFnZW50IG1heSBzZW5kIGEgQ29udGVudC1MZW5ndGggaGVhZGVyIHdpdGggMCB2YWx1ZSwgdGhpcyBzaG91bGQgYmUgYWxsb3dlZC5cbiAgaWYgKHNob3VsZFNlbmRDb250ZW50TGVuZ3RoKG1ldGhvZCkgJiYgY29udGVudExlbmd0aCA+IDAgJiYgcmVxdWVzdC5jb250ZW50TGVuZ3RoICE9PSBudWxsICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPT0gY29udGVudExlbmd0aCkge1xuICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICB9XG5cbiAgY29uc3Qgc29ja2V0ID0gY2xpZW50W2tTb2NrZXRdXG5cbiAgY29uc3QgYWJvcnQgPSAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcXVlc3QuYWJvcnRlZCB8fCByZXF1ZXN0LmNvbXBsZXRlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIgfHwgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoKSlcblxuICAgIHV0aWwuZGVzdHJveShib2R5KVxuICAgIHV0aWwuZGVzdHJveShzb2NrZXQsIG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ2Fib3J0ZWQnKSlcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmVxdWVzdC5vbkNvbm5lY3QoYWJvcnQpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICB9XG5cbiAgaWYgKHJlcXVlc3QuYWJvcnRlZCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgaWYgKG1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21jb2xsaW5hL3VuZGljaS9pc3N1ZXMvMjU4XG4gICAgLy8gQ2xvc2UgYWZ0ZXIgYSBIRUFEIHJlcXVlc3QgdG8gaW50ZXJvcCB3aXRoIG1pc2JlaGF2aW5nIHNlcnZlcnNcbiAgICAvLyB0aGF0IG1heSBzZW5kIGEgYm9keSBpbiB0aGUgcmVzcG9uc2UuXG5cbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmICh1cGdyYWRlIHx8IG1ldGhvZCA9PT0gJ0NPTk5FQ1QnKSB7XG4gICAgLy8gT24gQ09OTkVDVCBvciB1cGdyYWRlLCBibG9jayBwaXBlbGluZSBmcm9tIGRpc3BhdGNoaW5nIGZ1cnRoZXJcbiAgICAvLyByZXF1ZXN0cyBvbiB0aGlzIGNvbm5lY3Rpb24uXG5cbiAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgfVxuXG4gIGlmIChyZXNldCAhPSBudWxsKSB7XG4gICAgc29ja2V0W2tSZXNldF0gPSByZXNldFxuICB9XG5cbiAgaWYgKGNsaWVudFtrTWF4UmVxdWVzdHNdICYmIHNvY2tldFtrQ291bnRlcl0rKyA+PSBjbGllbnRba01heFJlcXVlc3RzXSkge1xuICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICB9XG5cbiAgaWYgKGJsb2NraW5nKSB7XG4gICAgc29ja2V0W2tCbG9ja2luZ10gPSB0cnVlXG4gIH1cblxuICBsZXQgaGVhZGVyID0gYCR7bWV0aG9kfSAke3BhdGh9IEhUVFAvMS4xXFxyXFxuYFxuXG4gIGlmICh0eXBlb2YgaG9zdCA9PT0gJ3N0cmluZycpIHtcbiAgICBoZWFkZXIgKz0gYGhvc3Q6ICR7aG9zdH1cXHJcXG5gXG4gIH0gZWxzZSB7XG4gICAgaGVhZGVyICs9IGNsaWVudFtrSG9zdEhlYWRlcl1cbiAgfVxuXG4gIGlmICh1cGdyYWRlKSB7XG4gICAgaGVhZGVyICs9IGBjb25uZWN0aW9uOiB1cGdyYWRlXFxyXFxudXBncmFkZTogJHt1cGdyYWRlfVxcclxcbmBcbiAgfSBlbHNlIGlmIChjbGllbnRba1BpcGVsaW5pbmddICYmICFzb2NrZXRba1Jlc2V0XSkge1xuICAgIGhlYWRlciArPSAnY29ubmVjdGlvbjoga2VlcC1hbGl2ZVxcclxcbidcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXIgKz0gJ2Nvbm5lY3Rpb246IGNsb3NlXFxyXFxuJ1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGhlYWRlcnMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgIGNvbnN0IGtleSA9IGhlYWRlcnNbbiArIDBdXG4gICAgICBjb25zdCB2YWwgPSBoZWFkZXJzW24gKyAxXVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaGVhZGVyICs9IGAke2tleX06ICR7dmFsW2ldfVxcclxcbmBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhZGVyICs9IGAke2tleX06ICR7dmFsfVxcclxcbmBcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY2hhbm5lbHMuc2VuZEhlYWRlcnMuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICBjaGFubmVscy5zZW5kSGVhZGVycy5wdWJsaXNoKHsgcmVxdWVzdCwgaGVhZGVyczogaGVhZGVyLCBzb2NrZXQgfSlcbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBhc3NlcnRpb24gKi9cbiAgaWYgKCFib2R5IHx8IGJvZHlMZW5ndGggPT09IDApIHtcbiAgICB3cml0ZUJ1ZmZlcihhYm9ydCwgbnVsbCwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpXG4gIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgIHdyaXRlQnVmZmVyKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIGlmICh1dGlsLmlzQmxvYkxpa2UoYm9keSkpIHtcbiAgICBpZiAodHlwZW9mIGJvZHkuc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3cml0ZUl0ZXJhYmxlKGFib3J0LCBib2R5LnN0cmVhbSgpLCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgICB9IGVsc2Uge1xuICAgICAgd3JpdGVCbG9iKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgICB9XG4gIH0gZWxzZSBpZiAodXRpbC5pc1N0cmVhbShib2R5KSkge1xuICAgIHdyaXRlU3RyZWFtKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIGlmICh1dGlsLmlzSXRlcmFibGUoYm9keSkpIHtcbiAgICB3cml0ZUl0ZXJhYmxlKGFib3J0LCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgaGVhZGVyLCBleHBlY3RzUGF5bG9hZClcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQoZmFsc2UpXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiB3cml0ZVN0cmVhbSAoYWJvcnQsIGJvZHksIGNsaWVudCwgcmVxdWVzdCwgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBoZWFkZXIsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdzdHJlYW0gYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICBsZXQgZmluaXNoZWQgPSBmYWxzZVxuXG4gIGNvbnN0IHdyaXRlciA9IG5ldyBBc3luY1dyaXRlcih7IGFib3J0LCBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KVxuXG4gIGNvbnN0IG9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghd3JpdGVyLndyaXRlKGNodW5rKSAmJiB0aGlzLnBhdXNlKSB7XG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdXRpbC5kZXN0cm95KHRoaXMsIGVycilcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25EcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChib2R5LnJlc3VtZSkge1xuICAgICAgYm9keS5yZXN1bWUoKVxuICAgIH1cbiAgfVxuICBjb25zdCBvbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vICdjbG9zZScgbWlnaHQgYmUgZW1pdHRlZCAqYmVmb3JlKiAnZXJyb3InIGZvclxuICAgIC8vIGJyb2tlbiBzdHJlYW1zLiBXYWl0IGEgdGljayB0byBhdm9pZCB0aGlzIGNhc2UuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gSXQncyBvbmx5IHNhZmUgdG8gcmVtb3ZlICdlcnJvcicgbGlzdGVuZXIgYWZ0ZXJcbiAgICAgIC8vICdjbG9zZScuXG4gICAgICBib2R5LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRmluaXNoZWQpXG4gICAgfSlcblxuICAgIGlmICghZmluaXNoZWQpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBSZXF1ZXN0QWJvcnRlZEVycm9yKClcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IG9uRmluaXNoZWQoZXJyKSlcbiAgICB9XG4gIH1cbiAgY29uc3Qgb25GaW5pc2hlZCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGZpbmlzaGVkID0gdHJ1ZVxuXG4gICAgYXNzZXJ0KHNvY2tldC5kZXN0cm95ZWQgfHwgKHNvY2tldFtrV3JpdGluZ10gJiYgY2xpZW50W2tSdW5uaW5nXSA8PSAxKSlcblxuICAgIHNvY2tldFxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICAgICAgLm9mZignZXJyb3InLCBvbkZpbmlzaGVkKVxuXG4gICAgYm9keVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkZpbmlzaGVkKVxuICAgICAgLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uQ2xvc2UpXG5cbiAgICBpZiAoIWVycikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd3JpdGVyLmVuZCgpXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBlcnIgPSBlclxuICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlci5kZXN0cm95KGVycilcblxuICAgIGlmIChlcnIgJiYgKGVyci5jb2RlICE9PSAnVU5EX0VSUl9JTkZPJyB8fCBlcnIubWVzc2FnZSAhPT0gJ3Jlc2V0JykpIHtcbiAgICAgIHV0aWwuZGVzdHJveShib2R5LCBlcnIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuZGVzdHJveShib2R5KVxuICAgIH1cbiAgfVxuXG4gIGJvZHlcbiAgICAub24oJ2RhdGEnLCBvbkRhdGEpXG4gICAgLm9uKCdlbmQnLCBvbkZpbmlzaGVkKVxuICAgIC5vbignZXJyb3InLCBvbkZpbmlzaGVkKVxuICAgIC5vbignY2xvc2UnLCBvbkNsb3NlKVxuXG4gIGlmIChib2R5LnJlc3VtZSkge1xuICAgIGJvZHkucmVzdW1lKClcbiAgfVxuXG4gIHNvY2tldFxuICAgIC5vbignZHJhaW4nLCBvbkRyYWluKVxuICAgIC5vbignZXJyb3InLCBvbkZpbmlzaGVkKVxuXG4gIGlmIChib2R5LmVycm9yRW1pdHRlZCA/PyBib2R5LmVycm9yZWQpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gb25GaW5pc2hlZChib2R5LmVycm9yZWQpKVxuICB9IGVsc2UgaWYgKGJvZHkuZW5kRW1pdHRlZCA/PyBib2R5LnJlYWRhYmxlRW5kZWQpIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gb25GaW5pc2hlZChudWxsKSlcbiAgfVxuXG4gIGlmIChib2R5LmNsb3NlRW1pdHRlZCA/PyBib2R5LmNsb3NlZCkge1xuICAgIHNldEltbWVkaWF0ZShvbkNsb3NlKVxuICB9XG59XG5cbmZ1bmN0aW9uIHdyaXRlQnVmZmVyIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIWJvZHkpIHtcbiAgICAgIGlmIChjb250ZW50TGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNvY2tldC53cml0ZShgJHtoZWFkZXJ9Y29udGVudC1sZW5ndGg6IDBcXHJcXG5cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBudWxsLCAnbm8gYm9keSBtdXN0IG5vdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcbiAgICAgICAgc29ja2V0LndyaXRlKGAke2hlYWRlcn1cXHJcXG5gLCAnbGF0aW4xJylcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNCdWZmZXIoYm9keSkpIHtcbiAgICAgIGFzc2VydChjb250ZW50TGVuZ3RoID09PSBib2R5LmJ5dGVMZW5ndGgsICdidWZmZXIgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gICAgICBzb2NrZXQuY29yaygpXG4gICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICBzb2NrZXQud3JpdGUoYm9keSlcbiAgICAgIHNvY2tldC51bmNvcmsoKVxuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGJvZHkpXG5cbiAgICAgIGlmICghZXhwZWN0c1BheWxvYWQgJiYgcmVxdWVzdC5yZXNldCAhPT0gZmFsc2UpIHtcbiAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVCbG9iIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuc2l6ZSwgJ2Jsb2IgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gIHRyeSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoICE9PSBib2R5LnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKSlcblxuICAgIHNvY2tldC5jb3JrKClcbiAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgc29ja2V0LndyaXRlKGJ1ZmZlcilcbiAgICBzb2NrZXQudW5jb3JrKClcblxuICAgIHJlcXVlc3Qub25Cb2R5U2VudChidWZmZXIpXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQgJiYgcmVxdWVzdC5yZXNldCAhPT0gZmFsc2UpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiB3cml0ZUl0ZXJhYmxlIChhYm9ydCwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGhlYWRlciwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ2l0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgbGV0IGNhbGxiYWNrID0gbnVsbFxuICBmdW5jdGlvbiBvbkRyYWluICgpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhc3NlcnQoY2FsbGJhY2sgPT09IG51bGwpXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHJlamVjdChzb2NrZXRba0Vycm9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9KVxuXG4gIHNvY2tldFxuICAgIC5vbignY2xvc2UnLCBvbkRyYWluKVxuICAgIC5vbignZHJhaW4nLCBvbkRyYWluKVxuXG4gIGNvbnN0IHdyaXRlciA9IG5ldyBBc3luY1dyaXRlcih7IGFib3J0LCBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KVxuICB0cnkge1xuICAgIC8vIEl0J3MgdXAgdG8gdGhlIHVzZXIgdG8gc29tZWhvdyBhYm9ydCB0aGUgYXN5bmMgaXRlcmFibGUuXG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBib2R5KSB7XG4gICAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICAgIH1cblxuICAgICAgaWYgKCF3cml0ZXIud3JpdGUoY2h1bmspKSB7XG4gICAgICAgIGF3YWl0IHdhaXRGb3JEcmFpbigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVyLmVuZCgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHdyaXRlci5kZXN0cm95KGVycilcbiAgfSBmaW5hbGx5IHtcbiAgICBzb2NrZXRcbiAgICAgIC5vZmYoJ2Nsb3NlJywgb25EcmFpbilcbiAgICAgIC5vZmYoJ2RyYWluJywgb25EcmFpbilcbiAgfVxufVxuXG5jbGFzcyBBc3luY1dyaXRlciB7XG4gIGNvbnN0cnVjdG9yICh7IGFib3J0LCBzb2NrZXQsIHJlcXVlc3QsIGNvbnRlbnRMZW5ndGgsIGNsaWVudCwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciB9KSB7XG4gICAgdGhpcy5zb2NrZXQgPSBzb2NrZXRcbiAgICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0XG4gICAgdGhpcy5jb250ZW50TGVuZ3RoID0gY29udGVudExlbmd0aFxuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50XG4gICAgdGhpcy5ieXRlc1dyaXR0ZW4gPSAwXG4gICAgdGhpcy5leHBlY3RzUGF5bG9hZCA9IGV4cGVjdHNQYXlsb2FkXG4gICAgdGhpcy5oZWFkZXIgPSBoZWFkZXJcbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcblxuICAgIHNvY2tldFtrV3JpdGluZ10gPSB0cnVlXG4gIH1cblxuICB3cml0ZSAoY2h1bmspIHtcbiAgICBjb25zdCB7IHNvY2tldCwgcmVxdWVzdCwgY29udGVudExlbmd0aCwgY2xpZW50LCBieXRlc1dyaXR0ZW4sIGV4cGVjdHNQYXlsb2FkLCBoZWFkZXIgfSA9IHRoaXNcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgoY2h1bmspXG4gICAgaWYgKCFsZW4pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gV2Ugc2hvdWxkIGRlZmVyIHdyaXRpbmcgY2h1bmtzLlxuICAgIGlmIChjb250ZW50TGVuZ3RoICE9PSBudWxsICYmIGJ5dGVzV3JpdHRlbiArIGxlbiA+IGNvbnRlbnRMZW5ndGgpIHtcbiAgICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICB9XG5cbiAgICBzb2NrZXQuY29yaygpXG5cbiAgICBpZiAoYnl0ZXNXcml0dGVuID09PSAwKSB7XG4gICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkICYmIHJlcXVlc3QucmVzZXQgIT09IGZhbHNlKSB7XG4gICAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfXRyYW5zZmVyLWVuY29kaW5nOiBjaHVua2VkXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAke2NvbnRlbnRMZW5ndGh9XFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggPT09IG51bGwpIHtcbiAgICAgIHNvY2tldC53cml0ZShgXFxyXFxuJHtsZW4udG9TdHJpbmcoMTYpfVxcclxcbmAsICdsYXRpbjEnKVxuICAgIH1cblxuICAgIHRoaXMuYnl0ZXNXcml0dGVuICs9IGxlblxuXG4gICAgY29uc3QgcmV0ID0gc29ja2V0LndyaXRlKGNodW5rKVxuXG4gICAgc29ja2V0LnVuY29yaygpXG5cbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoY2h1bmspXG5cbiAgICBpZiAoIXJldCkge1xuICAgICAgaWYgKHNvY2tldFtrUGFyc2VyXS50aW1lb3V0ICYmIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0VHlwZSA9PT0gVElNRU9VVF9IRUFERVJTKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBvbmx5IGZvciBqZXN0XG4gICAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgICAgc29ja2V0W2tQYXJzZXJdLnRpbWVvdXQucmVmcmVzaCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBlbmQgKCkge1xuICAgIGNvbnN0IHsgc29ja2V0LCBjb250ZW50TGVuZ3RoLCBjbGllbnQsIGJ5dGVzV3JpdHRlbiwgZXhwZWN0c1BheWxvYWQsIGhlYWRlciwgcmVxdWVzdCB9ID0gdGhpc1xuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBzb2NrZXRba1dyaXRpbmddID0gZmFsc2VcblxuICAgIGlmIChzb2NrZXRba0Vycm9yXSkge1xuICAgICAgdGhyb3cgc29ja2V0W2tFcnJvcl1cbiAgICB9XG5cbiAgICBpZiAoc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgaWYgKGV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbiAgICAgICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBzZW5kIGEgQ29udGVudC1MZW5ndGggaW4gYSByZXF1ZXN0IG1lc3NhZ2Ugd2hlblxuICAgICAgICAvLyBubyBUcmFuc2Zlci1FbmNvZGluZyBpcyBzZW50IGFuZCB0aGUgcmVxdWVzdCBtZXRob2QgZGVmaW5lcyBhIG1lYW5pbmdcbiAgICAgICAgLy8gZm9yIGFuIGVuY2xvc2VkIHBheWxvYWQgYm9keS5cblxuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfWNvbnRlbnQtbGVuZ3RoOiAwXFxyXFxuXFxyXFxuYCwgJ2xhdGluMScpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXQud3JpdGUoYCR7aGVhZGVyfVxcclxcbmAsICdsYXRpbjEnKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29udGVudExlbmd0aCA9PT0gbnVsbCkge1xuICAgICAgc29ja2V0LndyaXRlKCdcXHJcXG4wXFxyXFxuXFxyXFxuJywgJ2xhdGluMScpXG4gICAgfVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT09IG51bGwgJiYgYnl0ZXNXcml0dGVuICE9PSBjb250ZW50TGVuZ3RoKSB7XG4gICAgICBpZiAoY2xpZW50W2tTdHJpY3RDb250ZW50TGVuZ3RoXSkge1xuICAgICAgICB0aHJvdyBuZXcgUmVxdWVzdENvbnRlbnRMZW5ndGhNaXNtYXRjaEVycm9yKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dCAmJiBzb2NrZXRba1BhcnNlcl0udGltZW91dFR5cGUgPT09IFRJTUVPVVRfSEVBREVSUykge1xuICAgICAgLy8gaXN0YW5idWwgaWdub3JlIGVsc2U6IG9ubHkgZm9yIGplc3RcbiAgICAgIGlmIChzb2NrZXRba1BhcnNlcl0udGltZW91dC5yZWZyZXNoKSB7XG4gICAgICAgIHNvY2tldFtrUGFyc2VyXS50aW1lb3V0LnJlZnJlc2goKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH1cblxuICBkZXN0cm95IChlcnIpIHtcbiAgICBjb25zdCB7IHNvY2tldCwgY2xpZW50LCBhYm9ydCB9ID0gdGhpc1xuXG4gICAgc29ja2V0W2tXcml0aW5nXSA9IGZhbHNlXG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA8PSAxLCAncGlwZWxpbmUgc2hvdWxkIG9ubHkgY29udGFpbiB0aGlzIHJlcXVlc3QnKVxuICAgICAgYWJvcnQoZXJyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbm5lY3RIMVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/client-h1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/client-h2.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client-h2.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  RequestContentLengthMismatchError,\n  RequestAbortedError,\n  SocketError,\n  InformationalError\n} = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  kUrl,\n  kReset,\n  kClient,\n  kRunning,\n  kPending,\n  kQueue,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kSocket,\n  kStrictContentLength,\n  kOnError,\n  kMaxConcurrentStreams,\n  kHTTP2Session,\n  kResume,\n  kSize,\n  kHTTPContext\n} = __webpack_require__(/*! ../core/symbols.js */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nconst kOpenStreams = Symbol('open streams')\n\nlet extractBody\n\n// Experimental\nlet h2ExperimentalWarned = false\n\n/** @type {import('http2')} */\nlet http2\ntry {\n  http2 = __webpack_require__(/*! node:http2 */ \"node:http2\")\n} catch {\n  // @ts-ignore\n  http2 = { constants: {} }\n}\n\nconst {\n  constants: {\n    HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH,\n    HTTP2_HEADER_SCHEME,\n    HTTP2_HEADER_CONTENT_LENGTH,\n    HTTP2_HEADER_EXPECT,\n    HTTP2_HEADER_STATUS\n  }\n} = http2\n\nfunction parseH2Headers (headers) {\n  const result = []\n\n  for (const [name, value] of Object.entries(headers)) {\n    // h2 may concat the header value by array\n    // e.g. Set-Cookie\n    if (Array.isArray(value)) {\n      for (const subvalue of value) {\n        // we need to provide each header value of header name\n        // because the headers handler expect name-value pair\n        result.push(Buffer.from(name), Buffer.from(subvalue))\n      }\n    } else {\n      result.push(Buffer.from(name), Buffer.from(value))\n    }\n  }\n\n  return result\n}\n\nasync function connectH2 (client, socket) {\n  client[kSocket] = socket\n\n  if (!h2ExperimentalWarned) {\n    h2ExperimentalWarned = true\n    process.emitWarning('H2 support is experimental, expect them to change at any time.', {\n      code: 'UNDICI-H2'\n    })\n  }\n\n  const session = http2.connect(client[kUrl], {\n    createConnection: () => socket,\n    peerMaxConcurrentStreams: client[kMaxConcurrentStreams]\n  })\n\n  session[kOpenStreams] = 0\n  session[kClient] = client\n  session[kSocket] = socket\n\n  util.addListener(session, 'error', onHttp2SessionError)\n  util.addListener(session, 'frameError', onHttp2FrameError)\n  util.addListener(session, 'end', onHttp2SessionEnd)\n  util.addListener(session, 'goaway', onHTTP2GoAway)\n  util.addListener(session, 'close', function () {\n    const { [kClient]: client } = this\n    const { [kSocket]: socket } = client\n\n    const err = this[kSocket][kError] || this[kError] || new SocketError('closed', util.getSocketInfo(socket))\n\n    client[kHTTP2Session] = null\n\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n\n      // Fail entire queue.\n      const requests = client[kQueue].splice(client[kRunningIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(client, request, err)\n      }\n    }\n  })\n\n  session.unref()\n\n  client[kHTTP2Session] = session\n  socket[kHTTP2Session] = session\n\n  util.addListener(socket, 'error', function (err) {\n    assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n    this[kError] = err\n\n    this[kClient][kOnError](err)\n  })\n\n  util.addListener(socket, 'end', function () {\n    util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n  })\n\n  util.addListener(socket, 'close', function () {\n    const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n    client[kSocket] = null\n\n    if (this[kHTTP2Session] != null) {\n      this[kHTTP2Session].destroy(err)\n    }\n\n    client[kPendingIdx] = client[kRunningIdx]\n\n    assert(client[kRunning] === 0)\n\n    client.emit('disconnect', client[kUrl], [client], err)\n\n    client[kResume]()\n  })\n\n  let closed = false\n  socket.on('close', () => {\n    closed = true\n  })\n\n  return {\n    version: 'h2',\n    defaultPipelining: Infinity,\n    write (...args) {\n      return writeH2(client, ...args)\n    },\n    resume () {\n      resumeH2(client)\n    },\n    destroy (err, callback) {\n      if (closed) {\n        queueMicrotask(callback)\n      } else {\n        // Destroying the socket will trigger the session close\n        socket.destroy(err).on('close', callback)\n      }\n    },\n    get destroyed () {\n      return socket.destroyed\n    },\n    busy () {\n      return false\n    }\n  }\n}\n\nfunction resumeH2 (client) {\n  const socket = client[kSocket]\n\n  if (socket?.destroyed === false) {\n    if (client[kSize] === 0 && client[kMaxConcurrentStreams] === 0) {\n      socket.unref()\n      client[kHTTP2Session].unref()\n    } else {\n      socket.ref()\n      client[kHTTP2Session].ref()\n    }\n  }\n}\n\nfunction onHttp2SessionError (err) {\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  this[kSocket][kError] = err\n  this[kClient][kOnError](err)\n}\n\nfunction onHttp2FrameError (type, code, id) {\n  if (id === 0) {\n    const err = new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`)\n    this[kSocket][kError] = err\n    this[kClient][kOnError](err)\n  }\n}\n\nfunction onHttp2SessionEnd () {\n  const err = new SocketError('other side closed', util.getSocketInfo(this[kSocket]))\n  this.destroy(err)\n  util.destroy(this[kSocket], err)\n}\n\n/**\n * This is the root cause of #3011\n * We need to handle GOAWAY frames properly, and trigger the session close\n * along with the socket right away\n */\nfunction onHTTP2GoAway (code) {\n  // We cannot recover, so best to close the session and the socket\n  const err = this[kError] || new SocketError(`HTTP/2: \"GOAWAY\" frame received with code ${code}`, util.getSocketInfo(this))\n  const client = this[kClient]\n\n  client[kSocket] = null\n  client[kHTTPContext] = null\n\n  if (this[kHTTP2Session] != null) {\n    this[kHTTP2Session].destroy(err)\n    this[kHTTP2Session] = null\n  }\n\n  util.destroy(this[kSocket], err)\n\n  // Fail head of pipeline.\n  if (client[kRunningIdx] < client[kQueue].length) {\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n    util.errorRequest(client, request, err)\n    client[kPendingIdx] = client[kRunningIdx]\n  }\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  client[kResume]()\n}\n\n// https://www.rfc-editor.org/rfc/rfc7230#section-3.3.2\nfunction shouldSendContentLength (method) {\n  return method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS' && method !== 'TRACE' && method !== 'CONNECT'\n}\n\nfunction writeH2 (client, request) {\n  const session = client[kHTTP2Session]\n  const { method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request\n  let { body } = request\n\n  if (upgrade) {\n    util.errorRequest(client, request, new Error('Upgrade not supported for H2'))\n    return false\n  }\n\n  const headers = {}\n  for (let n = 0; n < reqHeaders.length; n += 2) {\n    const key = reqHeaders[n + 0]\n    const val = reqHeaders[n + 1]\n\n    if (Array.isArray(val)) {\n      for (let i = 0; i < val.length; i++) {\n        if (headers[key]) {\n          headers[key] += `,${val[i]}`\n        } else {\n          headers[key] = val[i]\n        }\n      }\n    } else {\n      headers[key] = val\n    }\n  }\n\n  /** @type {import('node:http2').ClientHttp2Stream} */\n  let stream\n\n  const { hostname, port } = client[kUrl]\n\n  headers[HTTP2_HEADER_AUTHORITY] = host || `${hostname}${port ? `:${port}` : ''}`\n  headers[HTTP2_HEADER_METHOD] = method\n\n  const abort = (err) => {\n    if (request.aborted || request.completed) {\n      return\n    }\n\n    err = err || new RequestAbortedError()\n\n    util.errorRequest(client, request, err)\n\n    if (stream != null) {\n      util.destroy(stream, err)\n    }\n\n    // We do not destroy the socket as we can continue using the session\n    // the stream get's destroyed and the session remains to create new streams\n    util.destroy(body, err)\n    client[kQueue][client[kRunningIdx]++] = null\n    client[kResume]()\n  }\n\n  try {\n    // We are already connected, streams are pending.\n    // We can call on connect, and wait for abort\n    request.onConnect(abort)\n  } catch (err) {\n    util.errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'CONNECT') {\n    session.ref()\n    // We are already connected, streams are pending, first request\n    // will create a new stream. We trigger a request to create the stream and wait until\n    // `ready` event is triggered\n    // We disabled endStream to allow the user to write to the stream\n    stream = session.request(headers, { endStream: false, signal })\n\n    if (stream.id && !stream.pending) {\n      request.onUpgrade(null, null, stream)\n      ++session[kOpenStreams]\n      client[kQueue][client[kRunningIdx]++] = null\n    } else {\n      stream.once('ready', () => {\n        request.onUpgrade(null, null, stream)\n        ++session[kOpenStreams]\n        client[kQueue][client[kRunningIdx]++] = null\n      })\n    }\n\n    stream.once('close', () => {\n      session[kOpenStreams] -= 1\n      if (session[kOpenStreams] === 0) session.unref()\n    })\n\n    return true\n  }\n\n  // https://tools.ietf.org/html/rfc7540#section-8.3\n  // :path and :scheme headers must be omitted when sending CONNECT\n\n  headers[HTTP2_HEADER_PATH] = path\n  headers[HTTP2_HEADER_SCHEME] = 'https'\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (util.isFormDataLike(body)) {\n    extractBody ??= (__webpack_require__(/*! ../web/fetch/body.js */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\").extractBody)\n\n    const [bodyStream, contentType] = extractBody(body)\n    headers['content-type'] = contentType\n\n    body = bodyStream.stream\n    contentLength = bodyStream.length\n  }\n\n  if (contentLength == null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 || !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  // https://github.com/nodejs/undici/issues/2046\n  // A user agent may send a Content-Length header with 0 value, this should be allowed.\n  if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      util.errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  if (contentLength != null) {\n    assert(body, 'no body must not have content length')\n    headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`\n  }\n\n  session.ref()\n\n  const shouldEndStream = method === 'GET' || method === 'HEAD' || body === null\n  if (expectContinue) {\n    headers[HTTP2_HEADER_EXPECT] = '100-continue'\n    stream = session.request(headers, { endStream: shouldEndStream, signal })\n\n    stream.once('continue', writeBodyH2)\n  } else {\n    stream = session.request(headers, {\n      endStream: shouldEndStream,\n      signal\n    })\n    writeBodyH2()\n  }\n\n  // Increment counter as we have new streams open\n  ++session[kOpenStreams]\n\n  stream.once('response', headers => {\n    const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers\n    request.onResponseStarted()\n\n    // Due to the stream nature, it is possible we face a race condition\n    // where the stream has been assigned, but the request has been aborted\n    // the request remains in-flight and headers hasn't been received yet\n    // for those scenarios, best effort is to destroy the stream immediately\n    // as there's no value to keep it open.\n    if (request.aborted) {\n      const err = new RequestAbortedError()\n      util.errorRequest(client, request, err)\n      util.destroy(stream, err)\n      return\n    }\n\n    if (request.onHeaders(Number(statusCode), parseH2Headers(realHeaders), stream.resume.bind(stream), '') === false) {\n      stream.pause()\n    }\n\n    stream.on('data', (chunk) => {\n      if (request.onData(chunk) === false) {\n        stream.pause()\n      }\n    })\n  })\n\n  stream.once('end', () => {\n    // When state is null, it means we haven't consumed body and the stream still do not have\n    // a state.\n    // Present specially when using pipeline or stream\n    if (stream.state?.state == null || stream.state.state < 6) {\n      request.onComplete([])\n    }\n\n    if (session[kOpenStreams] === 0) {\n      // Stream is closed or half-closed-remote (6), decrement counter and cleanup\n      // It does not have sense to continue working with the stream as we do not\n      // have yet RST_STREAM support on client-side\n\n      session.unref()\n    }\n\n    abort(new InformationalError('HTTP/2: stream half-closed (remote)'))\n    client[kQueue][client[kRunningIdx]++] = null\n    client[kPendingIdx] = client[kRunningIdx]\n    client[kResume]()\n  })\n\n  stream.once('close', () => {\n    session[kOpenStreams] -= 1\n    if (session[kOpenStreams] === 0) {\n      session.unref()\n    }\n  })\n\n  stream.once('error', function (err) {\n    abort(err)\n  })\n\n  stream.once('frameError', (type, code) => {\n    abort(new InformationalError(`HTTP/2: \"frameError\" received - type ${type}, code ${code}`))\n  })\n\n  // stream.on('aborted', () => {\n  //   // TODO(HTTP/2): Support aborted\n  // })\n\n  // stream.on('timeout', () => {\n  //   // TODO(HTTP/2): Support timeout\n  // })\n\n  // stream.on('push', headers => {\n  //   // TODO(HTTP/2): Support push\n  // })\n\n  // stream.on('trailers', headers => {\n  //   // TODO(HTTP/2): Support trailers\n  // })\n\n  return true\n\n  function writeBodyH2 () {\n    /* istanbul ignore else: assertion */\n    if (!body || contentLength === 0) {\n      writeBuffer(\n        abort,\n        stream,\n        null,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBuffer(body)) {\n      writeBuffer(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else if (util.isBlobLike(body)) {\n      if (typeof body.stream === 'function') {\n        writeIterable(\n          abort,\n          stream,\n          body.stream(),\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      } else {\n        writeBlob(\n          abort,\n          stream,\n          body,\n          client,\n          request,\n          client[kSocket],\n          contentLength,\n          expectsPayload\n        )\n      }\n    } else if (util.isStream(body)) {\n      writeStream(\n        abort,\n        client[kSocket],\n        expectsPayload,\n        stream,\n        body,\n        client,\n        request,\n        contentLength\n      )\n    } else if (util.isIterable(body)) {\n      writeIterable(\n        abort,\n        stream,\n        body,\n        client,\n        request,\n        client[kSocket],\n        contentLength,\n        expectsPayload\n      )\n    } else {\n      assert(false)\n    }\n  }\n}\n\nfunction writeBuffer (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  try {\n    if (body != null && util.isBuffer(body)) {\n      assert(contentLength === body.byteLength, 'buffer body must have content length')\n      h2stream.cork()\n      h2stream.write(body)\n      h2stream.uncork()\n      h2stream.end()\n\n      request.onBodySent(body)\n    }\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    request.onRequestSent()\n    client[kResume]()\n  } catch (error) {\n    abort(error)\n  }\n}\n\nfunction writeStream (abort, socket, expectsPayload, h2stream, body, client, request, contentLength) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  // For HTTP/2, is enough to pipe the stream\n  const pipe = pipeline(\n    body,\n    h2stream,\n    (err) => {\n      if (err) {\n        util.destroy(pipe, err)\n        abort(err)\n      } else {\n        util.removeAllListeners(pipe)\n        request.onRequestSent()\n\n        if (!expectsPayload) {\n          socket[kReset] = true\n        }\n\n        client[kResume]()\n      }\n    }\n  )\n\n  util.addListener(pipe, 'data', onPipeData)\n\n  function onPipeData (chunk) {\n    request.onBodySent(chunk)\n  }\n}\n\nasync function writeBlob (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    h2stream.cork()\n    h2stream.write(buffer)\n    h2stream.uncork()\n    h2stream.end()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  }\n}\n\nasync function writeIterable (abort, h2stream, body, client, request, socket, contentLength, expectsPayload) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  h2stream\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      const res = h2stream.write(chunk)\n      request.onBodySent(chunk)\n      if (!res) {\n        await waitForDrain()\n      }\n    }\n\n    h2stream.end()\n\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    client[kResume]()\n  } catch (err) {\n    abort(err)\n  } finally {\n    h2stream\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nmodule.exports = connectH2\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC1oMi5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkVBQW9COztBQUVoQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQSxVQUFVLG1CQUFPLENBQUMsOEJBQVk7QUFDOUIsRUFBRTtBQUNGO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQyxZQUFZLG9CQUFvQjs7QUFFaEM7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrRUFBK0UsS0FBSyxTQUFTLEtBQUs7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRixLQUFLO0FBQ2hHOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSwyRUFBMkU7QUFDckYsUUFBUSxPQUFPOztBQUVmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBLDhCQUE4QixPQUFPO0FBQ3JDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLGFBQWEsd0NBQXdDO0FBQ3JEOztBQUVBLFVBQVUsaUJBQWlCOztBQUUzQiwrQ0FBK0MsU0FBUyxFQUFFLFdBQVcsS0FBSyxPQUFPO0FBQ2pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDBCQUEwQjs7QUFFbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixrSEFBMkM7O0FBRS9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9DQUFvQzs7QUFFNUU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVksb0RBQW9EO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSx5RUFBeUUsS0FBSyxTQUFTLEtBQUs7QUFDNUYsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxjbGllbnQtaDIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgcGlwZWxpbmUgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwuanMnKVxuY29uc3Qge1xuICBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IsXG4gIFJlcXVlc3RBYm9ydGVkRXJyb3IsXG4gIFNvY2tldEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycy5qcycpXG5jb25zdCB7XG4gIGtVcmwsXG4gIGtSZXNldCxcbiAga0NsaWVudCxcbiAga1J1bm5pbmcsXG4gIGtQZW5kaW5nLFxuICBrUXVldWUsXG4gIGtQZW5kaW5nSWR4LFxuICBrUnVubmluZ0lkeCxcbiAga0Vycm9yLFxuICBrU29ja2V0LFxuICBrU3RyaWN0Q29udGVudExlbmd0aCxcbiAga09uRXJyb3IsXG4gIGtNYXhDb25jdXJyZW50U3RyZWFtcyxcbiAga0hUVFAyU2Vzc2lvbixcbiAga1Jlc3VtZSxcbiAga1NpemUsXG4gIGtIVFRQQ29udGV4dFxufSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scy5qcycpXG5cbmNvbnN0IGtPcGVuU3RyZWFtcyA9IFN5bWJvbCgnb3BlbiBzdHJlYW1zJylcblxubGV0IGV4dHJhY3RCb2R5XG5cbi8vIEV4cGVyaW1lbnRhbFxubGV0IGgyRXhwZXJpbWVudGFsV2FybmVkID0gZmFsc2VcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2h0dHAyJyl9ICovXG5sZXQgaHR0cDJcbnRyeSB7XG4gIGh0dHAyID0gcmVxdWlyZSgnbm9kZTpodHRwMicpXG59IGNhdGNoIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBodHRwMiA9IHsgY29uc3RhbnRzOiB7fSB9XG59XG5cbmNvbnN0IHtcbiAgY29uc3RhbnRzOiB7XG4gICAgSFRUUDJfSEVBREVSX0FVVEhPUklUWSxcbiAgICBIVFRQMl9IRUFERVJfTUVUSE9ELFxuICAgIEhUVFAyX0hFQURFUl9QQVRILFxuICAgIEhUVFAyX0hFQURFUl9TQ0hFTUUsXG4gICAgSFRUUDJfSEVBREVSX0NPTlRFTlRfTEVOR1RILFxuICAgIEhUVFAyX0hFQURFUl9FWFBFQ1QsXG4gICAgSFRUUDJfSEVBREVSX1NUQVRVU1xuICB9XG59ID0gaHR0cDJcblxuZnVuY3Rpb24gcGFyc2VIMkhlYWRlcnMgKGhlYWRlcnMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW11cblxuICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaGVhZGVycykpIHtcbiAgICAvLyBoMiBtYXkgY29uY2F0IHRoZSBoZWFkZXIgdmFsdWUgYnkgYXJyYXlcbiAgICAvLyBlLmcuIFNldC1Db29raWVcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3Qgc3VidmFsdWUgb2YgdmFsdWUpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBwcm92aWRlIGVhY2ggaGVhZGVyIHZhbHVlIG9mIGhlYWRlciBuYW1lXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGhlYWRlcnMgaGFuZGxlciBleHBlY3QgbmFtZS12YWx1ZSBwYWlyXG4gICAgICAgIHJlc3VsdC5wdXNoKEJ1ZmZlci5mcm9tKG5hbWUpLCBCdWZmZXIuZnJvbShzdWJ2YWx1ZSkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKEJ1ZmZlci5mcm9tKG5hbWUpLCBCdWZmZXIuZnJvbSh2YWx1ZSkpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5hc3luYyBmdW5jdGlvbiBjb25uZWN0SDIgKGNsaWVudCwgc29ja2V0KSB7XG4gIGNsaWVudFtrU29ja2V0XSA9IHNvY2tldFxuXG4gIGlmICghaDJFeHBlcmltZW50YWxXYXJuZWQpIHtcbiAgICBoMkV4cGVyaW1lbnRhbFdhcm5lZCA9IHRydWVcbiAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdIMiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCwgZXhwZWN0IHRoZW0gdG8gY2hhbmdlIGF0IGFueSB0aW1lLicsIHtcbiAgICAgIGNvZGU6ICdVTkRJQ0ktSDInXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHNlc3Npb24gPSBodHRwMi5jb25uZWN0KGNsaWVudFtrVXJsXSwge1xuICAgIGNyZWF0ZUNvbm5lY3Rpb246ICgpID0+IHNvY2tldCxcbiAgICBwZWVyTWF4Q29uY3VycmVudFN0cmVhbXM6IGNsaWVudFtrTWF4Q29uY3VycmVudFN0cmVhbXNdXG4gIH0pXG5cbiAgc2Vzc2lvbltrT3BlblN0cmVhbXNdID0gMFxuICBzZXNzaW9uW2tDbGllbnRdID0gY2xpZW50XG4gIHNlc3Npb25ba1NvY2tldF0gPSBzb2NrZXRcblxuICB1dGlsLmFkZExpc3RlbmVyKHNlc3Npb24sICdlcnJvcicsIG9uSHR0cDJTZXNzaW9uRXJyb3IpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2ZyYW1lRXJyb3InLCBvbkh0dHAyRnJhbWVFcnJvcilcbiAgdXRpbC5hZGRMaXN0ZW5lcihzZXNzaW9uLCAnZW5kJywgb25IdHRwMlNlc3Npb25FbmQpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2dvYXdheScsIG9uSFRUUDJHb0F3YXkpXG4gIHV0aWwuYWRkTGlzdGVuZXIoc2Vzc2lvbiwgJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHsgW2tDbGllbnRdOiBjbGllbnQgfSA9IHRoaXNcbiAgICBjb25zdCB7IFtrU29ja2V0XTogc29ja2V0IH0gPSBjbGllbnRcblxuICAgIGNvbnN0IGVyciA9IHRoaXNba1NvY2tldF1ba0Vycm9yXSB8fCB0aGlzW2tFcnJvcl0gfHwgbmV3IFNvY2tldEVycm9yKCdjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8oc29ja2V0KSlcblxuICAgIGNsaWVudFtrSFRUUDJTZXNzaW9uXSA9IG51bGxcblxuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nXSA9PT0gMClcblxuICAgICAgLy8gRmFpbCBlbnRpcmUgcXVldWUuXG4gICAgICBjb25zdCByZXF1ZXN0cyA9IGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1J1bm5pbmdJZHhdKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXF1ZXN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHNlc3Npb24udW5yZWYoKVxuXG4gIGNsaWVudFtrSFRUUDJTZXNzaW9uXSA9IHNlc3Npb25cbiAgc29ja2V0W2tIVFRQMlNlc3Npb25dID0gc2Vzc2lvblxuXG4gIHV0aWwuYWRkTGlzdGVuZXIoc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYXNzZXJ0KGVyci5jb2RlICE9PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpXG5cbiAgICB0aGlzW2tFcnJvcl0gPSBlcnJcblxuICAgIHRoaXNba0NsaWVudF1ba09uRXJyb3JdKGVycilcbiAgfSlcblxuICB1dGlsLmFkZExpc3RlbmVyKHNvY2tldCwgJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICB1dGlsLmRlc3Ryb3kodGhpcywgbmV3IFNvY2tldEVycm9yKCdvdGhlciBzaWRlIGNsb3NlZCcsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSkpXG4gIH0pXG5cbiAgdXRpbC5hZGRMaXN0ZW5lcihzb2NrZXQsICdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBlcnIgPSB0aGlzW2tFcnJvcl0gfHwgbmV3IFNvY2tldEVycm9yKCdjbG9zZWQnLCB1dGlsLmdldFNvY2tldEluZm8odGhpcykpXG5cbiAgICBjbGllbnRba1NvY2tldF0gPSBudWxsXG5cbiAgICBpZiAodGhpc1trSFRUUDJTZXNzaW9uXSAhPSBudWxsKSB7XG4gICAgICB0aGlzW2tIVFRQMlNlc3Npb25dLmRlc3Ryb3koZXJyKVxuICAgIH1cblxuICAgIGNsaWVudFtrUGVuZGluZ0lkeF0gPSBjbGllbnRba1J1bm5pbmdJZHhdXG5cbiAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcblxuICAgIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuXG4gICAgY2xpZW50W2tSZXN1bWVdKClcbiAgfSlcblxuICBsZXQgY2xvc2VkID0gZmFsc2VcbiAgc29ja2V0Lm9uKCdjbG9zZScsICgpID0+IHtcbiAgICBjbG9zZWQgPSB0cnVlXG4gIH0pXG5cbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAnaDInLFxuICAgIGRlZmF1bHRQaXBlbGluaW5nOiBJbmZpbml0eSxcbiAgICB3cml0ZSAoLi4uYXJncykge1xuICAgICAgcmV0dXJuIHdyaXRlSDIoY2xpZW50LCAuLi5hcmdzKVxuICAgIH0sXG4gICAgcmVzdW1lICgpIHtcbiAgICAgIHJlc3VtZUgyKGNsaWVudClcbiAgICB9LFxuICAgIGRlc3Ryb3kgKGVyciwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZXN0cm95aW5nIHRoZSBzb2NrZXQgd2lsbCB0cmlnZ2VyIHRoZSBzZXNzaW9uIGNsb3NlXG4gICAgICAgIHNvY2tldC5kZXN0cm95KGVycikub24oJ2Nsb3NlJywgY2FsbGJhY2spXG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQgZGVzdHJveWVkICgpIHtcbiAgICAgIHJldHVybiBzb2NrZXQuZGVzdHJveWVkXG4gICAgfSxcbiAgICBidXN5ICgpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVIMiAoY2xpZW50KSB7XG4gIGNvbnN0IHNvY2tldCA9IGNsaWVudFtrU29ja2V0XVxuXG4gIGlmIChzb2NrZXQ/LmRlc3Ryb3llZCA9PT0gZmFsc2UpIHtcbiAgICBpZiAoY2xpZW50W2tTaXplXSA9PT0gMCAmJiBjbGllbnRba01heENvbmN1cnJlbnRTdHJlYW1zXSA9PT0gMCkge1xuICAgICAgc29ja2V0LnVucmVmKClcbiAgICAgIGNsaWVudFtrSFRUUDJTZXNzaW9uXS51bnJlZigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHNvY2tldC5yZWYoKVxuICAgICAgY2xpZW50W2tIVFRQMlNlc3Npb25dLnJlZigpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSHR0cDJTZXNzaW9uRXJyb3IgKGVycikge1xuICBhc3NlcnQoZXJyLmNvZGUgIT09ICdFUlJfVExTX0NFUlRfQUxUTkFNRV9JTlZBTElEJylcblxuICB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gPSBlcnJcbiAgdGhpc1trQ2xpZW50XVtrT25FcnJvcl0oZXJyKVxufVxuXG5mdW5jdGlvbiBvbkh0dHAyRnJhbWVFcnJvciAodHlwZSwgY29kZSwgaWQpIHtcbiAgaWYgKGlkID09PSAwKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEluZm9ybWF0aW9uYWxFcnJvcihgSFRUUC8yOiBcImZyYW1lRXJyb3JcIiByZWNlaXZlZCAtIHR5cGUgJHt0eXBlfSwgY29kZSAke2NvZGV9YClcbiAgICB0aGlzW2tTb2NrZXRdW2tFcnJvcl0gPSBlcnJcbiAgICB0aGlzW2tDbGllbnRdW2tPbkVycm9yXShlcnIpXG4gIH1cbn1cblxuZnVuY3Rpb24gb25IdHRwMlNlc3Npb25FbmQgKCkge1xuICBjb25zdCBlcnIgPSBuZXcgU29ja2V0RXJyb3IoJ290aGVyIHNpZGUgY2xvc2VkJywgdXRpbC5nZXRTb2NrZXRJbmZvKHRoaXNba1NvY2tldF0pKVxuICB0aGlzLmRlc3Ryb3koZXJyKVxuICB1dGlsLmRlc3Ryb3kodGhpc1trU29ja2V0XSwgZXJyKVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHJvb3QgY2F1c2Ugb2YgIzMwMTFcbiAqIFdlIG5lZWQgdG8gaGFuZGxlIEdPQVdBWSBmcmFtZXMgcHJvcGVybHksIGFuZCB0cmlnZ2VyIHRoZSBzZXNzaW9uIGNsb3NlXG4gKiBhbG9uZyB3aXRoIHRoZSBzb2NrZXQgcmlnaHQgYXdheVxuICovXG5mdW5jdGlvbiBvbkhUVFAyR29Bd2F5IChjb2RlKSB7XG4gIC8vIFdlIGNhbm5vdCByZWNvdmVyLCBzbyBiZXN0IHRvIGNsb3NlIHRoZSBzZXNzaW9uIGFuZCB0aGUgc29ja2V0XG4gIGNvbnN0IGVyciA9IHRoaXNba0Vycm9yXSB8fCBuZXcgU29ja2V0RXJyb3IoYEhUVFAvMjogXCJHT0FXQVlcIiBmcmFtZSByZWNlaXZlZCB3aXRoIGNvZGUgJHtjb2RlfWAsIHV0aWwuZ2V0U29ja2V0SW5mbyh0aGlzKSlcbiAgY29uc3QgY2xpZW50ID0gdGhpc1trQ2xpZW50XVxuXG4gIGNsaWVudFtrU29ja2V0XSA9IG51bGxcbiAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBudWxsXG5cbiAgaWYgKHRoaXNba0hUVFAyU2Vzc2lvbl0gIT0gbnVsbCkge1xuICAgIHRoaXNba0hUVFAyU2Vzc2lvbl0uZGVzdHJveShlcnIpXG4gICAgdGhpc1trSFRUUDJTZXNzaW9uXSA9IG51bGxcbiAgfVxuXG4gIHV0aWwuZGVzdHJveSh0aGlzW2tTb2NrZXRdLCBlcnIpXG5cbiAgLy8gRmFpbCBoZWFkIG9mIHBpcGVsaW5lLlxuICBpZiAoY2xpZW50W2tSdW5uaW5nSWR4XSA8IGNsaWVudFtrUXVldWVdLmxlbmd0aCkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdXVxuICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gICAgY2xpZW50W2tQZW5kaW5nSWR4XSA9IGNsaWVudFtrUnVubmluZ0lkeF1cbiAgfVxuXG4gIGFzc2VydChjbGllbnRba1J1bm5pbmddID09PSAwKVxuXG4gIGNsaWVudC5lbWl0KCdkaXNjb25uZWN0JywgY2xpZW50W2tVcmxdLCBbY2xpZW50XSwgZXJyKVxuXG4gIGNsaWVudFtrUmVzdW1lXSgpXG59XG5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3MjMwI3NlY3Rpb24tMy4zLjJcbmZ1bmN0aW9uIHNob3VsZFNlbmRDb250ZW50TGVuZ3RoIChtZXRob2QpIHtcbiAgcmV0dXJuIG1ldGhvZCAhPT0gJ0dFVCcgJiYgbWV0aG9kICE9PSAnSEVBRCcgJiYgbWV0aG9kICE9PSAnT1BUSU9OUycgJiYgbWV0aG9kICE9PSAnVFJBQ0UnICYmIG1ldGhvZCAhPT0gJ0NPTk5FQ1QnXG59XG5cbmZ1bmN0aW9uIHdyaXRlSDIgKGNsaWVudCwgcmVxdWVzdCkge1xuICBjb25zdCBzZXNzaW9uID0gY2xpZW50W2tIVFRQMlNlc3Npb25dXG4gIGNvbnN0IHsgbWV0aG9kLCBwYXRoLCBob3N0LCB1cGdyYWRlLCBleHBlY3RDb250aW51ZSwgc2lnbmFsLCBoZWFkZXJzOiByZXFIZWFkZXJzIH0gPSByZXF1ZXN0XG4gIGxldCB7IGJvZHkgfSA9IHJlcXVlc3RcblxuICBpZiAodXBncmFkZSkge1xuICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgbmV3IEVycm9yKCdVcGdyYWRlIG5vdCBzdXBwb3J0ZWQgZm9yIEgyJykpXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBjb25zdCBoZWFkZXJzID0ge31cbiAgZm9yIChsZXQgbiA9IDA7IG4gPCByZXFIZWFkZXJzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgY29uc3Qga2V5ID0gcmVxSGVhZGVyc1tuICsgMF1cbiAgICBjb25zdCB2YWwgPSByZXFIZWFkZXJzW24gKyAxXVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhlYWRlcnNba2V5XSkge1xuICAgICAgICAgIGhlYWRlcnNba2V5XSArPSBgLCR7dmFsW2ldfWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWxbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkZXJzW2tleV0gPSB2YWxcbiAgICB9XG4gIH1cblxuICAvKiogQHR5cGUge2ltcG9ydCgnbm9kZTpodHRwMicpLkNsaWVudEh0dHAyU3RyZWFtfSAqL1xuICBsZXQgc3RyZWFtXG5cbiAgY29uc3QgeyBob3N0bmFtZSwgcG9ydCB9ID0gY2xpZW50W2tVcmxdXG5cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQVVUSE9SSVRZXSA9IGhvc3QgfHwgYCR7aG9zdG5hbWV9JHtwb3J0ID8gYDoke3BvcnR9YCA6ICcnfWBcbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfTUVUSE9EXSA9IG1ldGhvZFxuXG4gIGNvbnN0IGFib3J0ID0gKGVycikgPT4ge1xuICAgIGlmIChyZXF1ZXN0LmFib3J0ZWQgfHwgcmVxdWVzdC5jb21wbGV0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGVyciA9IGVyciB8fCBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG5cbiAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcblxuICAgIGlmIChzdHJlYW0gIT0gbnVsbCkge1xuICAgICAgdXRpbC5kZXN0cm95KHN0cmVhbSwgZXJyKVxuICAgIH1cblxuICAgIC8vIFdlIGRvIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgYXMgd2UgY2FuIGNvbnRpbnVlIHVzaW5nIHRoZSBzZXNzaW9uXG4gICAgLy8gdGhlIHN0cmVhbSBnZXQncyBkZXN0cm95ZWQgYW5kIHRoZSBzZXNzaW9uIHJlbWFpbnMgdG8gY3JlYXRlIG5ldyBzdHJlYW1zXG4gICAgdXRpbC5kZXN0cm95KGJvZHksIGVycilcbiAgICBjbGllbnRba1F1ZXVlXVtjbGllbnRba1J1bm5pbmdJZHhdKytdID0gbnVsbFxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH1cblxuICB0cnkge1xuICAgIC8vIFdlIGFyZSBhbHJlYWR5IGNvbm5lY3RlZCwgc3RyZWFtcyBhcmUgcGVuZGluZy5cbiAgICAvLyBXZSBjYW4gY2FsbCBvbiBjb25uZWN0LCBhbmQgd2FpdCBmb3IgYWJvcnRcbiAgICByZXF1ZXN0Lm9uQ29ubmVjdChhYm9ydClcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgdXRpbC5lcnJvclJlcXVlc3QoY2xpZW50LCByZXF1ZXN0LCBlcnIpXG4gIH1cblxuICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBpZiAobWV0aG9kID09PSAnQ09OTkVDVCcpIHtcbiAgICBzZXNzaW9uLnJlZigpXG4gICAgLy8gV2UgYXJlIGFscmVhZHkgY29ubmVjdGVkLCBzdHJlYW1zIGFyZSBwZW5kaW5nLCBmaXJzdCByZXF1ZXN0XG4gICAgLy8gd2lsbCBjcmVhdGUgYSBuZXcgc3RyZWFtLiBXZSB0cmlnZ2VyIGEgcmVxdWVzdCB0byBjcmVhdGUgdGhlIHN0cmVhbSBhbmQgd2FpdCB1bnRpbFxuICAgIC8vIGByZWFkeWAgZXZlbnQgaXMgdHJpZ2dlcmVkXG4gICAgLy8gV2UgZGlzYWJsZWQgZW5kU3RyZWFtIHRvIGFsbG93IHRoZSB1c2VyIHRvIHdyaXRlIHRvIHRoZSBzdHJlYW1cbiAgICBzdHJlYW0gPSBzZXNzaW9uLnJlcXVlc3QoaGVhZGVycywgeyBlbmRTdHJlYW06IGZhbHNlLCBzaWduYWwgfSlcblxuICAgIGlmIChzdHJlYW0uaWQgJiYgIXN0cmVhbS5wZW5kaW5nKSB7XG4gICAgICByZXF1ZXN0Lm9uVXBncmFkZShudWxsLCBudWxsLCBzdHJlYW0pXG4gICAgICArK3Nlc3Npb25ba09wZW5TdHJlYW1zXVxuICAgICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLm9uY2UoJ3JlYWR5JywgKCkgPT4ge1xuICAgICAgICByZXF1ZXN0Lm9uVXBncmFkZShudWxsLCBudWxsLCBzdHJlYW0pXG4gICAgICAgICsrc2Vzc2lvbltrT3BlblN0cmVhbXNdXG4gICAgICAgIGNsaWVudFtrUXVldWVdW2NsaWVudFtrUnVubmluZ0lkeF0rK10gPSBudWxsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHN0cmVhbS5vbmNlKCdjbG9zZScsICgpID0+IHtcbiAgICAgIHNlc3Npb25ba09wZW5TdHJlYW1zXSAtPSAxXG4gICAgICBpZiAoc2Vzc2lvbltrT3BlblN0cmVhbXNdID09PSAwKSBzZXNzaW9uLnVucmVmKClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTQwI3NlY3Rpb24tOC4zXG4gIC8vIDpwYXRoIGFuZCA6c2NoZW1lIGhlYWRlcnMgbXVzdCBiZSBvbWl0dGVkIHdoZW4gc2VuZGluZyBDT05ORUNUXG5cbiAgaGVhZGVyc1tIVFRQMl9IRUFERVJfUEFUSF0gPSBwYXRoXG4gIGhlYWRlcnNbSFRUUDJfSEVBREVSX1NDSEVNRV0gPSAnaHR0cHMnXG5cbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi00LjMuMVxuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTQuMy4yXG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNC4zLjVcblxuICAvLyBTZW5kaW5nIGEgcGF5bG9hZCBib2R5IG9uIGEgcmVxdWVzdCB0aGF0IGRvZXMgbm90XG4gIC8vIGV4cGVjdCBpdCBjYW4gY2F1c2UgdW5kZWZpbmVkIGJlaGF2aW9yIG9uIHNvbWVcbiAgLy8gc2VydmVycyBhbmQgY29ycnVwdCBjb25uZWN0aW9uIHN0YXRlLiBEbyBub3RcbiAgLy8gcmUtdXNlIHRoZSBjb25uZWN0aW9uIGZvciBmdXJ0aGVyIHJlcXVlc3RzLlxuXG4gIGNvbnN0IGV4cGVjdHNQYXlsb2FkID0gKFxuICAgIG1ldGhvZCA9PT0gJ1BVVCcgfHxcbiAgICBtZXRob2QgPT09ICdQT1NUJyB8fFxuICAgIG1ldGhvZCA9PT0gJ1BBVENIJ1xuICApXG5cbiAgaWYgKGJvZHkgJiYgdHlwZW9mIGJvZHkucmVhZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFRyeSB0byByZWFkIEVPRiBpbiBvcmRlciB0byBnZXQgbGVuZ3RoLlxuICAgIGJvZHkucmVhZCgwKVxuICB9XG5cbiAgbGV0IGNvbnRlbnRMZW5ndGggPSB1dGlsLmJvZHlMZW5ndGgoYm9keSlcblxuICBpZiAodXRpbC5pc0Zvcm1EYXRhTGlrZShib2R5KSkge1xuICAgIGV4dHJhY3RCb2R5ID8/PSByZXF1aXJlKCcuLi93ZWIvZmV0Y2gvYm9keS5qcycpLmV4dHJhY3RCb2R5XG5cbiAgICBjb25zdCBbYm9keVN0cmVhbSwgY29udGVudFR5cGVdID0gZXh0cmFjdEJvZHkoYm9keSlcbiAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IGNvbnRlbnRUeXBlXG5cbiAgICBib2R5ID0gYm9keVN0cmVhbS5zdHJlYW1cbiAgICBjb250ZW50TGVuZ3RoID0gYm9keVN0cmVhbS5sZW5ndGhcbiAgfVxuXG4gIGlmIChjb250ZW50TGVuZ3RoID09IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoID0gcmVxdWVzdC5jb250ZW50TGVuZ3RoXG4gIH1cblxuICBpZiAoY29udGVudExlbmd0aCA9PT0gMCB8fCAhZXhwZWN0c1BheWxvYWQpIHtcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMy4yXG4gICAgLy8gQSB1c2VyIGFnZW50IFNIT1VMRCBOT1Qgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBmaWVsZCB3aGVuXG4gICAgLy8gdGhlIHJlcXVlc3QgbWVzc2FnZSBkb2VzIG5vdCBjb250YWluIGEgcGF5bG9hZCBib2R5IGFuZCB0aGUgbWV0aG9kXG4gICAgLy8gc2VtYW50aWNzIGRvIG5vdCBhbnRpY2lwYXRlIHN1Y2ggYSBib2R5LlxuXG4gICAgY29udGVudExlbmd0aCA9IG51bGxcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDQ2XG4gIC8vIEEgdXNlciBhZ2VudCBtYXkgc2VuZCBhIENvbnRlbnQtTGVuZ3RoIGhlYWRlciB3aXRoIDAgdmFsdWUsIHRoaXMgc2hvdWxkIGJlIGFsbG93ZWQuXG4gIGlmIChzaG91bGRTZW5kQ29udGVudExlbmd0aChtZXRob2QpICYmIGNvbnRlbnRMZW5ndGggPiAwICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPSBudWxsICYmIHJlcXVlc3QuY29udGVudExlbmd0aCAhPT0gY29udGVudExlbmd0aCkge1xuICAgIGlmIChjbGllbnRba1N0cmljdENvbnRlbnRMZW5ndGhdKSB7XG4gICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcobmV3IFJlcXVlc3RDb250ZW50TGVuZ3RoTWlzbWF0Y2hFcnJvcigpKVxuICB9XG5cbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCkge1xuICAgIGFzc2VydChib2R5LCAnbm8gYm9keSBtdXN0IG5vdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcbiAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9DT05URU5UX0xFTkdUSF0gPSBgJHtjb250ZW50TGVuZ3RofWBcbiAgfVxuXG4gIHNlc3Npb24ucmVmKClcblxuICBjb25zdCBzaG91bGRFbmRTdHJlYW0gPSBtZXRob2QgPT09ICdHRVQnIHx8IG1ldGhvZCA9PT0gJ0hFQUQnIHx8IGJvZHkgPT09IG51bGxcbiAgaWYgKGV4cGVjdENvbnRpbnVlKSB7XG4gICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfRVhQRUNUXSA9ICcxMDAtY29udGludWUnXG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHsgZW5kU3RyZWFtOiBzaG91bGRFbmRTdHJlYW0sIHNpZ25hbCB9KVxuXG4gICAgc3RyZWFtLm9uY2UoJ2NvbnRpbnVlJywgd3JpdGVCb2R5SDIpXG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gc2Vzc2lvbi5yZXF1ZXN0KGhlYWRlcnMsIHtcbiAgICAgIGVuZFN0cmVhbTogc2hvdWxkRW5kU3RyZWFtLFxuICAgICAgc2lnbmFsXG4gICAgfSlcbiAgICB3cml0ZUJvZHlIMigpXG4gIH1cblxuICAvLyBJbmNyZW1lbnQgY291bnRlciBhcyB3ZSBoYXZlIG5ldyBzdHJlYW1zIG9wZW5cbiAgKytzZXNzaW9uW2tPcGVuU3RyZWFtc11cblxuICBzdHJlYW0ub25jZSgncmVzcG9uc2UnLCBoZWFkZXJzID0+IHtcbiAgICBjb25zdCB7IFtIVFRQMl9IRUFERVJfU1RBVFVTXTogc3RhdHVzQ29kZSwgLi4ucmVhbEhlYWRlcnMgfSA9IGhlYWRlcnNcbiAgICByZXF1ZXN0Lm9uUmVzcG9uc2VTdGFydGVkKClcblxuICAgIC8vIER1ZSB0byB0aGUgc3RyZWFtIG5hdHVyZSwgaXQgaXMgcG9zc2libGUgd2UgZmFjZSBhIHJhY2UgY29uZGl0aW9uXG4gICAgLy8gd2hlcmUgdGhlIHN0cmVhbSBoYXMgYmVlbiBhc3NpZ25lZCwgYnV0IHRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWRcbiAgICAvLyB0aGUgcmVxdWVzdCByZW1haW5zIGluLWZsaWdodCBhbmQgaGVhZGVycyBoYXNuJ3QgYmVlbiByZWNlaXZlZCB5ZXRcbiAgICAvLyBmb3IgdGhvc2Ugc2NlbmFyaW9zLCBiZXN0IGVmZm9ydCBpcyB0byBkZXN0cm95IHRoZSBzdHJlYW0gaW1tZWRpYXRlbHlcbiAgICAvLyBhcyB0aGVyZSdzIG5vIHZhbHVlIHRvIGtlZXAgaXQgb3Blbi5cbiAgICBpZiAocmVxdWVzdC5hYm9ydGVkKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgUmVxdWVzdEFib3J0ZWRFcnJvcigpXG4gICAgICB1dGlsLmVycm9yUmVxdWVzdChjbGllbnQsIHJlcXVlc3QsIGVycilcbiAgICAgIHV0aWwuZGVzdHJveShzdHJlYW0sIGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0Lm9uSGVhZGVycyhOdW1iZXIoc3RhdHVzQ29kZSksIHBhcnNlSDJIZWFkZXJzKHJlYWxIZWFkZXJzKSwgc3RyZWFtLnJlc3VtZS5iaW5kKHN0cmVhbSksICcnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHN0cmVhbS5wYXVzZSgpXG4gICAgfVxuXG4gICAgc3RyZWFtLm9uKCdkYXRhJywgKGNodW5rKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5vbkRhdGEoY2h1bmspID09PSBmYWxzZSkge1xuICAgICAgICBzdHJlYW0ucGF1c2UoKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2VuZCcsICgpID0+IHtcbiAgICAvLyBXaGVuIHN0YXRlIGlzIG51bGwsIGl0IG1lYW5zIHdlIGhhdmVuJ3QgY29uc3VtZWQgYm9keSBhbmQgdGhlIHN0cmVhbSBzdGlsbCBkbyBub3QgaGF2ZVxuICAgIC8vIGEgc3RhdGUuXG4gICAgLy8gUHJlc2VudCBzcGVjaWFsbHkgd2hlbiB1c2luZyBwaXBlbGluZSBvciBzdHJlYW1cbiAgICBpZiAoc3RyZWFtLnN0YXRlPy5zdGF0ZSA9PSBudWxsIHx8IHN0cmVhbS5zdGF0ZS5zdGF0ZSA8IDYpIHtcbiAgICAgIHJlcXVlc3Qub25Db21wbGV0ZShbXSlcbiAgICB9XG5cbiAgICBpZiAoc2Vzc2lvbltrT3BlblN0cmVhbXNdID09PSAwKSB7XG4gICAgICAvLyBTdHJlYW0gaXMgY2xvc2VkIG9yIGhhbGYtY2xvc2VkLXJlbW90ZSAoNiksIGRlY3JlbWVudCBjb3VudGVyIGFuZCBjbGVhbnVwXG4gICAgICAvLyBJdCBkb2VzIG5vdCBoYXZlIHNlbnNlIHRvIGNvbnRpbnVlIHdvcmtpbmcgd2l0aCB0aGUgc3RyZWFtIGFzIHdlIGRvIG5vdFxuICAgICAgLy8gaGF2ZSB5ZXQgUlNUX1NUUkVBTSBzdXBwb3J0IG9uIGNsaWVudC1zaWRlXG5cbiAgICAgIHNlc3Npb24udW5yZWYoKVxuICAgIH1cblxuICAgIGFib3J0KG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoJ0hUVFAvMjogc3RyZWFtIGhhbGYtY2xvc2VkIChyZW1vdGUpJykpXG4gICAgY2xpZW50W2tRdWV1ZV1bY2xpZW50W2tSdW5uaW5nSWR4XSsrXSA9IG51bGxcbiAgICBjbGllbnRba1BlbmRpbmdJZHhdID0gY2xpZW50W2tSdW5uaW5nSWR4XVxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgIHNlc3Npb25ba09wZW5TdHJlYW1zXSAtPSAxXG4gICAgaWYgKHNlc3Npb25ba09wZW5TdHJlYW1zXSA9PT0gMCkge1xuICAgICAgc2Vzc2lvbi51bnJlZigpXG4gICAgfVxuICB9KVxuXG4gIHN0cmVhbS5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH0pXG5cbiAgc3RyZWFtLm9uY2UoJ2ZyYW1lRXJyb3InLCAodHlwZSwgY29kZSkgPT4ge1xuICAgIGFib3J0KG5ldyBJbmZvcm1hdGlvbmFsRXJyb3IoYEhUVFAvMjogXCJmcmFtZUVycm9yXCIgcmVjZWl2ZWQgLSB0eXBlICR7dHlwZX0sIGNvZGUgJHtjb2RlfWApKVxuICB9KVxuXG4gIC8vIHN0cmVhbS5vbignYWJvcnRlZCcsICgpID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgYWJvcnRlZFxuICAvLyB9KVxuXG4gIC8vIHN0cmVhbS5vbigndGltZW91dCcsICgpID0+IHtcbiAgLy8gICAvLyBUT0RPKEhUVFAvMik6IFN1cHBvcnQgdGltZW91dFxuICAvLyB9KVxuXG4gIC8vIHN0cmVhbS5vbigncHVzaCcsIGhlYWRlcnMgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9ydCBwdXNoXG4gIC8vIH0pXG5cbiAgLy8gc3RyZWFtLm9uKCd0cmFpbGVycycsIGhlYWRlcnMgPT4ge1xuICAvLyAgIC8vIFRPRE8oSFRUUC8yKTogU3VwcG9ydCB0cmFpbGVyc1xuICAvLyB9KVxuXG4gIHJldHVybiB0cnVlXG5cbiAgZnVuY3Rpb24gd3JpdGVCb2R5SDIgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBhc3NlcnRpb24gKi9cbiAgICBpZiAoIWJvZHkgfHwgY29udGVudExlbmd0aCA9PT0gMCkge1xuICAgICAgd3JpdGVCdWZmZXIoXG4gICAgICAgIGFib3J0LFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIG51bGwsXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgd3JpdGVCdWZmZXIoXG4gICAgICAgIGFib3J0LFxuICAgICAgICBzdHJlYW0sXG4gICAgICAgIGJvZHksXG4gICAgICAgIGNsaWVudCxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICBleHBlY3RzUGF5bG9hZFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAodXRpbC5pc0Jsb2JMaWtlKGJvZHkpKSB7XG4gICAgICBpZiAodHlwZW9mIGJvZHkuc3RyZWFtID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdyaXRlSXRlcmFibGUoXG4gICAgICAgICAgYWJvcnQsXG4gICAgICAgICAgc3RyZWFtLFxuICAgICAgICAgIGJvZHkuc3RyZWFtKCksXG4gICAgICAgICAgY2xpZW50LFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgICAgZXhwZWN0c1BheWxvYWRcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGVCbG9iKFxuICAgICAgICAgIGFib3J0LFxuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGNsaWVudFtrU29ja2V0XSxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoLFxuICAgICAgICAgIGV4cGVjdHNQYXlsb2FkXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNTdHJlYW0oYm9keSkpIHtcbiAgICAgIHdyaXRlU3RyZWFtKFxuICAgICAgICBhYm9ydCxcbiAgICAgICAgY2xpZW50W2tTb2NrZXRdLFxuICAgICAgICBleHBlY3RzUGF5bG9hZCxcbiAgICAgICAgc3RyZWFtLFxuICAgICAgICBib2R5LFxuICAgICAgICBjbGllbnQsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGNvbnRlbnRMZW5ndGhcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNJdGVyYWJsZShib2R5KSkge1xuICAgICAgd3JpdGVJdGVyYWJsZShcbiAgICAgICAgYWJvcnQsXG4gICAgICAgIHN0cmVhbSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgY2xpZW50LFxuICAgICAgICByZXF1ZXN0LFxuICAgICAgICBjbGllbnRba1NvY2tldF0sXG4gICAgICAgIGNvbnRlbnRMZW5ndGgsXG4gICAgICAgIGV4cGVjdHNQYXlsb2FkXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVCdWZmZXIgKGFib3J0LCBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBzb2NrZXQsIGNvbnRlbnRMZW5ndGgsIGV4cGVjdHNQYXlsb2FkKSB7XG4gIHRyeSB7XG4gICAgaWYgKGJvZHkgIT0gbnVsbCAmJiB1dGlsLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICBhc3NlcnQoY29udGVudExlbmd0aCA9PT0gYm9keS5ieXRlTGVuZ3RoLCAnYnVmZmVyIGJvZHkgbXVzdCBoYXZlIGNvbnRlbnQgbGVuZ3RoJylcbiAgICAgIGgyc3RyZWFtLmNvcmsoKVxuICAgICAgaDJzdHJlYW0ud3JpdGUoYm9keSlcbiAgICAgIGgyc3RyZWFtLnVuY29yaygpXG4gICAgICBoMnN0cmVhbS5lbmQoKVxuXG4gICAgICByZXF1ZXN0Lm9uQm9keVNlbnQoYm9keSlcbiAgICB9XG5cbiAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9uUmVxdWVzdFNlbnQoKVxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYWJvcnQoZXJyb3IpXG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVTdHJlYW0gKGFib3J0LCBzb2NrZXQsIGV4cGVjdHNQYXlsb2FkLCBoMnN0cmVhbSwgYm9keSwgY2xpZW50LCByZXF1ZXN0LCBjb250ZW50TGVuZ3RoKSB7XG4gIGFzc2VydChjb250ZW50TGVuZ3RoICE9PSAwIHx8IGNsaWVudFtrUnVubmluZ10gPT09IDAsICdzdHJlYW0gYm9keSBjYW5ub3QgYmUgcGlwZWxpbmVkJylcblxuICAvLyBGb3IgSFRUUC8yLCBpcyBlbm91Z2ggdG8gcGlwZSB0aGUgc3RyZWFtXG4gIGNvbnN0IHBpcGUgPSBwaXBlbGluZShcbiAgICBib2R5LFxuICAgIGgyc3RyZWFtLFxuICAgIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdXRpbC5kZXN0cm95KHBpcGUsIGVycilcbiAgICAgICAgYWJvcnQoZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5yZW1vdmVBbGxMaXN0ZW5lcnMocGlwZSlcbiAgICAgICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgICAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICAgICAgc29ja2V0W2tSZXNldF0gPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICBjbGllbnRba1Jlc3VtZV0oKVxuICAgICAgfVxuICAgIH1cbiAgKVxuXG4gIHV0aWwuYWRkTGlzdGVuZXIocGlwZSwgJ2RhdGEnLCBvblBpcGVEYXRhKVxuXG4gIGZ1bmN0aW9uIG9uUGlwZURhdGEgKGNodW5rKSB7XG4gICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlQmxvYiAoYWJvcnQsIGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggPT09IGJvZHkuc2l6ZSwgJ2Jsb2IgYm9keSBtdXN0IGhhdmUgY29udGVudCBsZW5ndGgnKVxuXG4gIHRyeSB7XG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoICE9PSBib2R5LnNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSZXF1ZXN0Q29udGVudExlbmd0aE1pc21hdGNoRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGF3YWl0IGJvZHkuYXJyYXlCdWZmZXIoKSlcblxuICAgIGgyc3RyZWFtLmNvcmsoKVxuICAgIGgyc3RyZWFtLndyaXRlKGJ1ZmZlcilcbiAgICBoMnN0cmVhbS51bmNvcmsoKVxuICAgIGgyc3RyZWFtLmVuZCgpXG5cbiAgICByZXF1ZXN0Lm9uQm9keVNlbnQoYnVmZmVyKVxuICAgIHJlcXVlc3Qub25SZXF1ZXN0U2VudCgpXG5cbiAgICBpZiAoIWV4cGVjdHNQYXlsb2FkKSB7XG4gICAgICBzb2NrZXRba1Jlc2V0XSA9IHRydWVcbiAgICB9XG5cbiAgICBjbGllbnRba1Jlc3VtZV0oKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBhYm9ydChlcnIpXG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd3JpdGVJdGVyYWJsZSAoYWJvcnQsIGgyc3RyZWFtLCBib2R5LCBjbGllbnQsIHJlcXVlc3QsIHNvY2tldCwgY29udGVudExlbmd0aCwgZXhwZWN0c1BheWxvYWQpIHtcbiAgYXNzZXJ0KGNvbnRlbnRMZW5ndGggIT09IDAgfHwgY2xpZW50W2tSdW5uaW5nXSA9PT0gMCwgJ2l0ZXJhdG9yIGJvZHkgY2Fubm90IGJlIHBpcGVsaW5lZCcpXG5cbiAgbGV0IGNhbGxiYWNrID0gbnVsbFxuICBmdW5jdGlvbiBvbkRyYWluICgpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2tcbiAgICAgIGNhbGxiYWNrID0gbnVsbFxuICAgICAgY2IoKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHdhaXRGb3JEcmFpbiA9ICgpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBhc3NlcnQoY2FsbGJhY2sgPT09IG51bGwpXG5cbiAgICBpZiAoc29ja2V0W2tFcnJvcl0pIHtcbiAgICAgIHJlamVjdChzb2NrZXRba0Vycm9yXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2sgPSByZXNvbHZlXG4gICAgfVxuICB9KVxuXG4gIGgyc3RyZWFtXG4gICAgLm9uKCdjbG9zZScsIG9uRHJhaW4pXG4gICAgLm9uKCdkcmFpbicsIG9uRHJhaW4pXG5cbiAgdHJ5IHtcbiAgICAvLyBJdCdzIHVwIHRvIHRoZSB1c2VyIHRvIHNvbWVob3cgYWJvcnQgdGhlIGFzeW5jIGl0ZXJhYmxlLlxuICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgYm9keSkge1xuICAgICAgaWYgKHNvY2tldFtrRXJyb3JdKSB7XG4gICAgICAgIHRocm93IHNvY2tldFtrRXJyb3JdXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcyA9IGgyc3RyZWFtLndyaXRlKGNodW5rKVxuICAgICAgcmVxdWVzdC5vbkJvZHlTZW50KGNodW5rKVxuICAgICAgaWYgKCFyZXMpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvckRyYWluKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBoMnN0cmVhbS5lbmQoKVxuXG4gICAgcmVxdWVzdC5vblJlcXVlc3RTZW50KClcblxuICAgIGlmICghZXhwZWN0c1BheWxvYWQpIHtcbiAgICAgIHNvY2tldFtrUmVzZXRdID0gdHJ1ZVxuICAgIH1cblxuICAgIGNsaWVudFtrUmVzdW1lXSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGFib3J0KGVycilcbiAgfSBmaW5hbGx5IHtcbiAgICBoMnN0cmVhbVxuICAgICAgLm9mZignY2xvc2UnLCBvbkRyYWluKVxuICAgICAgLm9mZignZHJhaW4nLCBvbkRyYWluKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29ubmVjdEgyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/client-h2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/client.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/client.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// @ts-check\n\n\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst net = __webpack_require__(/*! node:net */ \"node:net\")\nconst http = __webpack_require__(/*! node:http */ \"node:http\")\nconst util = __webpack_require__(/*! ../core/util.js */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { channels } = __webpack_require__(/*! ../core/diagnostics.js */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst Request = __webpack_require__(/*! ../core/request.js */ \"(rsc)/./node_modules/undici/lib/core/request.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst {\n  InvalidArgumentError,\n  InformationalError,\n  ClientDestroyedError\n} = __webpack_require__(/*! ../core/errors.js */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect.js */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\nconst {\n  kUrl,\n  kServerName,\n  kClient,\n  kBusy,\n  kConnect,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize,\n  kOnError,\n  kHTTPContext,\n  kMaxConcurrentStreams,\n  kResume\n} = __webpack_require__(/*! ../core/symbols.js */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst connectH1 = __webpack_require__(/*! ./client-h1.js */ \"(rsc)/./node_modules/undici/lib/dispatcher/client-h1.js\")\nconst connectH2 = __webpack_require__(/*! ./client-h2.js */ \"(rsc)/./node_modules/undici/lib/dispatcher/client-h2.js\")\nlet deprecatedInterceptorWarned = false\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst noop = () => {}\n\nfunction getPipelining (client) {\n  return client[kPipelining] ?? client[kHTTPContext]?.defaultPipelining ?? 1\n}\n\n/**\n * @type {import('../../types/client.js').default}\n */\nclass Client extends DispatcherBase {\n  /**\n   *\n   * @param {string|URL} url\n   * @param {import('../../types/client.js').Client.Options} options\n   */\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    // h2\n    maxConcurrentStreams,\n    allowH2\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    // h2\n    if (allowH2 != null && typeof allowH2 !== 'boolean') {\n      throw new InvalidArgumentError('allowH2 must be a valid boolean value')\n    }\n\n    if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== 'number' || maxConcurrentStreams < 1)) {\n      throw new InvalidArgumentError('maxConcurrentStreams must be a positive integer, greater than 0')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    if (interceptors?.Client && Array.isArray(interceptors.Client)) {\n      this[kInterceptors] = interceptors.Client\n      if (!deprecatedInterceptorWarned) {\n        deprecatedInterceptorWarned = true\n        process.emitWarning('Client.Options#interceptor is deprecated. Use Dispatcher#compose instead.', {\n          code: 'UNDICI-CLIENT-INTERCEPTOR-DEPRECATED'\n        })\n      }\n    } else {\n      this[kInterceptors] = [createRedirectInterceptor({ maxRedirections })]\n    }\n\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 2e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n    this[kMaxConcurrentStreams] = maxConcurrentStreams != null ? maxConcurrentStreams : 100 // Max peerConcurrentStreams for a Node h2 server\n    this[kHTTPContext] = null\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n\n    this[kResume] = (sync) => resume(this, sync)\n    this[kOnError] = (err) => onError(this, err)\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    this[kResume](true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kHTTPContext] && !this[kConnecting] && !this[kHTTPContext].destroyed\n  }\n\n  get [kBusy] () {\n    return Boolean(\n      this[kHTTPContext]?.busy(null) ||\n      (this[kSize] >= (getPipelining(this) || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n    const request = new Request(origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      queueMicrotask(() => resume(this))\n    } else {\n      this[kResume](true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    // TODO: for H2 we need to gracefully flush the remaining enqueued\n    // request and close each stream.\n    return new Promise((resolve) => {\n      if (this[kSize]) {\n        this[kClosedResolve] = resolve\n      } else {\n        resolve(null)\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        util.errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          // TODO (fix): Should we error here with ClientDestroyedError?\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve(null)\n      }\n\n      if (this[kHTTPContext]) {\n        this[kHTTPContext].destroy(err, callback)\n        this[kHTTPContext] = null\n      } else {\n        queueMicrotask(callback)\n      }\n\n      this[kResume]()\n    })\n  }\n}\n\nconst createRedirectInterceptor = __webpack_require__(/*! ../interceptor/redirect-interceptor.js */ \"(rsc)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\")\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      util.errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\n/**\n * @param {Client} client\n * @returns\n */\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kHTTPContext])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substring(1, idx)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        version: client[kHTTPContext]?.version,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (client.destroyed) {\n      util.destroy(socket.on('error', noop), new ClientDestroyedError())\n      return\n    }\n\n    assert(socket)\n\n    try {\n      client[kHTTPContext] = socket.alpnProtocol === 'h2'\n        ? await connectH2(client, socket)\n        : await connectH1(client, socket)\n    } catch (err) {\n      socket.destroy().on('error', noop)\n      throw err\n    }\n\n    client[kConnecting] = false\n\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket[kClient] = client\n    socket[kError] = null\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    if (client.destroyed) {\n      return\n    }\n\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          version: client[kHTTPContext]?.version,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        util.errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  client[kResume]()\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosedResolve] && !client[kSize]) {\n      client[kClosedResolve]()\n      client[kClosedResolve] = null\n      return\n    }\n\n    if (client[kHTTPContext]) {\n      client[kHTTPContext].resume()\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        queueMicrotask(() => emitDrain(client))\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (getPipelining(client) || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n      client[kHTTPContext]?.destroy(new InformationalError('servername changed'), () => {\n        client[kHTTPContext] = null\n        resume(client)\n      })\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!client[kHTTPContext]) {\n      connect(client)\n      return\n    }\n\n    if (client[kHTTPContext].destroyed) {\n      return\n    }\n\n    if (client[kHTTPContext].busy(request)) {\n      return\n    }\n\n    if (!request.aborted && client[kHTTPContext].write(request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nmodule.exports = Client\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLDBCQUFVO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyw0QkFBVztBQUNoQyxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsbUZBQXdCO0FBQ3JELGdCQUFnQixtQkFBTyxDQUFDLDJFQUFvQjtBQUM1Qyx1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBbUI7QUFDL0IsdUJBQXVCLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7QUFDaEMsa0JBQWtCLG1CQUFPLENBQUMsK0VBQWdCO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLCtFQUFnQjtBQUMxQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGNsaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtY2hlY2tcblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25vZGU6bmV0JylcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdub2RlOmh0dHAnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbC5qcycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi9jb3JlL2RpYWdub3N0aWNzLmpzJylcbmNvbnN0IFJlcXVlc3QgPSByZXF1aXJlKCcuLi9jb3JlL3JlcXVlc3QuanMnKVxuY29uc3QgRGlzcGF0Y2hlckJhc2UgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItYmFzZScpXG5jb25zdCB7XG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbmZvcm1hdGlvbmFsRXJyb3IsXG4gIENsaWVudERlc3Ryb3llZEVycm9yXG59ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMuanMnKVxuY29uc3QgYnVpbGRDb25uZWN0b3IgPSByZXF1aXJlKCcuLi9jb3JlL2Nvbm5lY3QuanMnKVxuY29uc3Qge1xuICBrVXJsLFxuICBrU2VydmVyTmFtZSxcbiAga0NsaWVudCxcbiAga0J1c3ksXG4gIGtDb25uZWN0LFxuICBrUmVzdW1pbmcsXG4gIGtSdW5uaW5nLFxuICBrUGVuZGluZyxcbiAga1NpemUsXG4gIGtRdWV1ZSxcbiAga0Nvbm5lY3RlZCxcbiAga0Nvbm5lY3RpbmcsXG4gIGtOZWVkRHJhaW4sXG4gIGtLZWVwQWxpdmVEZWZhdWx0VGltZW91dCxcbiAga0hvc3RIZWFkZXIsXG4gIGtQZW5kaW5nSWR4LFxuICBrUnVubmluZ0lkeCxcbiAga0Vycm9yLFxuICBrUGlwZWxpbmluZyxcbiAga0tlZXBBbGl2ZVRpbWVvdXRWYWx1ZSxcbiAga01heEhlYWRlcnNTaXplLFxuICBrS2VlcEFsaXZlTWF4VGltZW91dCxcbiAga0tlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQsXG4gIGtIZWFkZXJzVGltZW91dCxcbiAga0JvZHlUaW1lb3V0LFxuICBrU3RyaWN0Q29udGVudExlbmd0aCxcbiAga0Nvbm5lY3RvcixcbiAga01heFJlZGlyZWN0aW9ucyxcbiAga01heFJlcXVlc3RzLFxuICBrQ291bnRlcixcbiAga0Nsb3NlLFxuICBrRGVzdHJveSxcbiAga0Rpc3BhdGNoLFxuICBrSW50ZXJjZXB0b3JzLFxuICBrTG9jYWxBZGRyZXNzLFxuICBrTWF4UmVzcG9uc2VTaXplLFxuICBrT25FcnJvcixcbiAga0hUVFBDb250ZXh0LFxuICBrTWF4Q29uY3VycmVudFN0cmVhbXMsXG4gIGtSZXN1bWVcbn0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMuanMnKVxuY29uc3QgY29ubmVjdEgxID0gcmVxdWlyZSgnLi9jbGllbnQtaDEuanMnKVxuY29uc3QgY29ubmVjdEgyID0gcmVxdWlyZSgnLi9jbGllbnQtaDIuanMnKVxubGV0IGRlcHJlY2F0ZWRJbnRlcmNlcHRvcldhcm5lZCA9IGZhbHNlXG5cbmNvbnN0IGtDbG9zZWRSZXNvbHZlID0gU3ltYm9sKCdrQ2xvc2VkUmVzb2x2ZScpXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5mdW5jdGlvbiBnZXRQaXBlbGluaW5nIChjbGllbnQpIHtcbiAgcmV0dXJuIGNsaWVudFtrUGlwZWxpbmluZ10gPz8gY2xpZW50W2tIVFRQQ29udGV4dF0/LmRlZmF1bHRQaXBlbGluaW5nID8/IDFcbn1cblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jbGllbnQuanMnKS5kZWZhdWx0fVxuICovXG5jbGFzcyBDbGllbnQgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2xpZW50LmpzJykuQ2xpZW50Lk9wdGlvbnN9IG9wdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1cmwsIHtcbiAgICBpbnRlcmNlcHRvcnMsXG4gICAgbWF4SGVhZGVyU2l6ZSxcbiAgICBoZWFkZXJzVGltZW91dCxcbiAgICBzb2NrZXRUaW1lb3V0LFxuICAgIHJlcXVlc3RUaW1lb3V0LFxuICAgIGNvbm5lY3RUaW1lb3V0LFxuICAgIGJvZHlUaW1lb3V0LFxuICAgIGlkbGVUaW1lb3V0LFxuICAgIGtlZXBBbGl2ZSxcbiAgICBrZWVwQWxpdmVUaW1lb3V0LFxuICAgIG1heEtlZXBBbGl2ZVRpbWVvdXQsXG4gICAga2VlcEFsaXZlTWF4VGltZW91dCxcbiAgICBrZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkLFxuICAgIHNvY2tldFBhdGgsXG4gICAgcGlwZWxpbmluZyxcbiAgICB0bHMsXG4gICAgc3RyaWN0Q29udGVudExlbmd0aCxcbiAgICBtYXhDYWNoZWRTZXNzaW9ucyxcbiAgICBtYXhSZWRpcmVjdGlvbnMsXG4gICAgY29ubmVjdCxcbiAgICBtYXhSZXF1ZXN0c1BlckNsaWVudCxcbiAgICBsb2NhbEFkZHJlc3MsXG4gICAgbWF4UmVzcG9uc2VTaXplLFxuICAgIGF1dG9TZWxlY3RGYW1pbHksXG4gICAgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0LFxuICAgIC8vIGgyXG4gICAgbWF4Q29uY3VycmVudFN0cmVhbXMsXG4gICAgYWxsb3dIMlxuICB9ID0ge30pIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoa2VlcEFsaXZlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQga2VlcEFsaXZlLCB1c2UgcGlwZWxpbmluZz0wIGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgc29ja2V0VGltZW91dCwgdXNlIGhlYWRlcnNUaW1lb3V0ICYgYm9keVRpbWVvdXQgaW5zdGVhZCcpXG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3RUaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigndW5zdXBwb3J0ZWQgcmVxdWVzdFRpbWVvdXQsIHVzZSBoZWFkZXJzVGltZW91dCAmIGJvZHlUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChpZGxlVGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIGlkbGVUaW1lb3V0LCB1c2Uga2VlcEFsaXZlVGltZW91dCBpbnN0ZWFkJylcbiAgICB9XG5cbiAgICBpZiAobWF4S2VlcEFsaXZlVGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Vuc3VwcG9ydGVkIG1heEtlZXBBbGl2ZVRpbWVvdXQsIHVzZSBrZWVwQWxpdmVNYXhUaW1lb3V0IGluc3RlYWQnKVxuICAgIH1cblxuICAgIGlmIChtYXhIZWFkZXJTaXplICE9IG51bGwgJiYgIU51bWJlci5pc0Zpbml0ZShtYXhIZWFkZXJTaXplKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdpbnZhbGlkIG1heEhlYWRlclNpemUnKVxuICAgIH1cblxuICAgIGlmIChzb2NrZXRQYXRoICE9IG51bGwgJiYgdHlwZW9mIHNvY2tldFBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgc29ja2V0UGF0aCcpXG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3RUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNGaW5pdGUoY29ubmVjdFRpbWVvdXQpIHx8IGNvbm5lY3RUaW1lb3V0IDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjb25uZWN0VGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVUaW1lb3V0KSB8fCBrZWVwQWxpdmVUaW1lb3V0IDw9IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlVGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZU1heFRpbWVvdXQgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShrZWVwQWxpdmVNYXhUaW1lb3V0KSB8fCBrZWVwQWxpdmVNYXhUaW1lb3V0IDw9IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlTWF4VGltZW91dCcpXG4gICAgfVxuXG4gICAgaWYgKGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQgIT0gbnVsbCAmJiAhTnVtYmVyLmlzRmluaXRlKGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQga2VlcEFsaXZlVGltZW91dFRocmVzaG9sZCcpXG4gICAgfVxuXG4gICAgaWYgKGhlYWRlcnNUaW1lb3V0ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKGhlYWRlcnNUaW1lb3V0KSB8fCBoZWFkZXJzVGltZW91dCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2hlYWRlcnNUaW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIHplcm8nKVxuICAgIH1cblxuICAgIGlmIChib2R5VGltZW91dCAhPSBudWxsICYmICghTnVtYmVyLmlzSW50ZWdlcihib2R5VGltZW91dCkgfHwgYm9keVRpbWVvdXQgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdib2R5VGltZW91dCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBvciB6ZXJvJylcbiAgICB9XG5cbiAgICBpZiAoY29ubmVjdCAhPSBudWxsICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25uZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdjb25uZWN0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBvYmplY3QnKVxuICAgIH1cblxuICAgIGlmIChtYXhSZWRpcmVjdGlvbnMgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVkaXJlY3Rpb25zKSB8fCBtYXhSZWRpcmVjdGlvbnMgPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdtYXhSZWRpcmVjdGlvbnMgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpXG4gICAgfVxuXG4gICAgaWYgKG1heFJlcXVlc3RzUGVyQ2xpZW50ICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlcXVlc3RzUGVyQ2xpZW50KSB8fCBtYXhSZXF1ZXN0c1BlckNsaWVudCA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ21heFJlcXVlc3RzUGVyQ2xpZW50IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChsb2NhbEFkZHJlc3MgIT0gbnVsbCAmJiAodHlwZW9mIGxvY2FsQWRkcmVzcyAhPT0gJ3N0cmluZycgfHwgbmV0LmlzSVAobG9jYWxBZGRyZXNzKSA9PT0gMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbG9jYWxBZGRyZXNzIG11c3QgYmUgdmFsaWQgc3RyaW5nIElQIGFkZHJlc3MnKVxuICAgIH1cblxuICAgIGlmIChtYXhSZXNwb25zZVNpemUgIT0gbnVsbCAmJiAoIU51bWJlci5pc0ludGVnZXIobWF4UmVzcG9uc2VTaXplKSB8fCBtYXhSZXNwb25zZVNpemUgPCAtMSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVzcG9uc2VTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCAhPSBudWxsICYmXG4gICAgICAoIU51bWJlci5pc0ludGVnZXIoYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0KSB8fCBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQgPCAtMSlcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIC8vIGgyXG4gICAgaWYgKGFsbG93SDIgIT0gbnVsbCAmJiB0eXBlb2YgYWxsb3dIMiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2FsbG93SDIgbXVzdCBiZSBhIHZhbGlkIGJvb2xlYW4gdmFsdWUnKVxuICAgIH1cblxuICAgIGlmIChtYXhDb25jdXJyZW50U3RyZWFtcyAhPSBudWxsICYmICh0eXBlb2YgbWF4Q29uY3VycmVudFN0cmVhbXMgIT09ICdudW1iZXInIHx8IG1heENvbmN1cnJlbnRTdHJlYW1zIDwgMSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4Q29uY3VycmVudFN0cmVhbXMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGdyZWF0ZXIgdGhhbiAwJylcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbm5lY3QgPSBidWlsZENvbm5lY3Rvcih7XG4gICAgICAgIC4uLnRscyxcbiAgICAgICAgbWF4Q2FjaGVkU2Vzc2lvbnMsXG4gICAgICAgIGFsbG93SDIsXG4gICAgICAgIHNvY2tldFBhdGgsXG4gICAgICAgIHRpbWVvdXQ6IGNvbm5lY3RUaW1lb3V0LFxuICAgICAgICAuLi4oYXV0b1NlbGVjdEZhbWlseSA/IHsgYXV0b1NlbGVjdEZhbWlseSwgYXV0b1NlbGVjdEZhbWlseUF0dGVtcHRUaW1lb3V0IH0gOiB1bmRlZmluZWQpLFxuICAgICAgICAuLi5jb25uZWN0XG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChpbnRlcmNlcHRvcnM/LkNsaWVudCAmJiBBcnJheS5pc0FycmF5KGludGVyY2VwdG9ycy5DbGllbnQpKSB7XG4gICAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gaW50ZXJjZXB0b3JzLkNsaWVudFxuICAgICAgaWYgKCFkZXByZWNhdGVkSW50ZXJjZXB0b3JXYXJuZWQpIHtcbiAgICAgICAgZGVwcmVjYXRlZEludGVyY2VwdG9yV2FybmVkID0gdHJ1ZVxuICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKCdDbGllbnQuT3B0aW9ucyNpbnRlcmNlcHRvciBpcyBkZXByZWNhdGVkLiBVc2UgRGlzcGF0Y2hlciNjb21wb3NlIGluc3RlYWQuJywge1xuICAgICAgICAgIGNvZGU6ICdVTkRJQ0ktQ0xJRU5ULUlOVEVSQ0VQVE9SLURFUFJFQ0FURUQnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0ludGVyY2VwdG9yc10gPSBbY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvcih7IG1heFJlZGlyZWN0aW9ucyB9KV1cbiAgICB9XG5cbiAgICB0aGlzW2tVcmxdID0gdXRpbC5wYXJzZU9yaWdpbih1cmwpXG4gICAgdGhpc1trQ29ubmVjdG9yXSA9IGNvbm5lY3RcbiAgICB0aGlzW2tQaXBlbGluaW5nXSA9IHBpcGVsaW5pbmcgIT0gbnVsbCA/IHBpcGVsaW5pbmcgOiAxXG4gICAgdGhpc1trTWF4SGVhZGVyc1NpemVdID0gbWF4SGVhZGVyU2l6ZSB8fCBodHRwLm1heEhlYWRlclNpemVcbiAgICB0aGlzW2tLZWVwQWxpdmVEZWZhdWx0VGltZW91dF0gPSBrZWVwQWxpdmVUaW1lb3V0ID09IG51bGwgPyA0ZTMgOiBrZWVwQWxpdmVUaW1lb3V0XG4gICAgdGhpc1trS2VlcEFsaXZlTWF4VGltZW91dF0gPSBrZWVwQWxpdmVNYXhUaW1lb3V0ID09IG51bGwgPyA2MDBlMyA6IGtlZXBBbGl2ZU1heFRpbWVvdXRcbiAgICB0aGlzW2tLZWVwQWxpdmVUaW1lb3V0VGhyZXNob2xkXSA9IGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGQgPT0gbnVsbCA/IDJlMyA6IGtlZXBBbGl2ZVRpbWVvdXRUaHJlc2hvbGRcbiAgICB0aGlzW2tLZWVwQWxpdmVUaW1lb3V0VmFsdWVdID0gdGhpc1trS2VlcEFsaXZlRGVmYXVsdFRpbWVvdXRdXG4gICAgdGhpc1trU2VydmVyTmFtZV0gPSBudWxsXG4gICAgdGhpc1trTG9jYWxBZGRyZXNzXSA9IGxvY2FsQWRkcmVzcyAhPSBudWxsID8gbG9jYWxBZGRyZXNzIDogbnVsbFxuICAgIHRoaXNba1Jlc3VtaW5nXSA9IDAgLy8gMCwgaWRsZSwgMSwgc2NoZWR1bGVkLCAyIHJlc3VtaW5nXG4gICAgdGhpc1trTmVlZERyYWluXSA9IDAgLy8gMCwgaWRsZSwgMSwgc2NoZWR1bGVkLCAyIHJlc3VtaW5nXG4gICAgdGhpc1trSG9zdEhlYWRlcl0gPSBgaG9zdDogJHt0aGlzW2tVcmxdLmhvc3RuYW1lfSR7dGhpc1trVXJsXS5wb3J0ID8gYDoke3RoaXNba1VybF0ucG9ydH1gIDogJyd9XFxyXFxuYFxuICAgIHRoaXNba0JvZHlUaW1lb3V0XSA9IGJvZHlUaW1lb3V0ICE9IG51bGwgPyBib2R5VGltZW91dCA6IDMwMGUzXG4gICAgdGhpc1trSGVhZGVyc1RpbWVvdXRdID0gaGVhZGVyc1RpbWVvdXQgIT0gbnVsbCA/IGhlYWRlcnNUaW1lb3V0IDogMzAwZTNcbiAgICB0aGlzW2tTdHJpY3RDb250ZW50TGVuZ3RoXSA9IHN0cmljdENvbnRlbnRMZW5ndGggPT0gbnVsbCA/IHRydWUgOiBzdHJpY3RDb250ZW50TGVuZ3RoXG4gICAgdGhpc1trTWF4UmVkaXJlY3Rpb25zXSA9IG1heFJlZGlyZWN0aW9uc1xuICAgIHRoaXNba01heFJlcXVlc3RzXSA9IG1heFJlcXVlc3RzUGVyQ2xpZW50XG4gICAgdGhpc1trQ2xvc2VkUmVzb2x2ZV0gPSBudWxsXG4gICAgdGhpc1trTWF4UmVzcG9uc2VTaXplXSA9IG1heFJlc3BvbnNlU2l6ZSA+IC0xID8gbWF4UmVzcG9uc2VTaXplIDogLTFcbiAgICB0aGlzW2tNYXhDb25jdXJyZW50U3RyZWFtc10gPSBtYXhDb25jdXJyZW50U3RyZWFtcyAhPSBudWxsID8gbWF4Q29uY3VycmVudFN0cmVhbXMgOiAxMDAgLy8gTWF4IHBlZXJDb25jdXJyZW50U3RyZWFtcyBmb3IgYSBOb2RlIGgyIHNlcnZlclxuICAgIHRoaXNba0hUVFBDb250ZXh0XSA9IG51bGxcblxuICAgIC8vIGtRdWV1ZSBpcyBidWlsdCB1cCBvZiAzIHNlY3Rpb25zIHNlcGFyYXRlZCBieVxuICAgIC8vIHRoZSBrUnVubmluZ0lkeCBhbmQga1BlbmRpbmdJZHggaW5kaWNlcy5cbiAgICAvLyB8ICAgY29tcGxldGUgICB8ICAgcnVubmluZyAgIHwgICBwZW5kaW5nICAgfFxuICAgIC8vICAgICAgICAgICAgICAgIF4ga1J1bm5pbmdJZHggXiBrUGVuZGluZ0lkeCBeIGtRdWV1ZS5sZW5ndGhcbiAgICAvLyBrUnVubmluZ0lkeCBwb2ludHMgdG8gdGhlIGZpcnN0IHJ1bm5pbmcgZWxlbWVudC5cbiAgICAvLyBrUGVuZGluZ0lkeCBwb2ludHMgdG8gdGhlIGZpcnN0IHBlbmRpbmcgZWxlbWVudC5cbiAgICAvLyBUaGlzIGltcGxlbWVudHMgYSBmYXN0IHF1ZXVlIHdpdGggYW4gYW1vcnRpemVkXG4gICAgLy8gdGltZSBvZiBPKDEpLlxuXG4gICAgdGhpc1trUXVldWVdID0gW11cbiAgICB0aGlzW2tSdW5uaW5nSWR4XSA9IDBcbiAgICB0aGlzW2tQZW5kaW5nSWR4XSA9IDBcblxuICAgIHRoaXNba1Jlc3VtZV0gPSAoc3luYykgPT4gcmVzdW1lKHRoaXMsIHN5bmMpXG4gICAgdGhpc1trT25FcnJvcl0gPSAoZXJyKSA9PiBvbkVycm9yKHRoaXMsIGVycilcbiAgfVxuXG4gIGdldCBwaXBlbGluaW5nICgpIHtcbiAgICByZXR1cm4gdGhpc1trUGlwZWxpbmluZ11cbiAgfVxuXG4gIHNldCBwaXBlbGluaW5nICh2YWx1ZSkge1xuICAgIHRoaXNba1BpcGVsaW5pbmddID0gdmFsdWVcbiAgICB0aGlzW2tSZXN1bWVdKHRydWUpXG4gIH1cblxuICBnZXQgW2tQZW5kaW5nXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1F1ZXVlXS5sZW5ndGggLSB0aGlzW2tQZW5kaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrUnVubmluZ10gKCkge1xuICAgIHJldHVybiB0aGlzW2tQZW5kaW5nSWR4XSAtIHRoaXNba1J1bm5pbmdJZHhdXG4gIH1cblxuICBnZXQgW2tTaXplXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1F1ZXVlXS5sZW5ndGggLSB0aGlzW2tSdW5uaW5nSWR4XVxuICB9XG5cbiAgZ2V0IFtrQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuICEhdGhpc1trSFRUUENvbnRleHRdICYmICF0aGlzW2tDb25uZWN0aW5nXSAmJiAhdGhpc1trSFRUUENvbnRleHRdLmRlc3Ryb3llZFxuICB9XG5cbiAgZ2V0IFtrQnVzeV0gKCkge1xuICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgdGhpc1trSFRUUENvbnRleHRdPy5idXN5KG51bGwpIHx8XG4gICAgICAodGhpc1trU2l6ZV0gPj0gKGdldFBpcGVsaW5pbmcodGhpcykgfHwgMSkpIHx8XG4gICAgICB0aGlzW2tQZW5kaW5nXSA+IDBcbiAgICApXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmU6IG9ubHkgdXNlZCBmb3IgdGVzdCAqL1xuICBba0Nvbm5lY3RdIChjYikge1xuICAgIGNvbm5lY3QodGhpcylcbiAgICB0aGlzLm9uY2UoJ2Nvbm5lY3QnLCBjYilcbiAgfVxuXG4gIFtrRGlzcGF0Y2hdIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gb3B0cy5vcmlnaW4gfHwgdGhpc1trVXJsXS5vcmlnaW5cbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3Qob3JpZ2luLCBvcHRzLCBoYW5kbGVyKVxuXG4gICAgdGhpc1trUXVldWVdLnB1c2gocmVxdWVzdClcbiAgICBpZiAodGhpc1trUmVzdW1pbmddKSB7XG4gICAgICAvLyBEbyBub3RoaW5nLlxuICAgIH0gZWxzZSBpZiAodXRpbC5ib2R5TGVuZ3RoKHJlcXVlc3QuYm9keSkgPT0gbnVsbCAmJiB1dGlsLmlzSXRlcmFibGUocmVxdWVzdC5ib2R5KSkge1xuICAgICAgLy8gV2FpdCBhIHRpY2sgaW4gY2FzZSBzdHJlYW0vaXRlcmF0b3IgaXMgZW5kZWQgaW4gdGhlIHNhbWUgdGljay5cbiAgICAgIHRoaXNba1Jlc3VtaW5nXSA9IDFcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHJlc3VtZSh0aGlzKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trUmVzdW1lXSh0cnVlKVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tSZXN1bWluZ10gJiYgdGhpc1trTmVlZERyYWluXSAhPT0gMiAmJiB0aGlzW2tCdXN5XSkge1xuICAgICAgdGhpc1trTmVlZERyYWluXSA9IDJcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1trTmVlZERyYWluXSA8IDJcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICAvLyBUT0RPOiBmb3IgSDIgd2UgbmVlZCB0byBncmFjZWZ1bGx5IGZsdXNoIHRoZSByZW1haW5pbmcgZW5xdWV1ZWRcbiAgICAvLyByZXF1ZXN0IGFuZCBjbG9zZSBlYWNoIHN0cmVhbS5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICh0aGlzW2tTaXplXSkge1xuICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IHJlc29sdmVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc29sdmUobnVsbClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICBjb25zdCByZXF1ZXN0cyA9IHRoaXNba1F1ZXVlXS5zcGxpY2UodGhpc1trUGVuZGluZ0lkeF0pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSByZXF1ZXN0c1tpXVxuICAgICAgICB1dGlsLmVycm9yUmVxdWVzdCh0aGlzLCByZXF1ZXN0LCBlcnIpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpc1trQ2xvc2VkUmVzb2x2ZV0pIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBTaG91bGQgd2UgZXJyb3IgaGVyZSB3aXRoIENsaWVudERlc3Ryb3llZEVycm9yP1xuICAgICAgICAgIHRoaXNba0Nsb3NlZFJlc29sdmVdKClcbiAgICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKG51bGwpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tIVFRQQ29udGV4dF0pIHtcbiAgICAgICAgdGhpc1trSFRUUENvbnRleHRdLmRlc3Ryb3koZXJyLCBjYWxsYmFjaylcbiAgICAgICAgdGhpc1trSFRUUENvbnRleHRdID0gbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2FsbGJhY2spXG4gICAgICB9XG5cbiAgICAgIHRoaXNba1Jlc3VtZV0oKVxuICAgIH0pXG4gIH1cbn1cblxuY29uc3QgY3JlYXRlUmVkaXJlY3RJbnRlcmNlcHRvciA9IHJlcXVpcmUoJy4uL2ludGVyY2VwdG9yL3JlZGlyZWN0LWludGVyY2VwdG9yLmpzJylcblxuZnVuY3Rpb24gb25FcnJvciAoY2xpZW50LCBlcnIpIHtcbiAgaWYgKFxuICAgIGNsaWVudFtrUnVubmluZ10gPT09IDAgJiZcbiAgICBlcnIuY29kZSAhPT0gJ1VORF9FUlJfSU5GTycgJiZcbiAgICBlcnIuY29kZSAhPT0gJ1VORF9FUlJfU09DS0VUJ1xuICApIHtcbiAgICAvLyBFcnJvciBpcyBub3QgY2F1c2VkIGJ5IHJ1bm5pbmcgcmVxdWVzdCBhbmQgbm90IGEgcmVjb3ZlcmFibGVcbiAgICAvLyBzb2NrZXQgZXJyb3IuXG5cbiAgICBhc3NlcnQoY2xpZW50W2tQZW5kaW5nSWR4XSA9PT0gY2xpZW50W2tSdW5uaW5nSWR4XSlcblxuICAgIGNvbnN0IHJlcXVlc3RzID0gY2xpZW50W2tRdWV1ZV0uc3BsaWNlKGNsaWVudFtrUnVubmluZ0lkeF0pXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZXF1ZXN0ID0gcmVxdWVzdHNbaV1cbiAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgIH1cbiAgICBhc3NlcnQoY2xpZW50W2tTaXplXSA9PT0gMClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnRcbiAqIEByZXR1cm5zXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNvbm5lY3QgKGNsaWVudCkge1xuICBhc3NlcnQoIWNsaWVudFtrQ29ubmVjdGluZ10pXG4gIGFzc2VydCghY2xpZW50W2tIVFRQQ29udGV4dF0pXG5cbiAgbGV0IHsgaG9zdCwgaG9zdG5hbWUsIHByb3RvY29sLCBwb3J0IH0gPSBjbGllbnRba1VybF1cblxuICAvLyBSZXNvbHZlIGlwdjZcbiAgaWYgKGhvc3RuYW1lWzBdID09PSAnWycpIHtcbiAgICBjb25zdCBpZHggPSBob3N0bmFtZS5pbmRleE9mKCddJylcblxuICAgIGFzc2VydChpZHggIT09IC0xKVxuICAgIGNvbnN0IGlwID0gaG9zdG5hbWUuc3Vic3RyaW5nKDEsIGlkeClcblxuICAgIGFzc2VydChuZXQuaXNJUChpcCkpXG4gICAgaG9zdG5hbWUgPSBpcFxuICB9XG5cbiAgY2xpZW50W2tDb25uZWN0aW5nXSA9IHRydWVcblxuICBpZiAoY2hhbm5lbHMuYmVmb3JlQ29ubmVjdC5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLmJlZm9yZUNvbm5lY3QucHVibGlzaCh7XG4gICAgICBjb25uZWN0UGFyYW1zOiB7XG4gICAgICAgIGhvc3QsXG4gICAgICAgIGhvc3RuYW1lLFxuICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgcG9ydCxcbiAgICAgICAgdmVyc2lvbjogY2xpZW50W2tIVFRQQ29udGV4dF0/LnZlcnNpb24sXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LFxuICAgICAgY29ubmVjdG9yOiBjbGllbnRba0Nvbm5lY3Rvcl1cbiAgICB9KVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBzb2NrZXQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjbGllbnRba0Nvbm5lY3Rvcl0oe1xuICAgICAgICBob3N0LFxuICAgICAgICBob3N0bmFtZSxcbiAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHNlcnZlcm5hbWU6IGNsaWVudFtrU2VydmVyTmFtZV0sXG4gICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICB9LCAoZXJyLCBzb2NrZXQpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShzb2NrZXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICB1dGlsLmRlc3Ryb3koc29ja2V0Lm9uKCdlcnJvcicsIG5vb3ApLCBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGFzc2VydChzb2NrZXQpXG5cbiAgICB0cnkge1xuICAgICAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBzb2NrZXQuYWxwblByb3RvY29sID09PSAnaDInXG4gICAgICAgID8gYXdhaXQgY29ubmVjdEgyKGNsaWVudCwgc29ja2V0KVxuICAgICAgICA6IGF3YWl0IGNvbm5lY3RIMShjbGllbnQsIHNvY2tldClcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHNvY2tldC5kZXN0cm95KCkub24oJ2Vycm9yJywgbm9vcClcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGNsaWVudFtrQ29ubmVjdGluZ10gPSBmYWxzZVxuXG4gICAgc29ja2V0W2tDb3VudGVyXSA9IDBcbiAgICBzb2NrZXRba01heFJlcXVlc3RzXSA9IGNsaWVudFtrTWF4UmVxdWVzdHNdXG4gICAgc29ja2V0W2tDbGllbnRdID0gY2xpZW50XG4gICAgc29ja2V0W2tFcnJvcl0gPSBudWxsXG5cbiAgICBpZiAoY2hhbm5lbHMuY29ubmVjdGVkLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICBjaGFubmVscy5jb25uZWN0ZWQucHVibGlzaCh7XG4gICAgICAgIGNvbm5lY3RQYXJhbXM6IHtcbiAgICAgICAgICBob3N0LFxuICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgIHBvcnQsXG4gICAgICAgICAgdmVyc2lvbjogY2xpZW50W2tIVFRQQ29udGV4dF0/LnZlcnNpb24sXG4gICAgICAgICAgc2VydmVybmFtZTogY2xpZW50W2tTZXJ2ZXJOYW1lXSxcbiAgICAgICAgICBsb2NhbEFkZHJlc3M6IGNsaWVudFtrTG9jYWxBZGRyZXNzXVxuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0b3I6IGNsaWVudFtrQ29ubmVjdG9yXSxcbiAgICAgICAgc29ja2V0XG4gICAgICB9KVxuICAgIH1cbiAgICBjbGllbnQuZW1pdCgnY29ubmVjdCcsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0pXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChjbGllbnQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjbGllbnRba0Nvbm5lY3RpbmddID0gZmFsc2VcblxuICAgIGlmIChjaGFubmVscy5jb25uZWN0RXJyb3IuaGFzU3Vic2NyaWJlcnMpIHtcbiAgICAgIGNoYW5uZWxzLmNvbm5lY3RFcnJvci5wdWJsaXNoKHtcbiAgICAgICAgY29ubmVjdFBhcmFtczoge1xuICAgICAgICAgIGhvc3QsXG4gICAgICAgICAgaG9zdG5hbWUsXG4gICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgcG9ydCxcbiAgICAgICAgICB2ZXJzaW9uOiBjbGllbnRba0hUVFBDb250ZXh0XT8udmVyc2lvbixcbiAgICAgICAgICBzZXJ2ZXJuYW1lOiBjbGllbnRba1NlcnZlck5hbWVdLFxuICAgICAgICAgIGxvY2FsQWRkcmVzczogY2xpZW50W2tMb2NhbEFkZHJlc3NdXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3RvcjogY2xpZW50W2tDb25uZWN0b3JdLFxuICAgICAgICBlcnJvcjogZXJyXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VSUl9UTFNfQ0VSVF9BTFROQU1FX0lOVkFMSUQnKSB7XG4gICAgICBhc3NlcnQoY2xpZW50W2tSdW5uaW5nXSA9PT0gMClcbiAgICAgIHdoaWxlIChjbGllbnRba1BlbmRpbmddID4gMCAmJiBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdXS5zZXJ2ZXJuYW1lID09PSBjbGllbnRba1NlcnZlck5hbWVdKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSBjbGllbnRba1F1ZXVlXVtjbGllbnRba1BlbmRpbmdJZHhdKytdXG4gICAgICAgIHV0aWwuZXJyb3JSZXF1ZXN0KGNsaWVudCwgcmVxdWVzdCwgZXJyKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbkVycm9yKGNsaWVudCwgZXJyKVxuICAgIH1cblxuICAgIGNsaWVudC5lbWl0KCdjb25uZWN0aW9uRXJyb3InLCBjbGllbnRba1VybF0sIFtjbGllbnRdLCBlcnIpXG4gIH1cblxuICBjbGllbnRba1Jlc3VtZV0oKVxufVxuXG5mdW5jdGlvbiBlbWl0RHJhaW4gKGNsaWVudCkge1xuICBjbGllbnRba05lZWREcmFpbl0gPSAwXG4gIGNsaWVudC5lbWl0KCdkcmFpbicsIGNsaWVudFtrVXJsXSwgW2NsaWVudF0pXG59XG5cbmZ1bmN0aW9uIHJlc3VtZSAoY2xpZW50LCBzeW5jKSB7XG4gIGlmIChjbGllbnRba1Jlc3VtaW5nXSA9PT0gMikge1xuICAgIHJldHVyblxuICB9XG5cbiAgY2xpZW50W2tSZXN1bWluZ10gPSAyXG5cbiAgX3Jlc3VtZShjbGllbnQsIHN5bmMpXG4gIGNsaWVudFtrUmVzdW1pbmddID0gMFxuXG4gIGlmIChjbGllbnRba1J1bm5pbmdJZHhdID4gMjU2KSB7XG4gICAgY2xpZW50W2tRdWV1ZV0uc3BsaWNlKDAsIGNsaWVudFtrUnVubmluZ0lkeF0pXG4gICAgY2xpZW50W2tQZW5kaW5nSWR4XSAtPSBjbGllbnRba1J1bm5pbmdJZHhdXG4gICAgY2xpZW50W2tSdW5uaW5nSWR4XSA9IDBcbiAgfVxufVxuXG5mdW5jdGlvbiBfcmVzdW1lIChjbGllbnQsIHN5bmMpIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoY2xpZW50LmRlc3Ryb3llZCkge1xuICAgICAgYXNzZXJ0KGNsaWVudFtrUGVuZGluZ10gPT09IDApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tDbG9zZWRSZXNvbHZlXSAmJiAhY2xpZW50W2tTaXplXSkge1xuICAgICAgY2xpZW50W2tDbG9zZWRSZXNvbHZlXSgpXG4gICAgICBjbGllbnRba0Nsb3NlZFJlc29sdmVdID0gbnVsbFxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrSFRUUENvbnRleHRdKSB7XG4gICAgICBjbGllbnRba0hUVFBDb250ZXh0XS5yZXN1bWUoKVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0J1c3ldKSB7XG4gICAgICBjbGllbnRba05lZWREcmFpbl0gPSAyXG4gICAgfSBlbHNlIGlmIChjbGllbnRba05lZWREcmFpbl0gPT09IDIpIHtcbiAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgIGNsaWVudFtrTmVlZERyYWluXSA9IDFcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZW1pdERyYWluKGNsaWVudCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0RHJhaW4oY2xpZW50KVxuICAgICAgfVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoY2xpZW50W2tQZW5kaW5nXSA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGNsaWVudFtrUnVubmluZ10gPj0gKGdldFBpcGVsaW5pbmcoY2xpZW50KSB8fCAxKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IGNsaWVudFtrUXVldWVdW2NsaWVudFtrUGVuZGluZ0lkeF1dXG5cbiAgICBpZiAoY2xpZW50W2tVcmxdLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiBjbGllbnRba1NlcnZlck5hbWVdICE9PSByZXF1ZXN0LnNlcnZlcm5hbWUpIHtcbiAgICAgIGlmIChjbGllbnRba1J1bm5pbmddID4gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgY2xpZW50W2tTZXJ2ZXJOYW1lXSA9IHJlcXVlc3Quc2VydmVybmFtZVxuICAgICAgY2xpZW50W2tIVFRQQ29udGV4dF0/LmRlc3Ryb3kobmV3IEluZm9ybWF0aW9uYWxFcnJvcignc2VydmVybmFtZSBjaGFuZ2VkJyksICgpID0+IHtcbiAgICAgICAgY2xpZW50W2tIVFRQQ29udGV4dF0gPSBudWxsXG4gICAgICAgIHJlc3VtZShjbGllbnQpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0Nvbm5lY3RpbmddKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIWNsaWVudFtrSFRUUENvbnRleHRdKSB7XG4gICAgICBjb25uZWN0KGNsaWVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0hUVFBDb250ZXh0XS5kZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChjbGllbnRba0hUVFBDb250ZXh0XS5idXN5KHJlcXVlc3QpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3QuYWJvcnRlZCAmJiBjbGllbnRba0hUVFBDb250ZXh0XS53cml0ZShyZXF1ZXN0KSkge1xuICAgICAgY2xpZW50W2tQZW5kaW5nSWR4XSsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaWVudFtrUXVldWVdLnNwbGljZShjbGllbnRba1BlbmRpbmdJZHhdLCAxKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js":
/*!***************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher-base.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { kDestroy, kClose, kClosed, kDestroyed, kDispatch, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nconst kOnDestroyed = Symbol('onDestroyed')\nconst kOnClosed = Symbol('onClosed')\nconst kInterceptedDispatch = Symbol('Intercepted Dispatch')\n\nclass DispatcherBase extends Dispatcher {\n  constructor () {\n    super()\n\n    this[kDestroyed] = false\n    this[kOnDestroyed] = null\n    this[kClosed] = false\n    this[kOnClosed] = []\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get interceptors () {\n    return this[kInterceptors]\n  }\n\n  set interceptors (newInterceptors) {\n    if (newInterceptors) {\n      for (let i = newInterceptors.length - 1; i >= 0; i--) {\n        const interceptor = this[kInterceptors][i]\n        if (typeof interceptor !== 'function') {\n          throw new InvalidArgumentError('interceptor must be an function')\n        }\n      }\n    }\n\n    this[kInterceptors] = newInterceptors\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      queueMicrotask(() => callback(new ClientDestroyedError(), null))\n      return\n    }\n\n    if (this[kClosed]) {\n      if (this[kOnClosed]) {\n        this[kOnClosed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    this[kClosed] = true\n    this[kOnClosed].push(callback)\n\n    const onClosed = () => {\n      const callbacks = this[kOnClosed]\n      this[kOnClosed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kClose]()\n      .then(() => this.destroy())\n      .then(() => {\n        queueMicrotask(onClosed)\n      })\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    this[kDestroyed] = true\n    this[kOnDestroyed] = this[kOnDestroyed] || []\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    // Should not error.\n    this[kDestroy](err).then(() => {\n      queueMicrotask(onDestroyed)\n    })\n  }\n\n  [kInterceptedDispatch] (opts, handler) {\n    if (!this[kInterceptors] || this[kInterceptors].length === 0) {\n      this[kInterceptedDispatch] = this[kDispatch]\n      return this[kDispatch](opts, handler)\n    }\n\n    let dispatch = this[kDispatch].bind(this)\n    for (let i = this[kInterceptors].length - 1; i >= 0; i--) {\n      dispatch = this[kInterceptors][i](dispatch)\n    }\n    this[kInterceptedDispatch] = dispatch\n    return dispatch(opts, handler)\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      if (this[kDestroyed] || this[kOnDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      return this[kInterceptedDispatch](opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n\n      return false\n    }\n  }\n}\n\nmodule.exports = DispatcherBase\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXItYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixtQkFBbUIsbUJBQU8sQ0FBQyw4RUFBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUM1QixRQUFRLGtFQUFrRSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCOztBQUVyRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcZGlzcGF0Y2hlci1iYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBEaXNwYXRjaGVyID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyJylcbmNvbnN0IHtcbiAgQ2xpZW50RGVzdHJveWVkRXJyb3IsXG4gIENsaWVudENsb3NlZEVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvclxufSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsga0Rlc3Ryb3ksIGtDbG9zZSwga0Nsb3NlZCwga0Rlc3Ryb3llZCwga0Rpc3BhdGNoLCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuXG5jb25zdCBrT25EZXN0cm95ZWQgPSBTeW1ib2woJ29uRGVzdHJveWVkJylcbmNvbnN0IGtPbkNsb3NlZCA9IFN5bWJvbCgnb25DbG9zZWQnKVxuY29uc3Qga0ludGVyY2VwdGVkRGlzcGF0Y2ggPSBTeW1ib2woJ0ludGVyY2VwdGVkIERpc3BhdGNoJylcblxuY2xhc3MgRGlzcGF0Y2hlckJhc2UgZXh0ZW5kcyBEaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXNba0Rlc3Ryb3llZF0gPSBmYWxzZVxuICAgIHRoaXNba09uRGVzdHJveWVkXSA9IG51bGxcbiAgICB0aGlzW2tDbG9zZWRdID0gZmFsc2VcbiAgICB0aGlzW2tPbkNsb3NlZF0gPSBbXVxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Rlc3Ryb3llZF1cbiAgfVxuXG4gIGdldCBjbG9zZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tDbG9zZWRdXG4gIH1cblxuICBnZXQgaW50ZXJjZXB0b3JzICgpIHtcbiAgICByZXR1cm4gdGhpc1trSW50ZXJjZXB0b3JzXVxuICB9XG5cbiAgc2V0IGludGVyY2VwdG9ycyAobmV3SW50ZXJjZXB0b3JzKSB7XG4gICAgaWYgKG5ld0ludGVyY2VwdG9ycykge1xuICAgICAgZm9yIChsZXQgaSA9IG5ld0ludGVyY2VwdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvciA9IHRoaXNba0ludGVyY2VwdG9yc11baV1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW50ZXJjZXB0b3IgbXVzdCBiZSBhbiBmdW5jdGlvbicpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gbmV3SW50ZXJjZXB0b3JzXG4gIH1cblxuICBjbG9zZSAoY2FsbGJhY2spIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShkYXRhKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY2FsbGJhY2snKVxuICAgIH1cblxuICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdKSB7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKSwgbnVsbCkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpc1trQ2xvc2VkXSkge1xuICAgICAgaWYgKHRoaXNba09uQ2xvc2VkXSkge1xuICAgICAgICB0aGlzW2tPbkNsb3NlZF0ucHVzaChjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNhbGxiYWNrKG51bGwsIG51bGwpKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpc1trQ2xvc2VkXSA9IHRydWVcbiAgICB0aGlzW2tPbkNsb3NlZF0ucHVzaChjYWxsYmFjaylcblxuICAgIGNvbnN0IG9uQ2xvc2VkID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2FsbGJhY2tzID0gdGhpc1trT25DbG9zZWRdXG4gICAgICB0aGlzW2tPbkNsb3NlZF0gPSBudWxsXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjYWxsYmFja3NbaV0obnVsbCwgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTaG91bGQgbm90IGVycm9yLlxuICAgIHRoaXNba0Nsb3NlXSgpXG4gICAgICAudGhlbigoKSA9PiB0aGlzLmRlc3Ryb3koKSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2sob25DbG9zZWQpXG4gICAgICB9KVxuICB9XG5cbiAgZGVzdHJveSAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgZXJyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IGVyclxuICAgICAgZXJyID0gbnVsbFxuICAgIH1cblxuICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLmRlc3Ryb3koZXJyLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGVyciA/IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgZXJyb3IgKi8gcmVqZWN0KGVycikgOiByZXNvbHZlKGRhdGEpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBjYWxsYmFjaycpXG4gICAgfVxuXG4gICAgaWYgKHRoaXNba0Rlc3Ryb3llZF0pIHtcbiAgICAgIGlmICh0aGlzW2tPbkRlc3Ryb3llZF0pIHtcbiAgICAgICAgdGhpc1trT25EZXN0cm95ZWRdLnB1c2goY2FsbGJhY2spXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBjYWxsYmFjayhudWxsLCBudWxsKSlcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghZXJyKSB7XG4gICAgICBlcnIgPSBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKVxuICAgIH1cblxuICAgIHRoaXNba0Rlc3Ryb3llZF0gPSB0cnVlXG4gICAgdGhpc1trT25EZXN0cm95ZWRdID0gdGhpc1trT25EZXN0cm95ZWRdIHx8IFtdXG4gICAgdGhpc1trT25EZXN0cm95ZWRdLnB1c2goY2FsbGJhY2spXG5cbiAgICBjb25zdCBvbkRlc3Ryb3llZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXNba09uRGVzdHJveWVkXVxuICAgICAgdGhpc1trT25EZXN0cm95ZWRdID0gbnVsbFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2tzW2ldKG51bGwsIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2hvdWxkIG5vdCBlcnJvci5cbiAgICB0aGlzW2tEZXN0cm95XShlcnIpLnRoZW4oKCkgPT4ge1xuICAgICAgcXVldWVNaWNyb3Rhc2sob25EZXN0cm95ZWQpXG4gICAgfSlcbiAgfVxuXG4gIFtrSW50ZXJjZXB0ZWREaXNwYXRjaF0gKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoIXRoaXNba0ludGVyY2VwdG9yc10gfHwgdGhpc1trSW50ZXJjZXB0b3JzXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXNba0ludGVyY2VwdGVkRGlzcGF0Y2hdID0gdGhpc1trRGlzcGF0Y2hdXG4gICAgICByZXR1cm4gdGhpc1trRGlzcGF0Y2hdKG9wdHMsIGhhbmRsZXIpXG4gICAgfVxuXG4gICAgbGV0IGRpc3BhdGNoID0gdGhpc1trRGlzcGF0Y2hdLmJpbmQodGhpcylcbiAgICBmb3IgKGxldCBpID0gdGhpc1trSW50ZXJjZXB0b3JzXS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZGlzcGF0Y2ggPSB0aGlzW2tJbnRlcmNlcHRvcnNdW2ldKGRpc3BhdGNoKVxuICAgIH1cbiAgICB0aGlzW2tJbnRlcmNlcHRlZERpc3BhdGNoXSA9IGRpc3BhdGNoXG4gICAgcmV0dXJuIGRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGlmICghaGFuZGxlciB8fCB0eXBlb2YgaGFuZGxlciAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzIG11c3QgYmUgYW4gb2JqZWN0LicpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW2tEZXN0cm95ZWRdIHx8IHRoaXNba09uRGVzdHJveWVkXSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2xpZW50RGVzdHJveWVkRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1trQ2xvc2VkXSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2xpZW50Q2xvc2VkRXJyb3IoKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpc1trSW50ZXJjZXB0ZWREaXNwYXRjaF0ob3B0cywgaGFuZGxlcilcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlci5vbkVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaW52YWxpZCBvbkVycm9yIG1ldGhvZCcpXG4gICAgICB9XG5cbiAgICAgIGhhbmRsZXIub25FcnJvcihlcnIpXG5cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXJCYXNlXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/dispatcher.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst EventEmitter = __webpack_require__(/*! node:events */ \"node:events\")\n\nclass Dispatcher extends EventEmitter {\n  dispatch () {\n    throw new Error('not implemented')\n  }\n\n  close () {\n    throw new Error('not implemented')\n  }\n\n  destroy () {\n    throw new Error('not implemented')\n  }\n\n  compose (...args) {\n    // So we handle [interceptor1, interceptor2] or interceptor1, interceptor2, ...\n    const interceptors = Array.isArray(args[0]) ? args[0] : args\n    let dispatch = this.dispatch.bind(this)\n\n    for (const interceptor of interceptors) {\n      if (interceptor == null) {\n        continue\n      }\n\n      if (typeof interceptor !== 'function') {\n        throw new TypeError(`invalid interceptor, expected function received ${typeof interceptor}`)\n      }\n\n      dispatch = interceptor(dispatch)\n\n      if (dispatch == null || typeof dispatch !== 'function' || dispatch.length !== 2) {\n        throw new TypeError('invalid interceptor')\n      }\n    }\n\n    return new ComposedDispatcher(this, dispatch)\n  }\n}\n\nclass ComposedDispatcher extends Dispatcher {\n  #dispatcher = null\n  #dispatch = null\n\n  constructor (dispatcher, dispatch) {\n    super()\n    this.#dispatcher = dispatcher\n    this.#dispatch = dispatch\n  }\n\n  dispatch (...args) {\n    this.#dispatch(...args)\n  }\n\n  close (...args) {\n    return this.#dispatcher.close(...args)\n  }\n\n  destroy (...args) {\n    return this.#dispatcher.destroy(...args)\n  }\n}\n\nmodule.exports = Dispatcher\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixxQkFBcUIsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtFQUErRSxtQkFBbUI7QUFDbEc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcZGlzcGF0Y2hlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcblxuY2xhc3MgRGlzcGF0Y2hlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGRpc3BhdGNoICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKVxuICB9XG5cbiAgY29tcG9zZSAoLi4uYXJncykge1xuICAgIC8vIFNvIHdlIGhhbmRsZSBbaW50ZXJjZXB0b3IxLCBpbnRlcmNlcHRvcjJdIG9yIGludGVyY2VwdG9yMSwgaW50ZXJjZXB0b3IyLCAuLi5cbiAgICBjb25zdCBpbnRlcmNlcHRvcnMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJnc1swXSA6IGFyZ3NcbiAgICBsZXQgZGlzcGF0Y2ggPSB0aGlzLmRpc3BhdGNoLmJpbmQodGhpcylcblxuICAgIGZvciAoY29uc3QgaW50ZXJjZXB0b3Igb2YgaW50ZXJjZXB0b3JzKSB7XG4gICAgICBpZiAoaW50ZXJjZXB0b3IgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgaW50ZXJjZXB0b3IsIGV4cGVjdGVkIGZ1bmN0aW9uIHJlY2VpdmVkICR7dHlwZW9mIGludGVyY2VwdG9yfWApXG4gICAgICB9XG5cbiAgICAgIGRpc3BhdGNoID0gaW50ZXJjZXB0b3IoZGlzcGF0Y2gpXG5cbiAgICAgIGlmIChkaXNwYXRjaCA9PSBudWxsIHx8IHR5cGVvZiBkaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJyB8fCBkaXNwYXRjaC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBpbnRlcmNlcHRvcicpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb21wb3NlZERpc3BhdGNoZXIodGhpcywgZGlzcGF0Y2gpXG4gIH1cbn1cblxuY2xhc3MgQ29tcG9zZWREaXNwYXRjaGVyIGV4dGVuZHMgRGlzcGF0Y2hlciB7XG4gICNkaXNwYXRjaGVyID0gbnVsbFxuICAjZGlzcGF0Y2ggPSBudWxsXG5cbiAgY29uc3RydWN0b3IgKGRpc3BhdGNoZXIsIGRpc3BhdGNoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuI2Rpc3BhdGNoZXIgPSBkaXNwYXRjaGVyXG4gICAgdGhpcy4jZGlzcGF0Y2ggPSBkaXNwYXRjaFxuICB9XG5cbiAgZGlzcGF0Y2ggKC4uLmFyZ3MpIHtcbiAgICB0aGlzLiNkaXNwYXRjaCguLi5hcmdzKVxuICB9XG5cbiAgY2xvc2UgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jZGlzcGF0Y2hlci5jbG9zZSguLi5hcmdzKVxuICB9XG5cbiAgZGVzdHJveSAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNkaXNwYXRjaGVyLmRlc3Ryb3koLi4uYXJncylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3BhdGNoZXJcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js":
/*!********************************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst { kClose, kDestroy, kClosed, kDestroyed, kDispatch, kNoProxyAgent, kHttpProxyAgent, kHttpsProxyAgent } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst ProxyAgent = __webpack_require__(/*! ./proxy-agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js\")\nconst Agent = __webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\n\nconst DEFAULT_PORTS = {\n  'http:': 80,\n  'https:': 443\n}\n\nlet experimentalWarned = false\n\nclass EnvHttpProxyAgent extends DispatcherBase {\n  #noProxyValue = null\n  #noProxyEntries = null\n  #opts = null\n\n  constructor (opts = {}) {\n    super()\n    this.#opts = opts\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('EnvHttpProxyAgent is experimental, expect them to change at any time.', {\n        code: 'UNDICI-EHPA'\n      })\n    }\n\n    const { httpProxy, httpsProxy, noProxy, ...agentOpts } = opts\n\n    this[kNoProxyAgent] = new Agent(agentOpts)\n\n    const HTTP_PROXY = httpProxy ?? process.env.http_proxy ?? process.env.HTTP_PROXY\n    if (HTTP_PROXY) {\n      this[kHttpProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTP_PROXY })\n    } else {\n      this[kHttpProxyAgent] = this[kNoProxyAgent]\n    }\n\n    const HTTPS_PROXY = httpsProxy ?? process.env.https_proxy ?? process.env.HTTPS_PROXY\n    if (HTTPS_PROXY) {\n      this[kHttpsProxyAgent] = new ProxyAgent({ ...agentOpts, uri: HTTPS_PROXY })\n    } else {\n      this[kHttpsProxyAgent] = this[kHttpProxyAgent]\n    }\n\n    this.#parseNoProxy()\n  }\n\n  [kDispatch] (opts, handler) {\n    const url = new URL(opts.origin)\n    const agent = this.#getProxyAgentForUrl(url)\n    return agent.dispatch(opts, handler)\n  }\n\n  async [kClose] () {\n    await this[kNoProxyAgent].close()\n    if (!this[kHttpProxyAgent][kClosed]) {\n      await this[kHttpProxyAgent].close()\n    }\n    if (!this[kHttpsProxyAgent][kClosed]) {\n      await this[kHttpsProxyAgent].close()\n    }\n  }\n\n  async [kDestroy] (err) {\n    await this[kNoProxyAgent].destroy(err)\n    if (!this[kHttpProxyAgent][kDestroyed]) {\n      await this[kHttpProxyAgent].destroy(err)\n    }\n    if (!this[kHttpsProxyAgent][kDestroyed]) {\n      await this[kHttpsProxyAgent].destroy(err)\n    }\n  }\n\n  #getProxyAgentForUrl (url) {\n    let { protocol, host: hostname, port } = url\n\n    // Stripping ports in this way instead of using parsedUrl.hostname to make\n    // sure that the brackets around IPv6 addresses are kept.\n    hostname = hostname.replace(/:\\d*$/, '').toLowerCase()\n    port = Number.parseInt(port, 10) || DEFAULT_PORTS[protocol] || 0\n    if (!this.#shouldProxy(hostname, port)) {\n      return this[kNoProxyAgent]\n    }\n    if (protocol === 'https:') {\n      return this[kHttpsProxyAgent]\n    }\n    return this[kHttpProxyAgent]\n  }\n\n  #shouldProxy (hostname, port) {\n    if (this.#noProxyChanged) {\n      this.#parseNoProxy()\n    }\n\n    if (this.#noProxyEntries.length === 0) {\n      return true // Always proxy if NO_PROXY is not set or empty.\n    }\n    if (this.#noProxyValue === '*') {\n      return false // Never proxy if wildcard is set.\n    }\n\n    for (let i = 0; i < this.#noProxyEntries.length; i++) {\n      const entry = this.#noProxyEntries[i]\n      if (entry.port && entry.port !== port) {\n        continue // Skip if ports don't match.\n      }\n      if (!/^[.*]/.test(entry.hostname)) {\n        // No wildcards, so don't proxy only if there is not an exact match.\n        if (hostname === entry.hostname) {\n          return false\n        }\n      } else {\n        // Don't proxy if the hostname ends with the no_proxy host.\n        if (hostname.endsWith(entry.hostname.replace(/^\\*/, ''))) {\n          return false\n        }\n      }\n    }\n\n    return true\n  }\n\n  #parseNoProxy () {\n    const noProxyValue = this.#opts.noProxy ?? this.#noProxyEnv\n    const noProxySplit = noProxyValue.split(/[,\\s]/)\n    const noProxyEntries = []\n\n    for (let i = 0; i < noProxySplit.length; i++) {\n      const entry = noProxySplit[i]\n      if (!entry) {\n        continue\n      }\n      const parsed = entry.match(/^(.+):(\\d+)$/)\n      noProxyEntries.push({\n        hostname: (parsed ? parsed[1] : entry).toLowerCase(),\n        port: parsed ? Number.parseInt(parsed[2], 10) : 0\n      })\n    }\n\n    this.#noProxyValue = noProxyValue\n    this.#noProxyEntries = noProxyEntries\n  }\n\n  get #noProxyChanged () {\n    if (this.#opts.noProxy !== undefined) {\n      return false\n    }\n    return this.#noProxyValue !== this.#noProxyEnv\n  }\n\n  get #noProxyEnv () {\n    return process.env.no_proxy ?? process.env.NO_PROXY ?? ''\n  }\n}\n\nmodule.exports = EnvHttpProxyAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2Vudi1odHRwLXByb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFtQjtBQUNsRCxRQUFRLHFHQUFxRyxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQ3hJLG1CQUFtQixtQkFBTyxDQUFDLGdGQUFlO0FBQzFDLGNBQWMsbUJBQU8sQ0FBQyxvRUFBUzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsWUFBWSwrQ0FBK0M7O0FBRTNEOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsK0JBQStCO0FBQzlFLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsZ0NBQWdDO0FBQ2hGLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxpQ0FBaUM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxcZW52LWh0dHAtcHJveHktYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgeyBrQ2xvc2UsIGtEZXN0cm95LCBrQ2xvc2VkLCBrRGVzdHJveWVkLCBrRGlzcGF0Y2gsIGtOb1Byb3h5QWdlbnQsIGtIdHRwUHJveHlBZ2VudCwga0h0dHBzUHJveHlBZ2VudCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IFByb3h5QWdlbnQgPSByZXF1aXJlKCcuL3Byb3h5LWFnZW50JylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudCcpXG5cbmNvbnN0IERFRkFVTFRfUE9SVFMgPSB7XG4gICdodHRwOic6IDgwLFxuICAnaHR0cHM6JzogNDQzXG59XG5cbmxldCBleHBlcmltZW50YWxXYXJuZWQgPSBmYWxzZVxuXG5jbGFzcyBFbnZIdHRwUHJveHlBZ2VudCBleHRlbmRzIERpc3BhdGNoZXJCYXNlIHtcbiAgI25vUHJveHlWYWx1ZSA9IG51bGxcbiAgI25vUHJveHlFbnRyaWVzID0gbnVsbFxuICAjb3B0cyA9IG51bGxcblxuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuI29wdHMgPSBvcHRzXG5cbiAgICBpZiAoIWV4cGVyaW1lbnRhbFdhcm5lZCkge1xuICAgICAgZXhwZXJpbWVudGFsV2FybmVkID0gdHJ1ZVxuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnRW52SHR0cFByb3h5QWdlbnQgaXMgZXhwZXJpbWVudGFsLCBleHBlY3QgdGhlbSB0byBjaGFuZ2UgYXQgYW55IHRpbWUuJywge1xuICAgICAgICBjb2RlOiAnVU5ESUNJLUVIUEEnXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHsgaHR0cFByb3h5LCBodHRwc1Byb3h5LCBub1Byb3h5LCAuLi5hZ2VudE9wdHMgfSA9IG9wdHNcblxuICAgIHRoaXNba05vUHJveHlBZ2VudF0gPSBuZXcgQWdlbnQoYWdlbnRPcHRzKVxuXG4gICAgY29uc3QgSFRUUF9QUk9YWSA9IGh0dHBQcm94eSA/PyBwcm9jZXNzLmVudi5odHRwX3Byb3h5ID8/IHByb2Nlc3MuZW52LkhUVFBfUFJPWFlcbiAgICBpZiAoSFRUUF9QUk9YWSkge1xuICAgICAgdGhpc1trSHR0cFByb3h5QWdlbnRdID0gbmV3IFByb3h5QWdlbnQoeyAuLi5hZ2VudE9wdHMsIHVyaTogSFRUUF9QUk9YWSB9KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tIdHRwUHJveHlBZ2VudF0gPSB0aGlzW2tOb1Byb3h5QWdlbnRdXG4gICAgfVxuXG4gICAgY29uc3QgSFRUUFNfUFJPWFkgPSBodHRwc1Byb3h5ID8/IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5ID8/IHByb2Nlc3MuZW52LkhUVFBTX1BST1hZXG4gICAgaWYgKEhUVFBTX1BST1hZKSB7XG4gICAgICB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdID0gbmV3IFByb3h5QWdlbnQoeyAuLi5hZ2VudE9wdHMsIHVyaTogSFRUUFNfUFJPWFkgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trSHR0cHNQcm94eUFnZW50XSA9IHRoaXNba0h0dHBQcm94eUFnZW50XVxuICAgIH1cblxuICAgIHRoaXMuI3BhcnNlTm9Qcm94eSgpXG4gIH1cblxuICBba0Rpc3BhdGNoXSAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwob3B0cy5vcmlnaW4pXG4gICAgY29uc3QgYWdlbnQgPSB0aGlzLiNnZXRQcm94eUFnZW50Rm9yVXJsKHVybClcbiAgICByZXR1cm4gYWdlbnQuZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCB0aGlzW2tOb1Byb3h5QWdlbnRdLmNsb3NlKClcbiAgICBpZiAoIXRoaXNba0h0dHBQcm94eUFnZW50XVtrQ2xvc2VkXSkge1xuICAgICAgYXdhaXQgdGhpc1trSHR0cFByb3h5QWdlbnRdLmNsb3NlKClcbiAgICB9XG4gICAgaWYgKCF0aGlzW2tIdHRwc1Byb3h5QWdlbnRdW2tDbG9zZWRdKSB7XG4gICAgICBhd2FpdCB0aGlzW2tIdHRwc1Byb3h5QWdlbnRdLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldIChlcnIpIHtcbiAgICBhd2FpdCB0aGlzW2tOb1Byb3h5QWdlbnRdLmRlc3Ryb3koZXJyKVxuICAgIGlmICghdGhpc1trSHR0cFByb3h5QWdlbnRdW2tEZXN0cm95ZWRdKSB7XG4gICAgICBhd2FpdCB0aGlzW2tIdHRwUHJveHlBZ2VudF0uZGVzdHJveShlcnIpXG4gICAgfVxuICAgIGlmICghdGhpc1trSHR0cHNQcm94eUFnZW50XVtrRGVzdHJveWVkXSkge1xuICAgICAgYXdhaXQgdGhpc1trSHR0cHNQcm94eUFnZW50XS5kZXN0cm95KGVycilcbiAgICB9XG4gIH1cblxuICAjZ2V0UHJveHlBZ2VudEZvclVybCAodXJsKSB7XG4gICAgbGV0IHsgcHJvdG9jb2wsIGhvc3Q6IGhvc3RuYW1lLCBwb3J0IH0gPSB1cmxcblxuICAgIC8vIFN0cmlwcGluZyBwb3J0cyBpbiB0aGlzIHdheSBpbnN0ZWFkIG9mIHVzaW5nIHBhcnNlZFVybC5ob3N0bmFtZSB0byBtYWtlXG4gICAgLy8gc3VyZSB0aGF0IHRoZSBicmFja2V0cyBhcm91bmQgSVB2NiBhZGRyZXNzZXMgYXJlIGtlcHQuXG4gICAgaG9zdG5hbWUgPSBob3N0bmFtZS5yZXBsYWNlKC86XFxkKiQvLCAnJykudG9Mb3dlckNhc2UoKVxuICAgIHBvcnQgPSBOdW1iZXIucGFyc2VJbnQocG9ydCwgMTApIHx8IERFRkFVTFRfUE9SVFNbcHJvdG9jb2xdIHx8IDBcbiAgICBpZiAoIXRoaXMuI3Nob3VsZFByb3h5KGhvc3RuYW1lLCBwb3J0KSkge1xuICAgICAgcmV0dXJuIHRoaXNba05vUHJveHlBZ2VudF1cbiAgICB9XG4gICAgaWYgKHByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgcmV0dXJuIHRoaXNba0h0dHBzUHJveHlBZ2VudF1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNba0h0dHBQcm94eUFnZW50XVxuICB9XG5cbiAgI3Nob3VsZFByb3h5IChob3N0bmFtZSwgcG9ydCkge1xuICAgIGlmICh0aGlzLiNub1Byb3h5Q2hhbmdlZCkge1xuICAgICAgdGhpcy4jcGFyc2VOb1Byb3h5KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jbm9Qcm94eUVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZSAvLyBBbHdheXMgcHJveHkgaWYgTk9fUFJPWFkgaXMgbm90IHNldCBvciBlbXB0eS5cbiAgICB9XG4gICAgaWYgKHRoaXMuI25vUHJveHlWYWx1ZSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gZmFsc2UgLy8gTmV2ZXIgcHJveHkgaWYgd2lsZGNhcmQgaXMgc2V0LlxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy4jbm9Qcm94eUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy4jbm9Qcm94eUVudHJpZXNbaV1cbiAgICAgIGlmIChlbnRyeS5wb3J0ICYmIGVudHJ5LnBvcnQgIT09IHBvcnQpIHtcbiAgICAgICAgY29udGludWUgLy8gU2tpcCBpZiBwb3J0cyBkb24ndCBtYXRjaC5cbiAgICAgIH1cbiAgICAgIGlmICghL15bLipdLy50ZXN0KGVudHJ5Lmhvc3RuYW1lKSkge1xuICAgICAgICAvLyBObyB3aWxkY2FyZHMsIHNvIGRvbid0IHByb3h5IG9ubHkgaWYgdGhlcmUgaXMgbm90IGFuIGV4YWN0IG1hdGNoLlxuICAgICAgICBpZiAoaG9zdG5hbWUgPT09IGVudHJ5Lmhvc3RuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvbid0IHByb3h5IGlmIHRoZSBob3N0bmFtZSBlbmRzIHdpdGggdGhlIG5vX3Byb3h5IGhvc3QuXG4gICAgICAgIGlmIChob3N0bmFtZS5lbmRzV2l0aChlbnRyeS5ob3N0bmFtZS5yZXBsYWNlKC9eXFwqLywgJycpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gICNwYXJzZU5vUHJveHkgKCkge1xuICAgIGNvbnN0IG5vUHJveHlWYWx1ZSA9IHRoaXMuI29wdHMubm9Qcm94eSA/PyB0aGlzLiNub1Byb3h5RW52XG4gICAgY29uc3Qgbm9Qcm94eVNwbGl0ID0gbm9Qcm94eVZhbHVlLnNwbGl0KC9bLFxcc10vKVxuICAgIGNvbnN0IG5vUHJveHlFbnRyaWVzID0gW11cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9Qcm94eVNwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IG5vUHJveHlTcGxpdFtpXVxuICAgICAgaWYgKCFlbnRyeSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2VkID0gZW50cnkubWF0Y2goL14oLispOihcXGQrKSQvKVxuICAgICAgbm9Qcm94eUVudHJpZXMucHVzaCh7XG4gICAgICAgIGhvc3RuYW1lOiAocGFyc2VkID8gcGFyc2VkWzFdIDogZW50cnkpLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIHBvcnQ6IHBhcnNlZCA/IE51bWJlci5wYXJzZUludChwYXJzZWRbMl0sIDEwKSA6IDBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy4jbm9Qcm94eVZhbHVlID0gbm9Qcm94eVZhbHVlXG4gICAgdGhpcy4jbm9Qcm94eUVudHJpZXMgPSBub1Byb3h5RW50cmllc1xuICB9XG5cbiAgZ2V0ICNub1Byb3h5Q2hhbmdlZCAoKSB7XG4gICAgaWYgKHRoaXMuI29wdHMubm9Qcm94eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuI25vUHJveHlWYWx1ZSAhPT0gdGhpcy4jbm9Qcm94eUVudlxuICB9XG5cbiAgZ2V0ICNub1Byb3h5RW52ICgpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYubm9fcHJveHkgPz8gcHJvY2Vzcy5lbnYuTk9fUFJPWFkgPz8gJydcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVudkh0dHBQcm94eUFnZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/env-http-proxy-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/fixed-queue.js ***!
  \***********************************************************/
/***/ ((module) => {

"use strict";
eval("/* eslint-disable */\n\n\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL2ZpeGVkLXF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXGZpeGVkLXF1ZXVlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlICovXG5cbid1c2Ugc3RyaWN0J1xuXG4vLyBFeHRyYWN0ZWQgZnJvbSBub2RlL2xpYi9pbnRlcm5hbC9maXhlZF9xdWV1ZS5qc1xuXG4vLyBDdXJyZW50bHkgb3B0aW1hbCBxdWV1ZSBzaXplLCB0ZXN0ZWQgb24gVjggNi4wIC0gNi42LiBNdXN0IGJlIHBvd2VyIG9mIHR3by5cbmNvbnN0IGtTaXplID0gMjA0ODtcbmNvbnN0IGtNYXNrID0ga1NpemUgLSAxO1xuXG4vLyBUaGUgRml4ZWRRdWV1ZSBpcyBpbXBsZW1lbnRlZCBhcyBhIHNpbmdseS1saW5rZWQgbGlzdCBvZiBmaXhlZC1zaXplXG4vLyBjaXJjdWxhciBidWZmZXJzLiBJdCBsb29rcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuLy9cbi8vICBoZWFkICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhaWxcbi8vICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuLy8gICAgdiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2XG4vLyArLS0tLS0tLS0tLS0rIDwtLS0tLVxcICAgICAgICstLS0tLS0tLS0tLSsgPC0tLS0tLVxcICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW251bGxdICAgfCAgICAgICAgXFwtLS0tLSB8ICAgbmV4dCAgICB8ICAgICAgICAgXFwtLS0tLS0tIHwgICBuZXh0ICAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgIGl0ZW0gICAgfCA8LS0gYm90dG9tICAgIHwgICBpdGVtICAgIHwgPC0tIGJvdHRvbSAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICBib3R0b20gLS0+IHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgICAuLi4gICAgfCAgICAgICAgICAgICAgIHwgICAgLi4uICAgIHwgICAgICAgICAgICAgICAgICB8ICAgIC4uLiAgICB8XG4vLyB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8ICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCA8LS0gdG9wICAgICAgIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfCAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICB8ICBbZW1wdHldICB8IDwtLSB0b3AgIHRvcCAtLT4gfCAgW2VtcHR5XSAgfFxuLy8gKy0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4vL1xuLy8gT3IsIGlmIHRoZXJlIGlzIG9ubHkgb25lIGNpcmN1bGFyIGJ1ZmZlciwgaXQgbG9va3Mgc29tZXRoaW5nXG4vLyBsaWtlIGVpdGhlciBvZiB0aGVzZTpcbi8vXG4vLyAgaGVhZCAgIHRhaWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkICAgdGFpbFxuLy8gICAgfCAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICB8XG4vLyAgICB2ICAgICB2ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgICAgIHZcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy8gfCAgW251bGxdICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICBbbnVsbF0gICB8XG4vLyArLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbi8vIHwgIFtlbXB0eV0gIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgIGl0ZW0gICAgfFxuLy8gfCAgW2VtcHR5XSAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgaXRlbSAgICB8XG4vLyB8ICAgaXRlbSAgICB8IDwtLSBib3R0b20gICAgICAgICAgICB0b3AgLS0+IHwgIFtlbXB0eV0gIHxcbi8vIHwgICBpdGVtICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgW2VtcHR5XSAgfFxuLy8gfCAgW2VtcHR5XSAgfCA8LS0gdG9wICAgICAgICAgICAgYm90dG9tIC0tPiB8ICAgaXRlbSAgICB8XG4vLyB8ICBbZW1wdHldICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICBpdGVtICAgIHxcbi8vICstLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuLy9cbi8vIEFkZGluZyBhIHZhbHVlIG1lYW5zIG1vdmluZyBgdG9wYCBmb3J3YXJkIGJ5IG9uZSwgcmVtb3ZpbmcgbWVhbnNcbi8vIG1vdmluZyBgYm90dG9tYCBmb3J3YXJkIGJ5IG9uZS4gQWZ0ZXIgcmVhY2hpbmcgdGhlIGVuZCwgdGhlIHF1ZXVlXG4vLyB3cmFwcyBhcm91bmQuXG4vL1xuLy8gV2hlbiBgdG9wID09PSBib3R0b21gIHRoZSBjdXJyZW50IHF1ZXVlIGlzIGVtcHR5IGFuZCB3aGVuXG4vLyBgdG9wICsgMSA9PT0gYm90dG9tYCBpdCdzIGZ1bGwuIFRoaXMgd2FzdGVzIGEgc2luZ2xlIHNwYWNlIG9mIHN0b3JhZ2Vcbi8vIGJ1dCBhbGxvd3MgbXVjaCBxdWlja2VyIGNoZWNrcy5cblxuY2xhc3MgRml4ZWRDaXJjdWxhckJ1ZmZlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYm90dG9tID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG4gICAgdGhpcy5saXN0ID0gbmV3IEFycmF5KGtTaXplKTtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy50b3AgPT09IHRoaXMuYm90dG9tO1xuICB9XG5cbiAgaXNGdWxsKCkge1xuICAgIHJldHVybiAoKHRoaXMudG9wICsgMSkgJiBrTWFzaykgPT09IHRoaXMuYm90dG9tO1xuICB9XG5cbiAgcHVzaChkYXRhKSB7XG4gICAgdGhpcy5saXN0W3RoaXMudG9wXSA9IGRhdGE7XG4gICAgdGhpcy50b3AgPSAodGhpcy50b3AgKyAxKSAmIGtNYXNrO1xuICB9XG5cbiAgc2hpZnQoKSB7XG4gICAgY29uc3QgbmV4dEl0ZW0gPSB0aGlzLmxpc3RbdGhpcy5ib3R0b21dO1xuICAgIGlmIChuZXh0SXRlbSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5saXN0W3RoaXMuYm90dG9tXSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9ICh0aGlzLmJvdHRvbSArIDEpICYga01hc2s7XG4gICAgcmV0dXJuIG5leHRJdGVtO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRml4ZWRRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBGaXhlZENpcmN1bGFyQnVmZmVyKCk7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmhlYWQuaXNFbXB0eSgpO1xuICB9XG5cbiAgcHVzaChkYXRhKSB7XG4gICAgaWYgKHRoaXMuaGVhZC5pc0Z1bGwoKSkge1xuICAgICAgLy8gSGVhZCBpcyBmdWxsOiBDcmVhdGVzIGEgbmV3IHF1ZXVlLCBzZXRzIHRoZSBvbGQgcXVldWUncyBgLm5leHRgIHRvIGl0LFxuICAgICAgLy8gYW5kIHNldHMgaXQgYXMgdGhlIG5ldyBtYWluIHF1ZXVlLlxuICAgICAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQgPSBuZXcgRml4ZWRDaXJjdWxhckJ1ZmZlcigpO1xuICAgIH1cbiAgICB0aGlzLmhlYWQucHVzaChkYXRhKTtcbiAgfVxuXG4gIHNoaWZ0KCkge1xuICAgIGNvbnN0IHRhaWwgPSB0aGlzLnRhaWw7XG4gICAgY29uc3QgbmV4dCA9IHRhaWwuc2hpZnQoKTtcbiAgICBpZiAodGFpbC5pc0VtcHR5KCkgJiYgdGFpbC5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBhbm90aGVyIHF1ZXVlLCBpdCBmb3JtcyB0aGUgbmV3IHRhaWwuXG4gICAgICB0aGlzLnRhaWwgPSB0YWlsLm5leHQ7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-base.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst FixedQueue = __webpack_require__(/*! ./fixed-queue */ \"(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js\")\nconst { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst PoolStats = __webpack_require__(/*! ./pool-stats */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool-stats.js\")\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\nconst kStats = Symbol('stats')\n\nclass PoolBase extends DispatcherBase {\n  constructor () {\n    super()\n\n    this[kQueue] = new FixedQueue()\n    this[kClients] = []\n    this[kQueued] = 0\n\n    const pool = this\n\n    this[kOnDrain] = function onDrain (origin, targets) {\n      const queue = pool[kQueue]\n\n      let needDrain = false\n\n      while (!needDrain) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        pool[kQueued]--\n        needDrain = !this.dispatch(item.opts, item.handler)\n      }\n\n      this[kNeedDrain] = needDrain\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false\n        pool.emit('drain', origin, [pool, ...targets])\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err)\n    }\n\n    this[kStats] = new PoolStats(this)\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kConnected] () {\n    return this[kClients].filter(client => client[kConnected]).length\n  }\n\n  get [kFree] () {\n    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get stats () {\n    return this[kStats]\n  }\n\n  async [kClose] () {\n    if (this[kQueue].isEmpty()) {\n      await Promise.all(this[kClients].map(c => c.close()))\n    } else {\n      await new Promise((resolve) => {\n        this[kClosedResolve] = resolve\n      })\n    }\n  }\n\n  async [kDestroy] (err) {\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    await Promise.all(this[kClients].map(c => c.destroy(err)))\n  }\n\n  [kDispatch] (opts, handler) {\n    const dispatcher = this[kGetDispatcher]()\n\n    if (!dispatcher) {\n      this[kNeedDrain] = true\n      this[kQueue].push({ opts, handler })\n      this[kQueued]++\n    } else if (!dispatcher.dispatch(opts, handler)) {\n      dispatcher[kNeedDrain] = true\n      this[kNeedDrain] = !this[kGetDispatcher]()\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain])\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      queueMicrotask(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtYmFzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWix1QkFBdUIsbUJBQU8sQ0FBQyx3RkFBbUI7QUFDbEQsbUJBQW1CLG1CQUFPLENBQUMsZ0ZBQWU7QUFDMUMsUUFBUSxrR0FBa0csRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUNySSxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBYzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZTtBQUN6QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxkaXNwYXRjaGVyXFxwb29sLWJhc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgRml4ZWRRdWV1ZSA9IHJlcXVpcmUoJy4vZml4ZWQtcXVldWUnKVxuY29uc3QgeyBrQ29ubmVjdGVkLCBrU2l6ZSwga1J1bm5pbmcsIGtQZW5kaW5nLCBrUXVldWVkLCBrQnVzeSwga0ZyZWUsIGtVcmwsIGtDbG9zZSwga0Rlc3Ryb3ksIGtEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IFBvb2xTdGF0cyA9IHJlcXVpcmUoJy4vcG9vbC1zdGF0cycpXG5cbmNvbnN0IGtDbGllbnRzID0gU3ltYm9sKCdjbGllbnRzJylcbmNvbnN0IGtOZWVkRHJhaW4gPSBTeW1ib2woJ25lZWREcmFpbicpXG5jb25zdCBrUXVldWUgPSBTeW1ib2woJ3F1ZXVlJylcbmNvbnN0IGtDbG9zZWRSZXNvbHZlID0gU3ltYm9sKCdjbG9zZWQgcmVzb2x2ZScpXG5jb25zdCBrT25EcmFpbiA9IFN5bWJvbCgnb25EcmFpbicpXG5jb25zdCBrT25Db25uZWN0ID0gU3ltYm9sKCdvbkNvbm5lY3QnKVxuY29uc3Qga09uRGlzY29ubmVjdCA9IFN5bWJvbCgnb25EaXNjb25uZWN0JylcbmNvbnN0IGtPbkNvbm5lY3Rpb25FcnJvciA9IFN5bWJvbCgnb25Db25uZWN0aW9uRXJyb3InKVxuY29uc3Qga0dldERpc3BhdGNoZXIgPSBTeW1ib2woJ2dldCBkaXNwYXRjaGVyJylcbmNvbnN0IGtBZGRDbGllbnQgPSBTeW1ib2woJ2FkZCBjbGllbnQnKVxuY29uc3Qga1JlbW92ZUNsaWVudCA9IFN5bWJvbCgncmVtb3ZlIGNsaWVudCcpXG5jb25zdCBrU3RhdHMgPSBTeW1ib2woJ3N0YXRzJylcblxuY2xhc3MgUG9vbEJhc2UgZXh0ZW5kcyBEaXNwYXRjaGVyQmFzZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzW2tRdWV1ZV0gPSBuZXcgRml4ZWRRdWV1ZSgpXG4gICAgdGhpc1trQ2xpZW50c10gPSBbXVxuICAgIHRoaXNba1F1ZXVlZF0gPSAwXG5cbiAgICBjb25zdCBwb29sID0gdGhpc1xuXG4gICAgdGhpc1trT25EcmFpbl0gPSBmdW5jdGlvbiBvbkRyYWluIChvcmlnaW4sIHRhcmdldHMpIHtcbiAgICAgIGNvbnN0IHF1ZXVlID0gcG9vbFtrUXVldWVdXG5cbiAgICAgIGxldCBuZWVkRHJhaW4gPSBmYWxzZVxuXG4gICAgICB3aGlsZSAoIW5lZWREcmFpbikge1xuICAgICAgICBjb25zdCBpdGVtID0gcXVldWUuc2hpZnQoKVxuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIHBvb2xba1F1ZXVlZF0tLVxuICAgICAgICBuZWVkRHJhaW4gPSAhdGhpcy5kaXNwYXRjaChpdGVtLm9wdHMsIGl0ZW0uaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgdGhpc1trTmVlZERyYWluXSA9IG5lZWREcmFpblxuXG4gICAgICBpZiAoIXRoaXNba05lZWREcmFpbl0gJiYgcG9vbFtrTmVlZERyYWluXSkge1xuICAgICAgICBwb29sW2tOZWVkRHJhaW5dID0gZmFsc2VcbiAgICAgICAgcG9vbC5lbWl0KCdkcmFpbicsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdKVxuICAgICAgfVxuXG4gICAgICBpZiAocG9vbFtrQ2xvc2VkUmVzb2x2ZV0gJiYgcXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICAgIFByb21pc2VcbiAgICAgICAgICAuYWxsKHBvb2xba0NsaWVudHNdLm1hcChjID0+IGMuY2xvc2UoKSkpXG4gICAgICAgICAgLnRoZW4ocG9vbFtrQ2xvc2VkUmVzb2x2ZV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0XSA9IChvcmlnaW4sIHRhcmdldHMpID0+IHtcbiAgICAgIHBvb2wuZW1pdCgnY29ubmVjdCcsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdKVxuICAgIH1cblxuICAgIHRoaXNba09uRGlzY29ubmVjdF0gPSAob3JpZ2luLCB0YXJnZXRzLCBlcnIpID0+IHtcbiAgICAgIHBvb2wuZW1pdCgnZGlzY29ubmVjdCcsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1trT25Db25uZWN0aW9uRXJyb3JdID0gKG9yaWdpbiwgdGFyZ2V0cywgZXJyKSA9PiB7XG4gICAgICBwb29sLmVtaXQoJ2Nvbm5lY3Rpb25FcnJvcicsIG9yaWdpbiwgW3Bvb2wsIC4uLnRhcmdldHNdLCBlcnIpXG4gICAgfVxuXG4gICAgdGhpc1trU3RhdHNdID0gbmV3IFBvb2xTdGF0cyh0aGlzKVxuICB9XG5cbiAgZ2V0IFtrQnVzeV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tOZWVkRHJhaW5dXG4gIH1cblxuICBnZXQgW2tDb25uZWN0ZWRdICgpIHtcbiAgICByZXR1cm4gdGhpc1trQ2xpZW50c10uZmlsdGVyKGNsaWVudCA9PiBjbGllbnRba0Nvbm5lY3RlZF0pLmxlbmd0aFxuICB9XG5cbiAgZ2V0IFtrRnJlZV0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDbGllbnRzXS5maWx0ZXIoY2xpZW50ID0+IGNsaWVudFtrQ29ubmVjdGVkXSAmJiAhY2xpZW50W2tOZWVkRHJhaW5dKS5sZW5ndGhcbiAgfVxuXG4gIGdldCBba1BlbmRpbmddICgpIHtcbiAgICBsZXQgcmV0ID0gdGhpc1trUXVldWVkXVxuICAgIGZvciAoY29uc3QgeyBba1BlbmRpbmddOiBwZW5kaW5nIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIHJldCArPSBwZW5kaW5nXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGdldCBba1J1bm5pbmddICgpIHtcbiAgICBsZXQgcmV0ID0gMFxuICAgIGZvciAoY29uc3QgeyBba1J1bm5pbmddOiBydW5uaW5nIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIHJldCArPSBydW5uaW5nXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGdldCBba1NpemVdICgpIHtcbiAgICBsZXQgcmV0ID0gdGhpc1trUXVldWVkXVxuICAgIGZvciAoY29uc3QgeyBba1NpemVdOiBzaXplIH0gb2YgdGhpc1trQ2xpZW50c10pIHtcbiAgICAgIHJldCArPSBzaXplXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGdldCBzdGF0cyAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1N0YXRzXVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGlmICh0aGlzW2tRdWV1ZV0uaXNFbXB0eSgpKSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbCh0aGlzW2tDbGllbnRzXS5tYXAoYyA9PiBjLmNsb3NlKCkpKVxuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0aGlzW2tDbG9zZWRSZXNvbHZlXSA9IHJlc29sdmVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgW2tEZXN0cm95XSAoZXJyKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzW2tRdWV1ZV0uc2hpZnQoKVxuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpdGVtLmhhbmRsZXIub25FcnJvcihlcnIpXG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwodGhpc1trQ2xpZW50c10ubWFwKGMgPT4gYy5kZXN0cm95KGVycikpKVxuICB9XG5cbiAgW2tEaXNwYXRjaF0gKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trR2V0RGlzcGF0Y2hlcl0oKVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICB0aGlzW2tOZWVkRHJhaW5dID0gdHJ1ZVxuICAgICAgdGhpc1trUXVldWVdLnB1c2goeyBvcHRzLCBoYW5kbGVyIH0pXG4gICAgICB0aGlzW2tRdWV1ZWRdKytcbiAgICB9IGVsc2UgaWYgKCFkaXNwYXRjaGVyLmRpc3BhdGNoKG9wdHMsIGhhbmRsZXIpKSB7XG4gICAgICBkaXNwYXRjaGVyW2tOZWVkRHJhaW5dID0gdHJ1ZVxuICAgICAgdGhpc1trTmVlZERyYWluXSA9ICF0aGlzW2tHZXREaXNwYXRjaGVyXSgpXG4gICAgfVxuXG4gICAgcmV0dXJuICF0aGlzW2tOZWVkRHJhaW5dXG4gIH1cblxuICBba0FkZENsaWVudF0gKGNsaWVudCkge1xuICAgIGNsaWVudFxuICAgICAgLm9uKCdkcmFpbicsIHRoaXNba09uRHJhaW5dKVxuICAgICAgLm9uKCdjb25uZWN0JywgdGhpc1trT25Db25uZWN0XSlcbiAgICAgIC5vbignZGlzY29ubmVjdCcsIHRoaXNba09uRGlzY29ubmVjdF0pXG4gICAgICAub24oJ2Nvbm5lY3Rpb25FcnJvcicsIHRoaXNba09uQ29ubmVjdGlvbkVycm9yXSlcblxuICAgIHRoaXNba0NsaWVudHNdLnB1c2goY2xpZW50KVxuXG4gICAgaWYgKHRoaXNba05lZWREcmFpbl0pIHtcbiAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXNba05lZWREcmFpbl0pIHtcbiAgICAgICAgICB0aGlzW2tPbkRyYWluXShjbGllbnRba1VybF0sIFt0aGlzLCBjbGllbnRdKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBba1JlbW92ZUNsaWVudF0gKGNsaWVudCkge1xuICAgIGNsaWVudC5jbG9zZSgoKSA9PiB7XG4gICAgICBjb25zdCBpZHggPSB0aGlzW2tDbGllbnRzXS5pbmRleE9mKGNsaWVudClcbiAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIHRoaXNba0NsaWVudHNdLnNwbGljZShpZHgsIDEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXNba05lZWREcmFpbl0gPSB0aGlzW2tDbGllbnRzXS5zb21lKGRpc3BhdGNoZXIgPT4gKFxuICAgICAgIWRpc3BhdGNoZXJba05lZWREcmFpbl0gJiZcbiAgICAgIGRpc3BhdGNoZXIuY2xvc2VkICE9PSB0cnVlICYmXG4gICAgICBkaXNwYXRjaGVyLmRlc3Ryb3llZCAhPT0gdHJ1ZVxuICAgICkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFBvb2xCYXNlLFxuICBrQ2xpZW50cyxcbiAga05lZWREcmFpbixcbiAga0FkZENsaWVudCxcbiAga1JlbW92ZUNsaWVudCxcbiAga0dldERpc3BhdGNoZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/pool-stats.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool-stats.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst kPool = Symbol('pool')\n\nclass PoolStats {\n  constructor (pool) {\n    this[kPool] = pool\n  }\n\n  get connected () {\n    return this[kPool][kConnected]\n  }\n\n  get free () {\n    return this[kPool][kFree]\n  }\n\n  get pending () {\n    return this[kPool][kPending]\n  }\n\n  get queued () {\n    return this[kPool][kQueued]\n  }\n\n  get running () {\n    return this[kPool][kRunning]\n  }\n\n  get size () {\n    return this[kPool][kSize]\n  }\n}\n\nmodule.exports = PoolStats\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wtc3RhdHMuanMiLCJtYXBwaW5ncyI6IkFBQUEsUUFBUSx3REFBd0QsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjtBQUMzRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXHBvb2wtc3RhdHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBrRnJlZSwga0Nvbm5lY3RlZCwga1BlbmRpbmcsIGtRdWV1ZWQsIGtSdW5uaW5nLCBrU2l6ZSB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGtQb29sID0gU3ltYm9sKCdwb29sJylcblxuY2xhc3MgUG9vbFN0YXRzIHtcbiAgY29uc3RydWN0b3IgKHBvb2wpIHtcbiAgICB0aGlzW2tQb29sXSA9IHBvb2xcbiAgfVxuXG4gIGdldCBjb25uZWN0ZWQgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrQ29ubmVjdGVkXVxuICB9XG5cbiAgZ2V0IGZyZWUgKCkge1xuICAgIHJldHVybiB0aGlzW2tQb29sXVtrRnJlZV1cbiAgfVxuXG4gIGdldCBwZW5kaW5nICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1BlbmRpbmddXG4gIH1cblxuICBnZXQgcXVldWVkICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1F1ZXVlZF1cbiAgfVxuXG4gIGdldCBydW5uaW5nICgpIHtcbiAgICByZXR1cm4gdGhpc1trUG9vbF1ba1J1bm5pbmddXG4gIH1cblxuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba1Bvb2xdW2tTaXplXVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbFN0YXRzXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/pool-stats.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/pool.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/pool.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kGetDispatcher\n} = __webpack_require__(/*! ./pool-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool-base.js\")\nconst Client = __webpack_require__(/*! ./client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst {\n  InvalidArgumentError\n} = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kUrl, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\n\nconst kOptions = Symbol('options')\nconst kConnections = Symbol('connections')\nconst kFactory = Symbol('factory')\n\nfunction defaultFactory (origin, opts) {\n  return new Client(origin, opts)\n}\n\nclass Pool extends PoolBase {\n  constructor (origin, {\n    connections,\n    factory = defaultFactory,\n    connect,\n    connectTimeout,\n    tls,\n    maxCachedSessions,\n    socketPath,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout,\n    allowH2,\n    ...options\n  } = {}) {\n    super()\n\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        allowH2,\n        socketPath,\n        timeout: connectTimeout,\n        ...(autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = options.interceptors?.Pool && Array.isArray(options.interceptors.Pool)\n      ? options.interceptors.Pool\n      : []\n    this[kConnections] = connections || null\n    this[kUrl] = util.parseOrigin(origin)\n    this[kOptions] = { ...util.deepClone(options), connect, allowH2 }\n    this[kOptions].interceptors = options.interceptors\n      ? { ...options.interceptors }\n      : undefined\n    this[kFactory] = factory\n\n    this.on('connectionError', (origin, targets, error) => {\n      // If a connection error occurs, we remove the client from the pool,\n      // and emit a connectionError event. They will not be re-used.\n      // Fixes https://github.com/nodejs/undici/issues/3895\n      for (const target of targets) {\n        // Do not use kRemoveClient here, as it will close the client,\n        // but the client cannot be closed in this state.\n        const idx = this[kClients].indexOf(target)\n        if (idx !== -1) {\n          this[kClients].splice(idx, 1)\n        }\n      }\n    })\n  }\n\n  [kGetDispatcher] () {\n    for (const client of this[kClients]) {\n      if (!client[kNeedDrain]) {\n        return client\n      }\n    }\n\n    if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n      const dispatcher = this[kFactory](this[kUrl], this[kOptions])\n      this[kAddClient](dispatcher)\n      return dispatcher\n    }\n  }\n}\n\nmodule.exports = Pool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Bvb2wuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWE7QUFDekIsZUFBZSxtQkFBTyxDQUFDLHNFQUFVO0FBQ2pDO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDNUIsYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDekQsdUJBQXVCLG1CQUFPLENBQUMsd0VBQWlCOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbURBQW1EO0FBQ3BGO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGRpc3BhdGNoZXJcXHBvb2wuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgUG9vbEJhc2UsXG4gIGtDbGllbnRzLFxuICBrTmVlZERyYWluLFxuICBrQWRkQ2xpZW50LFxuICBrR2V0RGlzcGF0Y2hlclxufSA9IHJlcXVpcmUoJy4vcG9vbC1iYXNlJylcbmNvbnN0IENsaWVudCA9IHJlcXVpcmUoJy4vY2xpZW50JylcbmNvbnN0IHtcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3Jcbn0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsga1VybCwga0ludGVyY2VwdG9ycyB9ID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi4vY29yZS9jb25uZWN0JylcblxuY29uc3Qga09wdGlvbnMgPSBTeW1ib2woJ29wdGlvbnMnKVxuY29uc3Qga0Nvbm5lY3Rpb25zID0gU3ltYm9sKCdjb25uZWN0aW9ucycpXG5jb25zdCBrRmFjdG9yeSA9IFN5bWJvbCgnZmFjdG9yeScpXG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWN0b3J5IChvcmlnaW4sIG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBDbGllbnQob3JpZ2luLCBvcHRzKVxufVxuXG5jbGFzcyBQb29sIGV4dGVuZHMgUG9vbEJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCB7XG4gICAgY29ubmVjdGlvbnMsXG4gICAgZmFjdG9yeSA9IGRlZmF1bHRGYWN0b3J5LFxuICAgIGNvbm5lY3QsXG4gICAgY29ubmVjdFRpbWVvdXQsXG4gICAgdGxzLFxuICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgIHNvY2tldFBhdGgsXG4gICAgYXV0b1NlbGVjdEZhbWlseSxcbiAgICBhdXRvU2VsZWN0RmFtaWx5QXR0ZW1wdFRpbWVvdXQsXG4gICAgYWxsb3dIMixcbiAgICAuLi5vcHRpb25zXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKClcblxuICAgIGlmIChjb25uZWN0aW9ucyAhPSBudWxsICYmICghTnVtYmVyLmlzRmluaXRlKGNvbm5lY3Rpb25zKSB8fCBjb25uZWN0aW9ucyA8IDApKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2ludmFsaWQgY29ubmVjdGlvbnMnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdmYWN0b3J5IG11c3QgYmUgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIGlmIChjb25uZWN0ICE9IG51bGwgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNvbm5lY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Nvbm5lY3QgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCcpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25uZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25uZWN0ID0gYnVpbGRDb25uZWN0b3Ioe1xuICAgICAgICAuLi50bHMsXG4gICAgICAgIG1heENhY2hlZFNlc3Npb25zLFxuICAgICAgICBhbGxvd0gyLFxuICAgICAgICBzb2NrZXRQYXRoLFxuICAgICAgICB0aW1lb3V0OiBjb25uZWN0VGltZW91dCxcbiAgICAgICAgLi4uKGF1dG9TZWxlY3RGYW1pbHkgPyB7IGF1dG9TZWxlY3RGYW1pbHksIGF1dG9TZWxlY3RGYW1pbHlBdHRlbXB0VGltZW91dCB9IDogdW5kZWZpbmVkKSxcbiAgICAgICAgLi4uY29ubmVjdFxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzW2tJbnRlcmNlcHRvcnNdID0gb3B0aW9ucy5pbnRlcmNlcHRvcnM/LlBvb2wgJiYgQXJyYXkuaXNBcnJheShvcHRpb25zLmludGVyY2VwdG9ycy5Qb29sKVxuICAgICAgPyBvcHRpb25zLmludGVyY2VwdG9ycy5Qb29sXG4gICAgICA6IFtdXG4gICAgdGhpc1trQ29ubmVjdGlvbnNdID0gY29ubmVjdGlvbnMgfHwgbnVsbFxuICAgIHRoaXNba1VybF0gPSB1dGlsLnBhcnNlT3JpZ2luKG9yaWdpbilcbiAgICB0aGlzW2tPcHRpb25zXSA9IHsgLi4udXRpbC5kZWVwQ2xvbmUob3B0aW9ucyksIGNvbm5lY3QsIGFsbG93SDIgfVxuICAgIHRoaXNba09wdGlvbnNdLmludGVyY2VwdG9ycyA9IG9wdGlvbnMuaW50ZXJjZXB0b3JzXG4gICAgICA/IHsgLi4ub3B0aW9ucy5pbnRlcmNlcHRvcnMgfVxuICAgICAgOiB1bmRlZmluZWRcbiAgICB0aGlzW2tGYWN0b3J5XSA9IGZhY3RvcnlcblxuICAgIHRoaXMub24oJ2Nvbm5lY3Rpb25FcnJvcicsIChvcmlnaW4sIHRhcmdldHMsIGVycm9yKSA9PiB7XG4gICAgICAvLyBJZiBhIGNvbm5lY3Rpb24gZXJyb3Igb2NjdXJzLCB3ZSByZW1vdmUgdGhlIGNsaWVudCBmcm9tIHRoZSBwb29sLFxuICAgICAgLy8gYW5kIGVtaXQgYSBjb25uZWN0aW9uRXJyb3IgZXZlbnQuIFRoZXkgd2lsbCBub3QgYmUgcmUtdXNlZC5cbiAgICAgIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8zODk1XG4gICAgICBmb3IgKGNvbnN0IHRhcmdldCBvZiB0YXJnZXRzKSB7XG4gICAgICAgIC8vIERvIG5vdCB1c2Uga1JlbW92ZUNsaWVudCBoZXJlLCBhcyBpdCB3aWxsIGNsb3NlIHRoZSBjbGllbnQsXG4gICAgICAgIC8vIGJ1dCB0aGUgY2xpZW50IGNhbm5vdCBiZSBjbG9zZWQgaW4gdGhpcyBzdGF0ZS5cbiAgICAgICAgY29uc3QgaWR4ID0gdGhpc1trQ2xpZW50c10uaW5kZXhPZih0YXJnZXQpXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgdGhpc1trQ2xpZW50c10uc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBba0dldERpc3BhdGNoZXJdICgpIHtcbiAgICBmb3IgKGNvbnN0IGNsaWVudCBvZiB0aGlzW2tDbGllbnRzXSkge1xuICAgICAgaWYgKCFjbGllbnRba05lZWREcmFpbl0pIHtcbiAgICAgICAgcmV0dXJuIGNsaWVudFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpc1trQ29ubmVjdGlvbnNdIHx8IHRoaXNba0NsaWVudHNdLmxlbmd0aCA8IHRoaXNba0Nvbm5lY3Rpb25zXSkge1xuICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKHRoaXNba1VybF0sIHRoaXNba09wdGlvbnNdKVxuICAgICAgdGhpc1trQWRkQ2xpZW50XShkaXNwYXRjaGVyKVxuICAgICAgcmV0dXJuIGRpc3BhdGNoZXJcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQb29sXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/proxy-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kProxy, kClose, kDestroy, kInterceptors } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { URL } = __webpack_require__(/*! node:url */ \"node:url\")\nconst Agent = __webpack_require__(/*! ./agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst Pool = __webpack_require__(/*! ./pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher-base.js\")\nconst { InvalidArgumentError, RequestAbortedError, SecureProxyConnectionError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst buildConnector = __webpack_require__(/*! ../core/connect */ \"(rsc)/./node_modules/undici/lib/core/connect.js\")\n\nconst kAgent = Symbol('proxy agent')\nconst kClient = Symbol('proxy client')\nconst kProxyHeaders = Symbol('proxy headers')\nconst kRequestTls = Symbol('request tls settings')\nconst kProxyTls = Symbol('proxy tls settings')\nconst kConnectEndpoint = Symbol('connect endpoint function')\n\nfunction defaultProtocolPort (protocol) {\n  return protocol === 'https:' ? 443 : 80\n}\n\nfunction defaultFactory (origin, opts) {\n  return new Pool(origin, opts)\n}\n\nconst noop = () => {}\n\nclass ProxyAgent extends DispatcherBase {\n  constructor (opts) {\n    super()\n\n    if (!opts || (typeof opts === 'object' && !(opts instanceof URL) && !opts.uri)) {\n      throw new InvalidArgumentError('Proxy uri is mandatory')\n    }\n\n    const { clientFactory = defaultFactory } = opts\n    if (typeof clientFactory !== 'function') {\n      throw new InvalidArgumentError('Proxy opts.clientFactory must be a function.')\n    }\n\n    const url = this.#getUrl(opts)\n    const { href, origin, port, protocol, username, password, hostname: proxyHostname } = url\n\n    this[kProxy] = { uri: href, protocol }\n    this[kInterceptors] = opts.interceptors?.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent)\n      ? opts.interceptors.ProxyAgent\n      : []\n    this[kRequestTls] = opts.requestTls\n    this[kProxyTls] = opts.proxyTls\n    this[kProxyHeaders] = opts.headers || {}\n\n    if (opts.auth && opts.token) {\n      throw new InvalidArgumentError('opts.auth cannot be used in combination with opts.token')\n    } else if (opts.auth) {\n      /* @deprecated in favour of opts.token */\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`\n    } else if (opts.token) {\n      this[kProxyHeaders]['proxy-authorization'] = opts.token\n    } else if (username && password) {\n      this[kProxyHeaders]['proxy-authorization'] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString('base64')}`\n    }\n\n    const connect = buildConnector({ ...opts.proxyTls })\n    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })\n    this[kClient] = clientFactory(url, { connect })\n    this[kAgent] = new Agent({\n      ...opts,\n      connect: async (opts, callback) => {\n        let requestedPath = opts.host\n        if (!opts.port) {\n          requestedPath += `:${defaultProtocolPort(opts.protocol)}`\n        }\n        try {\n          const { socket, statusCode } = await this[kClient].connect({\n            origin,\n            port,\n            path: requestedPath,\n            signal: opts.signal,\n            headers: {\n              ...this[kProxyHeaders],\n              host: opts.host\n            },\n            servername: this[kProxyTls]?.servername || proxyHostname\n          })\n          if (statusCode !== 200) {\n            socket.on('error', noop).destroy()\n            callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`))\n          }\n          if (opts.protocol !== 'https:') {\n            callback(null, socket)\n            return\n          }\n          let servername\n          if (this[kRequestTls]) {\n            servername = this[kRequestTls].servername\n          } else {\n            servername = opts.servername\n          }\n          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)\n        } catch (err) {\n          if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n            // Throw a custom error to avoid loop in client.js#connect\n            callback(new SecureProxyConnectionError(err))\n          } else {\n            callback(err)\n          }\n        }\n      }\n    })\n  }\n\n  dispatch (opts, handler) {\n    const headers = buildHeaders(opts.headers)\n    throwIfProxyAuthIsSent(headers)\n\n    if (headers && !('host' in headers) && !('Host' in headers)) {\n      const { host } = new URL(opts.origin)\n      headers.host = host\n    }\n\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        headers\n      },\n      handler\n    )\n  }\n\n  /**\n   * @param {import('../types/proxy-agent').ProxyAgent.Options | string | URL} opts\n   * @returns {URL}\n   */\n  #getUrl (opts) {\n    if (typeof opts === 'string') {\n      return new URL(opts)\n    } else if (opts instanceof URL) {\n      return opts\n    } else {\n      return new URL(opts.uri)\n    }\n  }\n\n  async [kClose] () {\n    await this[kAgent].close()\n    await this[kClient].close()\n  }\n\n  async [kDestroy] () {\n    await this[kAgent].destroy()\n    await this[kClient].destroy()\n  }\n}\n\n/**\n * @param {string[] | Record<string, string>} headers\n * @returns {Record<string, string>}\n */\nfunction buildHeaders (headers) {\n  // When using undici.fetch, the headers list is stored\n  // as an array.\n  if (Array.isArray(headers)) {\n    /** @type {Record<string, string>} */\n    const headersPair = {}\n\n    for (let i = 0; i < headers.length; i += 2) {\n      headersPair[headers[i]] = headers[i + 1]\n    }\n\n    return headersPair\n  }\n\n  return headers\n}\n\n/**\n * @param {Record<string, string>} headers\n *\n * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers\n * Nevertheless, it was changed and to avoid a security vulnerability by end users\n * this check was created.\n * It should be removed in the next major version for performance reasons\n */\nfunction throwIfProxyAuthIsSent (headers) {\n  const existProxyAuth = headers && Object.keys(headers)\n    .find((key) => key.toLowerCase() === 'proxy-authorization')\n  if (existProxyAuth) {\n    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')\n  }\n}\n\nmodule.exports = ProxyAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3Byb3h5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsMENBQTBDLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDN0UsUUFBUSxNQUFNLEVBQUUsbUJBQU8sQ0FBQywwQkFBVTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsb0VBQVM7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCLHVCQUF1QixtQkFBTyxDQUFDLHdGQUFtQjtBQUNsRCxRQUFRLHdFQUF3RSxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzFHLHVCQUF1QixtQkFBTyxDQUFDLHdFQUFpQjs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGlDQUFpQztBQUM3QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDRFQUE0RTs7QUFFeEYscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNERBQTRELFVBQVU7QUFDdEUsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCxlQUFlLDZCQUE2QixHQUFHLDZCQUE2QixzQkFBc0I7QUFDOUo7O0FBRUEscUNBQXFDLGtCQUFrQjtBQUN2RCw4Q0FBOEMsb0JBQW9CO0FBQ2xFLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUNBQW1DO0FBQ2xFO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnRUFBZ0UsV0FBVztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxtQ0FBbUMseUNBQXlDO0FBQzVFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxrRUFBa0U7QUFDL0UsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2Qzs7QUFFQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxccHJveHktYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga1Byb3h5LCBrQ2xvc2UsIGtEZXN0cm95LCBrSW50ZXJjZXB0b3JzIH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ25vZGU6dXJsJylcbmNvbnN0IEFnZW50ID0gcmVxdWlyZSgnLi9hZ2VudCcpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi9wb29sJylcbmNvbnN0IERpc3BhdGNoZXJCYXNlID0gcmVxdWlyZSgnLi9kaXNwYXRjaGVyLWJhc2UnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgUmVxdWVzdEFib3J0ZWRFcnJvciwgU2VjdXJlUHJveHlDb25uZWN0aW9uRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IGJ1aWxkQ29ubmVjdG9yID0gcmVxdWlyZSgnLi4vY29yZS9jb25uZWN0JylcblxuY29uc3Qga0FnZW50ID0gU3ltYm9sKCdwcm94eSBhZ2VudCcpXG5jb25zdCBrQ2xpZW50ID0gU3ltYm9sKCdwcm94eSBjbGllbnQnKVxuY29uc3Qga1Byb3h5SGVhZGVycyA9IFN5bWJvbCgncHJveHkgaGVhZGVycycpXG5jb25zdCBrUmVxdWVzdFRscyA9IFN5bWJvbCgncmVxdWVzdCB0bHMgc2V0dGluZ3MnKVxuY29uc3Qga1Byb3h5VGxzID0gU3ltYm9sKCdwcm94eSB0bHMgc2V0dGluZ3MnKVxuY29uc3Qga0Nvbm5lY3RFbmRwb2ludCA9IFN5bWJvbCgnY29ubmVjdCBlbmRwb2ludCBmdW5jdGlvbicpXG5cbmZ1bmN0aW9uIGRlZmF1bHRQcm90b2NvbFBvcnQgKHByb3RvY29sKSB7XG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MFxufVxuXG5mdW5jdGlvbiBkZWZhdWx0RmFjdG9yeSAob3JpZ2luLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUG9vbChvcmlnaW4sIG9wdHMpXG59XG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5jbGFzcyBQcm94eUFnZW50IGV4dGVuZHMgRGlzcGF0Y2hlckJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKClcblxuICAgIGlmICghb3B0cyB8fCAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmICEob3B0cyBpbnN0YW5jZW9mIFVSTCkgJiYgIW9wdHMudXJpKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eSB1cmkgaXMgbWFuZGF0b3J5JylcbiAgICB9XG5cbiAgICBjb25zdCB7IGNsaWVudEZhY3RvcnkgPSBkZWZhdWx0RmFjdG9yeSB9ID0gb3B0c1xuICAgIGlmICh0eXBlb2YgY2xpZW50RmFjdG9yeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdQcm94eSBvcHRzLmNsaWVudEZhY3RvcnkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpXG4gICAgfVxuXG4gICAgY29uc3QgdXJsID0gdGhpcy4jZ2V0VXJsKG9wdHMpXG4gICAgY29uc3QgeyBocmVmLCBvcmlnaW4sIHBvcnQsIHByb3RvY29sLCB1c2VybmFtZSwgcGFzc3dvcmQsIGhvc3RuYW1lOiBwcm94eUhvc3RuYW1lIH0gPSB1cmxcblxuICAgIHRoaXNba1Byb3h5XSA9IHsgdXJpOiBocmVmLCBwcm90b2NvbCB9XG4gICAgdGhpc1trSW50ZXJjZXB0b3JzXSA9IG9wdHMuaW50ZXJjZXB0b3JzPy5Qcm94eUFnZW50ICYmIEFycmF5LmlzQXJyYXkob3B0cy5pbnRlcmNlcHRvcnMuUHJveHlBZ2VudClcbiAgICAgID8gb3B0cy5pbnRlcmNlcHRvcnMuUHJveHlBZ2VudFxuICAgICAgOiBbXVxuICAgIHRoaXNba1JlcXVlc3RUbHNdID0gb3B0cy5yZXF1ZXN0VGxzXG4gICAgdGhpc1trUHJveHlUbHNdID0gb3B0cy5wcm94eVRsc1xuICAgIHRoaXNba1Byb3h5SGVhZGVyc10gPSBvcHRzLmhlYWRlcnMgfHwge31cblxuICAgIGlmIChvcHRzLmF1dGggJiYgb3B0cy50b2tlbikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdvcHRzLmF1dGggY2Fubm90IGJlIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBvcHRzLnRva2VuJylcbiAgICB9IGVsc2UgaWYgKG9wdHMuYXV0aCkge1xuICAgICAgLyogQGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdHMudG9rZW4gKi9cbiAgICAgIHRoaXNba1Byb3h5SGVhZGVyc11bJ3Byb3h5LWF1dGhvcml6YXRpb24nXSA9IGBCYXNpYyAke29wdHMuYXV0aH1gXG4gICAgfSBlbHNlIGlmIChvcHRzLnRva2VuKSB7XG4gICAgICB0aGlzW2tQcm94eUhlYWRlcnNdWydwcm94eS1hdXRob3JpemF0aW9uJ10gPSBvcHRzLnRva2VuXG4gICAgfSBlbHNlIGlmICh1c2VybmFtZSAmJiBwYXNzd29yZCkge1xuICAgICAgdGhpc1trUHJveHlIZWFkZXJzXVsncHJveHktYXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7QnVmZmVyLmZyb20oYCR7ZGVjb2RlVVJJQ29tcG9uZW50KHVzZXJuYW1lKX06JHtkZWNvZGVVUklDb21wb25lbnQocGFzc3dvcmQpfWApLnRvU3RyaW5nKCdiYXNlNjQnKX1gXG4gICAgfVxuXG4gICAgY29uc3QgY29ubmVjdCA9IGJ1aWxkQ29ubmVjdG9yKHsgLi4ub3B0cy5wcm94eVRscyB9KVxuICAgIHRoaXNba0Nvbm5lY3RFbmRwb2ludF0gPSBidWlsZENvbm5lY3Rvcih7IC4uLm9wdHMucmVxdWVzdFRscyB9KVxuICAgIHRoaXNba0NsaWVudF0gPSBjbGllbnRGYWN0b3J5KHVybCwgeyBjb25uZWN0IH0pXG4gICAgdGhpc1trQWdlbnRdID0gbmV3IEFnZW50KHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBjb25uZWN0OiBhc3luYyAob3B0cywgY2FsbGJhY2spID0+IHtcbiAgICAgICAgbGV0IHJlcXVlc3RlZFBhdGggPSBvcHRzLmhvc3RcbiAgICAgICAgaWYgKCFvcHRzLnBvcnQpIHtcbiAgICAgICAgICByZXF1ZXN0ZWRQYXRoICs9IGA6JHtkZWZhdWx0UHJvdG9jb2xQb3J0KG9wdHMucHJvdG9jb2wpfWBcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgc29ja2V0LCBzdGF0dXNDb2RlIH0gPSBhd2FpdCB0aGlzW2tDbGllbnRdLmNvbm5lY3Qoe1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIHBhdGg6IHJlcXVlc3RlZFBhdGgsXG4gICAgICAgICAgICBzaWduYWw6IG9wdHMuc2lnbmFsLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAuLi50aGlzW2tQcm94eUhlYWRlcnNdLFxuICAgICAgICAgICAgICBob3N0OiBvcHRzLmhvc3RcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJ2ZXJuYW1lOiB0aGlzW2tQcm94eVRsc10/LnNlcnZlcm5hbWUgfHwgcHJveHlIb3N0bmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgaWYgKHN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIG5vb3ApLmRlc3Ryb3koKVxuICAgICAgICAgICAgY2FsbGJhY2sobmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoYFByb3h5IHJlc3BvbnNlICgke3N0YXR1c0NvZGV9KSAhPT0gMjAwIHdoZW4gSFRUUCBUdW5uZWxpbmdgKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHMucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBzb2NrZXQpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHNlcnZlcm5hbWVcbiAgICAgICAgICBpZiAodGhpc1trUmVxdWVzdFRsc10pIHtcbiAgICAgICAgICAgIHNlcnZlcm5hbWUgPSB0aGlzW2tSZXF1ZXN0VGxzXS5zZXJ2ZXJuYW1lXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcnZlcm5hbWUgPSBvcHRzLnNlcnZlcm5hbWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpc1trQ29ubmVjdEVuZHBvaW50XSh7IC4uLm9wdHMsIHNlcnZlcm5hbWUsIGh0dHBTb2NrZXQ6IHNvY2tldCB9LCBjYWxsYmFjaylcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyci5jb2RlID09PSAnRVJSX1RMU19DRVJUX0FMVE5BTUVfSU5WQUxJRCcpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGVycm9yIHRvIGF2b2lkIGxvb3AgaW4gY2xpZW50LmpzI2Nvbm5lY3RcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBTZWN1cmVQcm94eUNvbm5lY3Rpb25FcnJvcihlcnIpKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGRpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IGJ1aWxkSGVhZGVycyhvcHRzLmhlYWRlcnMpXG4gICAgdGhyb3dJZlByb3h5QXV0aElzU2VudChoZWFkZXJzKVxuXG4gICAgaWYgKGhlYWRlcnMgJiYgISgnaG9zdCcgaW4gaGVhZGVycykgJiYgISgnSG9zdCcgaW4gaGVhZGVycykpIHtcbiAgICAgIGNvbnN0IHsgaG9zdCB9ID0gbmV3IFVSTChvcHRzLm9yaWdpbilcbiAgICAgIGhlYWRlcnMuaG9zdCA9IGhvc3RcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1trQWdlbnRdLmRpc3BhdGNoKFxuICAgICAge1xuICAgICAgICAuLi5vcHRzLFxuICAgICAgICBoZWFkZXJzXG4gICAgICB9LFxuICAgICAgaGFuZGxlclxuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvcHJveHktYWdlbnQnKS5Qcm94eUFnZW50Lk9wdGlvbnMgfCBzdHJpbmcgfCBVUkx9IG9wdHNcbiAgICogQHJldHVybnMge1VSTH1cbiAgICovXG4gICNnZXRVcmwgKG9wdHMpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbmV3IFVSTChvcHRzKVxuICAgIH0gZWxzZSBpZiAob3B0cyBpbnN0YW5jZW9mIFVSTCkge1xuICAgICAgcmV0dXJuIG9wdHNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBVUkwob3B0cy51cmkpXG4gICAgfVxuICB9XG5cbiAgYXN5bmMgW2tDbG9zZV0gKCkge1xuICAgIGF3YWl0IHRoaXNba0FnZW50XS5jbG9zZSgpXG4gICAgYXdhaXQgdGhpc1trQ2xpZW50XS5jbG9zZSgpXG4gIH1cblxuICBhc3luYyBba0Rlc3Ryb3ldICgpIHtcbiAgICBhd2FpdCB0aGlzW2tBZ2VudF0uZGVzdHJveSgpXG4gICAgYXdhaXQgdGhpc1trQ2xpZW50XS5kZXN0cm95KClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW10gfCBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fSBoZWFkZXJzXG4gKiBAcmV0dXJucyB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gYnVpbGRIZWFkZXJzIChoZWFkZXJzKSB7XG4gIC8vIFdoZW4gdXNpbmcgdW5kaWNpLmZldGNoLCB0aGUgaGVhZGVycyBsaXN0IGlzIHN0b3JlZFxuICAvLyBhcyBhbiBhcnJheS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVycykpIHtcbiAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgY29uc3QgaGVhZGVyc1BhaXIgPSB7fVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZWFkZXJzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICBoZWFkZXJzUGFpcltoZWFkZXJzW2ldXSA9IGhlYWRlcnNbaSArIDFdXG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYWRlcnNQYWlyXG4gIH1cblxuICByZXR1cm4gaGVhZGVyc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVyc1xuICpcbiAqIFByZXZpb3VzIHZlcnNpb25zIG9mIFByb3h5QWdlbnQgc3VnZ2VzdHMgdGhlIFByb3h5LUF1dGhvcml6YXRpb24gaW4gcmVxdWVzdCBoZWFkZXJzXG4gKiBOZXZlcnRoZWxlc3MsIGl0IHdhcyBjaGFuZ2VkIGFuZCB0byBhdm9pZCBhIHNlY3VyaXR5IHZ1bG5lcmFiaWxpdHkgYnkgZW5kIHVzZXJzXG4gKiB0aGlzIGNoZWNrIHdhcyBjcmVhdGVkLlxuICogSXQgc2hvdWxkIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICovXG5mdW5jdGlvbiB0aHJvd0lmUHJveHlBdXRoSXNTZW50IChoZWFkZXJzKSB7XG4gIGNvbnN0IGV4aXN0UHJveHlBdXRoID0gaGVhZGVycyAmJiBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgIC5maW5kKChrZXkpID0+IGtleS50b0xvd2VyQ2FzZSgpID09PSAncHJveHktYXV0aG9yaXphdGlvbicpXG4gIGlmIChleGlzdFByb3h5QXV0aCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignUHJveHktQXV0aG9yaXphdGlvbiBzaG91bGQgYmUgc2VudCBpbiBQcm94eUFnZW50IGNvbnN0cnVjdG9yJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3h5QWdlbnRcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/proxy-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/dispatcher/retry-agent.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/dispatcher/retry-agent.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst Dispatcher = __webpack_require__(/*! ./dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(rsc)/./node_modules/undici/lib/handler/retry-handler.js\")\n\nclass RetryAgent extends Dispatcher {\n  #agent = null\n  #options = null\n  constructor (agent, options = {}) {\n    super(options)\n    this.#agent = agent\n    this.#options = options\n  }\n\n  dispatch (opts, handler) {\n    const retry = new RetryHandler({\n      ...opts,\n      retryOptions: this.#options\n    }, {\n      dispatch: this.#agent.dispatch.bind(this.#agent),\n      handler\n    })\n    return this.#agent.dispatch(opts, retry)\n  }\n\n  close () {\n    return this.#agent.close()\n  }\n\n  destroy () {\n    return this.#agent.destroy()\n  }\n}\n\nmodule.exports = RetryAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9kaXNwYXRjaGVyL3JldHJ5LWFnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLG1CQUFtQixtQkFBTyxDQUFDLDhFQUFjO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLDBGQUEwQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcZGlzcGF0Y2hlclxccmV0cnktYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXInKVxuY29uc3QgUmV0cnlIYW5kbGVyID0gcmVxdWlyZSgnLi4vaGFuZGxlci9yZXRyeS1oYW5kbGVyJylcblxuY2xhc3MgUmV0cnlBZ2VudCBleHRlbmRzIERpc3BhdGNoZXIge1xuICAjYWdlbnQgPSBudWxsXG4gICNvcHRpb25zID0gbnVsbFxuICBjb25zdHJ1Y3RvciAoYWdlbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgdGhpcy4jYWdlbnQgPSBhZ2VudFxuICAgIHRoaXMuI29wdGlvbnMgPSBvcHRpb25zXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIGNvbnN0IHJldHJ5ID0gbmV3IFJldHJ5SGFuZGxlcih7XG4gICAgICAuLi5vcHRzLFxuICAgICAgcmV0cnlPcHRpb25zOiB0aGlzLiNvcHRpb25zXG4gICAgfSwge1xuICAgICAgZGlzcGF0Y2g6IHRoaXMuI2FnZW50LmRpc3BhdGNoLmJpbmQodGhpcy4jYWdlbnQpLFxuICAgICAgaGFuZGxlclxuICAgIH0pXG4gICAgcmV0dXJuIHRoaXMuI2FnZW50LmRpc3BhdGNoKG9wdHMsIHJldHJ5KVxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIHJldHVybiB0aGlzLiNhZ2VudC5jbG9zZSgpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWdlbnQuZGVzdHJveSgpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXRyeUFnZW50XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/dispatcher/retry-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/global.js":
/*!*******************************************!*\
  !*** ./node_modules/undici/lib/global.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// We include a version number for the Dispatcher API. In case of breaking changes,\n// this version number must be increased to avoid conflicts.\nconst globalDispatcher = Symbol.for('undici.globalDispatcher.1')\nconst { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst Agent = __webpack_require__(/*! ./dispatcher/agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\n\nif (getGlobalDispatcher() === undefined) {\n  setGlobalDispatcher(new Agent())\n}\n\nfunction setGlobalDispatcher (agent) {\n  if (!agent || typeof agent.dispatch !== 'function') {\n    throw new InvalidArgumentError('Argument agent must implement Agent')\n  }\n  Object.defineProperty(globalThis, globalDispatcher, {\n    value: agent,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nfunction getGlobalDispatcher () {\n  return globalThis[globalDispatcher]\n}\n\nmodule.exports = {\n  setGlobalDispatcher,\n  getGlobalDispatcher\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9nbG9iYWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHFFQUFlO0FBQ3hELGNBQWMsbUJBQU8sQ0FBQywrRUFBb0I7O0FBRTFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGdsb2JhbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gV2UgaW5jbHVkZSBhIHZlcnNpb24gbnVtYmVyIGZvciB0aGUgRGlzcGF0Y2hlciBBUEkuIEluIGNhc2Ugb2YgYnJlYWtpbmcgY2hhbmdlcyxcbi8vIHRoaXMgdmVyc2lvbiBudW1iZXIgbXVzdCBiZSBpbmNyZWFzZWQgdG8gYXZvaWQgY29uZmxpY3RzLlxuY29uc3QgZ2xvYmFsRGlzcGF0Y2hlciA9IFN5bWJvbC5mb3IoJ3VuZGljaS5nbG9iYWxEaXNwYXRjaGVyLjEnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9ID0gcmVxdWlyZSgnLi9jb3JlL2Vycm9ycycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hlci9hZ2VudCcpXG5cbmlmIChnZXRHbG9iYWxEaXNwYXRjaGVyKCkgPT09IHVuZGVmaW5lZCkge1xuICBzZXRHbG9iYWxEaXNwYXRjaGVyKG5ldyBBZ2VudCgpKVxufVxuXG5mdW5jdGlvbiBzZXRHbG9iYWxEaXNwYXRjaGVyIChhZ2VudCkge1xuICBpZiAoIWFnZW50IHx8IHR5cGVvZiBhZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignQXJndW1lbnQgYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWxUaGlzLCBnbG9iYWxEaXNwYXRjaGVyLCB7XG4gICAgdmFsdWU6IGFnZW50LFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0R2xvYmFsRGlzcGF0Y2hlciAoKSB7XG4gIHJldHVybiBnbG9iYWxUaGlzW2dsb2JhbERpc3BhdGNoZXJdXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXRHbG9iYWxEaXNwYXRjaGVyLFxuICBnZXRHbG9iYWxEaXNwYXRjaGVyXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/global.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/decorator-handler.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/handler/decorator-handler.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = class DecoratorHandler {\n  #handler\n\n  constructor (handler) {\n    if (typeof handler !== 'object' || handler === null) {\n      throw new TypeError('handler must be an object')\n    }\n    this.#handler = handler\n  }\n\n  onConnect (...args) {\n    return this.#handler.onConnect?.(...args)\n  }\n\n  onError (...args) {\n    return this.#handler.onError?.(...args)\n  }\n\n  onUpgrade (...args) {\n    return this.#handler.onUpgrade?.(...args)\n  }\n\n  onResponseStarted (...args) {\n    return this.#handler.onResponseStarted?.(...args)\n  }\n\n  onHeaders (...args) {\n    return this.#handler.onHeaders?.(...args)\n  }\n\n  onData (...args) {\n    return this.#handler.onData?.(...args)\n  }\n\n  onComplete (...args) {\n    return this.#handler.onComplete?.(...args)\n  }\n\n  onBodySent (...args) {\n    return this.#handler.onBodySent?.(...args)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxoYW5kbGVyXFxkZWNvcmF0b3ItaGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBEZWNvcmF0b3JIYW5kbGVyIHtcbiAgI2hhbmRsZXJcblxuICBjb25zdHJ1Y3RvciAoaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ29iamVjdCcgfHwgaGFuZGxlciA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGFuZGxlciBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICAgIHRoaXMuI2hhbmRsZXIgPSBoYW5kbGVyXG4gIH1cblxuICBvbkNvbm5lY3QgKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy4jaGFuZGxlci5vbkNvbm5lY3Q/LiguLi5hcmdzKVxuICB9XG5cbiAgb25FcnJvciAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uRXJyb3I/LiguLi5hcmdzKVxuICB9XG5cbiAgb25VcGdyYWRlICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25VcGdyYWRlPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uUmVzcG9uc2VTdGFydGVkICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25SZXNwb25zZVN0YXJ0ZWQ/LiguLi5hcmdzKVxuICB9XG5cbiAgb25IZWFkZXJzICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25IZWFkZXJzPy4oLi4uYXJncylcbiAgfVxuXG4gIG9uRGF0YSAoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uRGF0YT8uKC4uLmFyZ3MpXG4gIH1cblxuICBvbkNvbXBsZXRlICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25Db21wbGV0ZT8uKC4uLmFyZ3MpXG4gIH1cblxuICBvbkJvZHlTZW50ICguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25Cb2R5U2VudD8uKC4uLmFyZ3MpXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/redirect-handler.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/handler/redirect-handler.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst EE = __webpack_require__(/*! node:events */ \"node:events\")\n\nconst redirectableStatusCodes = [300, 301, 302, 303, 307, 308]\n\nconst kBody = Symbol('body')\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nclass RedirectHandler {\n  constructor (dispatch, maxRedirections, opts, handler) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    util.validateHandler(handler, opts.method, opts.upgrade)\n\n    this.dispatch = dispatch\n    this.location = null\n    this.abort = null\n    this.opts = { ...opts, maxRedirections: 0 } // opts must be a copy\n    this.maxRedirections = maxRedirections\n    this.handler = handler\n    this.history = []\n    this.redirectionLimitReached = false\n\n    if (util.isStream(this.opts.body)) {\n      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n      // so that it can be dispatched again?\n      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n      if (util.bodyLength(this.opts.body) === 0) {\n        this.opts.body\n          .on('data', function () {\n            assert(false)\n          })\n      }\n\n      if (typeof this.opts.body.readableDidRead !== 'boolean') {\n        this.opts.body[kBodyUsed] = false\n        EE.prototype.on.call(this.opts.body, 'data', function () {\n          this[kBodyUsed] = true\n        })\n      }\n    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n      // TODO (fix): We can't access ReadableStream internal state\n      // to determine whether or not it has been disturbed. This is just\n      // a workaround.\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    } else if (\n      this.opts.body &&\n      typeof this.opts.body !== 'string' &&\n      !ArrayBuffer.isView(this.opts.body) &&\n      util.isIterable(this.opts.body)\n    ) {\n      // TODO: Should we allow re-using iterable if !this.opts.idempotent\n      // or through some other flag?\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    }\n  }\n\n  onConnect (abort) {\n    this.abort = abort\n    this.handler.onConnect(abort, { history: this.history })\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    this.handler.onUpgrade(statusCode, headers, socket)\n  }\n\n  onError (error) {\n    this.handler.onError(error)\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)\n      ? null\n      : parseLocation(statusCode, headers)\n\n    if (this.opts.throwOnMaxRedirect && this.history.length >= this.maxRedirections) {\n      if (this.request) {\n        this.request.abort(new Error('max redirects'))\n      }\n\n      this.redirectionLimitReached = true\n      this.abort(new Error('max redirects'))\n      return\n    }\n\n    if (this.opts.origin) {\n      this.history.push(new URL(this.opts.path, this.opts.origin))\n    }\n\n    if (!this.location) {\n      return this.handler.onHeaders(statusCode, headers, resume, statusText)\n    }\n\n    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)))\n    const path = search ? `${pathname}${search}` : pathname\n\n    // Remove headers referring to the original URL.\n    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n    // https://tools.ietf.org/html/rfc7231#section-6.4\n    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)\n    this.opts.path = path\n    this.opts.origin = origin\n    this.opts.maxRedirections = 0\n    this.opts.query = null\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.4\n    // In case of HTTP 303, always replace method to be either HEAD or GET\n    if (statusCode === 303 && this.opts.method !== 'HEAD') {\n      this.opts.method = 'GET'\n      this.opts.body = null\n    }\n  }\n\n  onData (chunk) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitly chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */\n    } else {\n      return this.handler.onData(chunk)\n    }\n  }\n\n  onComplete (trailers) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed information.\n      */\n\n      this.location = null\n      this.abort = null\n\n      this.dispatch(this.opts, this)\n    } else {\n      this.handler.onComplete(trailers)\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) {\n      this.handler.onBodySent(chunk)\n    }\n  }\n}\n\nfunction parseLocation (statusCode, headers) {\n  if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n    return null\n  }\n\n  for (let i = 0; i < headers.length; i += 2) {\n    if (headers[i].length === 8 && util.headerNameToString(headers[i]) === 'location') {\n      return headers[i + 1]\n    }\n  }\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader (header, removeContent, unknownOrigin) {\n  if (header.length === 4) {\n    return util.headerNameToString(header) === 'host'\n  }\n  if (removeContent && util.headerNameToString(header).startsWith('content-')) {\n    return true\n  }\n  if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {\n    const name = util.headerNameToString(header)\n    return name === 'authorization' || name === 'cookie' || name === 'proxy-authorization'\n  }\n  return false\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders (headers, removeContent, unknownOrigin) {\n  const ret = []\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n        ret.push(headers[i], headers[i + 1])\n      }\n    }\n  } else if (headers && typeof headers === 'object') {\n    for (const key of Object.keys(headers)) {\n      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n        ret.push(key, headers[key])\n      }\n    }\n  } else {\n    assert(headers == null, 'headers must be an object or an array')\n  }\n  return ret\n}\n\nmodule.exports = RedirectHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLGtFQUFjO0FBQ25DLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsd0VBQWlCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQ3pELFdBQVcsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFaEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFlBQVksMkJBQTJCO0FBQ3ZDLDZCQUE2QixTQUFTLEVBQUUsT0FBTzs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGhhbmRsZXJcXHJlZGlyZWN0LWhhbmRsZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuY29uc3QgeyBrQm9keVVzZWQgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcblxuY29uc3QgcmVkaXJlY3RhYmxlU3RhdHVzQ29kZXMgPSBbMzAwLCAzMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF1cblxuY29uc3Qga0JvZHkgPSBTeW1ib2woJ2JvZHknKVxuXG5jbGFzcyBCb2R5QXN5bmNJdGVyYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChib2R5KSB7XG4gICAgdGhpc1trQm9keV0gPSBib2R5XG4gICAgdGhpc1trQm9keVVzZWRdID0gZmFsc2VcbiAgfVxuXG4gIGFzeW5jICogW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSAoKSB7XG4gICAgYXNzZXJ0KCF0aGlzW2tCb2R5VXNlZF0sICdkaXN0dXJiZWQnKVxuICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICB5aWVsZCAqIHRoaXNba0JvZHldXG4gIH1cbn1cblxuY2xhc3MgUmVkaXJlY3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKGRpc3BhdGNoLCBtYXhSZWRpcmVjdGlvbnMsIG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAobWF4UmVkaXJlY3Rpb25zICE9IG51bGwgJiYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJlZGlyZWN0aW9ucykgfHwgbWF4UmVkaXJlY3Rpb25zIDwgMCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4UmVkaXJlY3Rpb25zIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICAgIH1cblxuICAgIHV0aWwudmFsaWRhdGVIYW5kbGVyKGhhbmRsZXIsIG9wdHMubWV0aG9kLCBvcHRzLnVwZ3JhZGUpXG5cbiAgICB0aGlzLmRpc3BhdGNoID0gZGlzcGF0Y2hcbiAgICB0aGlzLmxvY2F0aW9uID0gbnVsbFxuICAgIHRoaXMuYWJvcnQgPSBudWxsXG4gICAgdGhpcy5vcHRzID0geyAuLi5vcHRzLCBtYXhSZWRpcmVjdGlvbnM6IDAgfSAvLyBvcHRzIG11c3QgYmUgYSBjb3B5XG4gICAgdGhpcy5tYXhSZWRpcmVjdGlvbnMgPSBtYXhSZWRpcmVjdGlvbnNcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyXG4gICAgdGhpcy5oaXN0b3J5ID0gW11cbiAgICB0aGlzLnJlZGlyZWN0aW9uTGltaXRSZWFjaGVkID0gZmFsc2VcblxuICAgIGlmICh1dGlsLmlzU3RyZWFtKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgLy8gVE9ETyAoZml4KTogUHJvdmlkZSBzb21lIHdheSBmb3IgdGhlIHVzZXIgdG8gY2FjaGUgdGhlIGZpbGUgdG8gZS5nLiAvdG1wXG4gICAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGFnYWluP1xuICAgICAgLy8gVE9ETyAoZml4KTogRG8gd2UgbmVlZCAxMDAtZXhwZWN0IHN1cHBvcnQgdG8gcHJvdmlkZSBhIHdheSB0byBkbyB0aGlzIHByb3Blcmx5P1xuICAgICAgaWYgKHV0aWwuYm9keUxlbmd0aCh0aGlzLm9wdHMuYm9keSkgPT09IDApIHtcbiAgICAgICAgdGhpcy5vcHRzLmJvZHlcbiAgICAgICAgICAub24oJ2RhdGEnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhc3NlcnQoZmFsc2UpXG4gICAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMuYm9keS5yZWFkYWJsZURpZFJlYWQgIT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLm9wdHMuYm9keVtrQm9keVVzZWRdID0gZmFsc2VcbiAgICAgICAgRUUucHJvdG90eXBlLm9uLmNhbGwodGhpcy5vcHRzLmJvZHksICdkYXRhJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXNba0JvZHlVc2VkXSA9IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0cy5ib2R5ICYmIHR5cGVvZiB0aGlzLm9wdHMuYm9keS5waXBlVG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRPRE8gKGZpeCk6IFdlIGNhbid0IGFjY2VzcyBSZWFkYWJsZVN0cmVhbSBpbnRlcm5hbCBzdGF0ZVxuICAgICAgLy8gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGl0IGhhcyBiZWVuIGRpc3R1cmJlZC4gVGhpcyBpcyBqdXN0XG4gICAgICAvLyBhIHdvcmthcm91bmQuXG4gICAgICB0aGlzLm9wdHMuYm9keSA9IG5ldyBCb2R5QXN5bmNJdGVyYWJsZSh0aGlzLm9wdHMuYm9keSlcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5vcHRzLmJvZHkgJiZcbiAgICAgIHR5cGVvZiB0aGlzLm9wdHMuYm9keSAhPT0gJ3N0cmluZycgJiZcbiAgICAgICFBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5vcHRzLmJvZHkpICYmXG4gICAgICB1dGlsLmlzSXRlcmFibGUodGhpcy5vcHRzLmJvZHkpXG4gICAgKSB7XG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgYWxsb3cgcmUtdXNpbmcgaXRlcmFibGUgaWYgIXRoaXMub3B0cy5pZGVtcG90ZW50XG4gICAgICAvLyBvciB0aHJvdWdoIHNvbWUgb3RoZXIgZmxhZz9cbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbmV3IEJvZHlBc3luY0l0ZXJhYmxlKHRoaXMub3B0cy5ib2R5KVxuICAgIH1cbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB0aGlzLmhhbmRsZXIub25Db25uZWN0KGFib3J0LCB7IGhpc3Rvcnk6IHRoaXMuaGlzdG9yeSB9KVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICB0aGlzLmhhbmRsZXIub25VcGdyYWRlKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHNvY2tldClcbiAgfVxuXG4gIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyb3IpXG4gIH1cblxuICBvbkhlYWRlcnMgKHN0YXR1c0NvZGUsIGhlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgIHRoaXMubG9jYXRpb24gPSB0aGlzLmhpc3RvcnkubGVuZ3RoID49IHRoaXMubWF4UmVkaXJlY3Rpb25zIHx8IHV0aWwuaXNEaXN0dXJiZWQodGhpcy5vcHRzLmJvZHkpXG4gICAgICA/IG51bGxcbiAgICAgIDogcGFyc2VMb2NhdGlvbihzdGF0dXNDb2RlLCBoZWFkZXJzKVxuXG4gICAgaWYgKHRoaXMub3B0cy50aHJvd09uTWF4UmVkaXJlY3QgJiYgdGhpcy5oaXN0b3J5Lmxlbmd0aCA+PSB0aGlzLm1heFJlZGlyZWN0aW9ucykge1xuICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xuICAgICAgICB0aGlzLnJlcXVlc3QuYWJvcnQobmV3IEVycm9yKCdtYXggcmVkaXJlY3RzJykpXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVkaXJlY3Rpb25MaW1pdFJlYWNoZWQgPSB0cnVlXG4gICAgICB0aGlzLmFib3J0KG5ldyBFcnJvcignbWF4IHJlZGlyZWN0cycpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0cy5vcmlnaW4pIHtcbiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKG5ldyBVUkwodGhpcy5vcHRzLnBhdGgsIHRoaXMub3B0cy5vcmlnaW4pKVxuICAgIH1cblxuICAgIGlmICghdGhpcy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkhlYWRlcnMoc3RhdHVzQ29kZSwgaGVhZGVycywgcmVzdW1lLCBzdGF0dXNUZXh0KVxuICAgIH1cblxuICAgIGNvbnN0IHsgb3JpZ2luLCBwYXRobmFtZSwgc2VhcmNoIH0gPSB1dGlsLnBhcnNlVVJMKG5ldyBVUkwodGhpcy5sb2NhdGlvbiwgdGhpcy5vcHRzLm9yaWdpbiAmJiBuZXcgVVJMKHRoaXMub3B0cy5wYXRoLCB0aGlzLm9wdHMub3JpZ2luKSkpXG4gICAgY29uc3QgcGF0aCA9IHNlYXJjaCA/IGAke3BhdGhuYW1lfSR7c2VhcmNofWAgOiBwYXRobmFtZVxuXG4gICAgLy8gUmVtb3ZlIGhlYWRlcnMgcmVmZXJyaW5nIHRvIHRoZSBvcmlnaW5hbCBVUkwuXG4gICAgLy8gQnkgZGVmYXVsdCBpdCBpcyBIb3N0IG9ubHksIHVubGVzcyBpdCdzIGEgMzAzIChzZWUgYmVsb3cpLCB3aGljaCByZW1vdmVzIGFsc28gYWxsIENvbnRlbnQtKiBoZWFkZXJzLlxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40XG4gICAgdGhpcy5vcHRzLmhlYWRlcnMgPSBjbGVhblJlcXVlc3RIZWFkZXJzKHRoaXMub3B0cy5oZWFkZXJzLCBzdGF0dXNDb2RlID09PSAzMDMsIHRoaXMub3B0cy5vcmlnaW4gIT09IG9yaWdpbilcbiAgICB0aGlzLm9wdHMucGF0aCA9IHBhdGhcbiAgICB0aGlzLm9wdHMub3JpZ2luID0gb3JpZ2luXG4gICAgdGhpcy5vcHRzLm1heFJlZGlyZWN0aW9ucyA9IDBcbiAgICB0aGlzLm9wdHMucXVlcnkgPSBudWxsXG5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNC40XG4gICAgLy8gSW4gY2FzZSBvZiBIVFRQIDMwMywgYWx3YXlzIHJlcGxhY2UgbWV0aG9kIHRvIGJlIGVpdGhlciBIRUFEIG9yIEdFVFxuICAgIGlmIChzdGF0dXNDb2RlID09PSAzMDMgJiYgdGhpcy5vcHRzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICB0aGlzLm9wdHMubWV0aG9kID0gJ0dFVCdcbiAgICAgIHRoaXMub3B0cy5ib2R5ID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICBpZiAodGhpcy5sb2NhdGlvbikge1xuICAgICAgLypcbiAgICAgICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzEjc2VjdGlvbi02LjRcblxuICAgICAgICBUTERSOiB1bmRpY2kgYWx3YXlzIGlnbm9yZXMgM3h4IHJlc3BvbnNlIGJvZGllcy5cblxuICAgICAgICBSZWRpcmVjdGlvbiBpcyB1c2VkIHRvIHNlcnZlIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgZnJvbSBhbm90aGVyIFVSTCwgc28gaXQgaXMgYXNzdW1lcyB0aGF0XG4gICAgICAgIG5vIGJvZHkgaXMgZ2VuZXJhdGVkIChhbmQgdGh1cyBjYW4gYmUgaWdub3JlZCkuIEV2ZW4gdGhvdWdoIGdlbmVyYXRpbmcgYSBib2R5IGlzIG5vdCBwcm9oaWJpdGVkLlxuXG4gICAgICAgIEZvciBzdGF0dXMgMzAxLCAzMDIsIDMwMywgMzA3IGFuZCAzMDggKHRoZSBsYXR0ZXIgZnJvbSBSRkMgNzIzOCksIHRoZSBzcGVjcyBtZW50aW9uIHRoYXQgdGhlIGJvZHkgdXN1YWxseVxuICAgICAgICAod2hpY2ggbWVhbnMgaXQncyBvcHRpb25hbCBhbmQgbm90IG1hbmRhdGVkKSBjb250YWluIGp1c3QgYW4gaHlwZXJsaW5rIHRvIHRoZSB2YWx1ZSBvZlxuICAgICAgICB0aGUgTG9jYXRpb24gcmVzcG9uc2UgaGVhZGVyLCBzbyB0aGUgYm9keSBjYW4gYmUgaWdub3JlZCBzYWZlbHkuXG5cbiAgICAgICAgRm9yIHN0YXR1cyAzMDAsIHdoaWNoIGlzIFwiTXVsdGlwbGUgQ2hvaWNlc1wiLCB0aGUgc3BlYyBtZW50aW9ucyBib3RoIGdlbmVyYXRpbmcgYSBMb2NhdGlvblxuICAgICAgICByZXNwb25zZSBoZWFkZXIgQU5EIGEgcmVzcG9uc2UgYm9keSB3aXRoIHRoZSBvdGhlciBwb3NzaWJsZSBsb2NhdGlvbiB0byBmb2xsb3cuXG4gICAgICAgIFNpbmNlIHRoZSBzcGVjIGV4cGxpY2l0bHkgY2hvb3NlcyBub3QgdG8gc3BlY2lmeSBhIGZvcm1hdCBmb3Igc3VjaCBib2R5IGFuZCBsZWF2ZSBpdCB0b1xuICAgICAgICBzZXJ2ZXJzIGFuZCBicm93c2VycyBpbXBsZW1lbnRvcnMsIHdlIGlnbm9yZSB0aGUgYm9keSBhcyB0aGVyZSBpcyBubyBzcGVjaWZpZWQgd2F5IHRvIGV2ZW50dWFsbHkgcGFyc2UgaXQuXG4gICAgICAqL1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uRGF0YShjaHVuaylcbiAgICB9XG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGlmICh0aGlzLmxvY2F0aW9uKSB7XG4gICAgICAvKlxuICAgICAgICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuXG4gICAgICAgIFRMRFI6IHVuZGljaSBhbHdheXMgaWdub3JlcyAzeHggcmVzcG9uc2UgdHJhaWxlcnMgYXMgdGhleSBhcmUgbm90IGV4cGVjdGVkIGluIGNhc2Ugb2YgcmVkaXJlY3Rpb25zXG4gICAgICAgIGFuZCBuZWl0aGVyIGFyZSB1c2VmdWwgaWYgcHJlc2VudC5cblxuICAgICAgICBTZWUgY29tbWVudCBvbiBvbkRhdGEgbWV0aG9kIGFib3ZlIGZvciBtb3JlIGRldGFpbGVkIGluZm9ybWF0aW9uLlxuICAgICAgKi9cblxuICAgICAgdGhpcy5sb2NhdGlvbiA9IG51bGxcbiAgICAgIHRoaXMuYWJvcnQgPSBudWxsXG5cbiAgICAgIHRoaXMuZGlzcGF0Y2godGhpcy5vcHRzLCB0aGlzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25Db21wbGV0ZSh0cmFpbGVycylcbiAgICB9XG4gIH1cblxuICBvbkJvZHlTZW50IChjaHVuaykge1xuICAgIGlmICh0aGlzLmhhbmRsZXIub25Cb2R5U2VudCkge1xuICAgICAgdGhpcy5oYW5kbGVyLm9uQm9keVNlbnQoY2h1bmspXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlTG9jYXRpb24gKHN0YXR1c0NvZGUsIGhlYWRlcnMpIHtcbiAgaWYgKHJlZGlyZWN0YWJsZVN0YXR1c0NvZGVzLmluZGV4T2Yoc3RhdHVzQ29kZSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGlmIChoZWFkZXJzW2ldLmxlbmd0aCA9PT0gOCAmJiB1dGlsLmhlYWRlck5hbWVUb1N0cmluZyhoZWFkZXJzW2ldKSA9PT0gJ2xvY2F0aW9uJykge1xuICAgICAgcmV0dXJuIGhlYWRlcnNbaSArIDFdXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMxI3NlY3Rpb24tNi40LjRcbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUhlYWRlciAoaGVhZGVyLCByZW1vdmVDb250ZW50LCB1bmtub3duT3JpZ2luKSB7XG4gIGlmIChoZWFkZXIubGVuZ3RoID09PSA0KSB7XG4gICAgcmV0dXJuIHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcikgPT09ICdob3N0J1xuICB9XG4gIGlmIChyZW1vdmVDb250ZW50ICYmIHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcikuc3RhcnRzV2l0aCgnY29udGVudC0nKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHVua25vd25PcmlnaW4gJiYgKGhlYWRlci5sZW5ndGggPT09IDEzIHx8IGhlYWRlci5sZW5ndGggPT09IDYgfHwgaGVhZGVyLmxlbmd0aCA9PT0gMTkpKSB7XG4gICAgY29uc3QgbmFtZSA9IHV0aWwuaGVhZGVyTmFtZVRvU3RyaW5nKGhlYWRlcilcbiAgICByZXR1cm4gbmFtZSA9PT0gJ2F1dGhvcml6YXRpb24nIHx8IG5hbWUgPT09ICdjb29raWUnIHx8IG5hbWUgPT09ICdwcm94eS1hdXRob3JpemF0aW9uJ1xuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMSNzZWN0aW9uLTYuNFxuZnVuY3Rpb24gY2xlYW5SZXF1ZXN0SGVhZGVycyAoaGVhZGVycywgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikge1xuICBjb25zdCByZXQgPSBbXVxuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKCFzaG91bGRSZW1vdmVIZWFkZXIoaGVhZGVyc1tpXSwgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikpIHtcbiAgICAgICAgcmV0LnB1c2goaGVhZGVyc1tpXSwgaGVhZGVyc1tpICsgMV0pXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGhlYWRlcnMgJiYgdHlwZW9mIGhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgIGlmICghc2hvdWxkUmVtb3ZlSGVhZGVyKGtleSwgcmVtb3ZlQ29udGVudCwgdW5rbm93bk9yaWdpbikpIHtcbiAgICAgICAgcmV0LnB1c2goa2V5LCBoZWFkZXJzW2tleV0pXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChoZWFkZXJzID09IG51bGwsICdoZWFkZXJzIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFuIGFycmF5JylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVkaXJlY3RIYW5kbGVyXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/redirect-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/handler/retry-handler.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/handler/retry-handler.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nconst { kRetryHandlerDefaultRetry } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { RequestRetryError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst {\n  isDisturbed,\n  parseHeaders,\n  parseRangeHeader,\n  wrapRequestBody\n} = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nfunction calculateRetryAfterHeader (retryAfter) {\n  const current = Date.now()\n  return new Date(retryAfter).getTime() - current\n}\n\nclass RetryHandler {\n  constructor (opts, handlers) {\n    const { retryOptions, ...dispatchOpts } = opts\n    const {\n      // Retry scoped\n      retry: retryFn,\n      maxRetries,\n      maxTimeout,\n      minTimeout,\n      timeoutFactor,\n      // Response scoped\n      methods,\n      errorCodes,\n      retryAfter,\n      statusCodes\n    } = retryOptions ?? {}\n\n    this.dispatch = handlers.dispatch\n    this.handler = handlers.handler\n    this.opts = { ...dispatchOpts, body: wrapRequestBody(opts.body) }\n    this.abort = null\n    this.aborted = false\n    this.retryOpts = {\n      retry: retryFn ?? RetryHandler[kRetryHandlerDefaultRetry],\n      retryAfter: retryAfter ?? true,\n      maxTimeout: maxTimeout ?? 30 * 1000, // 30s,\n      minTimeout: minTimeout ?? 500, // .5s\n      timeoutFactor: timeoutFactor ?? 2,\n      maxRetries: maxRetries ?? 5,\n      // What errors we should retry\n      methods: methods ?? ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE', 'TRACE'],\n      // Indicates which errors to retry\n      statusCodes: statusCodes ?? [500, 502, 503, 504, 429],\n      // List of errors to retry\n      errorCodes: errorCodes ?? [\n        'ECONNRESET',\n        'ECONNREFUSED',\n        'ENOTFOUND',\n        'ENETDOWN',\n        'ENETUNREACH',\n        'EHOSTDOWN',\n        'EHOSTUNREACH',\n        'EPIPE',\n        'UND_ERR_SOCKET'\n      ]\n    }\n\n    this.retryCount = 0\n    this.retryCountCheckpoint = 0\n    this.start = 0\n    this.end = null\n    this.etag = null\n    this.resume = null\n\n    // Handle possible onConnect duplication\n    this.handler.onConnect(reason => {\n      this.aborted = true\n      if (this.abort) {\n        this.abort(reason)\n      } else {\n        this.reason = reason\n      }\n    })\n  }\n\n  onRequestSent () {\n    if (this.handler.onRequestSent) {\n      this.handler.onRequestSent()\n    }\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    if (this.handler.onUpgrade) {\n      this.handler.onUpgrade(statusCode, headers, socket)\n    }\n  }\n\n  onConnect (abort) {\n    if (this.aborted) {\n      abort(this.reason)\n    } else {\n      this.abort = abort\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) return this.handler.onBodySent(chunk)\n  }\n\n  static [kRetryHandlerDefaultRetry] (err, { state, opts }, cb) {\n    const { statusCode, code, headers } = err\n    const { method, retryOptions } = opts\n    const {\n      maxRetries,\n      minTimeout,\n      maxTimeout,\n      timeoutFactor,\n      statusCodes,\n      errorCodes,\n      methods\n    } = retryOptions\n    const { counter } = state\n\n    // Any code that is not a Undici's originated and allowed to retry\n    if (code && code !== 'UND_ERR_REQ_RETRY' && !errorCodes.includes(code)) {\n      cb(err)\n      return\n    }\n\n    // If a set of method are provided and the current method is not in the list\n    if (Array.isArray(methods) && !methods.includes(method)) {\n      cb(err)\n      return\n    }\n\n    // If a set of status code are provided and the current status code is not in the list\n    if (\n      statusCode != null &&\n      Array.isArray(statusCodes) &&\n      !statusCodes.includes(statusCode)\n    ) {\n      cb(err)\n      return\n    }\n\n    // If we reached the max number of retries\n    if (counter > maxRetries) {\n      cb(err)\n      return\n    }\n\n    let retryAfterHeader = headers?.['retry-after']\n    if (retryAfterHeader) {\n      retryAfterHeader = Number(retryAfterHeader)\n      retryAfterHeader = Number.isNaN(retryAfterHeader)\n        ? calculateRetryAfterHeader(retryAfterHeader)\n        : retryAfterHeader * 1e3 // Retry-After is in seconds\n    }\n\n    const retryTimeout =\n      retryAfterHeader > 0\n        ? Math.min(retryAfterHeader, maxTimeout)\n        : Math.min(minTimeout * timeoutFactor ** (counter - 1), maxTimeout)\n\n    setTimeout(() => cb(null), retryTimeout)\n  }\n\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const headers = parseHeaders(rawHeaders)\n\n    this.retryCount += 1\n\n    if (statusCode >= 300) {\n      if (this.retryOpts.statusCodes.includes(statusCode) === false) {\n        return this.handler.onHeaders(\n          statusCode,\n          rawHeaders,\n          resume,\n          statusMessage\n        )\n      } else {\n        this.abort(\n          new RequestRetryError('Request failed', statusCode, {\n            headers,\n            data: {\n              count: this.retryCount\n            }\n          })\n        )\n        return false\n      }\n    }\n\n    // Checkpoint for resume from where we left it\n    if (this.resume != null) {\n      this.resume = null\n\n      // Only Partial Content 206 supposed to provide Content-Range,\n      // any other status code that partially consumed the payload\n      // should not be retry because it would result in downstream\n      // wrongly concatanete multiple responses.\n      if (statusCode !== 206 && (this.start > 0 || statusCode !== 200)) {\n        this.abort(\n          new RequestRetryError('server does not support the range header and the payload was partially consumed', statusCode, {\n            headers,\n            data: { count: this.retryCount }\n          })\n        )\n        return false\n      }\n\n      const contentRange = parseRangeHeader(headers['content-range'])\n      // If no content range\n      if (!contentRange) {\n        this.abort(\n          new RequestRetryError('Content-Range mismatch', statusCode, {\n            headers,\n            data: { count: this.retryCount }\n          })\n        )\n        return false\n      }\n\n      // Let's start with a weak etag check\n      if (this.etag != null && this.etag !== headers.etag) {\n        this.abort(\n          new RequestRetryError('ETag mismatch', statusCode, {\n            headers,\n            data: { count: this.retryCount }\n          })\n        )\n        return false\n      }\n\n      const { start, size, end = size - 1 } = contentRange\n\n      assert(this.start === start, 'content-range mismatch')\n      assert(this.end == null || this.end === end, 'content-range mismatch')\n\n      this.resume = resume\n      return true\n    }\n\n    if (this.end == null) {\n      if (statusCode === 206) {\n        // First time we receive 206\n        const range = parseRangeHeader(headers['content-range'])\n\n        if (range == null) {\n          return this.handler.onHeaders(\n            statusCode,\n            rawHeaders,\n            resume,\n            statusMessage\n          )\n        }\n\n        const { start, size, end = size - 1 } = range\n        assert(\n          start != null && Number.isFinite(start),\n          'content-range mismatch'\n        )\n        assert(end != null && Number.isFinite(end), 'invalid content-length')\n\n        this.start = start\n        this.end = end\n      }\n\n      // We make our best to checkpoint the body for further range headers\n      if (this.end == null) {\n        const contentLength = headers['content-length']\n        this.end = contentLength != null ? Number(contentLength) - 1 : null\n      }\n\n      assert(Number.isFinite(this.start))\n      assert(\n        this.end == null || Number.isFinite(this.end),\n        'invalid content-length'\n      )\n\n      this.resume = resume\n      this.etag = headers.etag != null ? headers.etag : null\n\n      // Weak etags are not useful for comparison nor cache\n      // for instance not safe to assume if the response is byte-per-byte\n      // equal\n      if (this.etag != null && this.etag.startsWith('W/')) {\n        this.etag = null\n      }\n\n      return this.handler.onHeaders(\n        statusCode,\n        rawHeaders,\n        resume,\n        statusMessage\n      )\n    }\n\n    const err = new RequestRetryError('Request failed', statusCode, {\n      headers,\n      data: { count: this.retryCount }\n    })\n\n    this.abort(err)\n\n    return false\n  }\n\n  onData (chunk) {\n    this.start += chunk.length\n\n    return this.handler.onData(chunk)\n  }\n\n  onComplete (rawTrailers) {\n    this.retryCount = 0\n    return this.handler.onComplete(rawTrailers)\n  }\n\n  onError (err) {\n    if (this.aborted || isDisturbed(this.opts.body)) {\n      return this.handler.onError(err)\n    }\n\n    // We reconcile in case of a mix between network errors\n    // and server error response\n    if (this.retryCount - this.retryCountCheckpoint > 0) {\n      // We count the difference between the last checkpoint and the current retry count\n      this.retryCount =\n        this.retryCountCheckpoint +\n        (this.retryCount - this.retryCountCheckpoint)\n    } else {\n      this.retryCount += 1\n    }\n\n    this.retryOpts.retry(\n      err,\n      {\n        state: { counter: this.retryCount },\n        opts: { retryOptions: this.retryOpts, ...this.opts }\n      },\n      onRetry.bind(this)\n    )\n\n    function onRetry (err) {\n      if (err != null || this.aborted || isDisturbed(this.opts.body)) {\n        return this.handler.onError(err)\n      }\n\n      if (this.start !== 0) {\n        const headers = { range: `bytes=${this.start}-${this.end ?? ''}` }\n\n        // Weak etag check - weak etags will make comparison algorithms never match\n        if (this.etag != null) {\n          headers['if-match'] = this.etag\n        }\n\n        this.opts = {\n          ...this.opts,\n          headers: {\n            ...this.opts.headers,\n            ...headers\n          }\n        }\n      }\n\n      try {\n        this.retryCountCheckpoint = this.retryCount\n        this.dispatch(this.opts, this)\n      } catch (err) {\n        this.handler.onError(err)\n      }\n    }\n  }\n}\n\nmodule.exports = RetryHandler\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9oYW5kbGVyL3JldHJ5LWhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7O0FBRXBDLFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDL0QsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsa0VBQWM7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsYUFBYTtBQUMxRCxZQUFZLDRCQUE0QjtBQUN4QyxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFlBQVksVUFBVTs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLDhCQUE4Qjs7QUFFNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsOEJBQThCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMEJBQTBCO0FBQzNDLGdCQUFnQjtBQUNoQixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixnQkFBZ0IsV0FBVyxHQUFHLGVBQWU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcaGFuZGxlclxccmV0cnktaGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcblxuY29uc3QgeyBrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5IH0gPSByZXF1aXJlKCcuLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBSZXF1ZXN0UmV0cnlFcnJvciB9ID0gcmVxdWlyZSgnLi4vY29yZS9lcnJvcnMnKVxuY29uc3Qge1xuICBpc0Rpc3R1cmJlZCxcbiAgcGFyc2VIZWFkZXJzLFxuICBwYXJzZVJhbmdlSGVhZGVyLFxuICB3cmFwUmVxdWVzdEJvZHlcbn0gPSByZXF1aXJlKCcuLi9jb3JlL3V0aWwnKVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVSZXRyeUFmdGVySGVhZGVyIChyZXRyeUFmdGVyKSB7XG4gIGNvbnN0IGN1cnJlbnQgPSBEYXRlLm5vdygpXG4gIHJldHVybiBuZXcgRGF0ZShyZXRyeUFmdGVyKS5nZXRUaW1lKCkgLSBjdXJyZW50XG59XG5cbmNsYXNzIFJldHJ5SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzLCBoYW5kbGVycykge1xuICAgIGNvbnN0IHsgcmV0cnlPcHRpb25zLCAuLi5kaXNwYXRjaE9wdHMgfSA9IG9wdHNcbiAgICBjb25zdCB7XG4gICAgICAvLyBSZXRyeSBzY29wZWRcbiAgICAgIHJldHJ5OiByZXRyeUZuLFxuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIG1heFRpbWVvdXQsXG4gICAgICBtaW5UaW1lb3V0LFxuICAgICAgdGltZW91dEZhY3RvcixcbiAgICAgIC8vIFJlc3BvbnNlIHNjb3BlZFxuICAgICAgbWV0aG9kcyxcbiAgICAgIGVycm9yQ29kZXMsXG4gICAgICByZXRyeUFmdGVyLFxuICAgICAgc3RhdHVzQ29kZXNcbiAgICB9ID0gcmV0cnlPcHRpb25zID8/IHt9XG5cbiAgICB0aGlzLmRpc3BhdGNoID0gaGFuZGxlcnMuZGlzcGF0Y2hcbiAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVycy5oYW5kbGVyXG4gICAgdGhpcy5vcHRzID0geyAuLi5kaXNwYXRjaE9wdHMsIGJvZHk6IHdyYXBSZXF1ZXN0Qm9keShvcHRzLmJvZHkpIH1cbiAgICB0aGlzLmFib3J0ID0gbnVsbFxuICAgIHRoaXMuYWJvcnRlZCA9IGZhbHNlXG4gICAgdGhpcy5yZXRyeU9wdHMgPSB7XG4gICAgICByZXRyeTogcmV0cnlGbiA/PyBSZXRyeUhhbmRsZXJba1JldHJ5SGFuZGxlckRlZmF1bHRSZXRyeV0sXG4gICAgICByZXRyeUFmdGVyOiByZXRyeUFmdGVyID8/IHRydWUsXG4gICAgICBtYXhUaW1lb3V0OiBtYXhUaW1lb3V0ID8/IDMwICogMTAwMCwgLy8gMzBzLFxuICAgICAgbWluVGltZW91dDogbWluVGltZW91dCA/PyA1MDAsIC8vIC41c1xuICAgICAgdGltZW91dEZhY3RvcjogdGltZW91dEZhY3RvciA/PyAyLFxuICAgICAgbWF4UmV0cmllczogbWF4UmV0cmllcyA/PyA1LFxuICAgICAgLy8gV2hhdCBlcnJvcnMgd2Ugc2hvdWxkIHJldHJ5XG4gICAgICBtZXRob2RzOiBtZXRob2RzID8/IFsnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQVVQnLCAnREVMRVRFJywgJ1RSQUNFJ10sXG4gICAgICAvLyBJbmRpY2F0ZXMgd2hpY2ggZXJyb3JzIHRvIHJldHJ5XG4gICAgICBzdGF0dXNDb2Rlczogc3RhdHVzQ29kZXMgPz8gWzUwMCwgNTAyLCA1MDMsIDUwNCwgNDI5XSxcbiAgICAgIC8vIExpc3Qgb2YgZXJyb3JzIHRvIHJldHJ5XG4gICAgICBlcnJvckNvZGVzOiBlcnJvckNvZGVzID8/IFtcbiAgICAgICAgJ0VDT05OUkVTRVQnLFxuICAgICAgICAnRUNPTk5SRUZVU0VEJyxcbiAgICAgICAgJ0VOT1RGT1VORCcsXG4gICAgICAgICdFTkVURE9XTicsXG4gICAgICAgICdFTkVUVU5SRUFDSCcsXG4gICAgICAgICdFSE9TVERPV04nLFxuICAgICAgICAnRUhPU1RVTlJFQUNIJyxcbiAgICAgICAgJ0VQSVBFJyxcbiAgICAgICAgJ1VORF9FUlJfU09DS0VUJ1xuICAgICAgXVxuICAgIH1cblxuICAgIHRoaXMucmV0cnlDb3VudCA9IDBcbiAgICB0aGlzLnJldHJ5Q291bnRDaGVja3BvaW50ID0gMFxuICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgdGhpcy5lbmQgPSBudWxsXG4gICAgdGhpcy5ldGFnID0gbnVsbFxuICAgIHRoaXMucmVzdW1lID0gbnVsbFxuXG4gICAgLy8gSGFuZGxlIHBvc3NpYmxlIG9uQ29ubmVjdCBkdXBsaWNhdGlvblxuICAgIHRoaXMuaGFuZGxlci5vbkNvbm5lY3QocmVhc29uID0+IHtcbiAgICAgIHRoaXMuYWJvcnRlZCA9IHRydWVcbiAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgIHRoaXMuYWJvcnQocmVhc29uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZWFzb24gPSByZWFzb25cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgb25SZXF1ZXN0U2VudCAoKSB7XG4gICAgaWYgKHRoaXMuaGFuZGxlci5vblJlcXVlc3RTZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZXIub25SZXF1ZXN0U2VudCgpXG4gICAgfVxuICB9XG5cbiAgb25VcGdyYWRlIChzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpIHtcbiAgICBpZiAodGhpcy5oYW5kbGVyLm9uVXBncmFkZSkge1xuICAgICAgdGhpcy5oYW5kbGVyLm9uVXBncmFkZShzdGF0dXNDb2RlLCBoZWFkZXJzLCBzb2NrZXQpXG4gICAgfVxuICB9XG5cbiAgb25Db25uZWN0IChhYm9ydCkge1xuICAgIGlmICh0aGlzLmFib3J0ZWQpIHtcbiAgICAgIGFib3J0KHRoaXMucmVhc29uKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFib3J0ID0gYWJvcnRcbiAgICB9XG4gIH1cblxuICBvbkJvZHlTZW50IChjaHVuaykge1xuICAgIGlmICh0aGlzLmhhbmRsZXIub25Cb2R5U2VudCkgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkJvZHlTZW50KGNodW5rKVxuICB9XG5cbiAgc3RhdGljIFtrUmV0cnlIYW5kbGVyRGVmYXVsdFJldHJ5XSAoZXJyLCB7IHN0YXRlLCBvcHRzIH0sIGNiKSB7XG4gICAgY29uc3QgeyBzdGF0dXNDb2RlLCBjb2RlLCBoZWFkZXJzIH0gPSBlcnJcbiAgICBjb25zdCB7IG1ldGhvZCwgcmV0cnlPcHRpb25zIH0gPSBvcHRzXG4gICAgY29uc3Qge1xuICAgICAgbWF4UmV0cmllcyxcbiAgICAgIG1pblRpbWVvdXQsXG4gICAgICBtYXhUaW1lb3V0LFxuICAgICAgdGltZW91dEZhY3RvcixcbiAgICAgIHN0YXR1c0NvZGVzLFxuICAgICAgZXJyb3JDb2RlcyxcbiAgICAgIG1ldGhvZHNcbiAgICB9ID0gcmV0cnlPcHRpb25zXG4gICAgY29uc3QgeyBjb3VudGVyIH0gPSBzdGF0ZVxuXG4gICAgLy8gQW55IGNvZGUgdGhhdCBpcyBub3QgYSBVbmRpY2kncyBvcmlnaW5hdGVkIGFuZCBhbGxvd2VkIHRvIHJldHJ5XG4gICAgaWYgKGNvZGUgJiYgY29kZSAhPT0gJ1VORF9FUlJfUkVRX1JFVFJZJyAmJiAhZXJyb3JDb2Rlcy5pbmNsdWRlcyhjb2RlKSkge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gSWYgYSBzZXQgb2YgbWV0aG9kIGFyZSBwcm92aWRlZCBhbmQgdGhlIGN1cnJlbnQgbWV0aG9kIGlzIG5vdCBpbiB0aGUgbGlzdFxuICAgIGlmIChBcnJheS5pc0FycmF5KG1ldGhvZHMpICYmICFtZXRob2RzLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIGEgc2V0IG9mIHN0YXR1cyBjb2RlIGFyZSBwcm92aWRlZCBhbmQgdGhlIGN1cnJlbnQgc3RhdHVzIGNvZGUgaXMgbm90IGluIHRoZSBsaXN0XG4gICAgaWYgKFxuICAgICAgc3RhdHVzQ29kZSAhPSBudWxsICYmXG4gICAgICBBcnJheS5pc0FycmF5KHN0YXR1c0NvZGVzKSAmJlxuICAgICAgIXN0YXR1c0NvZGVzLmluY2x1ZGVzKHN0YXR1c0NvZGUpXG4gICAgKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSByZWFjaGVkIHRoZSBtYXggbnVtYmVyIG9mIHJldHJpZXNcbiAgICBpZiAoY291bnRlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIGNiKGVycilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCByZXRyeUFmdGVySGVhZGVyID0gaGVhZGVycz8uWydyZXRyeS1hZnRlciddXG4gICAgaWYgKHJldHJ5QWZ0ZXJIZWFkZXIpIHtcbiAgICAgIHJldHJ5QWZ0ZXJIZWFkZXIgPSBOdW1iZXIocmV0cnlBZnRlckhlYWRlcilcbiAgICAgIHJldHJ5QWZ0ZXJIZWFkZXIgPSBOdW1iZXIuaXNOYU4ocmV0cnlBZnRlckhlYWRlcilcbiAgICAgICAgPyBjYWxjdWxhdGVSZXRyeUFmdGVySGVhZGVyKHJldHJ5QWZ0ZXJIZWFkZXIpXG4gICAgICAgIDogcmV0cnlBZnRlckhlYWRlciAqIDFlMyAvLyBSZXRyeS1BZnRlciBpcyBpbiBzZWNvbmRzXG4gICAgfVxuXG4gICAgY29uc3QgcmV0cnlUaW1lb3V0ID1cbiAgICAgIHJldHJ5QWZ0ZXJIZWFkZXIgPiAwXG4gICAgICAgID8gTWF0aC5taW4ocmV0cnlBZnRlckhlYWRlciwgbWF4VGltZW91dClcbiAgICAgICAgOiBNYXRoLm1pbihtaW5UaW1lb3V0ICogdGltZW91dEZhY3RvciAqKiAoY291bnRlciAtIDEpLCBtYXhUaW1lb3V0KVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiBjYihudWxsKSwgcmV0cnlUaW1lb3V0KVxuICB9XG5cbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gcGFyc2VIZWFkZXJzKHJhd0hlYWRlcnMpXG5cbiAgICB0aGlzLnJldHJ5Q291bnQgKz0gMVxuXG4gICAgaWYgKHN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgICBpZiAodGhpcy5yZXRyeU9wdHMuc3RhdHVzQ29kZXMuaW5jbHVkZXMoc3RhdHVzQ29kZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXIub25IZWFkZXJzKFxuICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgcmF3SGVhZGVycyxcbiAgICAgICAgICByZXN1bWUsXG4gICAgICAgICAgc3RhdHVzTWVzc2FnZVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFib3J0KFxuICAgICAgICAgIG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignUmVxdWVzdCBmYWlsZWQnLCBzdGF0dXNDb2RlLCB7XG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBjb3VudDogdGhpcy5yZXRyeUNvdW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVja3BvaW50IGZvciByZXN1bWUgZnJvbSB3aGVyZSB3ZSBsZWZ0IGl0XG4gICAgaWYgKHRoaXMucmVzdW1lICE9IG51bGwpIHtcbiAgICAgIHRoaXMucmVzdW1lID0gbnVsbFxuXG4gICAgICAvLyBPbmx5IFBhcnRpYWwgQ29udGVudCAyMDYgc3VwcG9zZWQgdG8gcHJvdmlkZSBDb250ZW50LVJhbmdlLFxuICAgICAgLy8gYW55IG90aGVyIHN0YXR1cyBjb2RlIHRoYXQgcGFydGlhbGx5IGNvbnN1bWVkIHRoZSBwYXlsb2FkXG4gICAgICAvLyBzaG91bGQgbm90IGJlIHJldHJ5IGJlY2F1c2UgaXQgd291bGQgcmVzdWx0IGluIGRvd25zdHJlYW1cbiAgICAgIC8vIHdyb25nbHkgY29uY2F0YW5ldGUgbXVsdGlwbGUgcmVzcG9uc2VzLlxuICAgICAgaWYgKHN0YXR1c0NvZGUgIT09IDIwNiAmJiAodGhpcy5zdGFydCA+IDAgfHwgc3RhdHVzQ29kZSAhPT0gMjAwKSkge1xuICAgICAgICB0aGlzLmFib3J0KFxuICAgICAgICAgIG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIHJhbmdlIGhlYWRlciBhbmQgdGhlIHBheWxvYWQgd2FzIHBhcnRpYWxseSBjb25zdW1lZCcsIHN0YXR1c0NvZGUsIHtcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBkYXRhOiB7IGNvdW50OiB0aGlzLnJldHJ5Q291bnQgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IHBhcnNlUmFuZ2VIZWFkZXIoaGVhZGVyc1snY29udGVudC1yYW5nZSddKVxuICAgICAgLy8gSWYgbm8gY29udGVudCByYW5nZVxuICAgICAgaWYgKCFjb250ZW50UmFuZ2UpIHtcbiAgICAgICAgdGhpcy5hYm9ydChcbiAgICAgICAgICBuZXcgUmVxdWVzdFJldHJ5RXJyb3IoJ0NvbnRlbnQtUmFuZ2UgbWlzbWF0Y2gnLCBzdGF0dXNDb2RlLCB7XG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgZGF0YTogeyBjb3VudDogdGhpcy5yZXRyeUNvdW50IH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBMZXQncyBzdGFydCB3aXRoIGEgd2VhayBldGFnIGNoZWNrXG4gICAgICBpZiAodGhpcy5ldGFnICE9IG51bGwgJiYgdGhpcy5ldGFnICE9PSBoZWFkZXJzLmV0YWcpIHtcbiAgICAgICAgdGhpcy5hYm9ydChcbiAgICAgICAgICBuZXcgUmVxdWVzdFJldHJ5RXJyb3IoJ0VUYWcgbWlzbWF0Y2gnLCBzdGF0dXNDb2RlLCB7XG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgZGF0YTogeyBjb3VudDogdGhpcy5yZXRyeUNvdW50IH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHN0YXJ0LCBzaXplLCBlbmQgPSBzaXplIC0gMSB9ID0gY29udGVudFJhbmdlXG5cbiAgICAgIGFzc2VydCh0aGlzLnN0YXJ0ID09PSBzdGFydCwgJ2NvbnRlbnQtcmFuZ2UgbWlzbWF0Y2gnKVxuICAgICAgYXNzZXJ0KHRoaXMuZW5kID09IG51bGwgfHwgdGhpcy5lbmQgPT09IGVuZCwgJ2NvbnRlbnQtcmFuZ2UgbWlzbWF0Y2gnKVxuXG4gICAgICB0aGlzLnJlc3VtZSA9IHJlc3VtZVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbmQgPT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXR1c0NvZGUgPT09IDIwNikge1xuICAgICAgICAvLyBGaXJzdCB0aW1lIHdlIHJlY2VpdmUgMjA2XG4gICAgICAgIGNvbnN0IHJhbmdlID0gcGFyc2VSYW5nZUhlYWRlcihoZWFkZXJzWydjb250ZW50LXJhbmdlJ10pXG5cbiAgICAgICAgaWYgKHJhbmdlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uSGVhZGVycyhcbiAgICAgICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgICAgICByYXdIZWFkZXJzLFxuICAgICAgICAgICAgcmVzdW1lLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIHNpemUsIGVuZCA9IHNpemUgLSAxIH0gPSByYW5nZVxuICAgICAgICBhc3NlcnQoXG4gICAgICAgICAgc3RhcnQgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUoc3RhcnQpLFxuICAgICAgICAgICdjb250ZW50LXJhbmdlIG1pc21hdGNoJ1xuICAgICAgICApXG4gICAgICAgIGFzc2VydChlbmQgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUoZW5kKSwgJ2ludmFsaWQgY29udGVudC1sZW5ndGgnKVxuXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydFxuICAgICAgICB0aGlzLmVuZCA9IGVuZFxuICAgICAgfVxuXG4gICAgICAvLyBXZSBtYWtlIG91ciBiZXN0IHRvIGNoZWNrcG9pbnQgdGhlIGJvZHkgZm9yIGZ1cnRoZXIgcmFuZ2UgaGVhZGVyc1xuICAgICAgaWYgKHRoaXMuZW5kID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ11cbiAgICAgICAgdGhpcy5lbmQgPSBjb250ZW50TGVuZ3RoICE9IG51bGwgPyBOdW1iZXIoY29udGVudExlbmd0aCkgLSAxIDogbnVsbFxuICAgICAgfVxuXG4gICAgICBhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHRoaXMuc3RhcnQpKVxuICAgICAgYXNzZXJ0KFxuICAgICAgICB0aGlzLmVuZCA9PSBudWxsIHx8IE51bWJlci5pc0Zpbml0ZSh0aGlzLmVuZCksXG4gICAgICAgICdpbnZhbGlkIGNvbnRlbnQtbGVuZ3RoJ1xuICAgICAgKVxuXG4gICAgICB0aGlzLnJlc3VtZSA9IHJlc3VtZVxuICAgICAgdGhpcy5ldGFnID0gaGVhZGVycy5ldGFnICE9IG51bGwgPyBoZWFkZXJzLmV0YWcgOiBudWxsXG5cbiAgICAgIC8vIFdlYWsgZXRhZ3MgYXJlIG5vdCB1c2VmdWwgZm9yIGNvbXBhcmlzb24gbm9yIGNhY2hlXG4gICAgICAvLyBmb3IgaW5zdGFuY2Ugbm90IHNhZmUgdG8gYXNzdW1lIGlmIHRoZSByZXNwb25zZSBpcyBieXRlLXBlci1ieXRlXG4gICAgICAvLyBlcXVhbFxuICAgICAgaWYgKHRoaXMuZXRhZyAhPSBudWxsICYmIHRoaXMuZXRhZy5zdGFydHNXaXRoKCdXLycpKSB7XG4gICAgICAgIHRoaXMuZXRhZyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkhlYWRlcnMoXG4gICAgICAgIHN0YXR1c0NvZGUsXG4gICAgICAgIHJhd0hlYWRlcnMsXG4gICAgICAgIHJlc3VtZSxcbiAgICAgICAgc3RhdHVzTWVzc2FnZVxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGVyciA9IG5ldyBSZXF1ZXN0UmV0cnlFcnJvcignUmVxdWVzdCBmYWlsZWQnLCBzdGF0dXNDb2RlLCB7XG4gICAgICBoZWFkZXJzLFxuICAgICAgZGF0YTogeyBjb3VudDogdGhpcy5yZXRyeUNvdW50IH1cbiAgICB9KVxuXG4gICAgdGhpcy5hYm9ydChlcnIpXG5cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICB0aGlzLnN0YXJ0ICs9IGNodW5rLmxlbmd0aFxuXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkRhdGEoY2h1bmspXG4gIH1cblxuICBvbkNvbXBsZXRlIChyYXdUcmFpbGVycykge1xuICAgIHRoaXMucmV0cnlDb3VudCA9IDBcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLm9uQ29tcGxldGUocmF3VHJhaWxlcnMpXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBpZiAodGhpcy5hYm9ydGVkIHx8IGlzRGlzdHVyYmVkKHRoaXMub3B0cy5ib2R5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkVycm9yKGVycilcbiAgICB9XG5cbiAgICAvLyBXZSByZWNvbmNpbGUgaW4gY2FzZSBvZiBhIG1peCBiZXR3ZWVuIG5ldHdvcmsgZXJyb3JzXG4gICAgLy8gYW5kIHNlcnZlciBlcnJvciByZXNwb25zZVxuICAgIGlmICh0aGlzLnJldHJ5Q291bnQgLSB0aGlzLnJldHJ5Q291bnRDaGVja3BvaW50ID4gMCkge1xuICAgICAgLy8gV2UgY291bnQgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbGFzdCBjaGVja3BvaW50IGFuZCB0aGUgY3VycmVudCByZXRyeSBjb3VudFxuICAgICAgdGhpcy5yZXRyeUNvdW50ID1cbiAgICAgICAgdGhpcy5yZXRyeUNvdW50Q2hlY2twb2ludCArXG4gICAgICAgICh0aGlzLnJldHJ5Q291bnQgLSB0aGlzLnJldHJ5Q291bnRDaGVja3BvaW50KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJldHJ5Q291bnQgKz0gMVxuICAgIH1cblxuICAgIHRoaXMucmV0cnlPcHRzLnJldHJ5KFxuICAgICAgZXJyLFxuICAgICAge1xuICAgICAgICBzdGF0ZTogeyBjb3VudGVyOiB0aGlzLnJldHJ5Q291bnQgfSxcbiAgICAgICAgb3B0czogeyByZXRyeU9wdGlvbnM6IHRoaXMucmV0cnlPcHRzLCAuLi50aGlzLm9wdHMgfVxuICAgICAgfSxcbiAgICAgIG9uUmV0cnkuYmluZCh0aGlzKVxuICAgIClcblxuICAgIGZ1bmN0aW9uIG9uUmV0cnkgKGVycikge1xuICAgICAgaWYgKGVyciAhPSBudWxsIHx8IHRoaXMuYWJvcnRlZCB8fCBpc0Rpc3R1cmJlZCh0aGlzLm9wdHMuYm9keSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5vbkVycm9yKGVycilcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhcnQgIT09IDApIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHsgcmFuZ2U6IGBieXRlcz0ke3RoaXMuc3RhcnR9LSR7dGhpcy5lbmQgPz8gJyd9YCB9XG5cbiAgICAgICAgLy8gV2VhayBldGFnIGNoZWNrIC0gd2VhayBldGFncyB3aWxsIG1ha2UgY29tcGFyaXNvbiBhbGdvcml0aG1zIG5ldmVyIG1hdGNoXG4gICAgICAgIGlmICh0aGlzLmV0YWcgIT0gbnVsbCkge1xuICAgICAgICAgIGhlYWRlcnNbJ2lmLW1hdGNoJ10gPSB0aGlzLmV0YWdcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3B0cyA9IHtcbiAgICAgICAgICAuLi50aGlzLm9wdHMsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRzLmhlYWRlcnMsXG4gICAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMucmV0cnlDb3VudENoZWNrcG9pbnQgPSB0aGlzLnJldHJ5Q291bnRcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh0aGlzLm9wdHMsIHRoaXMpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJldHJ5SGFuZGxlclxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/handler/retry-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/dns.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/dns.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { isIP } = __webpack_require__(/*! node:net */ \"node:net\")\nconst { lookup } = __webpack_require__(/*! node:dns */ \"node:dns\")\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\nconst { InvalidArgumentError, InformationalError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst maxInt = Math.pow(2, 31) - 1\n\nclass DNSInstance {\n  #maxTTL = 0\n  #maxItems = 0\n  #records = new Map()\n  dualStack = true\n  affinity = null\n  lookup = null\n  pick = null\n\n  constructor (opts) {\n    this.#maxTTL = opts.maxTTL\n    this.#maxItems = opts.maxItems\n    this.dualStack = opts.dualStack\n    this.affinity = opts.affinity\n    this.lookup = opts.lookup ?? this.#defaultLookup\n    this.pick = opts.pick ?? this.#defaultPick\n  }\n\n  get full () {\n    return this.#records.size === this.#maxItems\n  }\n\n  runLookup (origin, opts, cb) {\n    const ips = this.#records.get(origin.hostname)\n\n    // If full, we just return the origin\n    if (ips == null && this.full) {\n      cb(null, origin.origin)\n      return\n    }\n\n    const newOpts = {\n      affinity: this.affinity,\n      dualStack: this.dualStack,\n      lookup: this.lookup,\n      pick: this.pick,\n      ...opts.dns,\n      maxTTL: this.#maxTTL,\n      maxItems: this.#maxItems\n    }\n\n    // If no IPs we lookup\n    if (ips == null) {\n      this.lookup(origin, newOpts, (err, addresses) => {\n        if (err || addresses == null || addresses.length === 0) {\n          cb(err ?? new InformationalError('No DNS entries found'))\n          return\n        }\n\n        this.setRecords(origin, addresses)\n        const records = this.#records.get(origin.hostname)\n\n        const ip = this.pick(\n          origin,\n          records,\n          newOpts.affinity\n        )\n\n        let port\n        if (typeof ip.port === 'number') {\n          port = `:${ip.port}`\n        } else if (origin.port !== '') {\n          port = `:${origin.port}`\n        } else {\n          port = ''\n        }\n\n        cb(\n          null,\n          `${origin.protocol}//${\n            ip.family === 6 ? `[${ip.address}]` : ip.address\n          }${port}`\n        )\n      })\n    } else {\n      // If there's IPs we pick\n      const ip = this.pick(\n        origin,\n        ips,\n        newOpts.affinity\n      )\n\n      // If no IPs we lookup - deleting old records\n      if (ip == null) {\n        this.#records.delete(origin.hostname)\n        this.runLookup(origin, opts, cb)\n        return\n      }\n\n      let port\n      if (typeof ip.port === 'number') {\n        port = `:${ip.port}`\n      } else if (origin.port !== '') {\n        port = `:${origin.port}`\n      } else {\n        port = ''\n      }\n\n      cb(\n        null,\n        `${origin.protocol}//${\n          ip.family === 6 ? `[${ip.address}]` : ip.address\n        }${port}`\n      )\n    }\n  }\n\n  #defaultLookup (origin, opts, cb) {\n    lookup(\n      origin.hostname,\n      {\n        all: true,\n        family: this.dualStack === false ? this.affinity : 0,\n        order: 'ipv4first'\n      },\n      (err, addresses) => {\n        if (err) {\n          return cb(err)\n        }\n\n        const results = new Map()\n\n        for (const addr of addresses) {\n          // On linux we found duplicates, we attempt to remove them with\n          // the latest record\n          results.set(`${addr.address}:${addr.family}`, addr)\n        }\n\n        cb(null, results.values())\n      }\n    )\n  }\n\n  #defaultPick (origin, hostnameRecords, affinity) {\n    let ip = null\n    const { records, offset } = hostnameRecords\n\n    let family\n    if (this.dualStack) {\n      if (affinity == null) {\n        // Balance between ip families\n        if (offset == null || offset === maxInt) {\n          hostnameRecords.offset = 0\n          affinity = 4\n        } else {\n          hostnameRecords.offset++\n          affinity = (hostnameRecords.offset & 1) === 1 ? 6 : 4\n        }\n      }\n\n      if (records[affinity] != null && records[affinity].ips.length > 0) {\n        family = records[affinity]\n      } else {\n        family = records[affinity === 4 ? 6 : 4]\n      }\n    } else {\n      family = records[affinity]\n    }\n\n    // If no IPs we return null\n    if (family == null || family.ips.length === 0) {\n      return ip\n    }\n\n    if (family.offset == null || family.offset === maxInt) {\n      family.offset = 0\n    } else {\n      family.offset++\n    }\n\n    const position = family.offset % family.ips.length\n    ip = family.ips[position] ?? null\n\n    if (ip == null) {\n      return ip\n    }\n\n    if (Date.now() - ip.timestamp > ip.ttl) { // record TTL is already in ms\n      // We delete expired records\n      // It is possible that they have different TTL, so we manage them individually\n      family.ips.splice(position, 1)\n      return this.pick(origin, hostnameRecords, affinity)\n    }\n\n    return ip\n  }\n\n  setRecords (origin, addresses) {\n    const timestamp = Date.now()\n    const records = { records: { 4: null, 6: null } }\n    for (const record of addresses) {\n      record.timestamp = timestamp\n      if (typeof record.ttl === 'number') {\n        // The record TTL is expected to be in ms\n        record.ttl = Math.min(record.ttl, this.#maxTTL)\n      } else {\n        record.ttl = this.#maxTTL\n      }\n\n      const familyRecords = records.records[record.family] ?? { ips: [] }\n\n      familyRecords.ips.push(record)\n      records.records[record.family] = familyRecords\n    }\n\n    this.#records.set(origin.hostname, records)\n  }\n\n  getHandler (meta, opts) {\n    return new DNSDispatchHandler(this, meta, opts)\n  }\n}\n\nclass DNSDispatchHandler extends DecoratorHandler {\n  #state = null\n  #opts = null\n  #dispatch = null\n  #handler = null\n  #origin = null\n\n  constructor (state, { origin, handler, dispatch }, opts) {\n    super(handler)\n    this.#origin = origin\n    this.#handler = handler\n    this.#opts = { ...opts }\n    this.#state = state\n    this.#dispatch = dispatch\n  }\n\n  onError (err) {\n    switch (err.code) {\n      case 'ETIMEDOUT':\n      case 'ECONNREFUSED': {\n        if (this.#state.dualStack) {\n          // We delete the record and retry\n          this.#state.runLookup(this.#origin, this.#opts, (err, newOrigin) => {\n            if (err) {\n              return this.#handler.onError(err)\n            }\n\n            const dispatchOpts = {\n              ...this.#opts,\n              origin: newOrigin\n            }\n\n            this.#dispatch(dispatchOpts, this)\n          })\n\n          // if dual-stack disabled, we error out\n          return\n        }\n\n        this.#handler.onError(err)\n        return\n      }\n      case 'ENOTFOUND':\n        this.#state.deleteRecord(this.#origin)\n      // eslint-disable-next-line no-fallthrough\n      default:\n        this.#handler.onError(err)\n        break\n    }\n  }\n}\n\nmodule.exports = interceptorOpts => {\n  if (\n    interceptorOpts?.maxTTL != null &&\n    (typeof interceptorOpts?.maxTTL !== 'number' || interceptorOpts?.maxTTL < 0)\n  ) {\n    throw new InvalidArgumentError('Invalid maxTTL. Must be a positive number')\n  }\n\n  if (\n    interceptorOpts?.maxItems != null &&\n    (typeof interceptorOpts?.maxItems !== 'number' ||\n      interceptorOpts?.maxItems < 1)\n  ) {\n    throw new InvalidArgumentError(\n      'Invalid maxItems. Must be a positive number and greater than zero'\n    )\n  }\n\n  if (\n    interceptorOpts?.affinity != null &&\n    interceptorOpts?.affinity !== 4 &&\n    interceptorOpts?.affinity !== 6\n  ) {\n    throw new InvalidArgumentError('Invalid affinity. Must be either 4 or 6')\n  }\n\n  if (\n    interceptorOpts?.dualStack != null &&\n    typeof interceptorOpts?.dualStack !== 'boolean'\n  ) {\n    throw new InvalidArgumentError('Invalid dualStack. Must be a boolean')\n  }\n\n  if (\n    interceptorOpts?.lookup != null &&\n    typeof interceptorOpts?.lookup !== 'function'\n  ) {\n    throw new InvalidArgumentError('Invalid lookup. Must be a function')\n  }\n\n  if (\n    interceptorOpts?.pick != null &&\n    typeof interceptorOpts?.pick !== 'function'\n  ) {\n    throw new InvalidArgumentError('Invalid pick. Must be a function')\n  }\n\n  const dualStack = interceptorOpts?.dualStack ?? true\n  let affinity\n  if (dualStack) {\n    affinity = interceptorOpts?.affinity ?? null\n  } else {\n    affinity = interceptorOpts?.affinity ?? 4\n  }\n\n  const opts = {\n    maxTTL: interceptorOpts?.maxTTL ?? 10e3, // Expressed in ms\n    lookup: interceptorOpts?.lookup ?? null,\n    pick: interceptorOpts?.pick ?? null,\n    dualStack,\n    affinity,\n    maxItems: interceptorOpts?.maxItems ?? Infinity\n  }\n\n  const instance = new DNSInstance(opts)\n\n  return dispatch => {\n    return function dnsInterceptor (origDispatchOpts, handler) {\n      const origin =\n        origDispatchOpts.origin.constructor === URL\n          ? origDispatchOpts.origin\n          : new URL(origDispatchOpts.origin)\n\n      if (isIP(origin.hostname) !== 0) {\n        return dispatch(origDispatchOpts, handler)\n      }\n\n      instance.runLookup(origin, origDispatchOpts, (err, newOrigin) => {\n        if (err) {\n          return handler.onError(err)\n        }\n\n        let dispatchOpts = null\n        dispatchOpts = {\n          ...origDispatchOpts,\n          servername: origin.hostname, // For SNI on TLS\n          origin: newOrigin,\n          headers: {\n            host: origin.hostname,\n            ...origDispatchOpts.headers\n          }\n        }\n\n        dispatch(\n          dispatchOpts,\n          instance.getHandler({ origin, dispatch, handler }, origDispatchOpts)\n        )\n      })\n\n      return true\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kbnMuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLDBCQUFVO0FBQ25DLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsMEJBQVU7QUFDckMseUJBQXlCLG1CQUFPLENBQUMsa0dBQThCO0FBQy9ELFFBQVEsMkNBQTJDLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDN0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0IsVUFBVTtBQUNWLHFCQUFxQixZQUFZO0FBQ2pDLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixrQ0FBa0MsV0FBVztBQUM3QyxXQUFXLEVBQUUsS0FBSztBQUNsQjtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsUUFBUTtBQUNSLG1CQUFtQixZQUFZO0FBQy9CLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixnQ0FBZ0MsV0FBVztBQUMzQyxTQUFTLEVBQUUsS0FBSztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWEsR0FBRyxZQUFZO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkJBQTJCO0FBQzNEO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxpbnRlcmNlcHRvclxcZG5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgeyBpc0lQIH0gPSByZXF1aXJlKCdub2RlOm5ldCcpXG5jb25zdCB7IGxvb2t1cCB9ID0gcmVxdWlyZSgnbm9kZTpkbnMnKVxuY29uc3QgRGVjb3JhdG9ySGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvZGVjb3JhdG9yLWhhbmRsZXInKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgSW5mb3JtYXRpb25hbEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5jb25zdCBtYXhJbnQgPSBNYXRoLnBvdygyLCAzMSkgLSAxXG5cbmNsYXNzIEROU0luc3RhbmNlIHtcbiAgI21heFRUTCA9IDBcbiAgI21heEl0ZW1zID0gMFxuICAjcmVjb3JkcyA9IG5ldyBNYXAoKVxuICBkdWFsU3RhY2sgPSB0cnVlXG4gIGFmZmluaXR5ID0gbnVsbFxuICBsb29rdXAgPSBudWxsXG4gIHBpY2sgPSBudWxsXG5cbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICB0aGlzLiNtYXhUVEwgPSBvcHRzLm1heFRUTFxuICAgIHRoaXMuI21heEl0ZW1zID0gb3B0cy5tYXhJdGVtc1xuICAgIHRoaXMuZHVhbFN0YWNrID0gb3B0cy5kdWFsU3RhY2tcbiAgICB0aGlzLmFmZmluaXR5ID0gb3B0cy5hZmZpbml0eVxuICAgIHRoaXMubG9va3VwID0gb3B0cy5sb29rdXAgPz8gdGhpcy4jZGVmYXVsdExvb2t1cFxuICAgIHRoaXMucGljayA9IG9wdHMucGljayA/PyB0aGlzLiNkZWZhdWx0UGlja1xuICB9XG5cbiAgZ2V0IGZ1bGwgKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWNvcmRzLnNpemUgPT09IHRoaXMuI21heEl0ZW1zXG4gIH1cblxuICBydW5Mb29rdXAgKG9yaWdpbiwgb3B0cywgY2IpIHtcbiAgICBjb25zdCBpcHMgPSB0aGlzLiNyZWNvcmRzLmdldChvcmlnaW4uaG9zdG5hbWUpXG5cbiAgICAvLyBJZiBmdWxsLCB3ZSBqdXN0IHJldHVybiB0aGUgb3JpZ2luXG4gICAgaWYgKGlwcyA9PSBudWxsICYmIHRoaXMuZnVsbCkge1xuICAgICAgY2IobnVsbCwgb3JpZ2luLm9yaWdpbilcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IG5ld09wdHMgPSB7XG4gICAgICBhZmZpbml0eTogdGhpcy5hZmZpbml0eSxcbiAgICAgIGR1YWxTdGFjazogdGhpcy5kdWFsU3RhY2ssXG4gICAgICBsb29rdXA6IHRoaXMubG9va3VwLFxuICAgICAgcGljazogdGhpcy5waWNrLFxuICAgICAgLi4ub3B0cy5kbnMsXG4gICAgICBtYXhUVEw6IHRoaXMuI21heFRUTCxcbiAgICAgIG1heEl0ZW1zOiB0aGlzLiNtYXhJdGVtc1xuICAgIH1cblxuICAgIC8vIElmIG5vIElQcyB3ZSBsb29rdXBcbiAgICBpZiAoaXBzID09IG51bGwpIHtcbiAgICAgIHRoaXMubG9va3VwKG9yaWdpbiwgbmV3T3B0cywgKGVyciwgYWRkcmVzc2VzKSA9PiB7XG4gICAgICAgIGlmIChlcnIgfHwgYWRkcmVzc2VzID09IG51bGwgfHwgYWRkcmVzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNiKGVyciA/PyBuZXcgSW5mb3JtYXRpb25hbEVycm9yKCdObyBETlMgZW50cmllcyBmb3VuZCcpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRSZWNvcmRzKG9yaWdpbiwgYWRkcmVzc2VzKVxuICAgICAgICBjb25zdCByZWNvcmRzID0gdGhpcy4jcmVjb3Jkcy5nZXQob3JpZ2luLmhvc3RuYW1lKVxuXG4gICAgICAgIGNvbnN0IGlwID0gdGhpcy5waWNrKFxuICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICByZWNvcmRzLFxuICAgICAgICAgIG5ld09wdHMuYWZmaW5pdHlcbiAgICAgICAgKVxuXG4gICAgICAgIGxldCBwb3J0XG4gICAgICAgIGlmICh0eXBlb2YgaXAucG9ydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBwb3J0ID0gYDoke2lwLnBvcnR9YFxuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbi5wb3J0ICE9PSAnJykge1xuICAgICAgICAgIHBvcnQgPSBgOiR7b3JpZ2luLnBvcnR9YFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcnQgPSAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgY2IoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBgJHtvcmlnaW4ucHJvdG9jb2x9Ly8ke1xuICAgICAgICAgICAgaXAuZmFtaWx5ID09PSA2ID8gYFske2lwLmFkZHJlc3N9XWAgOiBpcC5hZGRyZXNzXG4gICAgICAgICAgfSR7cG9ydH1gXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3MgSVBzIHdlIHBpY2tcbiAgICAgIGNvbnN0IGlwID0gdGhpcy5waWNrKFxuICAgICAgICBvcmlnaW4sXG4gICAgICAgIGlwcyxcbiAgICAgICAgbmV3T3B0cy5hZmZpbml0eVxuICAgICAgKVxuXG4gICAgICAvLyBJZiBubyBJUHMgd2UgbG9va3VwIC0gZGVsZXRpbmcgb2xkIHJlY29yZHNcbiAgICAgIGlmIChpcCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuI3JlY29yZHMuZGVsZXRlKG9yaWdpbi5ob3N0bmFtZSlcbiAgICAgICAgdGhpcy5ydW5Mb29rdXAob3JpZ2luLCBvcHRzLCBjYilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGxldCBwb3J0XG4gICAgICBpZiAodHlwZW9mIGlwLnBvcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBvcnQgPSBgOiR7aXAucG9ydH1gXG4gICAgICB9IGVsc2UgaWYgKG9yaWdpbi5wb3J0ICE9PSAnJykge1xuICAgICAgICBwb3J0ID0gYDoke29yaWdpbi5wb3J0fWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcnQgPSAnJ1xuICAgICAgfVxuXG4gICAgICBjYihcbiAgICAgICAgbnVsbCxcbiAgICAgICAgYCR7b3JpZ2luLnByb3RvY29sfS8vJHtcbiAgICAgICAgICBpcC5mYW1pbHkgPT09IDYgPyBgWyR7aXAuYWRkcmVzc31dYCA6IGlwLmFkZHJlc3NcbiAgICAgICAgfSR7cG9ydH1gXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgI2RlZmF1bHRMb29rdXAgKG9yaWdpbiwgb3B0cywgY2IpIHtcbiAgICBsb29rdXAoXG4gICAgICBvcmlnaW4uaG9zdG5hbWUsXG4gICAgICB7XG4gICAgICAgIGFsbDogdHJ1ZSxcbiAgICAgICAgZmFtaWx5OiB0aGlzLmR1YWxTdGFjayA9PT0gZmFsc2UgPyB0aGlzLmFmZmluaXR5IDogMCxcbiAgICAgICAgb3JkZXI6ICdpcHY0Zmlyc3QnXG4gICAgICB9LFxuICAgICAgKGVyciwgYWRkcmVzc2VzKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gY2IoZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBNYXAoKVxuXG4gICAgICAgIGZvciAoY29uc3QgYWRkciBvZiBhZGRyZXNzZXMpIHtcbiAgICAgICAgICAvLyBPbiBsaW51eCB3ZSBmb3VuZCBkdXBsaWNhdGVzLCB3ZSBhdHRlbXB0IHRvIHJlbW92ZSB0aGVtIHdpdGhcbiAgICAgICAgICAvLyB0aGUgbGF0ZXN0IHJlY29yZFxuICAgICAgICAgIHJlc3VsdHMuc2V0KGAke2FkZHIuYWRkcmVzc306JHthZGRyLmZhbWlseX1gLCBhZGRyKVxuICAgICAgICB9XG5cbiAgICAgICAgY2IobnVsbCwgcmVzdWx0cy52YWx1ZXMoKSlcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICAjZGVmYXVsdFBpY2sgKG9yaWdpbiwgaG9zdG5hbWVSZWNvcmRzLCBhZmZpbml0eSkge1xuICAgIGxldCBpcCA9IG51bGxcbiAgICBjb25zdCB7IHJlY29yZHMsIG9mZnNldCB9ID0gaG9zdG5hbWVSZWNvcmRzXG5cbiAgICBsZXQgZmFtaWx5XG4gICAgaWYgKHRoaXMuZHVhbFN0YWNrKSB7XG4gICAgICBpZiAoYWZmaW5pdHkgPT0gbnVsbCkge1xuICAgICAgICAvLyBCYWxhbmNlIGJldHdlZW4gaXAgZmFtaWxpZXNcbiAgICAgICAgaWYgKG9mZnNldCA9PSBudWxsIHx8IG9mZnNldCA9PT0gbWF4SW50KSB7XG4gICAgICAgICAgaG9zdG5hbWVSZWNvcmRzLm9mZnNldCA9IDBcbiAgICAgICAgICBhZmZpbml0eSA9IDRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBob3N0bmFtZVJlY29yZHMub2Zmc2V0KytcbiAgICAgICAgICBhZmZpbml0eSA9IChob3N0bmFtZVJlY29yZHMub2Zmc2V0ICYgMSkgPT09IDEgPyA2IDogNFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmRzW2FmZmluaXR5XSAhPSBudWxsICYmIHJlY29yZHNbYWZmaW5pdHldLmlwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZhbWlseSA9IHJlY29yZHNbYWZmaW5pdHldXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmYW1pbHkgPSByZWNvcmRzW2FmZmluaXR5ID09PSA0ID8gNiA6IDRdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbWlseSA9IHJlY29yZHNbYWZmaW5pdHldXG4gICAgfVxuXG4gICAgLy8gSWYgbm8gSVBzIHdlIHJldHVybiBudWxsXG4gICAgaWYgKGZhbWlseSA9PSBudWxsIHx8IGZhbWlseS5pcHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaXBcbiAgICB9XG5cbiAgICBpZiAoZmFtaWx5Lm9mZnNldCA9PSBudWxsIHx8IGZhbWlseS5vZmZzZXQgPT09IG1heEludCkge1xuICAgICAgZmFtaWx5Lm9mZnNldCA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgZmFtaWx5Lm9mZnNldCsrXG4gICAgfVxuXG4gICAgY29uc3QgcG9zaXRpb24gPSBmYW1pbHkub2Zmc2V0ICUgZmFtaWx5Lmlwcy5sZW5ndGhcbiAgICBpcCA9IGZhbWlseS5pcHNbcG9zaXRpb25dID8/IG51bGxcblxuICAgIGlmIChpcCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gaXBcbiAgICB9XG5cbiAgICBpZiAoRGF0ZS5ub3coKSAtIGlwLnRpbWVzdGFtcCA+IGlwLnR0bCkgeyAvLyByZWNvcmQgVFRMIGlzIGFscmVhZHkgaW4gbXNcbiAgICAgIC8vIFdlIGRlbGV0ZSBleHBpcmVkIHJlY29yZHNcbiAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgdGhleSBoYXZlIGRpZmZlcmVudCBUVEwsIHNvIHdlIG1hbmFnZSB0aGVtIGluZGl2aWR1YWxseVxuICAgICAgZmFtaWx5Lmlwcy5zcGxpY2UocG9zaXRpb24sIDEpXG4gICAgICByZXR1cm4gdGhpcy5waWNrKG9yaWdpbiwgaG9zdG5hbWVSZWNvcmRzLCBhZmZpbml0eSlcbiAgICB9XG5cbiAgICByZXR1cm4gaXBcbiAgfVxuXG4gIHNldFJlY29yZHMgKG9yaWdpbiwgYWRkcmVzc2VzKSB7XG4gICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKVxuICAgIGNvbnN0IHJlY29yZHMgPSB7IHJlY29yZHM6IHsgNDogbnVsbCwgNjogbnVsbCB9IH1cbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiBhZGRyZXNzZXMpIHtcbiAgICAgIHJlY29yZC50aW1lc3RhbXAgPSB0aW1lc3RhbXBcbiAgICAgIGlmICh0eXBlb2YgcmVjb3JkLnR0bCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gVGhlIHJlY29yZCBUVEwgaXMgZXhwZWN0ZWQgdG8gYmUgaW4gbXNcbiAgICAgICAgcmVjb3JkLnR0bCA9IE1hdGgubWluKHJlY29yZC50dGwsIHRoaXMuI21heFRUTClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY29yZC50dGwgPSB0aGlzLiNtYXhUVExcbiAgICAgIH1cblxuICAgICAgY29uc3QgZmFtaWx5UmVjb3JkcyA9IHJlY29yZHMucmVjb3Jkc1tyZWNvcmQuZmFtaWx5XSA/PyB7IGlwczogW10gfVxuXG4gICAgICBmYW1pbHlSZWNvcmRzLmlwcy5wdXNoKHJlY29yZClcbiAgICAgIHJlY29yZHMucmVjb3Jkc1tyZWNvcmQuZmFtaWx5XSA9IGZhbWlseVJlY29yZHNcbiAgICB9XG5cbiAgICB0aGlzLiNyZWNvcmRzLnNldChvcmlnaW4uaG9zdG5hbWUsIHJlY29yZHMpXG4gIH1cblxuICBnZXRIYW5kbGVyIChtZXRhLCBvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBETlNEaXNwYXRjaEhhbmRsZXIodGhpcywgbWV0YSwgb3B0cylcbiAgfVxufVxuXG5jbGFzcyBETlNEaXNwYXRjaEhhbmRsZXIgZXh0ZW5kcyBEZWNvcmF0b3JIYW5kbGVyIHtcbiAgI3N0YXRlID0gbnVsbFxuICAjb3B0cyA9IG51bGxcbiAgI2Rpc3BhdGNoID0gbnVsbFxuICAjaGFuZGxlciA9IG51bGxcbiAgI29yaWdpbiA9IG51bGxcblxuICBjb25zdHJ1Y3RvciAoc3RhdGUsIHsgb3JpZ2luLCBoYW5kbGVyLCBkaXNwYXRjaCB9LCBvcHRzKSB7XG4gICAgc3VwZXIoaGFuZGxlcilcbiAgICB0aGlzLiNvcmlnaW4gPSBvcmlnaW5cbiAgICB0aGlzLiNoYW5kbGVyID0gaGFuZGxlclxuICAgIHRoaXMuI29wdHMgPSB7IC4uLm9wdHMgfVxuICAgIHRoaXMuI3N0YXRlID0gc3RhdGVcbiAgICB0aGlzLiNkaXNwYXRjaCA9IGRpc3BhdGNoXG4gIH1cblxuICBvbkVycm9yIChlcnIpIHtcbiAgICBzd2l0Y2ggKGVyci5jb2RlKSB7XG4gICAgICBjYXNlICdFVElNRURPVVQnOlxuICAgICAgY2FzZSAnRUNPTk5SRUZVU0VEJzoge1xuICAgICAgICBpZiAodGhpcy4jc3RhdGUuZHVhbFN0YWNrKSB7XG4gICAgICAgICAgLy8gV2UgZGVsZXRlIHRoZSByZWNvcmQgYW5kIHJldHJ5XG4gICAgICAgICAgdGhpcy4jc3RhdGUucnVuTG9va3VwKHRoaXMuI29yaWdpbiwgdGhpcy4jb3B0cywgKGVyciwgbmV3T3JpZ2luKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLiNoYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBkaXNwYXRjaE9wdHMgPSB7XG4gICAgICAgICAgICAgIC4uLnRoaXMuI29wdHMsXG4gICAgICAgICAgICAgIG9yaWdpbjogbmV3T3JpZ2luXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuI2Rpc3BhdGNoKGRpc3BhdGNoT3B0cywgdGhpcylcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgLy8gaWYgZHVhbC1zdGFjayBkaXNhYmxlZCwgd2UgZXJyb3Igb3V0XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiNoYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNhc2UgJ0VOT1RGT1VORCc6XG4gICAgICAgIHRoaXMuI3N0YXRlLmRlbGV0ZVJlY29yZCh0aGlzLiNvcmlnaW4pXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuI2hhbmRsZXIub25FcnJvcihlcnIpXG4gICAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJjZXB0b3JPcHRzID0+IHtcbiAgaWYgKFxuICAgIGludGVyY2VwdG9yT3B0cz8ubWF4VFRMICE9IG51bGwgJiZcbiAgICAodHlwZW9mIGludGVyY2VwdG9yT3B0cz8ubWF4VFRMICE9PSAnbnVtYmVyJyB8fCBpbnRlcmNlcHRvck9wdHM/Lm1heFRUTCA8IDApXG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBtYXhUVEwuIE11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKVxuICB9XG5cbiAgaWYgKFxuICAgIGludGVyY2VwdG9yT3B0cz8ubWF4SXRlbXMgIT0gbnVsbCAmJlxuICAgICh0eXBlb2YgaW50ZXJjZXB0b3JPcHRzPy5tYXhJdGVtcyAhPT0gJ251bWJlcicgfHxcbiAgICAgIGludGVyY2VwdG9yT3B0cz8ubWF4SXRlbXMgPCAxKVxuICApIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoXG4gICAgICAnSW52YWxpZCBtYXhJdGVtcy4gTXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlciBhbmQgZ3JlYXRlciB0aGFuIHplcm8nXG4gICAgKVxuICB9XG5cbiAgaWYgKFxuICAgIGludGVyY2VwdG9yT3B0cz8uYWZmaW5pdHkgIT0gbnVsbCAmJlxuICAgIGludGVyY2VwdG9yT3B0cz8uYWZmaW5pdHkgIT09IDQgJiZcbiAgICBpbnRlcmNlcHRvck9wdHM/LmFmZmluaXR5ICE9PSA2XG4gICkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignSW52YWxpZCBhZmZpbml0eS4gTXVzdCBiZSBlaXRoZXIgNCBvciA2JylcbiAgfVxuXG4gIGlmIChcbiAgICBpbnRlcmNlcHRvck9wdHM/LmR1YWxTdGFjayAhPSBudWxsICYmXG4gICAgdHlwZW9mIGludGVyY2VwdG9yT3B0cz8uZHVhbFN0YWNrICE9PSAnYm9vbGVhbidcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIGR1YWxTdGFjay4gTXVzdCBiZSBhIGJvb2xlYW4nKVxuICB9XG5cbiAgaWYgKFxuICAgIGludGVyY2VwdG9yT3B0cz8ubG9va3VwICE9IG51bGwgJiZcbiAgICB0eXBlb2YgaW50ZXJjZXB0b3JPcHRzPy5sb29rdXAgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIGxvb2t1cC4gTXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgfVxuXG4gIGlmIChcbiAgICBpbnRlcmNlcHRvck9wdHM/LnBpY2sgIT0gbnVsbCAmJlxuICAgIHR5cGVvZiBpbnRlcmNlcHRvck9wdHM/LnBpY2sgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdJbnZhbGlkIHBpY2suIE11c3QgYmUgYSBmdW5jdGlvbicpXG4gIH1cblxuICBjb25zdCBkdWFsU3RhY2sgPSBpbnRlcmNlcHRvck9wdHM/LmR1YWxTdGFjayA/PyB0cnVlXG4gIGxldCBhZmZpbml0eVxuICBpZiAoZHVhbFN0YWNrKSB7XG4gICAgYWZmaW5pdHkgPSBpbnRlcmNlcHRvck9wdHM/LmFmZmluaXR5ID8/IG51bGxcbiAgfSBlbHNlIHtcbiAgICBhZmZpbml0eSA9IGludGVyY2VwdG9yT3B0cz8uYWZmaW5pdHkgPz8gNFxuICB9XG5cbiAgY29uc3Qgb3B0cyA9IHtcbiAgICBtYXhUVEw6IGludGVyY2VwdG9yT3B0cz8ubWF4VFRMID8/IDEwZTMsIC8vIEV4cHJlc3NlZCBpbiBtc1xuICAgIGxvb2t1cDogaW50ZXJjZXB0b3JPcHRzPy5sb29rdXAgPz8gbnVsbCxcbiAgICBwaWNrOiBpbnRlcmNlcHRvck9wdHM/LnBpY2sgPz8gbnVsbCxcbiAgICBkdWFsU3RhY2ssXG4gICAgYWZmaW5pdHksXG4gICAgbWF4SXRlbXM6IGludGVyY2VwdG9yT3B0cz8ubWF4SXRlbXMgPz8gSW5maW5pdHlcbiAgfVxuXG4gIGNvbnN0IGluc3RhbmNlID0gbmV3IEROU0luc3RhbmNlKG9wdHMpXG5cbiAgcmV0dXJuIGRpc3BhdGNoID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZG5zSW50ZXJjZXB0b3IgKG9yaWdEaXNwYXRjaE9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IG9yaWdpbiA9XG4gICAgICAgIG9yaWdEaXNwYXRjaE9wdHMub3JpZ2luLmNvbnN0cnVjdG9yID09PSBVUkxcbiAgICAgICAgICA/IG9yaWdEaXNwYXRjaE9wdHMub3JpZ2luXG4gICAgICAgICAgOiBuZXcgVVJMKG9yaWdEaXNwYXRjaE9wdHMub3JpZ2luKVxuXG4gICAgICBpZiAoaXNJUChvcmlnaW4uaG9zdG5hbWUpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvcmlnRGlzcGF0Y2hPcHRzLCBoYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5ydW5Mb29rdXAob3JpZ2luLCBvcmlnRGlzcGF0Y2hPcHRzLCAoZXJyLCBuZXdPcmlnaW4pID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGVyLm9uRXJyb3IoZXJyKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRpc3BhdGNoT3B0cyA9IG51bGxcbiAgICAgICAgZGlzcGF0Y2hPcHRzID0ge1xuICAgICAgICAgIC4uLm9yaWdEaXNwYXRjaE9wdHMsXG4gICAgICAgICAgc2VydmVybmFtZTogb3JpZ2luLmhvc3RuYW1lLCAvLyBGb3IgU05JIG9uIFRMU1xuICAgICAgICAgIG9yaWdpbjogbmV3T3JpZ2luLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIGhvc3Q6IG9yaWdpbi5ob3N0bmFtZSxcbiAgICAgICAgICAgIC4uLm9yaWdEaXNwYXRjaE9wdHMuaGVhZGVyc1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgIGRpc3BhdGNoT3B0cyxcbiAgICAgICAgICBpbnN0YW5jZS5nZXRIYW5kbGVyKHsgb3JpZ2luLCBkaXNwYXRjaCwgaGFuZGxlciB9LCBvcmlnRGlzcGF0Y2hPcHRzKVxuICAgICAgICApXG4gICAgICB9KVxuXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/dns.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/dump.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/dump.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst DecoratorHandler = __webpack_require__(/*! ../handler/decorator-handler */ \"(rsc)/./node_modules/undici/lib/handler/decorator-handler.js\")\n\nclass DumpHandler extends DecoratorHandler {\n  #maxSize = 1024 * 1024\n  #abort = null\n  #dumped = false\n  #aborted = false\n  #size = 0\n  #reason = null\n  #handler = null\n\n  constructor ({ maxSize }, handler) {\n    super(handler)\n\n    if (maxSize != null && (!Number.isFinite(maxSize) || maxSize < 1)) {\n      throw new InvalidArgumentError('maxSize must be a number greater than 0')\n    }\n\n    this.#maxSize = maxSize ?? this.#maxSize\n    this.#handler = handler\n  }\n\n  onConnect (abort) {\n    this.#abort = abort\n\n    this.#handler.onConnect(this.#customAbort.bind(this))\n  }\n\n  #customAbort (reason) {\n    this.#aborted = true\n    this.#reason = reason\n  }\n\n  // TODO: will require adjustment after new hooks are out\n  onHeaders (statusCode, rawHeaders, resume, statusMessage) {\n    const headers = util.parseHeaders(rawHeaders)\n    const contentLength = headers['content-length']\n\n    if (contentLength != null && contentLength > this.#maxSize) {\n      throw new RequestAbortedError(\n        `Response size (${contentLength}) larger than maxSize (${\n          this.#maxSize\n        })`\n      )\n    }\n\n    if (this.#aborted) {\n      return true\n    }\n\n    return this.#handler.onHeaders(\n      statusCode,\n      rawHeaders,\n      resume,\n      statusMessage\n    )\n  }\n\n  onError (err) {\n    if (this.#dumped) {\n      return\n    }\n\n    err = this.#reason ?? err\n\n    this.#handler.onError(err)\n  }\n\n  onData (chunk) {\n    this.#size = this.#size + chunk.length\n\n    if (this.#size >= this.#maxSize) {\n      this.#dumped = true\n\n      if (this.#aborted) {\n        this.#handler.onError(this.#reason)\n      } else {\n        this.#handler.onComplete([])\n      }\n    }\n\n    return true\n  }\n\n  onComplete (trailers) {\n    if (this.#dumped) {\n      return\n    }\n\n    if (this.#aborted) {\n      this.#handler.onError(this.reason)\n      return\n    }\n\n    this.#handler.onComplete(trailers)\n  }\n}\n\nfunction createDumpInterceptor (\n  { maxSize: defaultMaxSize } = {\n    maxSize: 1024 * 1024\n  }\n) {\n  return dispatch => {\n    return function Intercept (opts, handler) {\n      const { dumpMaxSize = defaultMaxSize } =\n        opts\n\n      const dumpHandler = new DumpHandler(\n        { maxSize: dumpMaxSize },\n        handler\n      )\n\n      return dispatch(opts, dumpHandler)\n    }\n  }\n}\n\nmodule.exports = createDumpInterceptor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9kdW1wLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxrRUFBYztBQUNuQyxRQUFRLDRDQUE0QyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCO0FBQzlFLHlCQUF5QixtQkFBTyxDQUFDLGtHQUE4Qjs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDBCQUEwQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7O0FBRUE7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXGludGVyY2VwdG9yXFxkdW1wLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vY29yZS91dGlsJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IsIFJlcXVlc3RBYm9ydGVkRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IERlY29yYXRvckhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL2RlY29yYXRvci1oYW5kbGVyJylcblxuY2xhc3MgRHVtcEhhbmRsZXIgZXh0ZW5kcyBEZWNvcmF0b3JIYW5kbGVyIHtcbiAgI21heFNpemUgPSAxMDI0ICogMTAyNFxuICAjYWJvcnQgPSBudWxsXG4gICNkdW1wZWQgPSBmYWxzZVxuICAjYWJvcnRlZCA9IGZhbHNlXG4gICNzaXplID0gMFxuICAjcmVhc29uID0gbnVsbFxuICAjaGFuZGxlciA9IG51bGxcblxuICBjb25zdHJ1Y3RvciAoeyBtYXhTaXplIH0sIGhhbmRsZXIpIHtcbiAgICBzdXBlcihoYW5kbGVyKVxuXG4gICAgaWYgKG1heFNpemUgIT0gbnVsbCAmJiAoIU51bWJlci5pc0Zpbml0ZShtYXhTaXplKSB8fCBtYXhTaXplIDwgMSkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignbWF4U2l6ZSBtdXN0IGJlIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwJylcbiAgICB9XG5cbiAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZSA/PyB0aGlzLiNtYXhTaXplXG4gICAgdGhpcy4jaGFuZGxlciA9IGhhbmRsZXJcbiAgfVxuXG4gIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICB0aGlzLiNhYm9ydCA9IGFib3J0XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uQ29ubmVjdCh0aGlzLiNjdXN0b21BYm9ydC5iaW5kKHRoaXMpKVxuICB9XG5cbiAgI2N1c3RvbUFib3J0IChyZWFzb24pIHtcbiAgICB0aGlzLiNhYm9ydGVkID0gdHJ1ZVxuICAgIHRoaXMuI3JlYXNvbiA9IHJlYXNvblxuICB9XG5cbiAgLy8gVE9ETzogd2lsbCByZXF1aXJlIGFkanVzdG1lbnQgYWZ0ZXIgbmV3IGhvb2tzIGFyZSBvdXRcbiAgb25IZWFkZXJzIChzdGF0dXNDb2RlLCByYXdIZWFkZXJzLCByZXN1bWUsIHN0YXR1c01lc3NhZ2UpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdXRpbC5wYXJzZUhlYWRlcnMocmF3SGVhZGVycylcbiAgICBjb25zdCBjb250ZW50TGVuZ3RoID0gaGVhZGVyc1snY29udGVudC1sZW5ndGgnXVxuXG4gICAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBjb250ZW50TGVuZ3RoID4gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IFJlcXVlc3RBYm9ydGVkRXJyb3IoXG4gICAgICAgIGBSZXNwb25zZSBzaXplICgke2NvbnRlbnRMZW5ndGh9KSBsYXJnZXIgdGhhbiBtYXhTaXplICgke1xuICAgICAgICAgIHRoaXMuI21heFNpemVcbiAgICAgICAgfSlgXG4gICAgICApXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI2Fib3J0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuI2hhbmRsZXIub25IZWFkZXJzKFxuICAgICAgc3RhdHVzQ29kZSxcbiAgICAgIHJhd0hlYWRlcnMsXG4gICAgICByZXN1bWUsXG4gICAgICBzdGF0dXNNZXNzYWdlXG4gICAgKVxuICB9XG5cbiAgb25FcnJvciAoZXJyKSB7XG4gICAgaWYgKHRoaXMuI2R1bXBlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZXJyID0gdGhpcy4jcmVhc29uID8/IGVyclxuXG4gICAgdGhpcy4jaGFuZGxlci5vbkVycm9yKGVycilcbiAgfVxuXG4gIG9uRGF0YSAoY2h1bmspIHtcbiAgICB0aGlzLiNzaXplID0gdGhpcy4jc2l6ZSArIGNodW5rLmxlbmd0aFxuXG4gICAgaWYgKHRoaXMuI3NpemUgPj0gdGhpcy4jbWF4U2l6ZSkge1xuICAgICAgdGhpcy4jZHVtcGVkID0gdHJ1ZVxuXG4gICAgICBpZiAodGhpcy4jYWJvcnRlZCkge1xuICAgICAgICB0aGlzLiNoYW5kbGVyLm9uRXJyb3IodGhpcy4jcmVhc29uKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4jaGFuZGxlci5vbkNvbXBsZXRlKFtdKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBvbkNvbXBsZXRlICh0cmFpbGVycykge1xuICAgIGlmICh0aGlzLiNkdW1wZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLiNhYm9ydGVkKSB7XG4gICAgICB0aGlzLiNoYW5kbGVyLm9uRXJyb3IodGhpcy5yZWFzb24pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLiNoYW5kbGVyLm9uQ29tcGxldGUodHJhaWxlcnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRHVtcEludGVyY2VwdG9yIChcbiAgeyBtYXhTaXplOiBkZWZhdWx0TWF4U2l6ZSB9ID0ge1xuICAgIG1heFNpemU6IDEwMjQgKiAxMDI0XG4gIH1cbikge1xuICByZXR1cm4gZGlzcGF0Y2ggPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBJbnRlcmNlcHQgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgZHVtcE1heFNpemUgPSBkZWZhdWx0TWF4U2l6ZSB9ID1cbiAgICAgICAgb3B0c1xuXG4gICAgICBjb25zdCBkdW1wSGFuZGxlciA9IG5ldyBEdW1wSGFuZGxlcihcbiAgICAgICAgeyBtYXhTaXplOiBkdW1wTWF4U2l6ZSB9LFxuICAgICAgICBoYW5kbGVyXG4gICAgICApXG5cbiAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBkdW1wSGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEdW1wSW50ZXJjZXB0b3JcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/dump.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/redirect-interceptor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect-interceptor.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ \"(rsc)/./node_modules/undici/lib/handler/redirect-handler.js\")\n\nfunction createRedirectInterceptor ({ maxRedirections: defaultMaxRedirections }) {\n  return (dispatch) => {\n    return function Intercept (opts, handler) {\n      const { maxRedirections = defaultMaxRedirections } = opts\n\n      if (!maxRedirections) {\n        return dispatch(opts, handler)\n      }\n\n      const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler)\n      opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.\n      return dispatch(opts, redirectHandler)\n    }\n  }\n}\n\nmodule.exports = createRedirectInterceptor\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdC1pbnRlcmNlcHRvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWix3QkFBd0IsbUJBQU8sQ0FBQyxnR0FBNkI7O0FBRTdELHNDQUFzQyx5Q0FBeUM7QUFDL0U7QUFDQTtBQUNBLGNBQWMsMkNBQTJDOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxpbnRlcmNlcHRvclxccmVkaXJlY3QtaW50ZXJjZXB0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IFJlZGlyZWN0SGFuZGxlciA9IHJlcXVpcmUoJy4uL2hhbmRsZXIvcmVkaXJlY3QtaGFuZGxlcicpXG5cbmZ1bmN0aW9uIGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3IgKHsgbWF4UmVkaXJlY3Rpb25zOiBkZWZhdWx0TWF4UmVkaXJlY3Rpb25zIH0pIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiBJbnRlcmNlcHQgKG9wdHMsIGhhbmRsZXIpIHtcbiAgICAgIGNvbnN0IHsgbWF4UmVkaXJlY3Rpb25zID0gZGVmYXVsdE1heFJlZGlyZWN0aW9ucyB9ID0gb3B0c1xuXG4gICAgICBpZiAoIW1heFJlZGlyZWN0aW9ucykge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVkaXJlY3RIYW5kbGVyID0gbmV3IFJlZGlyZWN0SGFuZGxlcihkaXNwYXRjaCwgbWF4UmVkaXJlY3Rpb25zLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgb3B0cyA9IHsgLi4ub3B0cywgbWF4UmVkaXJlY3Rpb25zOiAwIH0gLy8gU3RvcCBzdWIgZGlzcGF0Y2hlciBmcm9tIGFsc28gcmVkaXJlY3RpbmcuXG4gICAgICByZXR1cm4gZGlzcGF0Y2gob3B0cywgcmVkaXJlY3RIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlZGlyZWN0SW50ZXJjZXB0b3JcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/redirect-interceptor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/redirect.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/redirect.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst RedirectHandler = __webpack_require__(/*! ../handler/redirect-handler */ \"(rsc)/./node_modules/undici/lib/handler/redirect-handler.js\")\n\nmodule.exports = opts => {\n  const globalMaxRedirections = opts?.maxRedirections\n  return dispatch => {\n    return function redirectInterceptor (opts, handler) {\n      const { maxRedirections = globalMaxRedirections, ...baseOpts } = opts\n\n      if (!maxRedirections) {\n        return dispatch(opts, handler)\n      }\n\n      const redirectHandler = new RedirectHandler(\n        dispatch,\n        maxRedirections,\n        opts,\n        handler\n      )\n\n      return dispatch(baseOpts, redirectHandler)\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZWRpcmVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLHdCQUF3QixtQkFBTyxDQUFDLGdHQUE2Qjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVEQUF1RDs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxpbnRlcmNlcHRvclxccmVkaXJlY3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBSZWRpcmVjdEhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3JlZGlyZWN0LWhhbmRsZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9wdHMgPT4ge1xuICBjb25zdCBnbG9iYWxNYXhSZWRpcmVjdGlvbnMgPSBvcHRzPy5tYXhSZWRpcmVjdGlvbnNcbiAgcmV0dXJuIGRpc3BhdGNoID0+IHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVkaXJlY3RJbnRlcmNlcHRvciAob3B0cywgaGFuZGxlcikge1xuICAgICAgY29uc3QgeyBtYXhSZWRpcmVjdGlvbnMgPSBnbG9iYWxNYXhSZWRpcmVjdGlvbnMsIC4uLmJhc2VPcHRzIH0gPSBvcHRzXG5cbiAgICAgIGlmICghbWF4UmVkaXJlY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBkaXNwYXRjaChvcHRzLCBoYW5kbGVyKVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZWRpcmVjdEhhbmRsZXIgPSBuZXcgUmVkaXJlY3RIYW5kbGVyKFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgbWF4UmVkaXJlY3Rpb25zLFxuICAgICAgICBvcHRzLFxuICAgICAgICBoYW5kbGVyXG4gICAgICApXG5cbiAgICAgIHJldHVybiBkaXNwYXRjaChiYXNlT3B0cywgcmVkaXJlY3RIYW5kbGVyKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/redirect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/interceptor/retry.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/interceptor/retry.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst RetryHandler = __webpack_require__(/*! ../handler/retry-handler */ \"(rsc)/./node_modules/undici/lib/handler/retry-handler.js\")\n\nmodule.exports = globalOpts => {\n  return dispatch => {\n    return function retryInterceptor (opts, handler) {\n      return dispatch(\n        opts,\n        new RetryHandler(\n          { ...opts, retryOptions: { ...globalOpts, ...opts.retryOptions } },\n          {\n            handler,\n            dispatch\n          }\n        )\n      )\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9pbnRlcmNlcHRvci9yZXRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLHFCQUFxQixtQkFBTyxDQUFDLDBGQUEwQjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUIsdUNBQXVDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxpbnRlcmNlcHRvclxccmV0cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBSZXRyeUhhbmRsZXIgPSByZXF1aXJlKCcuLi9oYW5kbGVyL3JldHJ5LWhhbmRsZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbE9wdHMgPT4ge1xuICByZXR1cm4gZGlzcGF0Y2ggPT4ge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXRyeUludGVyY2VwdG9yIChvcHRzLCBoYW5kbGVyKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2goXG4gICAgICAgIG9wdHMsXG4gICAgICAgIG5ldyBSZXRyeUhhbmRsZXIoXG4gICAgICAgICAgeyAuLi5vcHRzLCByZXRyeU9wdGlvbnM6IHsgLi4uZ2xvYmFsT3B0cywgLi4ub3B0cy5yZXRyeU9wdGlvbnMgfSB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBkaXNwYXRjaFxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/interceptor/retry.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/constants.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/constants.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/./node_modules/undici/lib/llhttp/utils.js\");\n// C headers\nvar ERROR;\n(function (ERROR) {\n    ERROR[ERROR[\"OK\"] = 0] = \"OK\";\n    ERROR[ERROR[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ERROR[ERROR[\"STRICT\"] = 2] = \"STRICT\";\n    ERROR[ERROR[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n    ERROR[ERROR[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n    ERROR[ERROR[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n    ERROR[ERROR[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n    ERROR[ERROR[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n    ERROR[ERROR[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n    ERROR[ERROR[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n    ERROR[ERROR[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n    ERROR[ERROR[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n    ERROR[ERROR[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n    ERROR[ERROR[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n    ERROR[ERROR[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n    ERROR[ERROR[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n    ERROR[ERROR[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n    ERROR[ERROR[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n    ERROR[ERROR[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n    ERROR[ERROR[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n    ERROR[ERROR[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n    ERROR[ERROR[\"PAUSED\"] = 21] = \"PAUSED\";\n    ERROR[ERROR[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n    ERROR[ERROR[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n    ERROR[ERROR[\"USER\"] = 24] = \"USER\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\nvar TYPE;\n(function (TYPE) {\n    TYPE[TYPE[\"BOTH\"] = 0] = \"BOTH\";\n    TYPE[TYPE[\"REQUEST\"] = 1] = \"REQUEST\";\n    TYPE[TYPE[\"RESPONSE\"] = 2] = \"RESPONSE\";\n})(TYPE = exports.TYPE || (exports.TYPE = {}));\nvar FLAGS;\n(function (FLAGS) {\n    FLAGS[FLAGS[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n    FLAGS[FLAGS[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n    FLAGS[FLAGS[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n    FLAGS[FLAGS[\"CHUNKED\"] = 8] = \"CHUNKED\";\n    FLAGS[FLAGS[\"UPGRADE\"] = 16] = \"UPGRADE\";\n    FLAGS[FLAGS[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n    FLAGS[FLAGS[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n    FLAGS[FLAGS[\"TRAILING\"] = 128] = \"TRAILING\";\n    // 1 << 8 is unused\n    FLAGS[FLAGS[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nvar LENIENT_FLAGS;\n(function (LENIENT_FLAGS) {\n    LENIENT_FLAGS[LENIENT_FLAGS[\"HEADERS\"] = 1] = \"HEADERS\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\nvar METHODS;\n(function (METHODS) {\n    METHODS[METHODS[\"DELETE\"] = 0] = \"DELETE\";\n    METHODS[METHODS[\"GET\"] = 1] = \"GET\";\n    METHODS[METHODS[\"HEAD\"] = 2] = \"HEAD\";\n    METHODS[METHODS[\"POST\"] = 3] = \"POST\";\n    METHODS[METHODS[\"PUT\"] = 4] = \"PUT\";\n    /* pathological */\n    METHODS[METHODS[\"CONNECT\"] = 5] = \"CONNECT\";\n    METHODS[METHODS[\"OPTIONS\"] = 6] = \"OPTIONS\";\n    METHODS[METHODS[\"TRACE\"] = 7] = \"TRACE\";\n    /* WebDAV */\n    METHODS[METHODS[\"COPY\"] = 8] = \"COPY\";\n    METHODS[METHODS[\"LOCK\"] = 9] = \"LOCK\";\n    METHODS[METHODS[\"MKCOL\"] = 10] = \"MKCOL\";\n    METHODS[METHODS[\"MOVE\"] = 11] = \"MOVE\";\n    METHODS[METHODS[\"PROPFIND\"] = 12] = \"PROPFIND\";\n    METHODS[METHODS[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n    METHODS[METHODS[\"SEARCH\"] = 14] = \"SEARCH\";\n    METHODS[METHODS[\"UNLOCK\"] = 15] = \"UNLOCK\";\n    METHODS[METHODS[\"BIND\"] = 16] = \"BIND\";\n    METHODS[METHODS[\"REBIND\"] = 17] = \"REBIND\";\n    METHODS[METHODS[\"UNBIND\"] = 18] = \"UNBIND\";\n    METHODS[METHODS[\"ACL\"] = 19] = \"ACL\";\n    /* subversion */\n    METHODS[METHODS[\"REPORT\"] = 20] = \"REPORT\";\n    METHODS[METHODS[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n    METHODS[METHODS[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n    METHODS[METHODS[\"MERGE\"] = 23] = \"MERGE\";\n    /* upnp */\n    METHODS[METHODS[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n    METHODS[METHODS[\"NOTIFY\"] = 25] = \"NOTIFY\";\n    METHODS[METHODS[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n    METHODS[METHODS[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n    /* RFC-5789 */\n    METHODS[METHODS[\"PATCH\"] = 28] = \"PATCH\";\n    METHODS[METHODS[\"PURGE\"] = 29] = \"PURGE\";\n    /* CalDAV */\n    METHODS[METHODS[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n    /* RFC-2068, section 19.6.1.2 */\n    METHODS[METHODS[\"LINK\"] = 31] = \"LINK\";\n    METHODS[METHODS[\"UNLINK\"] = 32] = \"UNLINK\";\n    /* icecast */\n    METHODS[METHODS[\"SOURCE\"] = 33] = \"SOURCE\";\n    /* RFC-7540, section 11.6 */\n    METHODS[METHODS[\"PRI\"] = 34] = \"PRI\";\n    /* RFC-2326 RTSP */\n    METHODS[METHODS[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n    METHODS[METHODS[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n    METHODS[METHODS[\"SETUP\"] = 37] = \"SETUP\";\n    METHODS[METHODS[\"PLAY\"] = 38] = \"PLAY\";\n    METHODS[METHODS[\"PAUSE\"] = 39] = \"PAUSE\";\n    METHODS[METHODS[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n    METHODS[METHODS[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n    METHODS[METHODS[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n    METHODS[METHODS[\"REDIRECT\"] = 43] = \"REDIRECT\";\n    METHODS[METHODS[\"RECORD\"] = 44] = \"RECORD\";\n    /* RAOP */\n    METHODS[METHODS[\"FLUSH\"] = 45] = \"FLUSH\";\n})(METHODS = exports.METHODS || (exports.METHODS = {}));\nexports.METHODS_HTTP = [\n    METHODS.DELETE,\n    METHODS.GET,\n    METHODS.HEAD,\n    METHODS.POST,\n    METHODS.PUT,\n    METHODS.CONNECT,\n    METHODS.OPTIONS,\n    METHODS.TRACE,\n    METHODS.COPY,\n    METHODS.LOCK,\n    METHODS.MKCOL,\n    METHODS.MOVE,\n    METHODS.PROPFIND,\n    METHODS.PROPPATCH,\n    METHODS.SEARCH,\n    METHODS.UNLOCK,\n    METHODS.BIND,\n    METHODS.REBIND,\n    METHODS.UNBIND,\n    METHODS.ACL,\n    METHODS.REPORT,\n    METHODS.MKACTIVITY,\n    METHODS.CHECKOUT,\n    METHODS.MERGE,\n    METHODS['M-SEARCH'],\n    METHODS.NOTIFY,\n    METHODS.SUBSCRIBE,\n    METHODS.UNSUBSCRIBE,\n    METHODS.PATCH,\n    METHODS.PURGE,\n    METHODS.MKCALENDAR,\n    METHODS.LINK,\n    METHODS.UNLINK,\n    METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    METHODS.SOURCE,\n];\nexports.METHODS_ICE = [\n    METHODS.SOURCE,\n];\nexports.METHODS_RTSP = [\n    METHODS.OPTIONS,\n    METHODS.DESCRIBE,\n    METHODS.ANNOUNCE,\n    METHODS.SETUP,\n    METHODS.PLAY,\n    METHODS.PAUSE,\n    METHODS.TEARDOWN,\n    METHODS.GET_PARAMETER,\n    METHODS.SET_PARAMETER,\n    METHODS.REDIRECT,\n    METHODS.RECORD,\n    METHODS.FLUSH,\n    // For AirPlay\n    METHODS.GET,\n    METHODS.POST,\n];\nexports.METHOD_MAP = utils_1.enumToMap(METHODS);\nexports.H_METHOD_MAP = {};\nObject.keys(exports.METHOD_MAP).forEach((key) => {\n    if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n    }\n});\nvar FINISH;\n(function (FINISH) {\n    FINISH[FINISH[\"SAFE\"] = 0] = \"SAFE\";\n    FINISH[FINISH[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n    FINISH[FINISH[\"UNSAFE\"] = 2] = \"UNSAFE\";\n})(FINISH = exports.FINISH || (exports.FINISH = {}));\nexports.ALPHA = [];\nfor (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n};\nexports.HEX_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,\n    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,\n};\nexports.NUM = [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = ['-', '_', '.', '!', '~', '*', '\\'', '(', ')'];\nexports.USERINFO_CHARS = exports.ALPHANUM\n    .concat(exports.MARK)\n    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);\n// TODO(indutny): use RFC\nexports.STRICT_URL_CHAR = [\n    '!', '\"', '$', '%', '&', '\\'',\n    '(', ')', '*', '+', ',', '-', '.', '/',\n    ':', ';', '<', '=', '>',\n    '@', '[', '\\\\', ']', '^', '_',\n    '`',\n    '{', '|', '}', '~',\n].concat(exports.ALPHANUM);\nexports.URL_CHAR = exports.STRICT_URL_CHAR\n    .concat(['\\t', '\\f']);\n// All characters with 0x80 bit set to 1\nfor (let i = 0x80; i <= 0xff; i++) {\n    exports.URL_CHAR.push(i);\n}\nexports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */\nexports.STRICT_TOKEN = [\n    '!', '#', '$', '%', '&', '\\'',\n    '*', '+', '-', '.',\n    '^', '_', '`',\n    '|', '~',\n].concat(exports.ALPHANUM);\nexports.TOKEN = exports.STRICT_TOKEN.concat([' ']);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */\nexports.HEADER_CHARS = ['\\t'];\nfor (let i = 32; i <= 255; i++) {\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nvar HEADER_STATE;\n(function (HEADER_STATE) {\n    HEADER_STATE[HEADER_STATE[\"GENERAL\"] = 0] = \"GENERAL\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION\"] = 1] = \"CONNECTION\";\n    HEADER_STATE[HEADER_STATE[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n    HEADER_STATE[HEADER_STATE[\"UPGRADE\"] = 4] = \"UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\nexports.SPECIAL_HEADERS = {\n    'connection': HEADER_STATE.CONNECTION,\n    'content-length': HEADER_STATE.CONTENT_LENGTH,\n    'proxy-connection': HEADER_STATE.CONNECTION,\n    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,\n    'upgrade': HEADER_STATE.UPGRADE,\n};\n//# sourceMappingURL=constants.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QixHQUFHLG9CQUFvQixHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsOEJBQThCLEdBQUcsb0JBQW9CLEdBQUcsYUFBYSxHQUFHLG9CQUFvQixHQUFHLFdBQVcsR0FBRyxnQkFBZ0IsR0FBRyx1QkFBdUIsR0FBRyxzQkFBc0IsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsV0FBVyxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLGNBQWMsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxvQkFBb0IsR0FBRyxtQkFBbUIsR0FBRyxvQkFBb0IsR0FBRyxlQUFlLEdBQUcscUJBQXFCLEdBQUcsYUFBYSxHQUFHLFlBQVksR0FBRyxhQUFhO0FBQy9qQixnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCLGFBQWEsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEIsWUFBWSxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCLGFBQWEsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEMscUJBQXFCLEtBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDLGVBQWUsS0FBSztBQUNyRCxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCLGNBQWMsS0FBSztBQUNsRCxhQUFhO0FBQ2IsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLHNCQUFzQjtBQUN0QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNLFVBQVU7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsMEJBQTBCLE1BQU07QUFDaEM7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDLG9CQUFvQixLQUFLO0FBQ3BFLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxsbGh0dHBcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU1BFQ0lBTF9IRUFERVJTID0gZXhwb3J0cy5IRUFERVJfU1RBVEUgPSBleHBvcnRzLk1JTk9SID0gZXhwb3J0cy5NQUpPUiA9IGV4cG9ydHMuQ09OTkVDVElPTl9UT0tFTl9DSEFSUyA9IGV4cG9ydHMuSEVBREVSX0NIQVJTID0gZXhwb3J0cy5UT0tFTiA9IGV4cG9ydHMuU1RSSUNUX1RPS0VOID0gZXhwb3J0cy5IRVggPSBleHBvcnRzLlVSTF9DSEFSID0gZXhwb3J0cy5TVFJJQ1RfVVJMX0NIQVIgPSBleHBvcnRzLlVTRVJJTkZPX0NIQVJTID0gZXhwb3J0cy5NQVJLID0gZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuTlVNID0gZXhwb3J0cy5IRVhfTUFQID0gZXhwb3J0cy5OVU1fTUFQID0gZXhwb3J0cy5BTFBIQSA9IGV4cG9ydHMuRklOSVNIID0gZXhwb3J0cy5IX01FVEhPRF9NQVAgPSBleHBvcnRzLk1FVEhPRF9NQVAgPSBleHBvcnRzLk1FVEhPRFNfUlRTUCA9IGV4cG9ydHMuTUVUSE9EU19JQ0UgPSBleHBvcnRzLk1FVEhPRFNfSFRUUCA9IGV4cG9ydHMuTUVUSE9EUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuRkxBR1MgPSBleHBvcnRzLlRZUEUgPSBleHBvcnRzLkVSUk9SID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLy8gQyBoZWFkZXJzXG52YXIgRVJST1I7XG4oZnVuY3Rpb24gKEVSUk9SKSB7XG4gICAgRVJST1JbRVJST1JbXCJPS1wiXSA9IDBdID0gXCJPS1wiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5URVJOQUxcIl0gPSAxXSA9IFwiSU5URVJOQUxcIjtcbiAgICBFUlJPUltFUlJPUltcIlNUUklDVFwiXSA9IDJdID0gXCJTVFJJQ1RcIjtcbiAgICBFUlJPUltFUlJPUltcIkxGX0VYUEVDVEVEXCJdID0gM10gPSBcIkxGX0VYUEVDVEVEXCI7XG4gICAgRVJST1JbRVJST1JbXCJVTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIXCJdID0gNF0gPSBcIlVORVhQRUNURURfQ09OVEVOVF9MRU5HVEhcIjtcbiAgICBFUlJPUltFUlJPUltcIkNMT1NFRF9DT05ORUNUSU9OXCJdID0gNV0gPSBcIkNMT1NFRF9DT05ORUNUSU9OXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX01FVEhPRFwiXSA9IDZdID0gXCJJTlZBTElEX01FVEhPRFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9VUkxcIl0gPSA3XSA9IFwiSU5WQUxJRF9VUkxcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfQ09OU1RBTlRcIl0gPSA4XSA9IFwiSU5WQUxJRF9DT05TVEFOVFwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9WRVJTSU9OXCJdID0gOV0gPSBcIklOVkFMSURfVkVSU0lPTlwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9IRUFERVJfVE9LRU5cIl0gPSAxMF0gPSBcIklOVkFMSURfSEVBREVSX1RPS0VOXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0NPTlRFTlRfTEVOR1RIXCJdID0gMTFdID0gXCJJTlZBTElEX0NPTlRFTlRfTEVOR1RIXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0NIVU5LX1NJWkVcIl0gPSAxMl0gPSBcIklOVkFMSURfQ0hVTktfU0laRVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiSU5WQUxJRF9TVEFUVVNcIl0gPSAxM10gPSBcIklOVkFMSURfU1RBVFVTXCI7XG4gICAgRVJST1JbRVJST1JbXCJJTlZBTElEX0VPRl9TVEFURVwiXSA9IDE0XSA9IFwiSU5WQUxJRF9FT0ZfU1RBVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIklOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkdcIl0gPSAxNV0gPSBcIklOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkdcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX01FU1NBR0VfQkVHSU5cIl0gPSAxNl0gPSBcIkNCX01FU1NBR0VfQkVHSU5cIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0hFQURFUlNfQ09NUExFVEVcIl0gPSAxN10gPSBcIkNCX0hFQURFUlNfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX01FU1NBR0VfQ09NUExFVEVcIl0gPSAxOF0gPSBcIkNCX01FU1NBR0VfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIkNCX0NIVU5LX0hFQURFUlwiXSA9IDE5XSA9IFwiQ0JfQ0hVTktfSEVBREVSXCI7XG4gICAgRVJST1JbRVJST1JbXCJDQl9DSFVOS19DT01QTEVURVwiXSA9IDIwXSA9IFwiQ0JfQ0hVTktfQ09NUExFVEVcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRFwiXSA9IDIxXSA9IFwiUEFVU0VEXCI7XG4gICAgRVJST1JbRVJST1JbXCJQQVVTRURfVVBHUkFERVwiXSA9IDIyXSA9IFwiUEFVU0VEX1VQR1JBREVcIjtcbiAgICBFUlJPUltFUlJPUltcIlBBVVNFRF9IMl9VUEdSQURFXCJdID0gMjNdID0gXCJQQVVTRURfSDJfVVBHUkFERVwiO1xuICAgIEVSUk9SW0VSUk9SW1wiVVNFUlwiXSA9IDI0XSA9IFwiVVNFUlwiO1xufSkoRVJST1IgPSBleHBvcnRzLkVSUk9SIHx8IChleHBvcnRzLkVSUk9SID0ge30pKTtcbnZhciBUWVBFO1xuKGZ1bmN0aW9uIChUWVBFKSB7XG4gICAgVFlQRVtUWVBFW1wiQk9USFwiXSA9IDBdID0gXCJCT1RIXCI7XG4gICAgVFlQRVtUWVBFW1wiUkVRVUVTVFwiXSA9IDFdID0gXCJSRVFVRVNUXCI7XG4gICAgVFlQRVtUWVBFW1wiUkVTUE9OU0VcIl0gPSAyXSA9IFwiUkVTUE9OU0VcIjtcbn0pKFRZUEUgPSBleHBvcnRzLlRZUEUgfHwgKGV4cG9ydHMuVFlQRSA9IHt9KSk7XG52YXIgRkxBR1M7XG4oZnVuY3Rpb24gKEZMQUdTKSB7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05ORUNUSU9OX0tFRVBfQUxJVkVcIl0gPSAxXSA9IFwiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJDT05ORUNUSU9OX0NMT1NFXCJdID0gMl0gPSBcIkNPTk5FQ1RJT05fQ0xPU0VcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNPTk5FQ1RJT05fVVBHUkFERVwiXSA9IDRdID0gXCJDT05ORUNUSU9OX1VQR1JBREVcIjtcbiAgICBGTEFHU1tGTEFHU1tcIkNIVU5LRURcIl0gPSA4XSA9IFwiQ0hVTktFRFwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiVVBHUkFERVwiXSA9IDE2XSA9IFwiVVBHUkFERVwiO1xuICAgIEZMQUdTW0ZMQUdTW1wiQ09OVEVOVF9MRU5HVEhcIl0gPSAzMl0gPSBcIkNPTlRFTlRfTEVOR1RIXCI7XG4gICAgRkxBR1NbRkxBR1NbXCJTS0lQQk9EWVwiXSA9IDY0XSA9IFwiU0tJUEJPRFlcIjtcbiAgICBGTEFHU1tGTEFHU1tcIlRSQUlMSU5HXCJdID0gMTI4XSA9IFwiVFJBSUxJTkdcIjtcbiAgICAvLyAxIDw8IDggaXMgdW51c2VkXG4gICAgRkxBR1NbRkxBR1NbXCJUUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDUxMl0gPSBcIlRSQU5TRkVSX0VOQ09ESU5HXCI7XG59KShGTEFHUyA9IGV4cG9ydHMuRkxBR1MgfHwgKGV4cG9ydHMuRkxBR1MgPSB7fSkpO1xudmFyIExFTklFTlRfRkxBR1M7XG4oZnVuY3Rpb24gKExFTklFTlRfRkxBR1MpIHtcbiAgICBMRU5JRU5UX0ZMQUdTW0xFTklFTlRfRkxBR1NbXCJIRUFERVJTXCJdID0gMV0gPSBcIkhFQURFUlNcIjtcbiAgICBMRU5JRU5UX0ZMQUdTW0xFTklFTlRfRkxBR1NbXCJDSFVOS0VEX0xFTkdUSFwiXSA9IDJdID0gXCJDSFVOS0VEX0xFTkdUSFwiO1xuICAgIExFTklFTlRfRkxBR1NbTEVOSUVOVF9GTEFHU1tcIktFRVBfQUxJVkVcIl0gPSA0XSA9IFwiS0VFUF9BTElWRVwiO1xufSkoTEVOSUVOVF9GTEFHUyA9IGV4cG9ydHMuTEVOSUVOVF9GTEFHUyB8fCAoZXhwb3J0cy5MRU5JRU5UX0ZMQUdTID0ge30pKTtcbnZhciBNRVRIT0RTO1xuKGZ1bmN0aW9uIChNRVRIT0RTKSB7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiREVMRVRFXCJdID0gMF0gPSBcIkRFTEVURVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkdFVFwiXSA9IDFdID0gXCJHRVRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJIRUFEXCJdID0gMl0gPSBcIkhFQURcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQT1NUXCJdID0gM10gPSBcIlBPU1RcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQVVRcIl0gPSA0XSA9IFwiUFVUXCI7XG4gICAgLyogcGF0aG9sb2dpY2FsICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQ09OTkVDVFwiXSA9IDVdID0gXCJDT05ORUNUXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiT1BUSU9OU1wiXSA9IDZdID0gXCJPUFRJT05TXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVFJBQ0VcIl0gPSA3XSA9IFwiVFJBQ0VcIjtcbiAgICAvKiBXZWJEQVYgKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDT1BZXCJdID0gOF0gPSBcIkNPUFlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJMT0NLXCJdID0gOV0gPSBcIkxPQ0tcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNS0NPTFwiXSA9IDEwXSA9IFwiTUtDT0xcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNT1ZFXCJdID0gMTFdID0gXCJNT1ZFXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJPUEZJTkRcIl0gPSAxMl0gPSBcIlBST1BGSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFJPUFBBVENIXCJdID0gMTNdID0gXCJQUk9QUEFUQ0hcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTRUFSQ0hcIl0gPSAxNF0gPSBcIlNFQVJDSFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOTE9DS1wiXSA9IDE1XSA9IFwiVU5MT0NLXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiQklORFwiXSA9IDE2XSA9IFwiQklORFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFQklORFwiXSA9IDE3XSA9IFwiUkVCSU5EXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiVU5CSU5EXCJdID0gMThdID0gXCJVTkJJTkRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJBQ0xcIl0gPSAxOV0gPSBcIkFDTFwiO1xuICAgIC8qIHN1YnZlcnNpb24gKi9cbiAgICBNRVRIT0RTW01FVEhPRFNbXCJSRVBPUlRcIl0gPSAyMF0gPSBcIlJFUE9SVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIk1LQUNUSVZJVFlcIl0gPSAyMV0gPSBcIk1LQUNUSVZJVFlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJDSEVDS09VVFwiXSA9IDIyXSA9IFwiQ0hFQ0tPVVRcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJNRVJHRVwiXSA9IDIzXSA9IFwiTUVSR0VcIjtcbiAgICAvKiB1cG5wICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTS1TRUFSQ0hcIl0gPSAyNF0gPSBcIk0tU0VBUkNIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTk9USUZZXCJdID0gMjVdID0gXCJOT1RJRllcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJTVUJTQ1JJQkVcIl0gPSAyNl0gPSBcIlNVQlNDUklCRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOU1VCU0NSSUJFXCJdID0gMjddID0gXCJVTlNVQlNDUklCRVwiO1xuICAgIC8qIFJGQy01Nzg5ICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUEFUQ0hcIl0gPSAyOF0gPSBcIlBBVENIXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiUFVSR0VcIl0gPSAyOV0gPSBcIlBVUkdFXCI7XG4gICAgLyogQ2FsREFWICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTUtDQUxFTkRBUlwiXSA9IDMwXSA9IFwiTUtDQUxFTkRBUlwiO1xuICAgIC8qIFJGQy0yMDY4LCBzZWN0aW9uIDE5LjYuMS4yICovXG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiTElOS1wiXSA9IDMxXSA9IFwiTElOS1wiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlVOTElOS1wiXSA9IDMyXSA9IFwiVU5MSU5LXCI7XG4gICAgLyogaWNlY2FzdCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNPVVJDRVwiXSA9IDMzXSA9IFwiU09VUkNFXCI7XG4gICAgLyogUkZDLTc1NDAsIHNlY3Rpb24gMTEuNiAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBSSVwiXSA9IDM0XSA9IFwiUFJJXCI7XG4gICAgLyogUkZDLTIzMjYgUlRTUCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkRFU0NSSUJFXCJdID0gMzVdID0gXCJERVNDUklCRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkFOTk9VTkNFXCJdID0gMzZdID0gXCJBTk5PVU5DRVwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlNFVFVQXCJdID0gMzddID0gXCJTRVRVUFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlBMQVlcIl0gPSAzOF0gPSBcIlBMQVlcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJQQVVTRVwiXSA9IDM5XSA9IFwiUEFVU0VcIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJURUFSRE9XTlwiXSA9IDQwXSA9IFwiVEVBUkRPV05cIjtcbiAgICBNRVRIT0RTW01FVEhPRFNbXCJHRVRfUEFSQU1FVEVSXCJdID0gNDFdID0gXCJHRVRfUEFSQU1FVEVSXCI7XG4gICAgTUVUSE9EU1tNRVRIT0RTW1wiU0VUX1BBUkFNRVRFUlwiXSA9IDQyXSA9IFwiU0VUX1BBUkFNRVRFUlwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFRElSRUNUXCJdID0gNDNdID0gXCJSRURJUkVDVFwiO1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIlJFQ09SRFwiXSA9IDQ0XSA9IFwiUkVDT1JEXCI7XG4gICAgLyogUkFPUCAqL1xuICAgIE1FVEhPRFNbTUVUSE9EU1tcIkZMVVNIXCJdID0gNDVdID0gXCJGTFVTSFwiO1xufSkoTUVUSE9EUyA9IGV4cG9ydHMuTUVUSE9EUyB8fCAoZXhwb3J0cy5NRVRIT0RTID0ge30pKTtcbmV4cG9ydHMuTUVUSE9EU19IVFRQID0gW1xuICAgIE1FVEhPRFMuREVMRVRFLFxuICAgIE1FVEhPRFMuR0VULFxuICAgIE1FVEhPRFMuSEVBRCxcbiAgICBNRVRIT0RTLlBPU1QsXG4gICAgTUVUSE9EUy5QVVQsXG4gICAgTUVUSE9EUy5DT05ORUNULFxuICAgIE1FVEhPRFMuT1BUSU9OUyxcbiAgICBNRVRIT0RTLlRSQUNFLFxuICAgIE1FVEhPRFMuQ09QWSxcbiAgICBNRVRIT0RTLkxPQ0ssXG4gICAgTUVUSE9EUy5NS0NPTCxcbiAgICBNRVRIT0RTLk1PVkUsXG4gICAgTUVUSE9EUy5QUk9QRklORCxcbiAgICBNRVRIT0RTLlBST1BQQVRDSCxcbiAgICBNRVRIT0RTLlNFQVJDSCxcbiAgICBNRVRIT0RTLlVOTE9DSyxcbiAgICBNRVRIT0RTLkJJTkQsXG4gICAgTUVUSE9EUy5SRUJJTkQsXG4gICAgTUVUSE9EUy5VTkJJTkQsXG4gICAgTUVUSE9EUy5BQ0wsXG4gICAgTUVUSE9EUy5SRVBPUlQsXG4gICAgTUVUSE9EUy5NS0FDVElWSVRZLFxuICAgIE1FVEhPRFMuQ0hFQ0tPVVQsXG4gICAgTUVUSE9EUy5NRVJHRSxcbiAgICBNRVRIT0RTWydNLVNFQVJDSCddLFxuICAgIE1FVEhPRFMuTk9USUZZLFxuICAgIE1FVEhPRFMuU1VCU0NSSUJFLFxuICAgIE1FVEhPRFMuVU5TVUJTQ1JJQkUsXG4gICAgTUVUSE9EUy5QQVRDSCxcbiAgICBNRVRIT0RTLlBVUkdFLFxuICAgIE1FVEhPRFMuTUtDQUxFTkRBUixcbiAgICBNRVRIT0RTLkxJTkssXG4gICAgTUVUSE9EUy5VTkxJTkssXG4gICAgTUVUSE9EUy5QUkksXG4gICAgLy8gVE9ETyhpbmR1dG55KTogc2hvdWxkIHdlIGFsbG93IGl0IHdpdGggSFRUUD9cbiAgICBNRVRIT0RTLlNPVVJDRSxcbl07XG5leHBvcnRzLk1FVEhPRFNfSUNFID0gW1xuICAgIE1FVEhPRFMuU09VUkNFLFxuXTtcbmV4cG9ydHMuTUVUSE9EU19SVFNQID0gW1xuICAgIE1FVEhPRFMuT1BUSU9OUyxcbiAgICBNRVRIT0RTLkRFU0NSSUJFLFxuICAgIE1FVEhPRFMuQU5OT1VOQ0UsXG4gICAgTUVUSE9EUy5TRVRVUCxcbiAgICBNRVRIT0RTLlBMQVksXG4gICAgTUVUSE9EUy5QQVVTRSxcbiAgICBNRVRIT0RTLlRFQVJET1dOLFxuICAgIE1FVEhPRFMuR0VUX1BBUkFNRVRFUixcbiAgICBNRVRIT0RTLlNFVF9QQVJBTUVURVIsXG4gICAgTUVUSE9EUy5SRURJUkVDVCxcbiAgICBNRVRIT0RTLlJFQ09SRCxcbiAgICBNRVRIT0RTLkZMVVNILFxuICAgIC8vIEZvciBBaXJQbGF5XG4gICAgTUVUSE9EUy5HRVQsXG4gICAgTUVUSE9EUy5QT1NULFxuXTtcbmV4cG9ydHMuTUVUSE9EX01BUCA9IHV0aWxzXzEuZW51bVRvTWFwKE1FVEhPRFMpO1xuZXhwb3J0cy5IX01FVEhPRF9NQVAgPSB7fTtcbk9iamVjdC5rZXlzKGV4cG9ydHMuTUVUSE9EX01BUCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKC9eSC8udGVzdChrZXkpKSB7XG4gICAgICAgIGV4cG9ydHMuSF9NRVRIT0RfTUFQW2tleV0gPSBleHBvcnRzLk1FVEhPRF9NQVBba2V5XTtcbiAgICB9XG59KTtcbnZhciBGSU5JU0g7XG4oZnVuY3Rpb24gKEZJTklTSCkge1xuICAgIEZJTklTSFtGSU5JU0hbXCJTQUZFXCJdID0gMF0gPSBcIlNBRkVcIjtcbiAgICBGSU5JU0hbRklOSVNIW1wiU0FGRV9XSVRIX0NCXCJdID0gMV0gPSBcIlNBRkVfV0lUSF9DQlwiO1xuICAgIEZJTklTSFtGSU5JU0hbXCJVTlNBRkVcIl0gPSAyXSA9IFwiVU5TQUZFXCI7XG59KShGSU5JU0ggPSBleHBvcnRzLkZJTklTSCB8fCAoZXhwb3J0cy5GSU5JU0ggPSB7fSkpO1xuZXhwb3J0cy5BTFBIQSA9IFtdO1xuZm9yIChsZXQgaSA9ICdBJy5jaGFyQ29kZUF0KDApOyBpIDw9ICdaJy5jaGFyQ29kZUF0KDApOyBpKyspIHtcbiAgICAvLyBVcHBlciBjYXNlXG4gICAgZXhwb3J0cy5BTFBIQS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoaSkpO1xuICAgIC8vIExvd2VyIGNhc2VcbiAgICBleHBvcnRzLkFMUEhBLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMHgyMCkpO1xufVxuZXhwb3J0cy5OVU1fTUFQID0ge1xuICAgIDA6IDAsIDE6IDEsIDI6IDIsIDM6IDMsIDQ6IDQsXG4gICAgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSxcbn07XG5leHBvcnRzLkhFWF9NQVAgPSB7XG4gICAgMDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCxcbiAgICA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LFxuICAgIEE6IDBYQSwgQjogMFhCLCBDOiAwWEMsIEQ6IDBYRCwgRTogMFhFLCBGOiAwWEYsXG4gICAgYTogMHhhLCBiOiAweGIsIGM6IDB4YywgZDogMHhkLCBlOiAweGUsIGY6IDB4Zixcbn07XG5leHBvcnRzLk5VTSA9IFtcbiAgICAnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsXG5dO1xuZXhwb3J0cy5BTFBIQU5VTSA9IGV4cG9ydHMuQUxQSEEuY29uY2F0KGV4cG9ydHMuTlVNKTtcbmV4cG9ydHMuTUFSSyA9IFsnLScsICdfJywgJy4nLCAnIScsICd+JywgJyonLCAnXFwnJywgJygnLCAnKSddO1xuZXhwb3J0cy5VU0VSSU5GT19DSEFSUyA9IGV4cG9ydHMuQUxQSEFOVU1cbiAgICAuY29uY2F0KGV4cG9ydHMuTUFSSylcbiAgICAuY29uY2F0KFsnJScsICc7JywgJzonLCAnJicsICc9JywgJysnLCAnJCcsICcsJ10pO1xuLy8gVE9ETyhpbmR1dG55KTogdXNlIFJGQ1xuZXhwb3J0cy5TVFJJQ1RfVVJMX0NIQVIgPSBbXG4gICAgJyEnLCAnXCInLCAnJCcsICclJywgJyYnLCAnXFwnJyxcbiAgICAnKCcsICcpJywgJyonLCAnKycsICcsJywgJy0nLCAnLicsICcvJyxcbiAgICAnOicsICc7JywgJzwnLCAnPScsICc+JyxcbiAgICAnQCcsICdbJywgJ1xcXFwnLCAnXScsICdeJywgJ18nLFxuICAgICdgJyxcbiAgICAneycsICd8JywgJ30nLCAnficsXG5dLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbmV4cG9ydHMuVVJMX0NIQVIgPSBleHBvcnRzLlNUUklDVF9VUkxfQ0hBUlxuICAgIC5jb25jYXQoWydcXHQnLCAnXFxmJ10pO1xuLy8gQWxsIGNoYXJhY3RlcnMgd2l0aCAweDgwIGJpdCBzZXQgdG8gMVxuZm9yIChsZXQgaSA9IDB4ODA7IGkgPD0gMHhmZjsgaSsrKSB7XG4gICAgZXhwb3J0cy5VUkxfQ0hBUi5wdXNoKGkpO1xufVxuZXhwb3J0cy5IRVggPSBleHBvcnRzLk5VTS5jb25jYXQoWydhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRiddKTtcbi8qIFRva2VucyBhcyBkZWZpbmVkIGJ5IHJmYyAyNjE2LiBBbHNvIGxvd2VyY2FzZXMgdGhlbS5cbiAqICAgICAgICB0b2tlbiAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gKiAgICAgc2VwYXJhdG9ycyAgICAgPSBcIihcIiB8IFwiKVwiIHwgXCI8XCIgfCBcIj5cIiB8IFwiQFwiXG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIixcIiB8IFwiO1wiIHwgXCI6XCIgfCBcIlxcXCIgfCA8XCI+XG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gKiAgICAgICAgICAgICAgICAgICAgfCBcIntcIiB8IFwifVwiIHwgU1AgfCBIVFxuICovXG5leHBvcnRzLlNUUklDVF9UT0tFTiA9IFtcbiAgICAnIScsICcjJywgJyQnLCAnJScsICcmJywgJ1xcJycsXG4gICAgJyonLCAnKycsICctJywgJy4nLFxuICAgICdeJywgJ18nLCAnYCcsXG4gICAgJ3wnLCAnficsXG5dLmNvbmNhdChleHBvcnRzLkFMUEhBTlVNKTtcbmV4cG9ydHMuVE9LRU4gPSBleHBvcnRzLlNUUklDVF9UT0tFTi5jb25jYXQoWycgJ10pO1xuLypcbiAqIFZlcmlmeSB0aGF0IGEgY2hhciBpcyBhIHZhbGlkIHZpc2libGUgKHByaW50YWJsZSkgVVMtQVNDSUlcbiAqIGNoYXJhY3RlciBvciAleDgwLUZGXG4gKi9cbmV4cG9ydHMuSEVBREVSX0NIQVJTID0gWydcXHQnXTtcbmZvciAobGV0IGkgPSAzMjsgaSA8PSAyNTU7IGkrKykge1xuICAgIGlmIChpICE9PSAxMjcpIHtcbiAgICAgICAgZXhwb3J0cy5IRUFERVJfQ0hBUlMucHVzaChpKTtcbiAgICB9XG59XG4vLyAnLCcgPSBcXHg0NFxuZXhwb3J0cy5DT05ORUNUSU9OX1RPS0VOX0NIQVJTID0gZXhwb3J0cy5IRUFERVJfQ0hBUlMuZmlsdGVyKChjKSA9PiBjICE9PSA0NCk7XG5leHBvcnRzLk1BSk9SID0gZXhwb3J0cy5OVU1fTUFQO1xuZXhwb3J0cy5NSU5PUiA9IGV4cG9ydHMuTUFKT1I7XG52YXIgSEVBREVSX1NUQVRFO1xuKGZ1bmN0aW9uIChIRUFERVJfU1RBVEUpIHtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiR0VORVJBTFwiXSA9IDBdID0gXCJHRU5FUkFMXCI7XG4gICAgSEVBREVSX1NUQVRFW0hFQURFUl9TVEFURVtcIkNPTk5FQ1RJT05cIl0gPSAxXSA9IFwiQ09OTkVDVElPTlwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05URU5UX0xFTkdUSFwiXSA9IDJdID0gXCJDT05URU5UX0xFTkdUSFwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJUUkFOU0ZFUl9FTkNPRElOR1wiXSA9IDNdID0gXCJUUkFOU0ZFUl9FTkNPRElOR1wiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJVUEdSQURFXCJdID0gNF0gPSBcIlVQR1JBREVcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTl9LRUVQX0FMSVZFXCJdID0gNV0gPSBcIkNPTk5FQ1RJT05fS0VFUF9BTElWRVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJDT05ORUNUSU9OX0NMT1NFXCJdID0gNl0gPSBcIkNPTk5FQ1RJT05fQ0xPU0VcIjtcbiAgICBIRUFERVJfU1RBVEVbSEVBREVSX1NUQVRFW1wiQ09OTkVDVElPTl9VUEdSQURFXCJdID0gN10gPSBcIkNPTk5FQ1RJT05fVVBHUkFERVwiO1xuICAgIEhFQURFUl9TVEFURVtIRUFERVJfU1RBVEVbXCJUUkFOU0ZFUl9FTkNPRElOR19DSFVOS0VEXCJdID0gOF0gPSBcIlRSQU5TRkVSX0VOQ09ESU5HX0NIVU5LRURcIjtcbn0pKEhFQURFUl9TVEFURSA9IGV4cG9ydHMuSEVBREVSX1NUQVRFIHx8IChleHBvcnRzLkhFQURFUl9TVEFURSA9IHt9KSk7XG5leHBvcnRzLlNQRUNJQUxfSEVBREVSUyA9IHtcbiAgICAnY29ubmVjdGlvbic6IEhFQURFUl9TVEFURS5DT05ORUNUSU9OLFxuICAgICdjb250ZW50LWxlbmd0aCc6IEhFQURFUl9TVEFURS5DT05URU5UX0xFTkdUSCxcbiAgICAncHJveHktY29ubmVjdGlvbic6IEhFQURFUl9TVEFURS5DT05ORUNUSU9OLFxuICAgICd0cmFuc2Zlci1lbmNvZGluZyc6IEhFQURFUl9TVEFURS5UUkFOU0ZFUl9FTkNPRElORyxcbiAgICAndXBncmFkZSc6IEhFQURFUl9TVEFURS5VUEdSQURFLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp-wasm.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nmodule.exports = Buffer.from('AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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CABB3AgLii1JbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAEH5NQsBAQBBkDYL4AEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB/TcLAQEAQZE4C14CAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEH9OQsBAQBBkToLXgIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAQfA7Cw1sb3NlZWVwLWFsaXZlAEGJPAsBAQBBoDwL4AEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBiT4LAQEAQaA+C+cBAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAEGwwAALXwEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAEGQwgALIWVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgBBwMIACy1yYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AQfnCAAsFAQIAAQMAQZDDAAvgAQQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH5xAALBQECAAEDAEGQxQAL4AEEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cYACwQBAAABAEGRxwAL3wEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEH6yAALBAEAAAIAQZDJAAtfAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAQfrKAAsEAQAAAQBBkMsACwEBAEGqywALQQIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAEH6zAALBAEAAAEAQZDNAAsBAQBBms0ACwYCAAAAAAIAQbHNAAs6AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB8M4AC5YBTk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv', 'base64')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwLXdhc20uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFeEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbGxodHRwXFxsbGh0dHAtd2FzbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXIuZnJvbSgnQUdGemJRRUFBQUFCSndkZ0FYOEJmMkFEZjM5L0FYOWdBWDhBWUFKL2Z3QmdCSDkvZjM4QmYyQUFBR0FEZjM5L0FBTExBUWdEWlc1MkdIZGhjMjFmYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFBRUEyVnVkaFYzWVhOdFgyOXVYMjFsYzNOaFoyVmZZbVZuYVc0QUFBTmxibllMZDJGemJWOXZibDkxY213QUFRTmxibllPZDJGemJWOXZibDl6ZEdGMGRYTUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmWm1sbGJHUUFBUU5sYm5ZVWQyRnpiVjl2Ymw5b1pXRmtaWEpmZG1Gc2RXVUFBUU5sYm5ZTWQyRnpiVjl2Ymw5aWIyUjVBQUVEWlc1MkdIZGhjMjFmYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlFBQUF5MHNCUVlBQUFJQUFBQUFBQUFDQVFJQUFnSUNBQUFEQUFBQUFBTURBd01CQVFFQkFRRUJBUUVBQUFJQUFBQUVCUUZ3QVJJU0JRTUJBQUlHQ0FGL0FVR0ExQVFMQjlFRklnWnRaVzF2Y25rQ0FBdGZhVzVwZEdsaGJHbDZaUUFJR1Y5ZmFXNWthWEpsWTNSZlpuVnVZM1JwYjI1ZmRHRmliR1VCQUF0c2JHaDBkSEJmYVc1cGRBQUpHR3hzYUhSMGNGOXphRzkxYkdSZmEyVmxjRjloYkdsMlpRQXZER3hzYUhSMGNGOWhiR3h2WXdBTEJtMWhiR3h2WXdBeEMyeHNhSFIwY0Y5bWNtVmxBQXdFWm5KbFpRQU1EMnhzYUhSMGNGOW5aWFJmZEhsd1pRQU5GV3hzYUhSMGNGOW5aWFJmYUhSMGNGOXRZV3B2Y2dBT0ZXeHNhSFIwY0Y5blpYUmZhSFIwY0Y5dGFXNXZjZ0FQRVd4c2FIUjBjRjluWlhSZmJXVjBhRzlrQUJBV2JHeG9kSFJ3WDJkbGRGOXpkR0YwZFhOZlkyOWtaUUFSRW14c2FIUjBjRjluWlhSZmRYQm5jbUZrWlFBU0RHeHNhSFIwY0Y5eVpYTmxkQUFURG14c2FIUjBjRjlsZUdWamRYUmxBQlFVYkd4b2RIUndYM05sZEhScGJtZHpYMmx1YVhRQUZRMXNiR2gwZEhCZlptbHVhWE5vQUJZTWJHeG9kSFJ3WDNCaGRYTmxBQmNOYkd4b2RIUndYM0psYzNWdFpRQVlHMnhzYUhSMGNGOXlaWE4xYldWZllXWjBaWEpmZFhCbmNtRmtaUUFaRUd4c2FIUjBjRjluWlhSZlpYSnlibThBR2hkc2JHaDBkSEJmWjJWMFgyVnljbTl5WDNKbFlYTnZiZ0FiRjJ4c2FIUjBjRjl6WlhSZlpYSnliM0pmY21WaGMyOXVBQndVYkd4b2RIUndYMmRsZEY5bGNuSnZjbDl3YjNNQUhSRnNiR2gwZEhCZlpYSnlibTlmYm1GdFpRQWVFbXhzYUhSMGNGOXRaWFJvYjJSZmJtRnRaUUFmRW14c2FIUjBjRjl6ZEdGMGRYTmZibUZ0WlFBZ0dteHNhSFIwY0Y5elpYUmZiR1Z1YVdWdWRGOW9aV0ZrWlhKekFDRWhiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMk5vZFc1clpXUmZiR1Z1WjNSb0FDSWRiR3hvZEhSd1gzTmxkRjlzWlc1cFpXNTBYMnRsWlhCZllXeHBkbVVBSXlSc2JHaDBkSEJmYzJWMFgyeGxibWxsYm5SZmRISmhibk5tWlhKZlpXNWpiMlJwYm1jQUpCaHNiR2gwZEhCZmJXVnpjMkZuWlY5dVpXVmtjMTlsYjJZQUxna1hBUUJCQVFzUkFRSURCQVVLQmdjckxTd3FLU2dsSnlZSzA3TUNMQllBUVlqUUFDZ0NBQVJBQUF0QmlOQUFRUUUyQWdBTEZBQWdBQkF3SUFBZ0FqWUNPQ0FBSUFFNkFDZ0xGQUFnQUNBQUx3RXlJQUF0QUM0Z0FCQXZFQUFMSGdFQmYwSEFBQkF5SWdFUU1DQUJRWUFJTmdJNElBRWdBRG9BS0NBQkM0OE1BUWQvQWtBZ0FFVU5BQ0FBUVFocklnRWdBRUVFYXlnQ0FDSUFRWGh4SWdScUlRVUNRQ0FBUVFGeERRQWdBRUVEY1VVTkFTQUJJQUVvQWdBaUFHc2lBVUdjMEFBb0FnQkpEUUVnQUNBRWFpRUVBa0FDUUVHZzBBQW9BZ0FnQVVjRVFDQUFRZjhCVFFSQUlBQkJBM1loQXlBQktBSUlJZ0FnQVNnQ0RDSUNSZ1JBUVl6UUFFR00wQUFvQWdCQmZpQURkM0UyQWdBTUJRc2dBaUFBTmdJSUlBQWdBallDREF3RUN5QUJLQUlZSVFZZ0FTQUJLQUlNSWdCSEJFQWdBQ0FCS0FJSUlnSTJBZ2dnQWlBQU5nSU1EQU1MSUFGQkZHb2lBeWdDQUNJQ1JRUkFJQUVvQWhBaUFrVU5BaUFCUVJCcUlRTUxBMEFnQXlFSElBSWlBRUVVYWlJREtBSUFJZ0lOQUNBQVFSQnFJUU1nQUNnQ0VDSUNEUUFMSUFkQkFEWUNBQXdDQ3lBRktBSUVJZ0JCQTNGQkEwY05BaUFGSUFCQmZuRTJBZ1JCbE5BQUlBUTJBZ0FnQlNBRU5nSUFJQUVnQkVFQmNqWUNCQXdEQzBFQUlRQUxJQVpGRFFBQ1FDQUJLQUljSWdKQkFuUkJ2TklBYWlJREtBSUFJQUZHQkVBZ0F5QUFOZ0lBSUFBTkFVR1EwQUJCa05BQUtBSUFRWDRnQW5keE5nSUFEQUlMSUFaQkVFRVVJQVlvQWhBZ0FVWWJhaUFBTmdJQUlBQkZEUUVMSUFBZ0JqWUNHQ0FCS0FJUUlnSUVRQ0FBSUFJMkFoQWdBaUFBTmdJWUN5QUJRUlJxS0FJQUlnSkZEUUFnQUVFVWFpQUNOZ0lBSUFJZ0FEWUNHQXNnQVNBRlR3MEFJQVVvQWdRaUFFRUJjVVVOQUFKQUFrQUNRQUpBSUFCQkFuRkZCRUJCcE5BQUtBSUFJQVZHQkVCQnBOQUFJQUUyQWdCQm1OQUFRWmpRQUNnQ0FDQUVhaUlBTmdJQUlBRWdBRUVCY2pZQ0JDQUJRYURRQUNnQ0FFY05Ca0dVMEFCQkFEWUNBRUdnMEFCQkFEWUNBQXdHQzBHZzBBQW9BZ0FnQlVZRVFFR2cwQUFnQVRZQ0FFR1UwQUJCbE5BQUtBSUFJQVJxSWdBMkFnQWdBU0FBUVFGeU5nSUVJQUFnQVdvZ0FEWUNBQXdHQ3lBQVFYaHhJQVJxSVFRZ0FFSC9BVTBFUUNBQVFRTjJJUU1nQlNnQ0NDSUFJQVVvQWd3aUFrWUVRRUdNMEFCQmpOQUFLQUlBUVg0Z0EzZHhOZ0lBREFVTElBSWdBRFlDQ0NBQUlBSTJBZ3dNQkFzZ0JTZ0NHQ0VHSUFVZ0JTZ0NEQ0lBUndSQVFaelFBQ2dDQUJvZ0FDQUZLQUlJSWdJMkFnZ2dBaUFBTmdJTURBTUxJQVZCRkdvaUF5Z0NBQ0lDUlFSQUlBVW9BaEFpQWtVTkFpQUZRUkJxSVFNTEEwQWdBeUVISUFJaUFFRVVhaUlES0FJQUlnSU5BQ0FBUVJCcUlRTWdBQ2dDRUNJQ0RRQUxJQWRCQURZQ0FBd0NDeUFGSUFCQmZuRTJBZ1FnQVNBRWFpQUVOZ0lBSUFFZ0JFRUJjallDQkF3REMwRUFJUUFMSUFaRkRRQUNRQ0FGS0FJY0lnSkJBblJCdk5JQWFpSURLQUlBSUFWR0JFQWdBeUFBTmdJQUlBQU5BVUdRMEFCQmtOQUFLQUlBUVg0Z0FuZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdCVVliYWlBQU5nSUFJQUJGRFFFTElBQWdCallDR0NBRktBSVFJZ0lFUUNBQUlBSTJBaEFnQWlBQU5nSVlDeUFGUVJScUtBSUFJZ0pGRFFBZ0FFRVVhaUFDTmdJQUlBSWdBRFlDR0FzZ0FTQUVhaUFFTmdJQUlBRWdCRUVCY2pZQ0JDQUJRYURRQUNnQ0FFY05BRUdVMEFBZ0JEWUNBQXdCQ3lBRVFmOEJUUVJBSUFSQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnSkJBU0FFUVFOMmRDSURjVVVFUUVHTTBBQWdBaUFEY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0lnQVRZQ0RDQUFJQUUyQWdnZ0FTQUFOZ0lNSUFFZ0FqWUNDQXdCQzBFZklRSWdCRUgvLy84SFRRUkFJQVJCSmlBRVFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hBZ3NnQVNBQ05nSWNJQUZDQURjQ0VDQUNRUUowUWJ6U0FHb2hBQUpBUVpEUUFDZ0NBQ0lEUVFFZ0FuUWlCM0ZGQkVBZ0FDQUJOZ0lBUVpEUUFDQURJQWR5TmdJQUlBRWdBRFlDR0NBQklBRTJBZ2dnQVNBQk5nSU1EQUVMSUFSQkdTQUNRUUYyYTBFQUlBSkJIMGNiZENFQ0lBQW9BZ0FoQUFKQUEwQWdBQ0lES0FJRVFYaHhJQVJHRFFFZ0FrRWRkaUVBSUFKQkFYUWhBaUFESUFCQkJIRnFRUkJxSWdjb0FnQWlBQTBBQ3lBSElBRTJBZ0FnQVNBRE5nSVlJQUVnQVRZQ0RDQUJJQUUyQWdnTUFRc2dBeWdDQ0NJQUlBRTJBZ3dnQXlBQk5nSUlJQUZCQURZQ0dDQUJJQU0yQWd3Z0FTQUFOZ0lJQzBHczBBQkJyTkFBS0FJQVFRRnJJZ0JCZnlBQUd6WUNBQXNMQndBZ0FDMEFLQXNIQUNBQUxRQXFDd2NBSUFBdEFDc0xCd0FnQUMwQUtRc0hBQ0FBTHdFeUN3Y0FJQUF0QUM0TFFBRUVmeUFBS0FJWUlRRWdBQzBBTFNFQ0lBQXRBQ2doQXlBQUtBSTRJUVFnQUJBd0lBQWdCRFlDT0NBQUlBTTZBQ2dnQUNBQ09nQXRJQUFnQVRZQ0dBdTc0Z0VDQjM4RGZpQUJJQUpxSVFRQ1FDQUFJZ0lvQWd3aUFBMEFJQUlvQWdRRVFDQUNJQUUyQWdRTEl3QkJFR3NpQ0NRQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBSW9BaHdpQTBFQmF3N2RBZG9CQWRrQkFnTUVCUVlIQ0FrS0N3d05EdGdCRHhEWEFSRVMxZ0VURkJVV0Z4Z1pHaHZnQWQ4QkhCMGUxUUVmSUNFaUl5UWwxQUVtSnlncEtpc3Mwd0hTQVMwdTBRSFFBUzh3TVRJek5EVTJOemc1T2pzOFBUNC9RRUZDUTBSRlJ0c0JSMGhKU3M4QnpnRkx6UUZNekFGTlRrOVFVVkpUVkZWV1YxaFpXbHRjWFY1ZllHRmlZMlJsWm1kb2FXcHJiRzF1YjNCeGNuTjBkWFozZUhsNmUzeDlmbitBQVlFQmdnR0RBWVFCaFFHR0FZY0JpQUdKQVlvQml3R01BWTBCamdHUEFaQUJrUUdTQVpNQmxBR1ZBWllCbHdHWUFaa0JtZ0diQVp3Qm5RR2VBWjhCb0FHaEFhSUJvd0drQWFVQnBnR25BYWdCcVFHcUFhc0JyQUd0QWE0QnJ3R3dBYkVCc2dHekFiUUJ0UUcyQWJjQnl3SEtBYmdCeVFHNUFjZ0J1Z0c3QWJ3QnZRRytBYjhCd0FIQkFjSUJ3d0hFQWNVQnhnRUEzQUVMUVFBTXhnRUxRUTRNeFFFTFFRME14QUVMUVE4TXd3RUxRUkFNd2dFTFFSTU13UUVMUVJRTXdBRUxRUlVNdndFTFFSWU12Z0VMUVJnTXZRRUxRUmtNdkFFTFFSb011d0VMUVJzTXVnRUxRUndNdVFFTFFSME11QUVMUVFnTXR3RUxRUjRNdGdFTFFTQU10UUVMUVI4TXRBRUxRUWNNc3dFTFFTRU1zZ0VMUVNJTXNRRUxRU01Nc0FFTFFTUU1yd0VMUVJJTXJnRUxRUkVNclFFTFFTVU1yQUVMUVNZTXF3RUxRU2NNcWdFTFFTZ01xUUVMUWNNQkRLZ0JDMEVxREtjQkMwRXJES1lCQzBFc0RLVUJDMEV0REtRQkMwRXVES01CQzBFdkRLSUJDMEhFQVF5aEFRdEJNQXlnQVF0Qk5BeWZBUXRCREF5ZUFRdEJNUXlkQVF0Qk1neWNBUXRCTXd5YkFRdEJPUXlhQVF0Qk5ReVpBUXRCeFFFTW1BRUxRUXNNbHdFTFFUb01sZ0VMUVRZTWxRRUxRUW9NbEFFTFFUY01rd0VMUVRnTWtnRUxRVHdNa1FFTFFUc01rQUVMUVQwTWp3RUxRUWtNamdFTFFTa01qUUVMUVQ0TWpBRUxRVDhNaXdFTFFjQUFESW9CQzBIQkFBeUpBUXRCd2dBTWlBRUxRY01BREljQkMwSEVBQXlHQVF0QnhRQU1oUUVMUWNZQURJUUJDMEVYRElNQkMwSEhBQXlDQVF0QnlBQU1nUUVMUWNrQURJQUJDMEhLQUF4L0MwSExBQXgrQzBITkFBeDlDMEhNQUF4OEMwSE9BQXg3QzBIUEFBeDZDMEhRQUF4NUMwSFJBQXg0QzBIU0FBeDNDMEhUQUF4MkMwSFVBQXgxQzBIV0FBeDBDMEhWQUF4ekMwRUdESElMUWRjQURIRUxRUVVNY0F0QjJBQU1id3RCQkF4dUMwSFpBQXh0QzBIYUFBeHNDMEhiQUF4ckMwSGNBQXhxQzBFRERHa0xRZDBBREdnTFFkNEFER2NMUWQ4QURHWUxRZUVBREdVTFFlQUFER1FMUWVJQURHTUxRZU1BREdJTFFRSU1ZUXRCNUFBTVlBdEI1UUFNWHd0QjVnQU1YZ3RCNXdBTVhRdEI2QUFNWEF0QjZRQU1Xd3RCNmdBTVdndEI2d0FNV1F0QjdBQU1XQXRCN1FBTVZ3dEI3Z0FNVmd0Qjd3QU1WUXRCOEFBTVZBdEI4UUFNVXd0QjhnQU1VZ3RCOHdBTVVRdEI5QUFNVUF0QjlRQU1Ud3RCOWdBTVRndEI5d0FNVFF0QitBQU1UQXRCK1FBTVN3dEIrZ0FNU2d0Qit3QU1TUXRCL0FBTVNBdEIvUUFNUnd0Qi9nQU1SZ3RCL3dBTVJRdEJnQUVNUkF0QmdRRU1Rd3RCZ2dFTVFndEJnd0VNUVF0QmhBRU1RQXRCaFFFTVB3dEJoZ0VNUGd0Qmh3RU1QUXRCaUFFTVBBdEJpUUVNT3d0QmlnRU1PZ3RCaXdFTU9RdEJqQUVNT0F0QmpRRU1Od3RCamdFTU5ndEJqd0VNTlF0QmtBRU1OQXRCa1FFTU13dEJrZ0VNTWd0Qmt3RU1NUXRCbEFFTU1BdEJsUUVNTHd0QmxnRU1MZ3RCbHdFTUxRdEJtQUVNTEF0Qm1RRU1Ld3RCbWdFTUtndEJtd0VNS1F0Qm5BRU1LQXRCblFFTUp3dEJuZ0VNSmd0Qm53RU1KUXRCb0FFTUpBdEJvUUVNSXd0Qm9nRU1JZ3RCb3dFTUlRdEJwQUVNSUF0QnBRRU1Id3RCcGdFTUhndEJwd0VNSFF0QnFBRU1IQXRCcVFFTUd3dEJxZ0VNR2d0QnF3RU1HUXRCckFFTUdBdEJyUUVNRnd0QnJnRU1GZ3RCQVF3VkMwR3ZBUXdVQzBHd0FRd1RDMEd4QVF3U0MwR3pBUXdSQzBHeUFRd1FDMEcwQVF3UEMwRzFBUXdPQzBHMkFRd05DMEczQVF3TUMwRzRBUXdMQzBHNUFRd0tDMEc2QVF3SkMwRzdBUXdJQzBIR0FRd0hDMEc4QVF3R0MwRzlBUXdGQzBHK0FRd0VDMEcvQVF3REMwSEFBUXdDQzBIQ0FRd0JDMEhCQVFzaEF3TkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUlDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUovQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQWdKL0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDZndKQUFrQUNRQUpBQW44Q1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUREc1lCQUFFQ0F3UUZCZ2NJQ1FvTERBME9EeEFSRWhNVUZSWVhHQmthR3h3ZEh5QWhJeVVtS0NvckxDOHdNVEl6TkRVMk56azZPenc5bEFOQVFrUkZSa2xMVGs5UVVWSlRWRlZXV0ZwYlhGMWVYMkJoWW1Oa1pXWm5hR3BzYjNCeGMzVjJlSGw2ZTN4L2dBR0JBWUlCZ3dHRUFZVUJoZ0dIQVlnQmlRR0tBWXNCakFHTkFZNEJqd0dRQVpFQmtnR1RBWlFCbFFHV0FaY0JtQUdaQVpvQm13R2NBWjBCbmdHZkFhQUJvUUdpQWFNQnBBR2xBYVlCcHdHb0Fha0JxZ0dyQWF3QnJRR3VBYThCc0FHeEFiSUJzd0cwQWJVQnRnRzNBYmdCdVFHNkFic0J2QUc5QWI0QnZ3SEFBY0VCd2dIREFjUUJ4UUhHQWNjQnlBSEpBY3NCekFITkFjNEJ6d0dLQTRrRGlBT0hBNFFEZ3dPQUEvc0MrZ0w1QXZnQzl3TDBBdk1DOGdMTEFzRUNzQUxaQVFzZ0FTQUVSdzN3QWtIZEFTRURETE1EQ3lBQklBUkhEY2dCUWNNQklRTU1zZ01MSUFFZ0JFY05lMEgzQUNFRERMRURDeUFCSUFSSERYQkI3d0FoQXd5d0F3c2dBU0FFUncxcFFlb0FJUU1NcndNTElBRWdCRWNOWlVIb0FDRURESzREQ3lBQklBUkhEV0pCNWdBaEF3eXRBd3NnQVNBRVJ3MGFRUmdoQXd5c0F3c2dBU0FFUncwVlFSSWhBd3lyQXdzZ0FTQUVSdzFDUWNVQUlRTU1xZ01MSUFFZ0JFY05ORUUvSVFNTXFRTUxJQUVnQkVjTk1rRThJUU1NcUFNTElBRWdCRWNOSzBFeElRTU1wd01MSUFJdEFDNUJBVVlObndNTXdRSUxRUUFoQUFKQUFrQUNRQ0FDTFFBcVJRMEFJQUl0QUN0RkRRQWdBaThCTUNJRFFRSnhSUTBCREFJTElBSXZBVEFpQTBFQmNVVU5BUXRCQVNFQUlBSXRBQ2hCQVVZTkFDQUNMd0V5SWdWQjVBQnJRZVFBU1EwQUlBVkJ6QUZHRFFBZ0JVR3dBa1lOQUNBRFFjQUFjUTBBUVFBaEFDQURRWWdFY1VHQUJFWU5BQ0FEUVNoeFFRQkhJUUFMSUFKQkFEc0JNQ0FDUVFBNkFDOGdBRVVOM3dJZ0FrSUFOd01nRE9BQ0MwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NMQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNNQVNBQVFSVkhEZDBDSUFKQkJEWUNIQ0FDSUFFMkFoUWdBa0d3R0RZQ0VDQUNRUlUyQWd4QkFDRURES1FEQ3lBQklBUkdCRUJCQmlFRERLUURDeUFCUVFGcUlRRkJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BbFFpQTBVTkFDQUNJQU1SQUFBaEFBc2dBQTNaQWd3Y0N5QUNRZ0EzQXlCQkVpRURESWtEQ3lBQklBUkhEUlpCSFNFRERLRURDeUFCSUFSSEJFQWdBVUVCYWlFQlFSQWhBd3lJQXd0QkJ5RURES0FEQ3lBQ0lBSXBBeUFpQ2lBRUlBRnJyU0lMZlNJTVFnQWdDaUFNV2hzM0F5QWdDaUFMV0EzVUFrRUlJUU1NbndNTElBRWdCRWNFUUNBQ1FRazJBZ2dnQWlBQk5nSUVRUlFoQXd5R0F3dEJDU0VEREo0REN5QUNLUU1nUWdCU0RjY0JJQUlnQWk4Qk1FR0FBWEk3QVRBTVFnc2dBU0FFUncwL1FkQUFJUU1NbkFNTElBRWdCRVlFUUVFTElRTU1uQU1MSUFGQkFXb2hBVUVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVUNJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRGM4Q0RNWUJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDU0NJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzR0FTQUFRUlZIRGMwQ0lBSkJDellDSENBQ0lBRTJBaFFnQWtHQ0dUWUNFQ0FDUVJVMkFneEJBQ0VEREpvREMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NTQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTBNSUFCQkZVY055Z0lnQWtFYU5nSWNJQUlnQVRZQ0ZDQUNRWUlaTmdJUUlBSkJGVFlDREVFQUlRTU1tUU1MUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FKTUlnTkZEUUFnQWlBREVRQUFJUUFMSUFCRkRjUUJJQUJCRlVjTnh3SWdBa0VMTmdJY0lBSWdBVFlDRkNBQ1FaRVhOZ0lRSUFKQkZUWUNERUVBSVFNTW1BTUxJQUVnQkVZRVFFRVBJUU1NbUFNTElBRXRBQUFpQUVFN1JnMEhJQUJCRFVjTnhBSWdBVUVCYWlFQkRNTUJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzREFTQUFRUlZIRGNJQ0lBSkJEellDSENBQ0lBRTJBaFFnQWtHUkZ6WUNFQ0FDUVJVMkFneEJBQ0VEREpZREN3TkFJQUV0QUFCQjhEVnFMUUFBSWdCQkFVY0VRQ0FBUVFKSERjRUNJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQlFRRnFJZ0VRTFNJQURjSUNETVVCQ3lBRUlBRkJBV29pQVVjTkFBdEJFaUVEREpVREMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NUQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTNGQVNBQVFSVkhEYjBDSUFKQkd6WUNIQ0FDSUFFMkFoUWdBa0dSRnpZQ0VDQUNRUlUyQWd4QkFDRURESlFEQ3lBQklBUkdCRUJCRmlFRERKUURDeUFDUVFvMkFnZ2dBaUFCTmdJRVFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSklJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEY0lCSUFCQkZVY051UUlnQWtFVk5nSWNJQUlnQVRZQ0ZDQUNRWUlaTmdJUUlBSkJGVFlDREVFQUlRTU1rd01MSUFFZ0JFY0VRQU5BSUFFdEFBQkI4RGRxTFFBQUlnQkJBa2NFUUFKQUlBQkJBV3NPQk1RQ3ZRSUF2Z0s5QWdzZ0FVRUJhaUVCUVFnaEF3ejhBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFSVWhBd3lUQXd0QkZTRURESklEQ3dOQUlBRXRBQUJCOERscUxRQUFJZ0JCQWtjRVFDQUFRUUZyRGdURkFyY0N3d0s0QXJjQ0N5QUVJQUZCQVdvaUFVY05BQXRCR0NFRERKRURDeUFCSUFSSEJFQWdBa0VMTmdJSUlBSWdBVFlDQkVFSElRTU0rQUlMUVJraEF3eVFBd3NnQVVFQmFpRUJEQUlMSUFFZ0JFWUVRRUVhSVFNTWp3TUxBa0FnQVMwQUFFRU5hdzRVdFFHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndFQXZ3RUxRUUFoQXlBQ1FRQTJBaHdnQWtHdkN6WUNFQ0FDUVFJMkFnd2dBaUFCUVFGcU5nSVVESTREQ3lBQklBUkdCRUJCR3lFRERJNERDeUFCTFFBQUlnQkJPMGNFUUNBQVFRMUhEYkVDSUFGQkFXb2hBUXk2QVFzZ0FVRUJhaUVCQzBFaUlRTU04d0lMSUFFZ0JFWUVRRUVjSVFNTWpBTUxRZ0FoQ2dKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQWdBUzBBQUVFd2F3NDN3UUxBQWdBQkFnTUVCUVlIMEFIUUFkQUIwQUhRQWRBQjBBRUlDUW9MREEzUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCRGc4UUVSSVQwQUVMUWdJaENnekFBZ3RDQXlFS0RMOENDMElFSVFvTXZnSUxRZ1VoQ2d5OUFndENCaUVLREx3Q0MwSUhJUW9NdXdJTFFnZ2hDZ3k2QWd0Q0NTRUtETGtDQzBJS0lRb011QUlMUWdzaENneTNBZ3RDRENFS0RMWUNDMElOSVFvTXRRSUxRZzRoQ2d5MEFndENEeUVLRExNQ0MwSUtJUW9Nc2dJTFFnc2hDZ3l4QWd0Q0RDRUtETEFDQzBJTklRb01yd0lMUWc0aENneXVBZ3RDRHlFS0RLMENDMElBSVFvQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUV0QUFCQk1Hc09OOEFDdndJQUFRSURCQVVHQjc0Q3ZnSytBcjRDdmdLK0FyNENDQWtLQ3d3TnZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQWc0UEVCRVNFNzRDQzBJQ0lRb012d0lMUWdNaENneStBZ3RDQkNFS0RMMENDMElGSVFvTXZBSUxRZ1loQ2d5N0FndENCeUVLRExvQ0MwSUlJUW9NdVFJTFFna2hDZ3k0QWd0Q0NpRUtETGNDQzBJTElRb010Z0lMUWd3aENneTFBZ3RDRFNFS0RMUUNDMElPSVFvTXN3SUxRZzhoQ2d5eUFndENDaUVLRExFQ0MwSUxJUW9Nc0FJTFFnd2hDZ3l2QWd0Q0RTRUtESzRDQzBJT0lRb01yUUlMUWc4aENneXNBZ3NnQWlBQ0tRTWdJZ29nQkNBQmE2MGlDMzBpREVJQUlBb2dERm9iTndNZ0lBb2dDMWdOcHdKQkh5RURESWtEQ3lBQklBUkhCRUFnQWtFSk5nSUlJQUlnQVRZQ0JFRWxJUU1NOEFJTFFTQWhBd3lJQXd0QkFTRUZJQUl2QVRBaUEwRUljVVVFUUNBQ0tRTWdRZ0JTSVFVTEFrQWdBaTBBTGdSQVFRRWhBQ0FDTFFBcFFRVkdEUUVnQTBIQUFIRkZJQVZ4UlEwQkMwRUFJUUFnQTBIQUFIRU5BRUVDSVFBZ0EwRUljUTBBSUFOQmdBUnhCRUFDUUNBQ0xRQW9RUUZIRFFBZ0FpMEFMVUVLY1EwQVFRVWhBQXdDQzBFRUlRQU1BUXNnQTBFZ2NVVUVRQUpBSUFJdEFDaEJBVVlOQUNBQ0x3RXlJZ0JCNUFCclFlUUFTUTBBSUFCQnpBRkdEUUFnQUVHd0FrWU5BRUVFSVFBZ0EwRW9jVVVOQWlBRFFZZ0VjVUdBQkVZTkFndEJBQ0VBREFFTFFRQkJBeUFDS1FNZ1VCc2hBQXNnQUVFQmF3NEZ2Z0lBc0FFQnBBS2hBZ3RCRVNFRERPMENDeUFDUVFFNkFDOE1oQU1MSUFFZ0JFY05uUUpCSkNFRERJUURDeUFCSUFSSERSeEJ4Z0FoQXd5REF3dEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9Ba1FpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVOSnlBQVFSVkhEWmdDSUFKQjBBQTJBaHdnQWlBQk5nSVVJQUpCa1JnMkFoQWdBa0VWTmdJTVFRQWhBd3lDQXdzZ0FTQUVSZ1JBUVNnaEF3eUNBd3RCQUNFRElBSkJBRFlDQkNBQ1FRdzJBZ2dnQWlBQklBRVFLaUlBUlEyVUFpQUNRU2MyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNEQXlCQXdzZ0FTQUVSZ1JBUVNraEF3eUJBd3NnQVMwQUFDSUFRU0JHRFJNZ0FFRUpSdzJWQWlBQlFRRnFJUUVNRkFzZ0FTQUVSd1JBSUFGQkFXb2hBUXdXQzBFcUlRTU0vd0lMSUFFZ0JFWUVRRUVySVFNTS93SUxJQUV0QUFBaUFFRUpSeUFBUVNCSGNRMlFBaUFDTFFBc1FRaEhEZDBDSUFKQkFEb0FMQXpkQWdzZ0FTQUVSZ1JBUVN3aEF3eitBZ3NnQVMwQUFFRUtSdzJPQWlBQlFRRnFJUUVNc0FFTElBRWdCRWNOaWdKQkx5RUREUHdDQ3dOQUlBRXRBQUFpQUVFZ1J3UkFJQUJCQ21zT0JJUUNpQUtJQW9RQ2hnSUxJQVFnQVVFQmFpSUJSdzBBQzBFeElRTU0rd0lMUVRJaEF5QUJJQVJHRGZvQ0lBSW9BZ0FpQUNBRUlBRnJhaUVISUFFZ0FHdEJBMm9oQmdKQUEwQWdBRUh3TzJvdEFBQWdBUzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRFFFZ0FFRURSZ1JBUVFZaEFRemlBZ3NnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBYzJBZ0FNK3dJTElBSkJBRFlDQUF5R0FndEJNeUVESUFRZ0FTSUFSZzM1QWlBRUlBRnJJQUlvQWdBaUFXb2hCeUFBSUFGclFRaHFJUVlDUUFOQUlBRkI5RHRxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzBCSUFGQkNFWUVRRUVGSVFFTTRRSUxJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBSE5nSUFEUG9DQ3lBQ1FRQTJBZ0FnQUNFQkRJVUNDMEUwSVFNZ0JDQUJJZ0JHRGZnQ0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdKQUEwQWdBVUhRd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncwQklBRkJCVVlFUUVFSElRRU00QUlMSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUhOZ0lBRFBrQ0N5QUNRUUEyQWdBZ0FDRUJESVFDQ3lBQklBUkhCRUFEUUNBQkxRQUFRWUErYWkwQUFDSUFRUUZIQkVBZ0FFRUNSZzBKRElFQ0N5QUVJQUZCQVdvaUFVY05BQXRCTUNFRERQZ0NDMEV3SVFNTTl3SUxJQUVnQkVjRVFBTkFJQUV0QUFBaUFFRWdSd1JBSUFCQkNtc09CUDhCL2dIK0FmOEIvZ0VMSUFRZ0FVRUJhaUlCUncwQUMwRTRJUU1NOXdJTFFUZ2hBd3oyQWdzRFFDQUJMUUFBSWdCQklFY2dBRUVKUjNFTjlnRWdCQ0FCUVFGcUlnRkhEUUFMUVR3aEF3ejFBZ3NEUUNBQkxRQUFJZ0JCSUVjRVFBSkFJQUJCQ21zT0JQa0JCQVQ1QVFBTElBQkJMRVlOOVFFTUF3c2dCQ0FCUVFGcUlnRkhEUUFMUVQ4aEF3ejBBZ3RCd0FBaEF5QUJJQVJHRGZNQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCbW9oQmdKQUEwQWdBRUdBUUdzdEFBQWdBUzBBQUVFZ2NrY05BU0FBUVFaR0Rkc0NJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFEUFFDQ3lBQ1FRQTJBZ0FMUVRZaEF3elpBZ3NnQVNBRVJnUkFRY0VBSVFNTThnSUxJQUpCRERZQ0NDQUNJQUUyQWdRZ0FpMEFMRUVCYXc0RSt3SHVBZXdCNndIVUFnc2dBVUVCYWlFQkRQb0JDeUFCSUFSSEJFQURRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeElnQkJDVVlOQUNBQVFTQkdEUUFDUUFKQUFrQUNRQ0FBUWVNQWF3NFRBQU1EQXdNREF3TUJBd01EQXdNREF3TURBZ01MSUFGQkFXb2hBVUV4SVFNTTNBSUxJQUZCQVdvaEFVRXlJUU1NMndJTElBRkJBV29oQVVFeklRTU0yZ0lMRFA0QkN5QUVJQUZCQVdvaUFVY05BQXRCTlNFRERQQUNDMEUxSVFNTTd3SUxJQUVnQkVjRVFBTkFJQUV0QUFCQmdEeHFMUUFBUVFGSERmY0JJQVFnQVVFQmFpSUJSdzBBQzBFOUlRTU03d0lMUVQwaEF3enVBZ3RCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWtBaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTkFTQUFRUlZIRGVZQklBSkJ3Z0EyQWh3Z0FpQUJOZ0lVSUFKQjR4ZzJBaEFnQWtFVk5nSU1RUUFoQXd6dEFnc2dBVUVCYWlFQkMwRThJUU1NMGdJTElBRWdCRVlFUUVIQ0FDRURET3NDQ3dKQUEwQUNRQ0FCTFFBQVFRbHJEaGdBQXN3Q3pBTFJBc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1Bc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1BZ0RNQWdzZ0JDQUJRUUZxSWdGSERRQUxRY0lBSVFNTTZ3SUxJQUZCQVdvaEFTQUNMUUF0UVFGeFJRMytBUXRCTENFREROQUNDeUFCSUFSSERkNEJRY1FBSVFNTTZBSUxBMEFnQVMwQUFFR1F3QUJxTFFBQVFRRkhEWndCSUFRZ0FVRUJhaUlCUncwQUMwSEZBQ0VERE9jQ0N5QUJMUUFBSWdCQklFWU4vZ0VnQUVFNlJ3M0FBaUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXBJZ0FOM2dFTTNRRUxRY2NBSVFNZ0JDQUJJZ0JHRGVVQ0lBUWdBV3NnQWlnQ0FDSUJhaUVISUFBZ0FXdEJCV29oQmdOQUlBRkJrTUlBYWkwQUFDQUFMUUFBSWdWQklISWdCU0FGUWNFQWEwSC9BWEZCR2trYlFmOEJjVWNOdndJZ0FVRUZSZzNDQWlBQlFRRnFJUUVnQkNBQVFRRnFJZ0JIRFFBTElBSWdCellDQUF6bEFndEJ5QUFoQXlBRUlBRWlBRVlONUFJZ0JDQUJheUFDS0FJQUlnRnFJUWNnQUNBQmEwRUphaUVHQTBBZ0FVR1d3Z0JxTFFBQUlBQXRBQUFpQlVFZ2NpQUZJQVZCd1FCclFmOEJjVUVhU1J0Qi93RnhSdzIrQWtFQ0lBRkJDVVlOd2dJYUlBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURPUUNDeUFCSUFSR0JFQkJ5UUFoQXd6a0Fnc0NRQUpBSUFFdEFBQWlBRUVnY2lBQUlBQkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFFlNEFhdzRIQUw4Q3Z3Sy9BcjhDdndJQnZ3SUxJQUZCQVdvaEFVRStJUU1NeXdJTElBRkJBV29oQVVFL0lRTU15Z0lMUWNvQUlRTWdCQ0FCSWdCR0RlSUNJQVFnQVdzZ0FpZ0NBQ0lCYWlFR0lBQWdBV3RCQVdvaEJ3TkFJQUZCb01JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnZBSWdBVUVCUmcyK0FpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQUlnQmpZQ0FBemlBZ3RCeXdBaEF5QUVJQUVpQUVZTjRRSWdCQ0FCYXlBQ0tBSUFJZ0ZxSVFjZ0FDQUJhMEVPYWlFR0EwQWdBVUdpd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncyN0FpQUJRUTVHRGI0Q0lBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURPRUNDMEhNQUNFRElBUWdBU0lBUmczZ0FpQUVJQUZySUFJb0FnQWlBV29oQnlBQUlBRnJRUTlxSVFZRFFDQUJRY0RDQUdvdEFBQWdBQzBBQUNJRlFTQnlJQVVnQlVIQkFHdEIvd0Z4UVJwSkcwSC9BWEZIRGJvQ1FRTWdBVUVQUmcyK0Fob2dBVUVCYWlFQklBUWdBRUVCYWlJQVJ3MEFDeUFDSUFjMkFnQU00QUlMUWMwQUlRTWdCQ0FCSWdCR0RkOENJQVFnQVdzZ0FpZ0NBQ0lCYWlFSElBQWdBV3RCQldvaEJnTkFJQUZCME1JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnVRSkJCQ0FCUVFWR0RiMENHaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFJZ0J6WUNBQXpmQWdzZ0FTQUVSZ1JBUWM0QUlRTU0zd0lMQWtBQ1FBSkFBa0FnQVMwQUFDSUFRU0J5SUFBZ0FFSEJBR3RCL3dGeFFScEpHMEgvQVhGQjR3QnJEaE1BdkFLOEFyd0N2QUs4QXJ3Q3ZBSzhBcndDdkFLOEFyd0NBYndDdkFLOEFnSUR2QUlMSUFGQkFXb2hBVUhCQUNFRERNZ0NDeUFCUVFGcUlRRkJ3Z0FoQXd6SEFnc2dBVUVCYWlFQlFjTUFJUU1NeGdJTElBRkJBV29oQVVIRUFDRURETVVDQ3lBQklBUkhCRUFnQWtFTk5nSUlJQUlnQVRZQ0JFSEZBQ0VERE1VQ0MwSFBBQ0VERE4wQ0N3SkFBa0FnQVMwQUFFRUthdzRFQVpBQmtBRUFrQUVMSUFGQkFXb2hBUXRCS0NFRERNTUNDeUFCSUFSR0JFQkIwUUFoQXd6Y0Fnc2dBUzBBQUVFZ1J3MEFJQUZCQVdvaEFTQUNMUUF0UVFGeFJRM1FBUXRCRnlFRERNRUNDeUFCSUFSSERjc0JRZElBSVFNTTJRSUxRZE1BSVFNZ0FTQUVSZzNZQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCaUFCSUFCclFRRnFJUVVEUUNBQkxRQUFJQUJCMXNJQWFpMEFBRWNOeHdFZ0FFRUJSZzNLQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCallDQUF6WUFnc2dBU0FFUmdSQVFkVUFJUU1NMkFJTElBRXRBQUJCQ2tjTndnRWdBVUVCYWlFQkRNb0JDeUFCSUFSR0JFQkIxZ0FoQXd6WEFnc0NRQUpBSUFFdEFBQkJDbXNPQkFEREFjTUJBY01CQ3lBQlFRRnFJUUVNeWdFTElBRkJBV29oQVVIS0FDRURETDBDQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1BDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQURiOEJRYzBBSVFNTXZBSUxJQUl0QUNsQklrWU56d0lNaVFFTElBUWdBU0lGUmdSQVFkc0FJUU1NMUFJTFFRQWhBRUVCSVFGQkFTRUdRUUFoQXdKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUNBRkxRQUFRVEJyRGdyRkFjUUJBQUVDQXdRRkJnakRBUXRCQWd3R0MwRUREQVVMUVFRTUJBdEJCUXdEQzBFR0RBSUxRUWNNQVF0QkNBc2hBMEVBSVFGQkFDRUdETDBCQzBFSklRTkJBU0VBUVFBaEFVRUFJUVlNdkFFTElBRWdCRVlFUUVIZEFDRURETk1DQ3lBQkxRQUFRUzVIRGJnQklBRkJBV29oQVF5SUFRc2dBU0FFUncyMkFVSGZBQ0VERE5FQ0N5QUJJQVJIQkVBZ0FrRU9OZ0lJSUFJZ0FUWUNCRUhRQUNFRERMZ0NDMEhnQUNFREROQUNDMEhoQUNFRElBRWdCRVlOendJZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRURhaUVHQTBBZ0FTMEFBQ0FBUWVMQ0FHb3RBQUJIRGJFQklBQkJBMFlOc3dFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTXp3SUxRZUlBSVFNZ0FTQUVSZzNPQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlEUUNBQkxRQUFJQUJCNXNJQWFpMEFBRWNOc0FFZ0FFRUNSZzJ2QVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6T0FndEI0d0FoQXlBQklBUkdEYzBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ05BSUFFdEFBQWdBRUhwd2dCcUxRQUFSdzJ2QVNBQVFRTkdEYTBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRE0wQ0N5QUJJQVJHQkVCQjVRQWhBd3pOQWdzZ0FVRUJhaUVCUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FJd0lnTkZEUUFnQWlBREVRQUFJUUFMSUFBTnFnRkIxZ0FoQXd5ekFnc2dBU0FFUndSQUEwQWdBUzBBQUNJQVFTQkhCRUFDUUFKQUFrQWdBRUhJQUdzT0N3QUJzd0d6QWJNQnN3R3pBYk1Cc3dHekFRS3pBUXNnQVVFQmFpRUJRZElBSVFNTXR3SUxJQUZCQVdvaEFVSFRBQ0VERExZQ0N5QUJRUUZxSVFGQjFBQWhBd3kxQWdzZ0JDQUJRUUZxSWdGSERRQUxRZVFBSVFNTXpBSUxRZVFBSVFNTXl3SUxBMEFnQVMwQUFFSHd3Z0JxTFFBQUlnQkJBVWNFUUNBQVFRSnJEZ09uQWFZQnBRR2tBUXNnQkNBQlFRRnFJZ0ZIRFFBTFFlWUFJUU1NeWdJTElBRkJBV29nQVNBRVJ3MENHa0huQUNFRERNa0NDd05BSUFFdEFBQkI4TVFBYWkwQUFDSUFRUUZIQkVBQ1FDQUFRUUpyRGdTaUFhRUJvQUVBbndFTFFkY0FJUU1Nc1FJTElBUWdBVUVCYWlJQlJ3MEFDMEhvQUNFRERNZ0NDeUFCSUFSR0JFQkI2UUFoQXd6SUFnc0NRQ0FCTFFBQUlnQkJDbXNPR3JjQm13R2JBYlFCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCcEFHYkFac0JBSmtCQ3lBQlFRRnFDeUVCUVFZaEF3eXRBZ3NEUUNBQkxRQUFRZkRHQUdvdEFBQkJBVWNOZlNBRUlBRkJBV29pQVVjTkFBdEI2Z0FoQXd6RkFnc2dBVUVCYWlBQklBUkhEUUlhUWVzQUlRTU14QUlMSUFFZ0JFWUVRRUhzQUNFRERNUUNDeUFCUVFGcURBRUxJQUVnQkVZRVFFSHRBQ0VERE1NQ0N5QUJRUUZxQ3lFQlFRUWhBd3lvQWdzZ0FTQUVSZ1JBUWU0QUlRTU13UUlMQWtBQ1FBSkFJQUV0QUFCQjhNZ0FhaTBBQUVFQmF3NEhrQUdQQVk0QkFId0JBbzBCQ3lBQlFRRnFJUUVNQ3dzZ0FVRUJhZ3lUQVF0QkFDRURJQUpCQURZQ0hDQUNRWnNTTmdJUUlBSkJCellDRENBQ0lBRkJBV28yQWhRTXdBSUxBa0FEUUNBQkxRQUFRZkRJQUdvdEFBQWlBRUVFUndSQUFrQUNRQ0FBUVFGckRnZVVBWk1Ca2dHTkFRQUVBWTBCQzBIYUFDRURES29DQ3lBQlFRRnFJUUZCM0FBaEF3eXBBZ3NnQkNBQlFRRnFJZ0ZIRFFBTFFlOEFJUU1Nd0FJTElBRkJBV29Na1FFTElBUWdBU0lBUmdSQVFmQUFJUU1NdndJTElBQXRBQUJCTDBjTkFTQUFRUUZxSVFFTUJ3c2dCQ0FCSWdCR0JFQkI4UUFoQXd5K0Fnc2dBQzBBQUNJQlFTOUdCRUFnQUVFQmFpRUJRZDBBSVFNTXBRSUxJQUZCQ21zaUEwRVdTdzBBSUFBaEFVRUJJQU4wUVltQWdBSnhEZmtCQzBFQUlRTWdBa0VBTmdJY0lBSWdBRFlDRkNBQ1FZd2NOZ0lRSUFKQkJ6WUNEQXk4QWdzZ0FTQUVSd1JBSUFGQkFXb2hBVUhlQUNFRERLTUNDMEh5QUNFRERMc0NDeUFCSUFSR0JFQkI5QUFoQXd5N0Fnc0NRQ0FCTFFBQVFmRE1BR290QUFCQkFXc09BL2NCY3dDQ0FRdEI0UUFoQXd5aEFnc2dBU0FFUndSQUEwQWdBUzBBQUVId3lnQnFMUUFBSWdCQkEwY0VRQUpBSUFCQkFXc09BdmtCQUlVQkMwSGZBQ0VEREtNQ0N5QUVJQUZCQVdvaUFVY05BQXRCOHdBaEF3eTZBZ3RCOHdBaEF3eTVBZ3NnQVNBRVJ3UkFJQUpCRHpZQ0NDQUNJQUUyQWdSQjRBQWhBd3lnQWd0QjlRQWhBd3k0QWdzZ0FTQUVSZ1JBUWZZQUlRTU11QUlMSUFKQkR6WUNDQ0FDSUFFMkFnUUxRUU1oQXd5ZEFnc0RRQ0FCTFFBQVFTQkhEWTRDSUFRZ0FVRUJhaUlCUncwQUMwSDNBQ0VERExVQ0N5QUJJQVJHQkVCQitBQWhBd3kxQWdzZ0FTMEFBRUVnUncxNklBRkJBV29oQVF4YkMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NPQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFEWGdNZ0FJTElBRWdCRVlFUUVINkFDRURETE1DQ3lBQkxRQUFRY3dBUncxMElBRkJBV29oQVVFVERIWUxRZnNBSVFNZ0FTQUVSZzJ4QWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlEUUNBQkxRQUFJQUJCOE00QWFpMEFBRWNOY3lBQVFRVkdEWFVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNc1FJTElBRWdCRVlFUUVIOEFDRURETEVDQ3dKQUFrQWdBUzBBQUVIREFHc09EQUIwZEhSMGRIUjBkSFIwQVhRTElBRkJBV29oQVVIbUFDRURESmdDQ3lBQlFRRnFJUUZCNXdBaEF3eVhBZ3RCL1FBaEF5QUJJQVJHRGE4Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFlM1BBR290QUFCSERYSWdBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURMQUNDeUFDUVFBMkFnQWdCa0VCYWlFQlFSQU1jd3RCL2dBaEF5QUJJQVJHRGE0Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCV29oQmdKQUEwQWdBUzBBQUNBQVFmYk9BR290QUFCSERYRWdBRUVGUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLOENDeUFDUVFBMkFnQWdCa0VCYWlFQlFSWU1jZ3RCL3dBaEF5QUJJQVJHRGEwQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFmek9BR290QUFCSERYQWdBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLNENDeUFDUVFBMkFnQWdCa0VCYWlFQlFRVU1jUXNnQVNBRVJnUkFRWUFCSVFNTXJRSUxJQUV0QUFCQjJRQkhEVzRnQVVFQmFpRUJRUWdNY0FzZ0FTQUVSZ1JBUVlFQklRTU1yQUlMQWtBQ1FDQUJMUUFBUWM0QWF3NERBRzhCYndzZ0FVRUJhaUVCUWVzQUlRTU1rd0lMSUFGQkFXb2hBVUhzQUNFRERKSUNDeUFCSUFSR0JFQkJnZ0VoQXd5ckFnc0NRQUpBSUFFdEFBQkJ5QUJyRGdnQWJtNXVibTV1QVc0TElBRkJBV29oQVVIcUFDRURESklDQ3lBQlFRRnFJUUZCN1FBaEF3eVJBZ3RCZ3dFaEF5QUJJQVJHRGFrQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFZRFBBR290QUFCSERXd2dBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLb0NDeUFDUVFBMkFnQWdCa0VCYWlFQlFRQU1iUXRCaEFFaEF5QUJJQVJHRGFnQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCR29oQmdKQUEwQWdBUzBBQUNBQVFZUFBBR290QUFCSERXc2dBRUVFUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURLa0NDeUFDUVFBMkFnQWdCa0VCYWlFQlFTTU1iQXNnQVNBRVJnUkFRWVVCSVFNTXFBSUxBa0FDUUNBQkxRQUFRY3dBYXc0SUFHdHJhMnRyYXdGckN5QUJRUUZxSVFGQjd3QWhBd3lQQWdzZ0FVRUJhaUVCUWZBQUlRTU1qZ0lMSUFFZ0JFWUVRRUdHQVNFRERLY0NDeUFCTFFBQVFjVUFSdzFvSUFGQkFXb2hBUXhnQzBHSEFTRURJQUVnQkVZTnBRSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVEYWlFR0FrQURRQ0FCTFFBQUlBQkJpTThBYWkwQUFFY05hQ0FBUVFOR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1wZ0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJMUXhwQzBHSUFTRURJQUVnQkVZTnBBSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVJYWlFR0FrQURRQ0FCTFFBQUlBQkIwTThBYWkwQUFFY05aeUFBUVFoR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1wUUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJLUXhvQ3lBQklBUkdCRUJCaVFFaEF3eWtBZ3RCQVNBQkxRQUFRZDhBUncxbkdpQUJRUUZxSVFFTVhndEJpZ0VoQXlBQklBUkdEYUlDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ05BSUFFdEFBQWdBRUdNendCcUxRQUFSdzFrSUFCQkFVWU4rZ0VnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNb2dJTFFZc0JJUU1nQVNBRVJnMmhBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdPendCcUxRQUFSdzFrSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlpQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVDREdVTFFZd0JJUU1nQVNBRVJnMmdBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUh3endCcUxRQUFSdzFqSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXloQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVmREdRTFFZMEJJUU1nQVNBRVJnMmZBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFGcUlRWUNRQU5BSUFFdEFBQWdBRUh5endCcUxRQUFSdzFpSUFCQkFVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlnQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVKREdNTElBRWdCRVlFUUVHT0FTRURESjhDQ3dKQUFrQWdBUzBBQUVISkFHc09Cd0JpWW1KaVlnRmlDeUFCUVFGcUlRRkIrQUFoQXd5R0Fnc2dBVUVCYWlFQlFma0FJUU1NaFFJTFFZOEJJUU1nQVNBRVJnMmRBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdSendCcUxRQUFSdzFnSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXllQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVZREdFTFFaQUJJUU1nQVNBRVJnMmNBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdYendCcUxRQUFSdzFmSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlkQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVYREdBTFFaRUJJUU1nQVNBRVJnMmJBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFacUlRWUNRQU5BSUFFdEFBQWdBRUdhendCcUxRQUFSdzFlSUFCQkJrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXljQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVWREY4TFFaSUJJUU1nQVNBRVJnMmFBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFWcUlRWUNRQU5BSUFFdEFBQWdBRUdoendCcUxRQUFSdzFkSUFCQkJVWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXliQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVlREY0TElBRWdCRVlFUUVHVEFTRURESm9DQ3lBQkxRQUFRY3dBUncxYklBRkJBV29oQVVFS0RGMExJQUVnQkVZRVFFR1VBU0VEREprQ0N3SkFBa0FnQVMwQUFFSEJBR3NPRHdCY1hGeGNYRnhjWEZ4Y1hGeGNBVndMSUFGQkFXb2hBVUgrQUNFRERJQUNDeUFCUVFGcUlRRkIvd0FoQXd6L0FRc2dBU0FFUmdSQVFaVUJJUU1NbUFJTEFrQUNRQ0FCTFFBQVFjRUFhdzREQUZzQld3c2dBVUVCYWlFQlFmMEFJUU1NL3dFTElBRkJBV29oQVVHQUFTRUREUDRCQzBHV0FTRURJQUVnQkVZTmxnSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJwODhBYWkwQUFFY05XU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sd0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJDd3hhQ3lBQklBUkdCRUJCbHdFaEF3eVdBZ3NDUUFKQUFrQUNRQ0FCTFFBQVFTMXJEaU1BVzF0YlcxdGJXMXRiVzF0YlcxdGJXMXRiVzF0Ylcxc0JXMXRiVzFzQ1cxdGJBMXNMSUFGQkFXb2hBVUg3QUNFRERQOEJDeUFCUVFGcUlRRkIvQUFoQXd6K0FRc2dBVUVCYWlFQlFZRUJJUU1NL1FFTElBRkJBV29oQVVHQ0FTRUREUHdCQzBHWUFTRURJQUVnQkVZTmxBSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVFYWlFR0FrQURRQ0FCTFFBQUlBQkJxYzhBYWkwQUFFY05WeUFBUVFSR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sUUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJHUXhZQzBHWkFTRURJQUVnQkVZTmt3SWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVGYWlFR0FrQURRQ0FCTFFBQUlBQkJyczhBYWkwQUFFY05WaUFBUVFWR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1sQUlMSUFKQkFEWUNBQ0FHUVFGcUlRRkJCZ3hYQzBHYUFTRURJQUVnQkVZTmtnSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJ0TThBYWkwQUFFY05WU0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1rd0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJIQXhXQzBHYkFTRURJQUVnQkVZTmtRSWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVCYWlFR0FrQURRQ0FCTFFBQUlBQkJ0czhBYWkwQUFFY05WQ0FBUVFGR0RRRWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU1rZ0lMSUFKQkFEWUNBQ0FHUVFGcUlRRkJKd3hWQ3lBQklBUkdCRUJCbkFFaEF3eVJBZ3NDUUFKQUlBRXRBQUJCMUFCckRnSUFBVlFMSUFGQkFXb2hBVUdHQVNFRERQZ0JDeUFCUVFGcUlRRkJod0VoQXd6M0FRdEJuUUVoQXlBQklBUkdEWThDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJqUEFHb3RBQUJIRFZJZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREpBQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVNZTVV3dEJuZ0VoQXlBQklBUkdEWTRDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFXb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJyUEFHb3RBQUJIRFZFZ0FFRUJSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREk4Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVFNTVVndEJud0VoQXlBQklBUkdEWTBDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkFtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWUzUEFHb3RBQUJIRFZBZ0FFRUNSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREk0Q0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVF3TVVRdEJvQUVoQXlBQklBUkdEWXdDSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWJ6UEFHb3RBQUJIRFU4Z0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBREkwQ0N5QUNRUUEyQWdBZ0JrRUJhaUVCUVEwTVVBc2dBU0FFUmdSQVFhRUJJUU1NakFJTEFrQUNRQ0FCTFFBQVFjWUFhdzRMQUU5UFQwOVBUMDlQVHdGUEN5QUJRUUZxSVFGQml3RWhBd3p6QVFzZ0FVRUJhaUVCUVl3QklRTU04Z0VMSUFFZ0JFWUVRRUdpQVNFRERJc0NDeUFCTFFBQVFkQUFSdzFNSUFGQkFXb2hBUXhHQ3lBQklBUkdCRUJCb3dFaEF3eUtBZ3NDUUFKQUlBRXRBQUJCeVFCckRnY0JUVTFOVFUwQVRRc2dBVUVCYWlFQlFZNEJJUU1NOFFFTElBRkJBV29oQVVFaURFMExRYVFCSVFNZ0FTQUVSZzJJQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVIQXp3QnFMUUFBUncxTElBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5SkFnc2dBa0VBTmdJQUlBWkJBV29oQVVFZERFd0xJQUVnQkVZRVFFR2xBU0VERElnQ0N3SkFBa0FnQVMwQUFFSFNBR3NPQXdCTEFVc0xJQUZCQVdvaEFVR1FBU0VERE84QkN5QUJRUUZxSVFGQkJBeExDeUFCSUFSR0JFQkJwZ0VoQXd5SEFnc0NRQUpBQWtBQ1FBSkFJQUV0QUFCQndRQnJEaFVBVFUxTlRVMU5UVTFOVFFGTlRRSk5UUU5OVFFSTkN5QUJRUUZxSVFGQmlBRWhBd3p4QVFzZ0FVRUJhaUVCUVlrQklRTU04QUVMSUFGQkFXb2hBVUdLQVNFRERPOEJDeUFCUVFGcUlRRkJqd0VoQXd6dUFRc2dBVUVCYWlFQlFaRUJJUU1NN1FFTFFhY0JJUU1nQVNBRVJnMkZBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUh0endCcUxRQUFSdzFJSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlHQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVSREVrTFFhZ0JJUU1nQVNBRVJnMkVBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhDendCcUxRQUFSdzFISUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlGQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVzREVnTFFha0JJUU1nQVNBRVJnMkRBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFScUlRWUNRQU5BSUFFdEFBQWdBRUhGendCcUxRQUFSdzFHSUFCQkJFWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlFQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVyREVjTFFhb0JJUU1nQVNBRVJnMkNBaUFDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhLendCcUxRQUFSdzFGSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlEQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVVREVZTElBRWdCRVlFUUVHckFTRURESUlDQ3dKQUFrQUNRQUpBSUFFdEFBQkJ3Z0JyRGc4QUFRSkhSMGRIUjBkSFIwZEhSd05IQ3lBQlFRRnFJUUZCa3dFaEF3enJBUXNnQVVFQmFpRUJRWlFCSVFNTTZnRUxJQUZCQVdvaEFVR1ZBU0VERE9rQkN5QUJRUUZxSVFGQmxnRWhBd3pvQVFzZ0FTQUVSZ1JBUWF3QklRTU1nUUlMSUFFdEFBQkJ4UUJIRFVJZ0FVRUJhaUVCREQwTFFhMEJJUU1nQVNBRVJnMy9BU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUhOendCcUxRQUFSdzFDSUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXlBQWdzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVPREVNTElBRWdCRVlFUUVHdUFTRUREUDhCQ3lBQkxRQUFRZEFBUncxQUlBRkJBV29oQVVFbERFSUxRYThCSVFNZ0FTQUVSZzM5QVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRaHFJUVlDUUFOQUlBRXRBQUFnQUVIUXp3QnFMUUFBUncxQUlBQkJDRVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6K0FRc2dBa0VBTmdJQUlBWkJBV29oQVVFcURFRUxJQUVnQkVZRVFFR3dBU0VERFAwQkN3SkFBa0FnQVMwQUFFSFZBR3NPQ3dCQVFFQkFRRUJBUUVBQlFBc2dBVUVCYWlFQlFab0JJUU1NNUFFTElBRkJBV29oQVVHYkFTRURET01CQ3lBQklBUkdCRUJCc1FFaEF3ejhBUXNDUUFKQUlBRXRBQUJCd1FCckRoUUFQejgvUHo4L1B6OC9QejgvUHo4L1B6OC9BVDhMSUFGQkFXb2hBVUdaQVNFRERPTUJDeUFCUVFGcUlRRkJuQUVoQXd6aUFRdEJzZ0VoQXlBQklBUkdEZm9CSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkEyb2hCZ0pBQTBBZ0FTMEFBQ0FBUWRuUEFHb3RBQUJIRFQwZ0FFRURSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBzQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVNFTVBndEJzd0VoQXlBQklBUkdEZmtCSUFJb0FnQWlBQ0FFSUFGcmFpRUZJQUVnQUd0QkJtb2hCZ0pBQTBBZ0FTMEFBQ0FBUWQzUEFHb3RBQUJIRFR3Z0FFRUdSZzBCSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBvQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVJvTVBRc2dBU0FFUmdSQVFiUUJJUU1NK1FFTEFrQUNRQUpBSUFFdEFBQkJ4UUJyRGhFQVBUMDlQVDA5UFQwOUFUMDlQVDA5QWowTElBRkJBV29oQVVHZEFTRURET0VCQ3lBQlFRRnFJUUZCbmdFaEF3emdBUXNnQVVFQmFpRUJRWjhCSVFNTTN3RUxRYlVCSVFNZ0FTQUVSZzMzQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVIa3p3QnFMUUFBUncwNklBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6NEFRc2dBa0VBTmdJQUlBWkJBV29oQVVFb0REc0xRYllCSVFNZ0FTQUVSZzMyQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIcXp3QnFMUUFBUncwNUlBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF6M0FRc2dBa0VBTmdJQUlBWkJBV29oQVVFSEREb0xJQUVnQkVZRVFFRzNBU0VERFBZQkN3SkFBa0FnQVMwQUFFSEZBR3NPRGdBNU9UazVPVGs1T1RrNU9Ua0JPUXNnQVVFQmFpRUJRYUVCSVFNTTNRRUxJQUZCQVdvaEFVR2lBU0VERE53QkMwRzRBU0VESUFFZ0JFWU45QUVnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQ2FpRUdBa0FEUUNBQkxRQUFJQUJCN2M4QWFpMEFBRWNOTnlBQVFRSkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOVFFTElBSkJBRFlDQUNBR1FRRnFJUUZCRWd3NEMwRzVBU0VESUFFZ0JFWU44d0VnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCOE04QWFpMEFBRWNOTmlBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOUFFTElBSkJBRFlDQUNBR1FRRnFJUUZCSUF3M0MwRzZBU0VESUFFZ0JFWU44Z0VnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCOHM4QWFpMEFBRWNOTlNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOHdFTElBSkJBRFlDQUNBR1FRRnFJUUZCRHd3MkN5QUJJQVJHQkVCQnV3RWhBd3p5QVFzQ1FBSkFJQUV0QUFCQnlRQnJEZ2NBTlRVMU5UVUJOUXNnQVVFQmFpRUJRYVVCSVFNTTJRRUxJQUZCQVdvaEFVR21BU0VERE5nQkMwRzhBU0VESUFFZ0JFWU44QUVnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFSGFpRUdBa0FEUUNBQkxRQUFJQUJCOU04QWFpMEFBRWNOTXlBQVFRZEdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNOFFFTElBSkJBRFlDQUNBR1FRRnFJUUZCR3d3MEN5QUJJQVJHQkVCQnZRRWhBd3p3QVFzQ1FBSkFBa0FnQVMwQUFFSENBR3NPRWdBME5EUTBORFEwTkRRQk5EUTBORFEwQWpRTElBRkJBV29oQVVHa0FTRURETmdCQ3lBQlFRRnFJUUZCcHdFaEF3elhBUXNnQVVFQmFpRUJRYWdCSVFNTTFnRUxJQUVnQkVZRVFFRytBU0VERE84QkN5QUJMUUFBUWM0QVJ3MHdJQUZCQVdvaEFRd3NDeUFCSUFSR0JFQkJ2d0VoQXd6dUFRc0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUNBQkxRQUFRY0VBYXc0VkFBRUNBejhFQlFZL1B6OEhDQWtLQ3o4TURRNFBQd3NnQVVFQmFpRUJRZWdBSVFNTTR3RUxJQUZCQVdvaEFVSHBBQ0VERE9JQkN5QUJRUUZxSVFGQjdnQWhBd3poQVFzZ0FVRUJhaUVCUWZJQUlRTU00QUVMSUFGQkFXb2hBVUh6QUNFREROOEJDeUFCUVFGcUlRRkI5Z0FoQXd6ZUFRc2dBVUVCYWlFQlFmY0FJUU1NM1FFTElBRkJBV29oQVVINkFDRURETndCQ3lBQlFRRnFJUUZCZ3dFaEF3emJBUXNnQVVFQmFpRUJRWVFCSVFNTTJnRUxJQUZCQVdvaEFVR0ZBU0VERE5rQkN5QUJRUUZxSVFGQmtnRWhBd3pZQVFzZ0FVRUJhaUVCUVpnQklRTU0xd0VMSUFGQkFXb2hBVUdnQVNFREROWUJDeUFCUVFGcUlRRkJvd0VoQXd6VkFRc2dBVUVCYWlFQlFhb0JJUU1NMUFFTElBRWdCRWNFUUNBQ1FSQTJBZ2dnQWlBQk5nSUVRYXNCSVFNTTFBRUxRY0FCSVFNTTdBRUxRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUkwSWdORkRRQWdBaUFERVFBQUlRQUxJQUJGRFY0Z0FFRVZSdzBISUFKQjBRQTJBaHdnQWlBQk5nSVVJQUpCc0JjMkFoQWdBa0VWTmdJTVFRQWhBd3pyQVFzZ0FVRUJhaUFCSUFSSERRZ2FRY0lCSVFNTTZnRUxBMEFDUUNBQkxRQUFRUXByRGdRSUFBQUxBQXNnQkNBQlFRRnFJZ0ZIRFFBTFFjTUJJUU1NNlFFTElBRWdCRWNFUUNBQ1FSRTJBZ2dnQWlBQk5nSUVRUUVoQXd6UUFRdEJ4QUVoQXd6b0FRc2dBU0FFUmdSQVFjVUJJUU1NNkFFTEFrQUNRQ0FCTFFBQVFRcHJEZ1FCS0NnQUtBc2dBVUVCYWd3SkN5QUJRUUZxREFVTElBRWdCRVlFUUVIR0FTRURET2NCQ3dKQUFrQWdBUzBBQUVFS2F3NFhBUXNMQVFzTEN3c0xDd3NMQ3dzTEN3c0xDd3NMQ3dBTEN5QUJRUUZxSVFFTFFiQUJJUU1NelFFTElBRWdCRVlFUUVISUFTRURET1lCQ3lBQkxRQUFRU0JIRFFrZ0FrRUFPd0V5SUFGQkFXb2hBVUd6QVNFRERNd0JDd05BSUFFaEFBSkFJQUVnQkVjRVFDQUJMUUFBUVRCclFmOEJjU0lEUVFwSkRRRU1Kd3RCeHdFaEF3em1BUXNDUUNBQ0x3RXlJZ0ZCbVROTERRQWdBaUFCUVFwc0lnVTdBVElnQlVIKy93TnhJQU5CLy84RGMwc05BQ0FBUVFGcUlRRWdBaUFESUFWcUlnTTdBVElnQTBILy93TnhRZWdIU1EwQkN3dEJBQ0VESUFKQkFEWUNIQ0FDUWNFSk5nSVFJQUpCRFRZQ0RDQUNJQUJCQVdvMkFoUU01QUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0h3RERZQ0VDQUNRUnMyQWd4QkFDRURET01CQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDWWlBQTBCSUFGQkFXb0xJUUZCclFFaEF3eklBUXNnQWtIQkFUWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVRUUFoQXd6Z0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFtSWdBTkFTQUJRUUZxQ3lFQlFhNEJJUU1NeFFFTElBSkJ3Z0UyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkVFQUlRTU0zUUVMSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dYQ3pZQ0VDQUNRUTAyQWd4QkFDRURETndCQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCNHhBMkFoQWdBa0VKTmdJTVFRQWhBd3piQVFzZ0FrRUNPZ0FvREt3QkMwRUFJUU1nQWtFQU5nSWNJQUpCcndzMkFoQWdBa0VDTmdJTUlBSWdBVUVCYWpZQ0ZBelpBUXRCQWlFRERMOEJDMEVOSVFNTXZnRUxRU1loQXd5OUFRdEJGU0VEREx3QkMwRVdJUU1NdXdFTFFSZ2hBd3k2QVF0QkhDRURETGtCQzBFZElRTU11QUVMUVNBaEF3eTNBUXRCSVNFRERMWUJDMEVqSVFNTXRRRUxRY1lBSVFNTXRBRUxRUzRoQXd5ekFRdEJQU0VERExJQkMwSExBQ0VERExFQkMwSE9BQ0VERExBQkMwSFlBQ0VEREs4QkMwSFpBQ0VEREs0QkMwSGJBQ0VEREswQkMwSHhBQ0VEREt3QkMwSDBBQ0VEREtzQkMwR05BU0VEREtvQkMwR1hBU0VEREtrQkMwR3BBU0VEREtnQkMwR3ZBU0VEREtjQkMwR3hBU0VEREtZQkN5QUNRUUEyQWdBTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI4UnMyQWhBZ0FrRUdOZ0lNREwwQkN5QUNRUUEyQWdBZ0JrRUJhaUVCUVNRTE9nQXBJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSnlJQVJRUkFRZVVBSVFNTW93RUxJQUpCK1FBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU11d0VMSUFCQkZVY0VRQ0FDUVFBMkFod2dBaUFCTmdJVUlBSkJ6QTQyQWhBZ0FrRWdOZ0lNUVFBaEF3eTdBUXNnQWtINEFEWUNIQ0FDSUFFMkFoUWdBa0hLR0RZQ0VDQUNRUlUyQWd4QkFDRURETG9CQ3lBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCamhzMkFoQWdBa0VHTmdJTVFRQWhBd3k1QVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWY0Uk5nSVFJQUpCQnpZQ0RFRUFJUU1NdUFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHTUhEWUNFQ0FDUVFjMkFneEJBQ0VERExjQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnd3ODJBaEFnQWtFSE5nSU1RUUFoQXd5MkFRc2dBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjTVBOZ0lRSUFKQkJ6WUNERUVBSVFNTXRRRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMFJJQUpCNVFBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU10QUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBnSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc3dFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwaUlBSkIwZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXNnRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRME9JQUpCNVFBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1zUUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBkSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc0FFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwZklBSkIwZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXJ3RUxJQUJCUDBjTkFTQUJRUUZxQ3lFQlFRVWhBd3lVQVF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSDlFallDRUNBQ1FRYzJBZ3dNckFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIY0NEWUNFQ0FDUVFjMkFneEJBQ0VEREtzQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUJFQ1VpQUVVTkJ5QUNRZVVBTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3hCQUNFRERLb0JDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FCRUNVaUFFVU5GaUFDUWRNQU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURES2tCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDVWlBRVVOR0NBQ1FkSUFOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFneEJBQ0VEREtnQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnhnbzJBaEFnQWtFSE5nSU1RUUFoQXd5bkFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRTWdBa0hsQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eW1BUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBbElnQkZEUklnQWtIVEFEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3lsQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFJRZ0FrSFNBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd5a0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRQWdBa0hsQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eWpBUXRCMVFBaEF3eUpBUXNnQUVFVlJ3UkFJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrRzVEVFlDRUNBQ1FSbzJBZ3hCQUNFRERLSUJDeUFDUWVRQU5nSWNJQUlnQVRZQ0ZDQUNRZU1YTmdJUUlBSkJGVFlDREVFQUlRTU1vUUVMSUFKQkFEWUNBQ0FHUVFGcUlRRWdBaTBBS1NJQVFTTnJRUXRKRFFRQ1FDQUFRUVpMRFFCQkFTQUFkRUhLQUhGRkRRQU1CUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIM0NUWUNFQ0FDUVFnMkFnd01vQUVMSUFKQkFEWUNBQ0FHUVFGcUlRRWdBaTBBS1VFaFJnMERJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR2JDallDRUNBQ1FRZzJBZ3hCQUNFRERKOEJDeUFDUVFBMkFnQUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCa0RNMkFoQWdBa0VJTmdJTURKMEJDeUFDUVFBMkFnQWdCa0VCYWlFQklBSXRBQ2xCSTBrTkFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjB3azJBaEFnQWtFSU5nSU1RUUFoQXd5Y0FRdEIwUUFoQXd5Q0FRc2dBUzBBQUVFd2F5SUFRZjhCY1VFS1NRUkFJQUlnQURvQUtpQUJRUUZxSVFGQnp3QWhBd3lDQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQW9JZ0JGRFlZQklBSkIzZ0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTW1nRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRS0NJQVJRMkdBU0FDUWR3QU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURESmtCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBRkVDZ2lBRVVFUUNBRklRRU1od0VMSUFKQjJnQTJBaHdnQWlBRk5nSVVJQUlnQURZQ0RBeVlBUXRCQUNFQlFRRWhBd3NnQWlBRE9nQXJJQVZCQVdvaEF3SkFBa0FDUUNBQ0xRQXRRUkJ4RFFBQ1FBSkFBa0FnQWkwQUtnNERBUUFDQkFzZ0JrVU5Bd3dDQ3lBQURRRU1BZ3NnQVVVTkFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBeEFvSWdCRkJFQWdBeUVCREFJTElBSkIyQUEyQWh3Z0FpQUROZ0lVSUFJZ0FEWUNERUVBSVFNTW1BRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQU1RS0NJQVJRUkFJQU1oQVF5SEFRc2dBa0haQURZQ0hDQUNJQU0yQWhRZ0FpQUFOZ0lNUVFBaEF3eVhBUXRCekFBaEF3eDlDeUFBUVJWSEJFQWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FaUU5OZ0lRSUFKQklUWUNERUVBSVFNTWxnRUxJQUpCMXdBMkFod2dBaUFCTmdJVUlBSkJ5UmMyQWhBZ0FrRVZOZ0lNUVFBaEF3eVZBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHQUVUWUNFQ0FDUVFrMkFnd01sQUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBBSUFKQjB3QTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Na3dFTFFja0FJUU1NZVFzZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNFb05nSVFJQUpCQnpZQ0RDQUNRUUEyQWdCQkFDRURESkVCQ3lBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRRQWdBa0hTQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREpBQkMwSElBQ0VEREhZTElBSkJBRFlDQUNBRklRRUxJQUpCZ0JJN0FTb2dBVUVCYWlFQlFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSXdJZ05GRFFBZ0FpQURFUUFBSVFBTElBQU5BUXRCeHdBaEF3eHpDeUFBUVJWR0JFQWdBa0hSQURZQ0hDQUNJQUUyQWhRZ0FrSGpGellDRUNBQ1FSVTJBZ3hCQUNFRERJd0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJrTk5nSVFJQUpCR2pZQ0RBeUxBUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHZ0dUWUNFQ0FDUVI0MkFnd01pZ0VMSUFFdEFBQkJPa1lFUUNBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFwSWdCRkRRRWdBa0hEQURZQ0hDQUNJQUEyQWd3Z0FpQUJRUUZxTmdJVURJb0JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJFUk5nSVFJQUpCQ2pZQ0RBeUpBUXNnQVVFQmFpRUJRVHNoQXd4dkN5QUNRY01BTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWh3RUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCOEE0MkFoQWdBa0VjTmdJTURJWUJDeUFDSUFJdkFUQkJFSEk3QVRBTVpnc0NRQ0FDTHdFd0lnQkJDSEZGRFFBZ0FpMEFLRUVCUncwQUlBSXRBQzFCQ0hGRkRRTUxJQUlnQUVIMyt3TnhRWUFFY2pzQk1Bd0VDeUFCSUFSSEJFQUNRQU5BSUFFdEFBQkJNR3NpQUVIL0FYRkJDazhFUUVFMUlRTU1iZ3NnQWlrRElDSUtRcG16NXN5WnMrYk1HVllOQVNBQ0lBcENDbjRpQ2pjRElDQUtJQUN0UXY4Qmd5SUxRbitGVmcwQklBSWdDaUFMZkRjRElDQUVJQUZCQVdvaUFVY05BQXRCT1NFRERJVUJDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FVRUJhaUlCRUNvaUFBME1ESGNMUVRraEF3eURBUXNnQWkwQU1FRWdjUTBHUWNVQklRTU1hUXRCQUNFRElBSkJBRFlDQkNBQ0lBRWdBUkFxSWdCRkRRUWdBa0U2TmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWdRRUxJQUl0QUNoQkFVY05BQ0FDTFFBdFFRaHhSUTBCQzBFM0lRTU1aZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBQkVBZ0FrRTdOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNZndzZ0FVRUJhaUVCREc0TElBSkJDRG9BTEF3RUN5QUJRUUZxSVFFTWJRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hrRWpZQ0VDQUNRUVEyQWd3TWV3c2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFSUTFzSUFKQk56WUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURIb0xJQUlnQWk4Qk1FRWdjanNCTUF0Qk1DRURERjhMSUFKQk5qWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURIY0xJQUJCTEVjTkFTQUJRUUZxSVFCQkFTRUJBa0FDUUFKQUFrQUNRQ0FDTFFBc1FRVnJEZ1FEQVFJRUFBc2dBQ0VCREFRTFFRSWhBUXdCQzBFRUlRRUxJQUpCQVRvQUxDQUNJQUl2QVRBZ0FYSTdBVEFnQUNFQkRBRUxJQUlnQWk4Qk1FRUljanNCTUNBQUlRRUxRVGtoQXd4Y0N5QUNRUUE2QUN3TFFUUWhBd3hhQ3lBQklBUkdCRUJCTFNFRERITUxBa0FDUUFOQUFrQWdBUzBBQUVFS2F3NEVBZ0FBQXdBTElBUWdBVUVCYWlJQlJ3MEFDMEV0SVFNTWRBc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtpSUFSUTBDSUFKQkxEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURITUxJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQkVDb2lBRVVFUUNBQlFRRnFJUUVNQWdzZ0FrRXNOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNY2dzZ0FTMEFBRUVOUmdSQUlBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCRUNvaUFFVUVRQ0FCUVFGcUlRRU1BZ3NnQWtFc05nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1jZ3NnQWkwQUxVRUJjUVJBUWNRQklRTU1XUXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBRFFFTVpRdEJMeUVEREZjTElBSkJMallDSENBQ0lBRTJBaFFnQWlBQU5nSU1ERzhMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjhCUTJBaEFnQWtFRE5nSU1ERzRMUVFFaEF3SkFBa0FDUUFKQUlBSXRBQ3hCQldzT0JBTUJBZ0FFQ3lBQ0lBSXZBVEJCQ0hJN0FUQU1Bd3RCQWlFRERBRUxRUVFoQXdzZ0FrRUJPZ0FzSUFJZ0FpOEJNQ0FEY2pzQk1BdEJLaUVEREZNTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI0UTgyQWhBZ0FrRUtOZ0lNREdzTFFRRWhBd0pBQWtBQ1FBSkFBa0FDUUNBQ0xRQXNRUUpyRGdjRkJBUURBUUlBQkFzZ0FpQUNMd0V3UVFoeU93RXdEQU1MUVFJaEF3d0JDMEVFSVFNTElBSkJBVG9BTENBQ0lBSXZBVEFnQTNJN0FUQUxRU3NoQXd4U0MwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYXNTTmdJUUlBSkJDellDREF4cUMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRZjBOTmdJUUlBSkJIVFlDREF4cEN5QUJJQVJIQkVBRFFDQUJMUUFBUVNCSERVZ2dCQ0FCUVFGcUlnRkhEUUFMUVNVaEF3eHBDMEVsSVFNTWFBc2dBaTBBTFVFQmNRUkFRY01CSVFNTVR3c2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUWdBaUFBSUFFUUtTSUFCRUFnQWtFbU5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1hQXNnQVVFQmFpRUJERndMSUFGQkFXb2hBU0FDTHdFd0lnQkJnQUZ4QkVCQkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FsUWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVU5CaUFBUVJWSERSOGdBa0VGTmdJY0lBSWdBVFlDRkNBQ1Fma1hOZ0lRSUFKQkZUWUNERUVBSVFNTVp3c0NRQ0FBUWFBRWNVR2dCRWNOQUNBQ0xRQXRRUUp4RFFCQkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR1dFellDRUNBQ1FRUTJBZ3dNWndzZ0FnSi9JQUl2QVRCQkZIRkJGRVlFUUVFQklBSXRBQ2hCQVVZTkFSb2dBaThCTWtIbEFFWU1BUXNnQWkwQUtVRUZSZ3M2QUM1QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FpUWlBMFVOQUNBQ0lBTVJBQUFoQUFzQ1FBSkFBa0FDUUFKQUlBQU9GZ0lCQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFNRUN5QUNRUUU2QUM0TElBSWdBaThCTUVIQUFISTdBVEFMUVNjaEF3eFBDeUFDUVNNMkFod2dBaUFCTmdJVUlBSkJwUlkyQWhBZ0FrRVZOZ0lNUVFBaEF3eG5DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWRVTE5nSVFJQUpCRVRZQ0RBeG1DMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDTENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRFFFTFFRNGhBd3hMQ3lBQVFSVkdCRUFnQWtFQ05nSWNJQUlnQVRZQ0ZDQUNRYkFZTmdJUUlBSkJGVFlDREVFQUlRTU1aQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHbkRqWUNFQ0FDUVJJMkFnd01Zd3RCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHcUhEWUNFQ0FDUVE4MkFnd01ZZ3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRWdDcWRxSWdFUUt5SUFSUTBBSUFKQkJUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURHRUxRUThoQXd4SEMwRUFJUU1nQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRYzBUTmdJUUlBSkJERFlDREF4ZkMwSUJJUW9MSUFGQkFXb2hBUUpBSUFJcEF5QWlDMEwvLy8vLy8vLy8vdzlZQkVBZ0FpQUxRZ1NHSUFxRU53TWdEQUVMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnJRazJBaEFnQWtFTU5nSU1ERjRMUVNRaEF3eEVDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwVE5nSVFJQUpCRERZQ0RBeGNDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQ0FDSUFBZ0FSQXNJZ0JGQkVBZ0FVRUJhaUVCREZJTElBSkJGellDSENBQ0lBQTJBZ3dnQWlBQlFRRnFOZ0lVREZzTElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUFrQWdBaUFBSUFFUUxDSUFSUVJBSUFGQkFXb2hBUXdCQ3lBQ1FSWTJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhiQzBFZklRTU1RUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYUR6WUNFQ0FDUVNJMkFnd01XUXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFMU0lBUlFSQUlBRkJBV29oQVF4UUN5QUNRUlEyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkF4WUN5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JBSkFJQUlnQUNBQkVDMGlBRVVFUUNBQlFRRnFJUUVNQVFzZ0FrRVROZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNV0F0QkhpRURERDRMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnhndzJBaEFnQWtFak5nSU1ERllMSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFSUFJZ0FDQUJFQzBpQUVVRVFDQUJRUUZxSVFFTVRnc2dBa0VSTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVZRc2dBa0VRTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3dNVkF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSEdERFlDRUNBQ1FTTTJBZ3dNVXd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSEFGVFlDRUNBQ1FRSTJBZ3dNVWdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRQ1FDQUNJQUFnQVJBdElnQkZCRUFnQVVFQmFpRUJEQUVMSUFKQkRqWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVERklMUVJzaEF3dzRDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNZTU5nSVFJQUpCSXpZQ0RBeFFDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQUpBSUFJZ0FDQUJFQ3dpQUVVRVFDQUJRUUZxSVFFTUFRc2dBa0VOTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVVBdEJHaUVERERZTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJtZzgyQWhBZ0FrRWlOZ0lNREU0TElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUFrQWdBaUFBSUFFUUxDSUFSUVJBSUFGQkFXb2hBUXdCQ3lBQ1FRdzJBaHdnQWlBQU5nSU1JQUlnQVVFQmFqWUNGQXhPQzBFWklRTU1OQXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHYUR6WUNFQ0FDUVNJMkFnd01UQXNnQUVFVlJ3UkFRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCZ3d3MkFoQWdBa0VUTmdJTURFd0xJQUpCQ2pZQ0hDQUNJQUUyQWhRZ0FrSGtGallDRUNBQ1FSVTJBZ3hCQUNFRERFc0xJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQklBcW5haUlCRUNzaUFBUkFJQUpCQnpZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREVzTFFSTWhBd3d4Q3lBQVFSVkhCRUJCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIYURUWUNFQ0FDUVJRMkFnd01TZ3NnQWtFZU5nSWNJQUlnQVRZQ0ZDQUNRZmtYTmdJUUlBSkJGVFlDREVFQUlRTU1TUXRCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWl3aUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTlFTQUFRUlZHQkVBZ0FrRUROZ0ljSUFJZ0FUWUNGQ0FDUWJBWU5nSVFJQUpCRlRZQ0RFRUFJUU1NU1F0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNU0F0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSGFEVFlDRUNBQ1FSUTJBZ3dNUnd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNUmdzZ0FrRUFPZ0F2SUFJdEFDMUJCSEZGRFQ4TElBSkJBRG9BTHlBQ1FRRTZBRFJCQUNFRERDc0xRUUFoQXlBQ1FRQTJBaHdnQWtIa0VUWUNFQ0FDUVFjMkFnd2dBaUFCUVFGcU5nSVVERU1MQWtBRFFBSkFJQUV0QUFCQkNtc09CQUFDQWdBQ0N5QUVJQUZCQVdvaUFVY05BQXRCM1FFaEF3eERDd0pBQWtBZ0FpMEFORUVCUncwQVFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSllJZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEUUFnQUVFVlJ3MEJJQUpCM0FFMkFod2dBaUFCTmdJVUlBSkIxUlkyQWhBZ0FrRVZOZ0lNUVFBaEF3eEVDMEhCQVNFRERDb0xJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSHBDellDRUNBQ1FSODJBZ3hCQUNFRERFSUxBa0FDUUNBQ0xRQW9RUUZyRGdJRUFRQUxRY0FCSVFNTUtRdEJ1UUVoQXd3b0N5QUNRUUk2QUM5QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FnQWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVUVRRUhDQVNFRERDZ0xJQUJCRlVjRVFDQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnBBdzJBaEFnQWtFUU5nSU1RUUFoQXd4QkN5QUNRZHNCTmdJY0lBSWdBVFlDRkNBQ1Fmb1dOZ0lRSUFKQkZUWUNERUVBSVFNTVFBc2dBU0FFUmdSQVFkb0JJUU1NUUFzZ0FTMEFBRUhJQUVZTkFTQUNRUUU2QUNnTFFhd0JJUU1NSlF0QnZ3RWhBd3drQ3lBQklBUkhCRUFnQWtFUU5nSUlJQUlnQVRZQ0JFRytBU0VERENRTFFka0JJUU1NUEFzZ0FTQUVSZ1JBUWRnQklRTU1QQXNnQVMwQUFFSElBRWNOQkNBQlFRRnFJUUZCdlFFaEF3d2lDeUFCSUFSR0JFQkIxd0VoQXd3N0N3SkFBa0FnQVMwQUFFSEZBR3NPRUFBRkJRVUZCUVVGQlFVRkJRVUZCUUVGQ3lBQlFRRnFJUUZCdXdFaEF3d2lDeUFCUVFGcUlRRkJ2QUVoQXd3aEMwSFdBU0VESUFFZ0JFWU5PU0FDS0FJQUlnQWdCQ0FCYTJvaEJTQUJJQUJyUVFKcUlRWUNRQU5BSUFFdEFBQWdBRUdEMEFCcUxRQUFSdzBESUFCQkFrWU5BU0FBUVFGcUlRQWdCQ0FCUVFGcUlnRkhEUUFMSUFJZ0JUWUNBQXc2Q3lBQ0tBSUVJUUFnQWtJQU53TUFJQUlnQUNBR1FRRnFJZ0VRSnlJQVJRUkFRY1lCSVFNTUlRc2dBa0hWQVRZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3dzVDMEhVQVNFRElBRWdCRVlOT0NBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVHQjBBQnFMUUFBUncwQ0lBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF3NUN5QUNRWUVFT3dFb0lBSW9BZ1FoQUNBQ1FnQTNBd0FnQWlBQUlBWkJBV29pQVJBbklnQU5Bd3dDQ3lBQ1FRQTJBZ0FMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjJCczJBaEFnQWtFSU5nSU1ERFlMUWJvQklRTU1IQXNnQWtIVEFUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3cwQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ09DSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRMEFJQUJCRlVZTkFTQUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQnpBNDJBaEFnQWtFZ05nSU1RUUFoQXd3ekMwSGtBQ0VEREJrTElBSkIrQUEyQWh3Z0FpQUJOZ0lVSUFKQnloZzJBaEFnQWtFVk5nSU1RUUFoQXd3eEMwSFNBU0VESUFRZ0FTSUFSZzB3SUFRZ0FXc2dBaWdDQUNJQmFpRUZJQUFnQVd0QkJHb2hCZ0pBQTBBZ0FDMEFBQ0FCUWZ6UEFHb3RBQUJIRFFFZ0FVRUVSZzBESUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUZOZ0lBRERFTElBSkJBRFlDSENBQ0lBQTJBaFFnQWtHUU16WUNFQ0FDUVFnMkFnd2dBa0VBTmdJQVFRQWhBd3d3Q3lBQklBUkhCRUFnQWtFT05nSUlJQUlnQVRZQ0JFRzNBU0VEREJjTFFkRUJJUU1NTHdzZ0FrRUFOZ0lBSUFaQkFXb2hBUXRCdUFFaEF3d1VDeUFCSUFSR0JFQkIwQUVoQXd3dEN5QUJMUUFBUVRCcklnQkIvd0Z4UVFwSkJFQWdBaUFBT2dBcUlBRkJBV29oQVVHMkFTRUREQlFMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUtDSUFSUTBVSUFKQnp3RTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NTEFzZ0FTQUVSZ1JBUWM0QklRTU1MQXNDUUNBQkxRQUFRUzVHQkVBZ0FVRUJhaUVCREFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFLQ0lBUlEwVklBSkJ6UUUyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTUxBdEJ0UUVoQXd3U0N5QUVJQUVpQlVZRVFFSE1BU0VERENzTFFRQWhBRUVCSVFGQkFTRUdRUUFoQXdKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBSUFVdEFBQkJNR3NPQ2dvSkFBRUNBd1FGQmdnTEMwRUNEQVlMUVFNTUJRdEJCQXdFQzBFRkRBTUxRUVlNQWd0QkJ3d0JDMEVJQ3lFRFFRQWhBVUVBSVFZTUFndEJDU0VEUVFFaEFFRUFJUUZCQUNFR0RBRUxRUUFoQVVFQklRTUxJQUlnQXpvQUt5QUZRUUZxSVFNQ1FBSkFJQUl0QUMxQkVIRU5BQUpBQWtBQ1FDQUNMUUFxRGdNQkFBSUVDeUFHUlEwRERBSUxJQUFOQVF3Q0N5QUJSUTBCQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBREVDZ2lBRVVFUUNBRElRRU1Bd3NnQWtISkFUWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3d0Q3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBREVDZ2lBRVVFUUNBRElRRU1HQXNnQWtIS0FUWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3dzQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBRkVDZ2lBRVVFUUNBRklRRU1GZ3NnQWtITEFUWUNIQ0FDSUFVMkFoUWdBaUFBTmdJTURDc0xRYlFCSVFNTUVRdEJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BandpQTBVTkFDQUNJQU1SQUFBaEFBc0NRQ0FBQkVBZ0FFRVZSZzBCSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dVRFRZQ0VDQUNRU0UyQWd4QkFDRUREQ3NMUWJJQklRTU1FUXNnQWtISUFUWUNIQ0FDSUFFMkFoUWdBa0hKRnpZQ0VDQUNRUlUyQWd4QkFDRUREQ2tMSUFKQkFEWUNBQ0FHUVFGcUlRRkI5UUFoQXd3UEN5QUNMUUFwUVFWR0JFQkI0d0FoQXd3UEMwSGlBQ0VEREE0TElBQWhBU0FDUVFBMkFnQUxJQUpCQURvQUxFRUpJUU1NREFzZ0FrRUFOZ0lBSUFkQkFXb2hBVUhBQUNFRERBc0xRUUVMT2dBc0lBSkJBRFlDQUNBR1FRRnFJUUVMUVNraEF3d0lDMEU0SVFNTUJ3c0NRQ0FCSUFSSEJFQURRQ0FCTFFBQVFZQSthaTBBQUNJQVFRRkhCRUFnQUVFQ1J3MERJQUZCQVdvaEFRd0ZDeUFFSUFGQkFXb2lBVWNOQUF0QlBpRUREQ0VMUVQ0aEF3d2dDd3NnQWtFQU9nQXNEQUVMUVFzaEF3d0VDMEU2SVFNTUF3c2dBVUVCYWlFQlFTMGhBd3dDQ3lBQ0lBRTZBQ3dnQWtFQU5nSUFJQVpCQVdvaEFVRU1JUU1NQVFzZ0FrRUFOZ0lBSUFaQkFXb2hBVUVLSVFNTUFBc0FDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwUU5nSVFJQUpCQ1RZQ0RBd1hDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVrS05nSVFJQUpCQ1RZQ0RBd1dDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJjUU5nSVFJQUpCQ1RZQ0RBd1ZDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVp3Uk5nSVFJQUpCQ1RZQ0RBd1VDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwUU5nSVFJQUpCQ1RZQ0RBd1RDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVrS05nSVFJQUpCQ1RZQ0RBd1NDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWJjUU5nSVFJQUpCQ1RZQ0RBd1JDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVp3Uk5nSVFJQUpCQ1RZQ0RBd1FDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpjVk5nSVFJQUpCRHpZQ0RBd1BDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpjVk5nSVFJQUpCRHpZQ0RBd09DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNBU05nSVFJQUpCQ3pZQ0RBd05DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUVpVSk5nSVFJQUpCQ3pZQ0RBd01DMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWVFUE5nSVFJQUpCQ2pZQ0RBd0xDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZzUE5nSVFJQUpCQ2pZQ0RBd0tDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZFWk5nSVFJQUpCQWpZQ0RBd0pDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWNRVU5nSVFJQUpCQWpZQ0RBd0lDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWZJVk5nSVFJQUpCQWpZQ0RBd0hDeUFDUVFJMkFod2dBaUFCTmdJVUlBSkJuQm8yQWhBZ0FrRVdOZ0lNUVFBaEF3d0dDMEVCSVFNTUJRdEIxQUFoQXlBQklBUkdEUVFnQ0VFSWFpRUpJQUlvQWdBaEJRSkFBa0FnQVNBRVJ3UkFJQVZCMk1JQWFpRUhJQVFnQldvZ0FXc2hBQ0FGUVg5elFRcHFJZ1VnQVdvaEJnTkFJQUV0QUFBZ0J5MEFBRWNFUUVFQ0lRY01Bd3NnQlVVRVFFRUFJUWNnQmlFQkRBTUxJQVZCQVdzaEJTQUhRUUZxSVFjZ0JDQUJRUUZxSWdGSERRQUxJQUFoQlNBRUlRRUxJQWxCQVRZQ0FDQUNJQVUyQWdBTUFRc2dBa0VBTmdJQUlBa2dCellDQUFzZ0NTQUJOZ0lFSUFnb0Fnd2hBQ0FJS0FJSURnTUJCQUlBQ3dBTElBSkJBRFlDSENBQ1FiVWFOZ0lRSUFKQkZ6WUNEQ0FDSUFCQkFXbzJBaFJCQUNFRERBSUxJQUpCQURZQ0hDQUNJQUEyQWhRZ0FrSEtHallDRUNBQ1FRazJBZ3hCQUNFRERBRUxJQUVnQkVZRVFFRWlJUU1NQVFzZ0FrRUpOZ0lJSUFJZ0FUWUNCRUVoSVFNTElBaEJFR29rQUNBRFJRUkFJQUlvQWd3aEFBd0JDeUFDSUFNMkFoeEJBQ0VBSUFJb0FnUWlBVVVOQUNBQ0lBRWdCQ0FDS0FJSUVRRUFJZ0ZGRFFBZ0FpQUVOZ0lVSUFJZ0FUWUNEQ0FCSVFBTElBQUx2Z0lCQW44Z0FFRUFPZ0FBSUFCQjNBQnFJZ0ZCQVd0QkFEb0FBQ0FBUVFBNkFBSWdBRUVBT2dBQklBRkJBMnRCQURvQUFDQUJRUUpyUVFBNkFBQWdBRUVBT2dBRElBRkJCR3RCQURvQUFFRUFJQUJyUVFOeElnRWdBR29pQUVFQU5nSUFRZHdBSUFGclFYeHhJZ0lnQUdvaUFVRUVhMEVBTmdJQUFrQWdBa0VKU1EwQUlBQkJBRFlDQ0NBQVFRQTJBZ1FnQVVFSWEwRUFOZ0lBSUFGQkRHdEJBRFlDQUNBQ1FSbEpEUUFnQUVFQU5nSVlJQUJCQURZQ0ZDQUFRUUEyQWhBZ0FFRUFOZ0lNSUFGQkVHdEJBRFlDQUNBQlFSUnJRUUEyQWdBZ0FVRVlhMEVBTmdJQUlBRkJIR3RCQURZQ0FDQUNJQUJCQkhGQkdISWlBbXNpQVVFZ1NRMEFJQUFnQW1vaEFBTkFJQUJDQURjREdDQUFRZ0EzQXhBZ0FFSUFOd01JSUFCQ0FEY0RBQ0FBUVNCcUlRQWdBVUVnYXlJQlFSOUxEUUFMQ3d0V0FRRi9Ba0FnQUNnQ0RBMEFBa0FDUUFKQUFrQWdBQzBBTHc0REFRQURBZ3NnQUNnQ09DSUJSUTBBSUFFb0Fpd2lBVVVOQUNBQUlBRVJBQUFpQVEwREMwRUFEd3NBQ3lBQVFjTVdOZ0lRUVE0aEFRc2dBUXNhQUNBQUtBSU1SUVJBSUFCQjBSczJBaEFnQUVFVk5nSU1Dd3NVQUNBQUtBSU1RUlZHQkVBZ0FFRUFOZ0lNQ3dzVUFDQUFLQUlNUVJaR0JFQWdBRUVBTmdJTUN3c0hBQ0FBS0FJTUN3Y0FJQUFvQWhBTENRQWdBQ0FCTmdJUUN3Y0FJQUFvQWhRTEZ3QWdBRUVrVHdSQUFBc2dBRUVDZEVHZ00yb29BZ0FMRndBZ0FFRXVUd1JBQUFzZ0FFRUNkRUd3Tkdvb0FnQUx2d2tCQVg5QjZ5Z2hBUUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFCQjVBQnJEdlFEWTJJQUFXRmhZV0ZoWVFJREJBVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoQmdjSUNRb0xEQTBPRDJGaFlXRmhFR0ZoWVdGaFlXRmhZV0ZoRVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVJJVEZCVVdGeGdaR2h0aFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEhCMGVIeUFoSWlNa0pTWW5LQ2txS3l3dExpOHdNVEl6TkRVMllUYzRPVHBoWVdGaFlXRmhZVHRoWVdFOFlXRmhZVDArUDJGaFlXRmhZV0ZoUUdGaFFXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZVUpEUkVWR1IwaEpTa3RNVFU1UFVGRlNVMkZoWVdGaFlXRmhWRlZXVjFoWldsdGhYRjFoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGZVlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFgyQmhDMEhoSnc4TFFhUWhEd3RCeXl3UEMwSCtNUThMUWNBa0R3dEJxeVFQQzBHTktBOExRZUltRHd0QmdEQVBDMEc1THc4TFFkY2tEd3RCN3g4UEMwSGhIdzhMUWZvZkR3dEI4aUFQQzBHb0x3OExRYTR5RHd0QmlEQVBDMEhzSnc4TFFZSWlEd3RCamgwUEMwSFFMZzhMUWNvakR3dEJ4VElQQzBIZkhBOExRZEljRHd0QnhDQVBDMEhYSUE4TFFhSWZEd3RCN1M0UEMwR3JNQThMUWRRbER3dEJ6QzRQQzBINkxnOExRZndyRHd0QjBqQVBDMEh4SFE4TFFic2dEd3RCOXlzUEMwR1FNUThMUWRjeER3dEJvaTBQQzBIVUp3OExRZUFyRHd0Qm55d1BDMEhyTVE4TFFkVWZEd3RCeWpFUEMwSGVKUThMUWRRZUR3dEI5QndQQzBHbk1nOExRYkVkRHd0Qm9CMFBDMEc1TVE4TFFid3dEd3RCa2lFUEMwR3pKZzhMUWVrc0R3dEJyQjRQQzBIVUt3OExRZmNtRHd0QmdDWVBDMEd3SVE4TFFmNGVEd3RCalNNUEMwR0pMUThMUWZjaUR3dEJvREVQQzBHdUh3OExRY1lsRHd0QjZCNFBDMEdUSWc4TFFjSXZEd3RCd3gwUEMwR0xMQThMUWVFZER3dEJqUzhQQzBIcUlROExRYlF0RHd0QjBpOFBDMEhmTWc4TFFkSXlEd3RCOERBUEMwR3BJZzhMUWZrakR3dEJtUjRQQzBHMUxBOExRWnN3RHd0QmtqSVBDMEcyS3c4TFFjSWlEd3RCK0RJUEMwR2VKUThMUWRBaUR3dEJ1aDRQQzBHQkhnOExBQXRCMWlFaEFRc2dBUXNXQUNBQUlBQXRBQzFCL2dGeElBRkJBRWR5T2dBdEN4a0FJQUFnQUMwQUxVSDlBWEVnQVVFQVIwRUJkSEk2QUMwTEdRQWdBQ0FBTFFBdFFmc0JjU0FCUVFCSFFRSjBjam9BTFFzWkFDQUFJQUF0QUMxQjl3RnhJQUZCQUVkQkEzUnlPZ0F0Q3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0JDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ4aEUyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0NDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z28yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0RDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3Um8yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0VDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsUkEyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0ZDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJxaHMyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0dDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI3Uk0yQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0tDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkI5Z2cyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0hDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJ3aGsyQWhCQkdDRUVDeUFFQ3o0QkFuOENRQ0FBS0FJNElnTkZEUUFnQXlnQ0lDSURSUTBBSUFBZ0FTQUNJQUZySUFNUkFRQWlCRUYvUncwQUlBQkJsQlEyQWhCQkdDRUVDeUFFQzFrQkFuOENRQ0FBTFFBb1FRRkdEUUFnQUM4Qk1pSUJRZVFBYTBIa0FFa05BQ0FCUWN3QlJnMEFJQUZCc0FKR0RRQWdBQzhCTUNJQVFjQUFjUTBBUVFFaEFpQUFRWWdFY1VHQUJFWU5BQ0FBUVNoeFJTRUNDeUFDQzR3QkFRSi9Ba0FDUUFKQUlBQXRBQ3BGRFFBZ0FDMEFLMFVOQUNBQUx3RXdJZ0ZCQW5GRkRRRU1BZ3NnQUM4Qk1DSUJRUUZ4UlEwQkMwRUJJUUlnQUMwQUtFRUJSZzBBSUFBdkFUSWlBRUhrQUd0QjVBQkpEUUFnQUVITUFVWU5BQ0FBUWJBQ1JnMEFJQUZCd0FCeERRQkJBQ0VDSUFGQmlBUnhRWUFFUmcwQUlBRkJLSEZCQUVjaEFnc2dBZ3RYQUNBQVFSaHFRZ0EzQXdBZ0FFSUFOd01BSUFCQk9HcENBRGNEQUNBQVFUQnFRZ0EzQXdBZ0FFRW9ha0lBTndNQUlBQkJJR3BDQURjREFDQUFRUkJxUWdBM0F3QWdBRUVJYWtJQU53TUFJQUJCM1FFMkFod0xCZ0FnQUJBeUM1b3RBUXQvSXdCQkVHc2lDaVFBUWFUUUFDZ0NBQ0lKUlFSQVFlVFRBQ2dDQUNJRlJRUkFRZkRUQUVKL053SUFRZWpUQUVLQWdJU0FnSURBQURjQ0FFSGswd0FnQ2tFSWFrRndjVUhZcXRXcUJYTWlCVFlDQUVINDB3QkJBRFlDQUVISTB3QkJBRFlDQUF0QnpOTUFRWURVQkRZQ0FFR2MwQUJCZ05RRU5nSUFRYkRRQUNBRk5nSUFRYXpRQUVGL05nSUFRZERUQUVHQXJBTTJBZ0FEUUNBQlFjalFBR29nQVVHODBBQnFJZ0kyQWdBZ0FpQUJRYlRRQUdvaUF6WUNBQ0FCUWNEUUFHb2dBellDQUNBQlFkRFFBR29nQVVIRTBBQnFJZ00yQWdBZ0F5QUNOZ0lBSUFGQjJOQUFhaUFCUWN6UUFHb2lBallDQUNBQ0lBTTJBZ0FnQVVIVTBBQnFJQUkyQWdBZ0FVRWdhaUlCUVlBQ1J3MEFDMEdNMUFSQndhc0ROZ0lBUWFqUUFFSDAwd0FvQWdBMkFnQkJtTkFBUWNDckF6WUNBRUdrMEFCQmlOUUVOZ0lBUWN6L0IwRTROZ0lBUVlqVUJDRUpDd0pBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkI3QUZOQkVCQmpOQUFLQUlBSWdaQkVDQUFRUk5xUVhCeElBQkJDMGtiSWdSQkEzWWlBSFlpQVVFRGNRUkFBa0FnQVVFQmNTQUFja0VCY3lJQ1FRTjBJZ0JCdE5BQWFpSUJJQUJCdk5BQWFpZ0NBQ0lBS0FJSUlnTkdCRUJCak5BQUlBWkJmaUFDZDNFMkFnQU1BUXNnQVNBRE5nSUlJQU1nQVRZQ0RBc2dBRUVJYWlFQklBQWdBa0VEZENJQ1FRTnlOZ0lFSUFBZ0Ftb2lBQ0FBS0FJRVFRRnlOZ0lFREJFTFFaVFFBQ2dDQUNJSUlBUlBEUUVnQVFSQUFrQkJBaUFBZENJQ1FRQWdBbXR5SUFFZ0FIUnhhQ0lBUVFOMElnSkJ0TkFBYWlJQklBSkJ2TkFBYWlnQ0FDSUNLQUlJSWdOR0JFQkJqTkFBSUFaQmZpQUFkM0VpQmpZQ0FBd0JDeUFCSUFNMkFnZ2dBeUFCTmdJTUN5QUNJQVJCQTNJMkFnUWdBRUVEZENJQUlBUnJJUVVnQUNBQ2FpQUZOZ0lBSUFJZ0JHb2lCQ0FGUVFGeU5nSUVJQWdFUUNBSVFYaHhRYlRRQUdvaEFFR2cwQUFvQWdBaEF3Si9RUUVnQ0VFRGRuUWlBU0FHY1VVRVFFR00wQUFnQVNBR2NqWUNBQ0FBREFFTElBQW9BZ2dMSWdFZ0F6WUNEQ0FBSUFNMkFnZ2dBeUFBTmdJTUlBTWdBVFlDQ0FzZ0FrRUlhaUVCUWFEUUFDQUVOZ0lBUVpUUUFDQUZOZ0lBREJFTFFaRFFBQ2dDQUNJTFJRMEJJQXRvUVFKMFFielNBR29vQWdBaUFDZ0NCRUY0Y1NBRWF5RUZJQUFoQWdOQUFrQWdBaWdDRUNJQlJRUkFJQUpCRkdvb0FnQWlBVVVOQVFzZ0FTZ0NCRUY0Y1NBRWF5SURJQVZKSVFJZ0F5QUZJQUliSVFVZ0FTQUFJQUliSVFBZ0FTRUNEQUVMQ3lBQUtBSVlJUWtnQUNnQ0RDSURJQUJIQkVCQm5OQUFLQUlBR2lBRElBQW9BZ2dpQVRZQ0NDQUJJQU0yQWd3TUVBc2dBRUVVYWlJQ0tBSUFJZ0ZGQkVBZ0FDZ0NFQ0lCUlEwRElBQkJFR29oQWdzRFFDQUNJUWNnQVNJRFFSUnFJZ0lvQWdBaUFRMEFJQU5CRUdvaEFpQURLQUlRSWdFTkFBc2dCMEVBTmdJQURBOExRWDhoQkNBQVFiOS9TdzBBSUFCQkUyb2lBVUZ3Y1NFRVFaRFFBQ2dDQUNJSVJRMEFRUUFnQkdzaEJRSkFBa0FDUUFKL1FRQWdCRUdBQWtrTkFCcEJIeUFFUWYvLy93ZExEUUFhSUFSQkppQUJRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9MSWdaQkFuUkJ2TklBYWlnQ0FDSUNSUVJBUVFBaEFVRUFJUU1NQVF0QkFDRUJJQVJCR1NBR1FRRjJhMEVBSUFaQkgwY2JkQ0VBUVFBaEF3TkFBa0FnQWlnQ0JFRjRjU0FFYXlJSElBVlBEUUFnQWlFRElBY2lCUTBBUVFBaEJTQUNJUUVNQXdzZ0FTQUNRUlJxS0FJQUlnY2dCeUFDSUFCQkhYWkJCSEZxUVJCcUtBSUFJZ0pHR3lBQklBY2JJUUVnQUVFQmRDRUFJQUlOQUFzTElBRWdBM0pGQkVCQkFDRURRUUlnQm5RaUFFRUFJQUJyY2lBSWNTSUFSUTBESUFCb1FRSjBRYnpTQUdvb0FnQWhBUXNnQVVVTkFRc0RRQ0FCS0FJRVFYaHhJQVJySWdJZ0JVa2hBQ0FDSUFVZ0FCc2hCU0FCSUFNZ0FCc2hBeUFCS0FJUUlnQUVmeUFBQlNBQlFSUnFLQUlBQ3lJQkRRQUxDeUFEUlEwQUlBVkJsTkFBS0FJQUlBUnJUdzBBSUFNb0FoZ2hCeUFESUFNb0Fnd2lBRWNFUUVHYzBBQW9BZ0FhSUFBZ0F5Z0NDQ0lCTmdJSUlBRWdBRFlDREF3T0N5QURRUlJxSWdJb0FnQWlBVVVFUUNBREtBSVFJZ0ZGRFFNZ0EwRVFhaUVDQ3dOQUlBSWhCaUFCSWdCQkZHb2lBaWdDQUNJQkRRQWdBRUVRYWlFQ0lBQW9BaEFpQVEwQUN5QUdRUUEyQWdBTURRdEJsTkFBS0FJQUlnTWdCRThFUUVHZzBBQW9BZ0FoQVFKQUlBTWdCR3NpQWtFUVR3UkFJQUVnQkdvaUFDQUNRUUZ5TmdJRUlBRWdBMm9nQWpZQ0FDQUJJQVJCQTNJMkFnUU1BUXNnQVNBRFFRTnlOZ0lFSUFFZ0Eyb2lBQ0FBS0FJRVFRRnlOZ0lFUVFBaEFFRUFJUUlMUVpUUUFDQUNOZ0lBUWFEUUFDQUFOZ0lBSUFGQkNHb2hBUXdQQzBHWTBBQW9BZ0FpQXlBRVN3UkFJQVFnQ1dvaUFDQURJQVJySWdGQkFYSTJBZ1JCcE5BQUlBQTJBZ0JCbU5BQUlBRTJBZ0FnQ1NBRVFRTnlOZ0lFSUFsQkNHb2hBUXdQQzBFQUlRRWdCQUovUWVUVEFDZ0NBQVJBUWV6VEFDZ0NBQXdCQzBIdzB3QkNmemNDQUVIbzB3QkNnSUNFZ0lDQXdBQTNBZ0JCNU5NQUlBcEJER3BCY0hGQjJLclZxZ1Z6TmdJQVFmalRBRUVBTmdJQVFjalRBRUVBTmdJQVFZQ0FCQXNpQUNBRVFjY0FhaUlGYWlJR1FRQWdBR3NpQjNFaUFrOEVRRUg4MHdCQk1EWUNBQXdQQ3dKQVFjVFRBQ2dDQUNJQlJRMEFRYnpUQUNnQ0FDSUlJQUpxSVFBZ0FDQUJUU0FBSUFoTGNRMEFRUUFoQVVIODB3QkJNRFlDQUF3UEMwSEkwd0F0QUFCQkJIRU5CQUpBQWtBZ0NRUkFRY3pUQUNFQkEwQWdBU2dDQUNJQUlBbE5CRUFnQUNBQktBSUVhaUFKU3cwREN5QUJLQUlJSWdFTkFBc0xRUUFRTXlJQVFYOUdEUVVnQWlFR1FlalRBQ2dDQUNJQlFRRnJJZ01nQUhFRVFDQUNJQUJySUFBZ0EycEJBQ0FCYTNGcUlRWUxJQVFnQms4TkJTQUdRZjcvLy84SFN3MEZRY1RUQUNnQ0FDSURCRUJCdk5NQUtBSUFJZ2NnQm1vaEFTQUJJQWRORFFZZ0FTQURTdzBHQ3lBR0VETWlBU0FBUncwQkRBY0xJQVlnQTJzZ0IzRWlCa0grLy8vL0Iwc05CQ0FHRURNaEFDQUFJQUVvQWdBZ0FTZ0NCR3BHRFFNZ0FDRUJDd0pBSUFZZ0JFSElBR3BQRFFBZ0FVRi9SZzBBUWV6VEFDZ0NBQ0lBSUFVZ0JtdHFRUUFnQUd0eElnQkIvdi8vL3dkTEJFQWdBU0VBREFjTElBQVFNMEYvUndSQUlBQWdCbW9oQmlBQklRQU1Cd3RCQUNBR2F4QXpHZ3dFQ3lBQklnQkJmMGNOQlF3REMwRUFJUU1NREF0QkFDRUFEQW9MSUFCQmYwY05BZ3RCeU5NQVFjalRBQ2dDQUVFRWNqWUNBQXNnQWtIKy8vLy9CMHNOQVNBQ0VETWhBRUVBRURNaEFTQUFRWDlHRFFFZ0FVRi9SZzBCSUFBZ0FVOE5BU0FCSUFCcklnWWdCRUU0YWswTkFRdEJ2Tk1BUWJ6VEFDZ0NBQ0FHYWlJQk5nSUFRY0RUQUNnQ0FDQUJTUVJBUWNEVEFDQUJOZ0lBQ3dKQUFrQUNRRUdrMEFBb0FnQWlBZ1JBUWN6VEFDRUJBMEFnQUNBQktBSUFJZ01nQVNnQ0JDSUZha1lOQWlBQktBSUlJZ0VOQUFzTUFndEJuTkFBS0FJQUlnRkJBRWNnQUNBQlQzRkZCRUJCbk5BQUlBQTJBZ0FMUVFBaEFVSFEwd0FnQmpZQ0FFSE0wd0FnQURZQ0FFR3MwQUJCZnpZQ0FFR3cwQUJCNU5NQUtBSUFOZ0lBUWRqVEFFRUFOZ0lBQTBBZ0FVSEkwQUJxSUFGQnZOQUFhaUlDTmdJQUlBSWdBVUcwMEFCcUlnTTJBZ0FnQVVIQTBBQnFJQU0yQWdBZ0FVSFEwQUJxSUFGQnhOQUFhaUlETmdJQUlBTWdBallDQUNBQlFkalFBR29nQVVITTBBQnFJZ0kyQWdBZ0FpQUROZ0lBSUFGQjFOQUFhaUFDTmdJQUlBRkJJR29pQVVHQUFrY05BQXRCZUNBQWEwRVBjU0lCSUFCcUlnSWdCa0U0YXlJRElBRnJJZ0ZCQVhJMkFnUkJxTkFBUWZUVEFDZ0NBRFlDQUVHWTBBQWdBVFlDQUVHazBBQWdBallDQUNBQUlBTnFRVGcyQWdRTUFnc2dBQ0FDVFEwQUlBSWdBMGtOQUNBQktBSU1RUWh4RFFCQmVDQUNhMEVQY1NJQUlBSnFJZ05CbU5BQUtBSUFJQVpxSWdjZ0FHc2lBRUVCY2pZQ0JDQUJJQVVnQm1vMkFnUkJxTkFBUWZUVEFDZ0NBRFlDQUVHWTBBQWdBRFlDQUVHazBBQWdBellDQUNBQ0lBZHFRVGcyQWdRTUFRc2dBRUdjMEFBb0FnQkpCRUJCbk5BQUlBQTJBZ0FMSUFBZ0Jtb2hBMEhNMHdBaEFRSkFBa0FDUUFOQUlBTWdBU2dDQUVjRVFDQUJLQUlJSWdFTkFRd0NDd3NnQVMwQURFRUljVVVOQVF0QnpOTUFJUUVEUUNBQktBSUFJZ01nQWswRVFDQURJQUVvQWdScUlnVWdBa3NOQXdzZ0FTZ0NDQ0VCREFBTEFBc2dBU0FBTmdJQUlBRWdBU2dDQkNBR2FqWUNCQ0FBUVhnZ0FHdEJEM0ZxSWdrZ0JFRURjallDQkNBRFFYZ2dBMnRCRDNGcUlnWWdCQ0FKYWlJRWF5RUJJQUlnQmtZRVFFR2swQUFnQkRZQ0FFR1kwQUJCbU5BQUtBSUFJQUZxSWdBMkFnQWdCQ0FBUVFGeU5nSUVEQWdMUWFEUUFDZ0NBQ0FHUmdSQVFhRFFBQ0FFTmdJQVFaVFFBRUdVMEFBb0FnQWdBV29pQURZQ0FDQUVJQUJCQVhJMkFnUWdBQ0FFYWlBQU5nSUFEQWdMSUFZb0FnUWlCVUVEY1VFQlJ3MEdJQVZCZUhFaENDQUZRZjhCVFFSQUlBVkJBM1loQXlBR0tBSUlJZ0FnQmlnQ0RDSUNSZ1JBUVl6UUFFR00wQUFvQWdCQmZpQURkM0UyQWdBTUJ3c2dBaUFBTmdJSUlBQWdBallDREF3R0N5QUdLQUlZSVFjZ0JpQUdLQUlNSWdCSEJFQWdBQ0FHS0FJSUlnSTJBZ2dnQWlBQU5nSU1EQVVMSUFaQkZHb2lBaWdDQUNJRlJRUkFJQVlvQWhBaUJVVU5CQ0FHUVJCcUlRSUxBMEFnQWlFRElBVWlBRUVVYWlJQ0tBSUFJZ1VOQUNBQVFSQnFJUUlnQUNnQ0VDSUZEUUFMSUFOQkFEWUNBQXdFQzBGNElBQnJRUTl4SWdFZ0FHb2lCeUFHUVRocklnTWdBV3NpQVVFQmNqWUNCQ0FBSUFOcVFUZzJBZ1FnQWlBRlFUY2dCV3RCRDNGcVFUOXJJZ01nQXlBQ1FSQnFTUnNpQTBFak5nSUVRYWpRQUVIMDB3QW9BZ0EyQWdCQm1OQUFJQUUyQWdCQnBOQUFJQWMyQWdBZ0EwRVFha0hVMHdBcEFnQTNBZ0FnQTBITTB3QXBBZ0EzQWdoQjFOTUFJQU5CQ0dvMkFnQkIwTk1BSUFZMkFnQkJ6Tk1BSUFBMkFnQkIyTk1BUVFBMkFnQWdBMEVrYWlFQkEwQWdBVUVITmdJQUlBVWdBVUVFYWlJQlN3MEFDeUFDSUFOR0RRQWdBeUFES0FJRVFYNXhOZ0lFSUFNZ0F5QUNheUlGTmdJQUlBSWdCVUVCY2pZQ0JDQUZRZjhCVFFSQUlBVkJlSEZCdE5BQWFpRUFBbjlCak5BQUtBSUFJZ0ZCQVNBRlFRTjJkQ0lEY1VVRVFFR00wQUFnQVNBRGNqWUNBQ0FBREFFTElBQW9BZ2dMSWdFZ0FqWUNEQ0FBSUFJMkFnZ2dBaUFBTmdJTUlBSWdBVFlDQ0F3QkMwRWZJUUVnQlVILy8vOEhUUVJBSUFWQkppQUZRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9oQVFzZ0FpQUJOZ0ljSUFKQ0FEY0NFQ0FCUVFKMFFielNBR29oQUVHUTBBQW9BZ0FpQTBFQklBRjBJZ1p4UlFSQUlBQWdBallDQUVHUTBBQWdBeUFHY2pZQ0FDQUNJQUEyQWhnZ0FpQUNOZ0lJSUFJZ0FqWUNEQXdCQ3lBRlFSa2dBVUVCZG10QkFDQUJRUjlIRzNRaEFTQUFLQUlBSVFNQ1FBTkFJQU1pQUNnQ0JFRjRjU0FGUmcwQklBRkJIWFloQXlBQlFRRjBJUUVnQUNBRFFRUnhha0VRYWlJR0tBSUFJZ01OQUFzZ0JpQUNOZ0lBSUFJZ0FEWUNHQ0FDSUFJMkFnd2dBaUFDTmdJSURBRUxJQUFvQWdnaUFTQUNOZ0lNSUFBZ0FqWUNDQ0FDUVFBMkFoZ2dBaUFBTmdJTUlBSWdBVFlDQ0F0Qm1OQUFLQUlBSWdFZ0JFME5BRUdrMEFBb0FnQWlBQ0FFYWlJQ0lBRWdCR3NpQVVFQmNqWUNCRUdZMEFBZ0FUWUNBRUdrMEFBZ0FqWUNBQ0FBSUFSQkEzSTJBZ1FnQUVFSWFpRUJEQWdMUVFBaEFVSDgwd0JCTURZQ0FBd0hDMEVBSVFBTElBZEZEUUFDUUNBR0tBSWNJZ0pCQW5SQnZOSUFhaUlES0FJQUlBWkdCRUFnQXlBQU5nSUFJQUFOQVVHUTBBQkJrTkFBS0FJQVFYNGdBbmR4TmdJQURBSUxJQWRCRUVFVUlBY29BaEFnQmtZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQnpZQ0dDQUdLQUlRSWdJRVFDQUFJQUkyQWhBZ0FpQUFOZ0lZQ3lBR1FSUnFLQUlBSWdKRkRRQWdBRUVVYWlBQ05nSUFJQUlnQURZQ0dBc2dBU0FJYWlFQklBWWdDR29pQmlnQ0JDRUZDeUFHSUFWQmZuRTJBZ1FnQVNBRWFpQUJOZ0lBSUFRZ0FVRUJjallDQkNBQlFmOEJUUVJBSUFGQmVIRkJ0TkFBYWlFQUFuOUJqTkFBS0FJQUlnSkJBU0FCUVFOMmRDSUJjVVVFUUVHTTBBQWdBU0FDY2pZQ0FDQUFEQUVMSUFBb0FnZ0xJZ0VnQkRZQ0RDQUFJQVEyQWdnZ0JDQUFOZ0lNSUFRZ0FUWUNDQXdCQzBFZklRVWdBVUgvLy84SFRRUkFJQUZCSmlBQlFRaDJaeUlBYTNaQkFYRWdBRUVCZEd0QlBtb2hCUXNnQkNBRk5nSWNJQVJDQURjQ0VDQUZRUUowUWJ6U0FHb2hBRUdRMEFBb0FnQWlBa0VCSUFWMElnTnhSUVJBSUFBZ0JEWUNBRUdRMEFBZ0FpQURjallDQUNBRUlBQTJBaGdnQkNBRU5nSUlJQVFnQkRZQ0RBd0JDeUFCUVJrZ0JVRUJkbXRCQUNBRlFSOUhHM1FoQlNBQUtBSUFJUUFDUUFOQUlBQWlBaWdDQkVGNGNTQUJSZzBCSUFWQkhYWWhBQ0FGUVFGMElRVWdBaUFBUVFSeGFrRVFhaUlES0FJQUlnQU5BQXNnQXlBRU5nSUFJQVFnQWpZQ0dDQUVJQVEyQWd3Z0JDQUVOZ0lJREFFTElBSW9BZ2dpQUNBRU5nSU1JQUlnQkRZQ0NDQUVRUUEyQWhnZ0JDQUNOZ0lNSUFRZ0FEWUNDQXNnQ1VFSWFpRUJEQUlMQWtBZ0IwVU5BQUpBSUFNb0Fod2lBVUVDZEVHODBnQnFJZ0lvQWdBZ0EwWUVRQ0FDSUFBMkFnQWdBQTBCUVpEUUFDQUlRWDRnQVhkeElnZzJBZ0FNQWdzZ0IwRVFRUlFnQnlnQ0VDQURSaHRxSUFBMkFnQWdBRVVOQVFzZ0FDQUhOZ0lZSUFNb0FoQWlBUVJBSUFBZ0FUWUNFQ0FCSUFBMkFoZ0xJQU5CRkdvb0FnQWlBVVVOQUNBQVFSUnFJQUUyQWdBZ0FTQUFOZ0lZQ3dKQUlBVkJEMDBFUUNBRElBUWdCV29pQUVFRGNqWUNCQ0FBSUFOcUlnQWdBQ2dDQkVFQmNqWUNCQXdCQ3lBRElBUnFJZ0lnQlVFQmNqWUNCQ0FESUFSQkEzSTJBZ1FnQWlBRmFpQUZOZ0lBSUFWQi93Rk5CRUFnQlVGNGNVRzAwQUJxSVFBQ2YwR00wQUFvQWdBaUFVRUJJQVZCQTNaMElnVnhSUVJBUVl6UUFDQUJJQVZ5TmdJQUlBQU1BUXNnQUNnQ0NBc2lBU0FDTmdJTUlBQWdBallDQ0NBQ0lBQTJBZ3dnQWlBQk5nSUlEQUVMUVI4aEFTQUZRZi8vL3dkTkJFQWdCVUVtSUFWQkNIWm5JZ0JyZGtFQmNTQUFRUUYwYTBFK2FpRUJDeUFDSUFFMkFod2dBa0lBTndJUUlBRkJBblJCdk5JQWFpRUFRUUVnQVhRaUJDQUljVVVFUUNBQUlBSTJBZ0JCa05BQUlBUWdDSEkyQWdBZ0FpQUFOZ0lZSUFJZ0FqWUNDQ0FDSUFJMkFnd01BUXNnQlVFWklBRkJBWFpyUVFBZ0FVRWZSeHQwSVFFZ0FDZ0NBQ0VFQWtBRFFDQUVJZ0FvQWdSQmVIRWdCVVlOQVNBQlFSMTJJUVFnQVVFQmRDRUJJQUFnQkVFRWNXcEJFR29pQmlnQ0FDSUVEUUFMSUFZZ0FqWUNBQ0FDSUFBMkFoZ2dBaUFDTmdJTUlBSWdBallDQ0F3QkN5QUFLQUlJSWdFZ0FqWUNEQ0FBSUFJMkFnZ2dBa0VBTmdJWUlBSWdBRFlDRENBQ0lBRTJBZ2dMSUFOQkNHb2hBUXdCQ3dKQUlBbEZEUUFDUUNBQUtBSWNJZ0ZCQW5SQnZOSUFhaUlDS0FJQUlBQkdCRUFnQWlBRE5nSUFJQU1OQVVHUTBBQWdDMEYrSUFGM2NUWUNBQXdDQ3lBSlFSQkJGQ0FKS0FJUUlBQkdHMm9nQXpZQ0FDQURSUTBCQ3lBRElBazJBaGdnQUNnQ0VDSUJCRUFnQXlBQk5nSVFJQUVnQXpZQ0dBc2dBRUVVYWlnQ0FDSUJSUTBBSUFOQkZHb2dBVFlDQUNBQklBTTJBaGdMQWtBZ0JVRVBUUVJBSUFBZ0JDQUZhaUlCUVFOeU5nSUVJQUFnQVdvaUFTQUJLQUlFUVFGeU5nSUVEQUVMSUFBZ0JHb2lCeUFGUVFGeU5nSUVJQUFnQkVFRGNqWUNCQ0FGSUFkcUlBVTJBZ0FnQ0FSQUlBaEJlSEZCdE5BQWFpRUJRYURRQUNnQ0FDRURBbjlCQVNBSVFRTjJkQ0lDSUFaeFJRUkFRWXpRQUNBQ0lBWnlOZ0lBSUFFTUFRc2dBU2dDQ0FzaUFpQUROZ0lNSUFFZ0F6WUNDQ0FESUFFMkFnd2dBeUFDTmdJSUMwR2cwQUFnQnpZQ0FFR1UwQUFnQlRZQ0FBc2dBRUVJYWlFQkN5QUtRUkJxSkFBZ0FRdERBQ0FBUlFSQVB3QkJFSFFQQ3dKQUlBQkIvLzhEY1EwQUlBQkJBRWdOQUNBQVFSQjJRQUFpQUVGL1JnUkFRZnpUQUVFd05nSUFRWDhQQ3lBQVFSQjBEd3NBQ3d2Y1B5SUFRWUFJQ3drQkFBQUFBZ0FBQUFNQVFaUUlDd1VFQUFBQUJRQkJwQWdMQ1FZQUFBQUhBQUFBQ0FCQjNBZ0xpaTFKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUhGMVpYSjVBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZZbTlrZVFCRGIyNTBaVzUwTFV4bGJtZDBhQ0J2ZG1WeVpteHZkd0JEYUhWdWF5QnphWHBsSUc5MlpYSm1iRzkzQUZKbGMzQnZibk5sSUc5MlpYSm1iRzkzQUVsdWRtRnNhV1FnYldWMGFHOWtJR1p2Y2lCSVZGUlFMM2d1ZUNCeVpYRjFaWE4wQUVsdWRtRnNhV1FnYldWMGFHOWtJR1p2Y2lCU1ZGTlFMM2d1ZUNCeVpYRjFaWE4wQUVWNGNHVmpkR1ZrSUZOUFZWSkRSU0J0WlhSb2IyUWdabTl5SUVsRFJTOTRMbmdnY21WeGRXVnpkQUJKYm5aaGJHbGtJR05vWVhJZ2FXNGdkWEpzSUdaeVlXZHRaVzUwSUhOMFlYSjBBRVY0Y0dWamRHVmtJR1J2ZEFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNOMFlYUjFjd0JKYm5aaGJHbGtJSEpsYzNCdmJuTmxJSE4wWVhSMWN3QkpiblpoYkdsa0lHTm9ZWEpoWTNSbGNpQnBiaUJqYUhWdWF5QmxlSFJsYm5OcGIyNXpBRlZ6WlhJZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgzSmxjMlYwWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZlkyaDFibXRmYUdWaFpHVnlZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmYldWemMyRm5aVjlpWldkcGJtQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMk5vZFc1clgyVjRkR1Z1YzJsdmJsOTJZV3gxWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgzTjBZWFIxYzE5amIyMXdiR1YwWldBZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgzWmxjbk5wYjI1ZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOTFjbXhmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5amFIVnVhMTlqYjIxd2JHVjBaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFZRzl1WDJobFlXUmxjbDkyWVd4MVpWOWpiMjF3YkdWMFpXQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMjFsYzNOaFoyVmZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl0WlhSb2IyUmZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDlvWldGa1pYSmZabWxsYkdSZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOWphSFZ1YTE5bGVIUmxibk5wYjI1ZmJtRnRaV0FnWTJGc2JHSmhZMnNnWlhKeWIzSUFWVzVsZUhCbFkzUmxaQ0JqYUdGeUlHbHVJSFZ5YkNCelpYSjJaWElBU1c1MllXeHBaQ0JvWldGa1pYSWdkbUZzZFdVZ1kyaGhjZ0JKYm5aaGJHbGtJR2hsWVdSbGNpQm1hV1ZzWkNCamFHRnlBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZkbVZ5YzJsdmJnQkpiblpoYkdsa0lHMXBibTl5SUhabGNuTnBiMjRBU1c1MllXeHBaQ0J0WVdwdmNpQjJaWEp6YVc5dUFFVjRjR1ZqZEdWa0lITndZV05sSUdGbWRHVnlJSFpsY25OcGIyNEFSWGh3WldOMFpXUWdRMUpNUmlCaFpuUmxjaUIyWlhKemFXOXVBRWx1ZG1Gc2FXUWdTRlJVVUNCMlpYSnphVzl1QUVsdWRtRnNhV1FnYUdWaFpHVnlJSFJ2YTJWdUFGTndZVzRnWTJGc2JHSmhZMnNnWlhKeWIzSWdhVzRnYjI1ZmRYSnNBRWx1ZG1Gc2FXUWdZMmhoY21GamRHVnljeUJwYmlCMWNtd0FWVzVsZUhCbFkzUmxaQ0J6ZEdGeWRDQmphR0Z5SUdsdUlIVnliQUJFYjNWaWJHVWdRQ0JwYmlCMWNtd0FSVzF3ZEhrZ1EyOXVkR1Z1ZEMxTVpXNW5kR2dBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1EyOXVkR1Z1ZEMxTVpXNW5kR2dBUkhWd2JHbGpZWFJsSUVOdmJuUmxiblF0VEdWdVozUm9BRWx1ZG1Gc2FXUWdZMmhoY2lCcGJpQjFjbXdnY0dGMGFBQkRiMjUwWlc1MExVeGxibWQwYUNCallXNG5kQ0JpWlNCd2NtVnpaVzUwSUhkcGRHZ2dWSEpoYm5ObVpYSXRSVzVqYjJScGJtY0FTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2djMmw2WlFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDJobFlXUmxjbDkyWVd4MVpRQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5MllXeDFaUUJKYm5aaGJHbGtJR05vWVhKaFkzUmxjaUJwYmlCamFIVnVheUJsZUhSbGJuTnBiMjV6SUhaaGJIVmxBRTFwYzNOcGJtY2daWGh3WldOMFpXUWdURVlnWVdaMFpYSWdhR1ZoWkdWeUlIWmhiSFZsQUVsdWRtRnNhV1FnWUZSeVlXNXpabVZ5TFVWdVkyOWthVzVuWUNCb1pXRmtaWElnZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUJ4ZFc5MFpTQjJZV3gxWlFCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY2lCcGJpQmphSFZ1YXlCbGVIUmxibk5wYjI1eklIRjFiM1JsWkNCMllXeDFaUUJRWVhWelpXUWdZbmtnYjI1ZmFHVmhaR1Z5YzE5amIyMXdiR1YwWlFCSmJuWmhiR2xrSUVWUFJpQnpkR0YwWlFCdmJsOXlaWE5sZENCd1lYVnpaUUJ2Ymw5amFIVnVhMTlvWldGa1pYSWdjR0YxYzJVQWIyNWZiV1Z6YzJGblpWOWlaV2RwYmlCd1lYVnpaUUJ2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmZG1Gc2RXVWdjR0YxYzJVQWIyNWZjM1JoZEhWelgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgzWmxjbk5wYjI1ZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmRYSnNYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMk5vZFc1clgyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyaGxZV1JsY2w5MllXeDFaVjlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDl0WlhOellXZGxYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYMjFsZEdodlpGOWpiMjF3YkdWMFpTQndZWFZ6WlFCdmJsOW9aV0ZrWlhKZlptbGxiR1JmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYMjVoYldVZ2NHRjFjMlVBVlc1bGVIQmxZM1JsWkNCemNHRmpaU0JoWm5SbGNpQnpkR0Z5ZENCc2FXNWxBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgyNWhiV1VBU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3lCdVlXMWxBRkJoZFhObElHOXVJRU5QVGs1RlExUXZWWEJuY21Ga1pRQlFZWFZ6WlNCdmJpQlFVa2t2VlhCbmNtRmtaUUJGZUhCbFkzUmxaQ0JJVkZSUUx6SWdRMjl1Ym1WamRHbHZiaUJRY21WbVlXTmxBRk53WVc0Z1kyRnNiR0poWTJzZ1pYSnliM0lnYVc0Z2IyNWZiV1YwYUc5a0FFVjRjR1ZqZEdWa0lITndZV05sSUdGbWRHVnlJRzFsZEdodlpBQlRjR0Z1SUdOaGJHeGlZV05ySUdWeWNtOXlJR2x1SUc5dVgyaGxZV1JsY2w5bWFXVnNaQUJRWVhWelpXUUFTVzUyWVd4cFpDQjNiM0prSUdWdVkyOTFiblJsY21Wa0FFbHVkbUZzYVdRZ2JXVjBhRzlrSUdWdVkyOTFiblJsY21Wa0FGVnVaWGh3WldOMFpXUWdZMmhoY2lCcGJpQjFjbXdnYzJOb1pXMWhBRkpsY1hWbGMzUWdhR0Z6SUdsdWRtRnNhV1FnWUZSeVlXNXpabVZ5TFVWdVkyOWthVzVuWUFCVFYwbFVRMGhmVUZKUFdGa0FWVk5GWDFCU1QxaFpBRTFMUVVOVVNWWkpWRmtBVlU1UVVrOURSVk5UUVVKTVJWOUZUbFJKVkZrQVEwOVFXUUJOVDFaRlJGOVFSVkpOUVU1RlRsUk1XUUJVVDA5ZlJVRlNURmtBVGs5VVNVWlpBRVpCU1V4RlJGOUVSVkJGVGtSRlRrTlpBRUpCUkY5SFFWUkZWMEZaQUZCTVFWa0FVRlZVQUVOSVJVTkxUMVZVQUVkQlZFVlhRVmxmVkVsTlJVOVZWQUJTUlZGVlJWTlVYMVJKVFVWUFZWUUFUa1ZVVjA5U1MxOURUMDVPUlVOVVgxUkpUVVZQVlZRQVEwOU9Ua1ZEVkVsUFRsOVVTVTFGVDFWVUFFeFBSMGxPWDFSSlRVVlBWVlFBVGtWVVYwOVNTMTlTUlVGRVgxUkpUVVZQVlZRQVVFOVRWQUJOU1ZORVNWSkZRMVJGUkY5U1JWRlZSVk5VQUVOTVNVVk9WRjlEVEU5VFJVUmZVa1ZSVlVWVFZBQkRURWxGVGxSZlEweFBVMFZFWDB4UFFVUmZRa0ZNUVU1RFJVUmZVa1ZSVlVWVFZBQkNRVVJmVWtWUlZVVlRWQUJJVkZSUVgxSkZVVlZGVTFSZlUwVk9WRjlVVDE5SVZGUlFVMTlRVDFKVUFGSkZVRTlTVkFCSlRWOUJYMVJGUVZCUFZBQlNSVk5GVkY5RFQwNVVSVTVVQUU1UFgwTlBUbFJGVGxRQVVFRlNWRWxCVEY5RFQwNVVSVTVVQUVoUVJWOUpUbFpCVEVsRVgwTlBUbE5VUVU1VUFFaFFSVjlEUWw5U1JWTkZWQUJIUlZRQVNGQkZYMU5VVWtsRFZBQkRUMDVHVEVsRFZBQlVSVTFRVDFKQlVsbGZVa1ZFU1ZKRlExUUFVRVZTVFVGT1JVNVVYMUpGUkVsU1JVTlVBRU5QVGs1RlExUUFUVlZNVkVsZlUxUkJWRlZUQUVoUVJWOUpUbFpCVEVsRVgxTlVRVlJWVXdCVVQwOWZUVUZPV1Y5U1JWRlZSVk5VVXdCRlFWSk1XVjlJU1U1VVV3QlZUa0ZXUVVsTVFVSk1SVjlHVDFKZlRFVkhRVXhmVWtWQlUwOU9Vd0JQVUZSSlQwNVRBRk5YU1ZSRFNFbE9SMTlRVWs5VVQwTlBURk1BVmtGU1NVRk9WRjlCVEZOUFgwNUZSMDlVU1VGVVJWTUFUVlZNVkVsUVRFVmZRMGhQU1VORlV3QkpUbFJGVWs1QlRGOVRSVkpXUlZKZlJWSlNUMUlBVjBWQ1gxTkZVbFpGVWw5VlRrdE9UMWRPWDBWU1VrOVNBRkpCU1V4SFZVNWZSVkpTVDFJQVNVUkZUbFJKVkZsZlVGSlBWa2xFUlZKZlFWVlVTRVZPVkVsRFFWUkpUMDVmUlZKU1QxSUFVMU5NWDBORlVsUkpSa2xEUVZSRlgwVlNVazlTQUVsT1ZrRk1TVVJmV0Y5R1QxSlhRVkpFUlVSZlJrOVNBRk5GVkY5UVFWSkJUVVZVUlZJQVIwVlVYMUJCVWtGTlJWUkZVZ0JJVUVWZlZWTkZVZ0JUUlVWZlQxUklSVklBU0ZCRlgwTkNYME5JVlU1TFgwaEZRVVJGVWdCTlMwTkJURVZPUkVGU0FGTkZWRlZRQUZkRlFsOVRSVkpXUlZKZlNWTmZSRTlYVGdCVVJVRlNSRTlYVGdCSVVFVmZRMHhQVTBWRVgwTlBUazVGUTFSSlQwNEFTRVZWVWtsVFZFbERYMFZZVUVsU1FWUkpUMDRBUkVsVFEwOU9Ua1ZEVkVWRVgwOVFSVkpCVkVsUFRnQk9UMDVmUVZWVVNFOVNTVlJCVkVsV1JWOUpUa1pQVWsxQlZFbFBUZ0JJVUVWZlNVNVdRVXhKUkY5V1JWSlRTVTlPQUVoUVJWOURRbDlOUlZOVFFVZEZYMEpGUjBsT0FGTkpWRVZmU1ZOZlJsSlBXa1ZPQUVoUVJWOUpUbFpCVEVsRVgwaEZRVVJGVWw5VVQwdEZUZ0JKVGxaQlRFbEVYMVJQUzBWT0FFWlBVa0pKUkVSRlRnQkZUa2hCVGtORlgxbFBWVkpmUTBGTVRRQklVRVZmU1U1V1FVeEpSRjlWVWt3QVFreFBRMHRGUkY5Q1dWOVFRVkpGVGxSQlRGOURUMDVVVWs5TUFFMUxRMDlNQUVGRFRBQklVRVZmU1U1VVJWSk9RVXdBVWtWUlZVVlRWRjlJUlVGRVJWSmZSa2xGVEVSVFgxUlBUMTlNUVZKSFJWOVZUazlHUmtsRFNVRk1BRWhRUlY5UFN3QlZUa3hKVGtzQVZVNU1UME5MQUZCU1NRQlNSVlJTV1Y5WFNWUklBRWhRUlY5SlRsWkJURWxFWDBOUFRsUkZUbFJmVEVWT1IxUklBRWhRUlY5VlRrVllVRVZEVkVWRVgwTlBUbFJGVGxSZlRFVk9SMVJJQUVaTVZWTklBRkJTVDFCUVFWUkRTQUJOTFZORlFWSkRTQUJWVWtsZlZFOVBYMHhQVGtjQVVGSlBRMFZUVTBsT1J3Qk5TVk5EUlV4TVFVNUZUMVZUWDFCRlVsTkpVMVJGVGxSZlYwRlNUa2xPUndCTlNWTkRSVXhNUVU1RlQxVlRYMWRCVWs1SlRrY0FTRkJGWDBsT1ZrRk1TVVJmVkZKQlRsTkdSVkpmUlU1RFQwUkpUa2NBUlhod1pXTjBaV1FnUTFKTVJnQklVRVZmU1U1V1FVeEpSRjlEU0ZWT1MxOVRTVnBGQUUxUFZrVUFRMDlPVkVsT1ZVVUFTRkJGWDBOQ1gxTlVRVlJWVTE5RFQwMVFURVZVUlFCSVVFVmZRMEpmU0VWQlJFVlNVMTlEVDAxUVRFVlVSUUJJVUVWZlEwSmZWa1ZTVTBsUFRsOURUMDFRVEVWVVJRQklVRVZmUTBKZlZWSk1YME5QVFZCTVJWUkZBRWhRUlY5RFFsOURTRlZPUzE5RFQwMVFURVZVUlFCSVVFVmZRMEpmU0VWQlJFVlNYMVpCVEZWRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5RFNGVk9TMTlGV0ZSRlRsTkpUMDVmVmtGTVZVVmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwTklWVTVMWDBWWVZFVk9VMGxQVGw5T1FVMUZYME5QVFZCTVJWUkZBRWhRUlY5RFFsOU5SVk5UUVVkRlgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5TlJWUklUMFJmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMGhGUVVSRlVsOUdTVVZNUkY5RFQwMVFURVZVUlFCRVJVeEZWRVVBU0ZCRlgwbE9Wa0ZNU1VSZlJVOUdYMU5VUVZSRkFFbE9Wa0ZNU1VSZlUxTk1YME5GVWxSSlJrbERRVlJGQUZCQlZWTkZBRTVQWDFKRlUxQlBUbE5GQUZWT1UxVlFVRTlTVkVWRVgwMUZSRWxCWDFSWlVFVUFSMDlPUlFCT1QxUmZRVU5EUlZCVVFVSk1SUUJUUlZKV1NVTkZYMVZPUVZaQlNVeEJRa3hGQUZKQlRrZEZYMDVQVkY5VFFWUkpVMFpKUVVKTVJRQlBVa2xIU1U1ZlNWTmZWVTVTUlVGRFNFRkNURVVBVWtWVFVFOU9VMFZmU1ZOZlUxUkJURVVBVUZWU1IwVUFUVVZTUjBVQVVrVlJWVVZUVkY5SVJVRkVSVkpmUmtsRlRFUlRYMVJQVDE5TVFWSkhSUUJTUlZGVlJWTlVYMGhGUVVSRlVsOVVUMDlmVEVGU1IwVUFVRUZaVEU5QlJGOVVUMDlmVEVGU1IwVUFTVTVUVlVaR1NVTkpSVTVVWDFOVVQxSkJSMFVBU0ZCRlgxQkJWVk5GUkY5VlVFZFNRVVJGQUVoUVJWOVFRVlZUUlVSZlNESmZWVkJIVWtGRVJRQlRUMVZTUTBVQVFVNU9UMVZPUTBVQVZGSkJRMFVBU0ZCRlgxVk9SVmhRUlVOVVJVUmZVMUJCUTBVQVJFVlRRMUpKUWtVQVZVNVRWVUpUUTFKSlFrVUFVa1ZEVDFKRUFFaFFSVjlKVGxaQlRFbEVYMDFGVkVoUFJBQk9UMVJmUms5VlRrUUFVRkpQVUVaSlRrUUFWVTVDU1U1RUFGSkZRa2xPUkFCVlRrRlZWRWhQVWtsYVJVUUFUVVZVU0U5RVgwNVBWRjlCVEV4UFYwVkVBRWhVVkZCZlZrVlNVMGxQVGw5T1QxUmZVMVZRVUU5U1ZFVkVBRUZNVWtWQlJGbGZVa1ZRVDFKVVJVUUFRVU5EUlZCVVJVUUFUazlVWDBsTlVFeEZUVVZPVkVWRUFFeFBUMUJmUkVWVVJVTlVSVVFBU0ZCRlgwTlNYMFZZVUVWRFZFVkVBRWhRUlY5TVJsOUZXRkJGUTFSRlJBQkRVa1ZCVkVWRUFFbE5YMVZUUlVRQVNGQkZYMUJCVlZORlJBQlVTVTFGVDFWVVgwOURRMVZTUlVRQVVFRlpUVVZPVkY5U1JWRlZTVkpGUkFCUVVrVkRUMDVFU1ZSSlQwNWZVa1ZSVlVsU1JVUUFVRkpQV0ZsZlFWVlVTRVZPVkVsRFFWUkpUMDVmVWtWUlZVbFNSVVFBVGtWVVYwOVNTMTlCVlZSSVJVNVVTVU5CVkVsUFRsOVNSVkZWU1ZKRlJBQk1SVTVIVkVoZlVrVlJWVWxTUlVRQVUxTk1YME5GVWxSSlJrbERRVlJGWDFKRlVWVkpVa1ZFQUZWUVIxSkJSRVZmVWtWUlZVbFNSVVFBVUVGSFJWOUZXRkJKVWtWRUFGQlNSVU5QVGtSSlZFbFBUbDlHUVVsTVJVUUFSVmhRUlVOVVFWUkpUMDVmUmtGSlRFVkVBRkpGVmtGTVNVUkJWRWxQVGw5R1FVbE1SVVFBVTFOTVgwaEJUa1JUU0VGTFJWOUdRVWxNUlVRQVRFOURTMFZFQUZSU1FVNVRSazlTVFVGVVNVOU9YMEZRVUV4SlJVUUFUazlVWDAxUFJFbEdTVVZFQUU1UFZGOUZXRlJGVGtSRlJBQkNRVTVFVjBsRVZFaGZURWxOU1ZSZlJWaERSVVZFUlVRQVUwbFVSVjlKVTE5UFZrVlNURTlCUkVWRUFFaEZRVVFBUlhod1pXTjBaV1FnU0ZSVVVDOEFBRjRUQUFBbUV3QUFNQkFBQVBBWEFBQ2RFd0FBRlJJQUFEa1hBQUR3RWdBQUNoQUFBSFVTQUFDdEVnQUFnaE1BQUU4VUFBQi9FQUFBb0JVQUFDTVVBQUNKRWdBQWl4UUFBRTBWQUFEVUVRQUF6eFFBQUJBWUFBREpGZ0FBM0JZQUFNRVJBQURnRndBQXV4UUFBSFFVQUFCOEZRQUE1UlFBQUFnWEFBQWZFQUFBWlJVQUFLTVVBQUFvRlFBQUFoVUFBSmtWQUFBc0VBQUFpeGtBQUU4UEFBRFVEZ0FBYWhBQUFNNFFBQUFDRndBQWlRNEFBRzRUQUFBY0V3QUFaaFFBQUZZWEFBREJFd0FBelJNQUFHd1RBQUJvRndBQVpoY0FBRjhYQUFBaUV3QUF6ZzhBQUdrT0FBRFlEZ0FBWXhZQUFNc1RBQUNxRGdBQUtCY0FBQ1lYQUFERkV3QUFYUllBQU9nUkFBQm5Fd0FBWlJNQUFQSVdBQUJ6RXdBQUhSY0FBUGtXQUFEekVRQUF6dzRBQU00VkFBQU1FZ0FBc3hFQUFLVVJBQUJoRUFBQU1oY0FBTHNUQUVINU5Rc0JBUUJCa0RZTDRBRUJBUUlCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQkIvVGNMQVFFQVFaRTRDMTRDQXdJQ0FnSUNBQUFDQWdBQ0FnQUNBZ0lDQWdJQ0FnSUNBQVFBQUFBQUFBSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FBQUFBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lBQWdBQ0FFSDlPUXNCQVFCQmtUb0xYZ0lBQWdJQ0FnSUFBQUlDQUFJQ0FBSUNBZ0lDQWdJQ0FnSUFBd0FFQUFBQUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQUFBQUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0FDQUFJQVFmQTdDdzFzYjNObFpXVndMV0ZzYVhabEFFR0pQQXNCQVFCQm9Ed0w0QUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCaVQ0TEFRRUFRYUErQytjQkFRRUJBUUVCQVFFQkFRRUJBZ0VCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFGamFIVnVhMlZrQUVHd3dBQUxYd0VCQUFFQkFRRUJBQUFCQVFBQkFRQUJBUUVCQVFFQkFRRUJBQUFBQUFBQUFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBQUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFBQkFFR1F3Z0FMSVdWamRHbHZibVZ1ZEMxc1pXNW5kR2h2Ym5KdmVIa3RZMjl1Ym1WamRHbHZiZ0JCd01JQUN5MXlZVzV6Wm1WeUxXVnVZMjlrYVc1bmNHZHlZV1JsRFFvTkNnMEtVMDBOQ2cwS1ZGUlFMME5GTDFSVFVDOEFRZm5DQUFzRkFRSUFBUU1BUVpEREFBdmdBUVFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBRUg1eEFBTEJRRUNBQUVEQUVHUXhRQUw0QUVFQVFFRkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUJCK2NZQUN3UUJBQUFCQUVHUnh3QUwzd0VCQVFBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBRUg2eUFBTEJBRUFBQUlBUVpESkFBdGZBd1FBQUFRRUJBUUVCQVFFQkFRRUJRUUVCQVFFQkFRRUJBUUVCQUFFQUFZSEJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUFBUUFCQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFBQUFRQVFmcktBQXNFQVFBQUFRQkJrTXNBQ3dFQkFFR3F5d0FMUVFJQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0FBQUFBQUFBTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREFFSDZ6QUFMQkFFQUFBRUFRWkROQUFzQkFRQkJtczBBQ3dZQ0FBQUFBQUlBUWJITkFBczZBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TUFBQUFBQUFBREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdCQjhNNEFDNVlCVGs5VlRrTkZSVU5MVDFWVVRrVkRWRVZVUlVOU1NVSkZURlZUU0VWVVJVRkVVMFZCVWtOSVVrZEZRMVJKVmtsVVdVeEZUa1JCVWxaRlQxUkpSbGxRVkVsUFRsTkRTRk5GUVZsVFZFRlVRMGhIUlU5U1JFbFNSVU5VVDFKVVVrTklVRUZTUVUxRlZFVlNWVkpEUlVKVFExSkpRa1ZCVWtSUFYwNUJRMFZKVGtST1MwTkxWVUpUUTFKSlFrVklWRlJRTDBGRVZGQXYnLCAnYmFzZTY0JylcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/llhttp-wasm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Buffer } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nmodule.exports = Buffer.from('AGFzbQEAAAABJwdgAX8Bf2ADf39/AX9gAX8AYAJ/fwBgBH9/f38Bf2AAAGADf39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQAEA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAy0sBQYAAAIAAAAAAAACAQIAAgICAAADAAAAAAMDAwMBAQEBAQEBAQEAAAIAAAAEBQFwARISBQMBAAIGCAF/AUGA1AQLB9EFIgZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAIGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAJGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQAvDGxsaHR0cF9hbGxvYwALBm1hbGxvYwAxC2xsaHR0cF9mcmVlAAwEZnJlZQAMD2xsaHR0cF9nZXRfdHlwZQANFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAOFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAPEWxsaHR0cF9nZXRfbWV0aG9kABAWbGxodHRwX2dldF9zdGF0dXNfY29kZQAREmxsaHR0cF9nZXRfdXBncmFkZQASDGxsaHR0cF9yZXNldAATDmxsaHR0cF9leGVjdXRlABQUbGxodHRwX3NldHRpbmdzX2luaXQAFQ1sbGh0dHBfZmluaXNoABYMbGxodHRwX3BhdXNlABcNbGxodHRwX3Jlc3VtZQAYG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAZEGxsaHR0cF9nZXRfZXJybm8AGhdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAbF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uABwUbGxodHRwX2dldF9lcnJvcl9wb3MAHRFsbGh0dHBfZXJybm9fbmFtZQAeEmxsaHR0cF9tZXRob2RfbmFtZQAfEmxsaHR0cF9zdGF0dXNfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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PgtBhwEMPQtBiAEMPAtBiQEMOwtBigEMOgtBiwEMOQtBjAEMOAtBjQEMNwtBjgEMNgtBjwEMNQtBkAEMNAtBkQEMMwtBkgEMMgtBkwEMMQtBlAEMMAtBlQEMLwtBlgEMLgtBlwEMLQtBmAEMLAtBmQEMKwtBmgEMKgtBmwEMKQtBnAEMKAtBnQEMJwtBngEMJgtBnwEMJQtBoAEMJAtBoQEMIwtBogEMIgtBowEMIQtBpAEMIAtBpQEMHwtBpgEMHgtBpwEMHQtBqAEMHAtBqQEMGwtBqgEMGgtBqwEMGQtBrAEMGAtBrQEMFwtBrgEMFgtBAQwVC0GvAQwUC0GwAQwTC0GxAQwSC0GzAQwRC0GyAQwQC0G0AQwPC0G1AQwOC0G2AQwNC0G3AQwMC0G4AQwLC0G5AQwKC0G6AQwJC0G7AQwIC0HGAQwHC0G8AQwGC0G9AQwFC0G+AQwEC0G/AQwDC0HAAQwCC0HCAQwBC0HBAQshAwNAAkACQAJAAkACQAJAAkACQAJAIAICfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAgJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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iQEhAwykAgtBASABLQAAQd8ARw1nGiABQQFqIQEMXgtBigEhAyABIARGDaICIAIoAgAiACAEIAFraiEFIAEgAGtBAWohBgNAIAEtAAAgAEGMzwBqLQAARw1kIABBAUYN+gEgAEEBaiEAIAQgAUEBaiIBRw0ACyACIAU2AgAMogILQYsBIQMgASAERg2hAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGOzwBqLQAARw1kIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyiAgsgAkEANgIAIAZBAWohAUECDGULQYwBIQMgASAERg2gAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHwzwBqLQAARw1jIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyhAgsgAkEANgIAIAZBAWohAUEfDGQLQY0BIQMgASAERg2fAiACKAIAIgAgBCABa2ohBSABIABrQQFqIQYCQANAIAEtAAAgAEHyzwBqLQAARw1iIABBAUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAygAgsgAkEANgIAIAZBAWohAUEJDGMLIAEgBEYEQEGOASEDDJ8CCwJAAkAgAS0AAEHJAGsOBwBiYmJiYgFiCyABQQFqIQFB+AAhAwyGAgsgAUEBaiEBQfkAIQMMhQILQY8BIQMgASAERg2dAiACKAIAIgAgBCABa2ohBSABIABrQQVqIQYCQANAIAEtAAAgAEGRzwBqLQAARw1gIABBBUYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAyeAgsgAkEANgIAIAZBAWohAUEYDGELQZABIQMgASAERg2cAiACKAIAIgAgBCABa2ohBSABIABrQQJqIQYCQANAIAEtAAAgAEGXzwBqLQAARw1fIABBAkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAydAgsgAkEANgIAIAZBAWohAUEXDGALQZEBIQMgASAERg2bAiACKAIAIgAgBCABa2ohBSABIABrQQZqIQYCQANAIAEtAAAgAEGazwBqLQAARw1eIABBBkYNASAAQQFqIQAgBCABQQFqIgFHDQALIAIgBTYCAAycAgsgAkEANgIAIAZBAWohAUEV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JSIARQ0RIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMtAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0gIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMswELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0iIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMsgELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0OIAJB5QA2AhwgAiABNgIUIAIgADYCDEEAIQMMsQELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0dIAJB0wA2AhwgAiABNgIUIAIgADYCDEEAIQMMsAELIAIoAgQhACACQQA2AgQgAiAAIAEQJSIARQ0fIAJB0gA2AhwgAiABNgIUIAIgADYCDEEAIQMMrwELIABBP0cNASABQQFqCyEBQQUhAwyUAQtBACEDIAJBADYCHCACIAE2AhQgAkH9EjYCECACQQc2AgwMrAELIAJBADYCHCACIAE2AhQgAkHcCDYCECACQQc2AgxBACEDDKsBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNByACQeUANgIcIAIgATYCFCACIAA2AgxBACEDDKoBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNFiACQdMANgIcIAIgATYCFCACIAA2AgxBACEDDKkBCyACKAIEIQAgAkEANgIEIAIgACABECUiAEUNGCACQdIANgIcIAIgATYCFCACIAA2AgxBACEDDKgBCyACQQA2AhwgAiABNgIUIAJBxgo2AhAgAkEHNgIMQQAhAwynAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQMgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwymAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRIgAkHTADYCHCACIAE2AhQgAiAANgIMQQAhAwylAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDRQgAkHSADYCHCACIAE2AhQgAiAANgIMQQAhAwykAQsgAigCBCEAIAJBADYCBCACIAAgARAlIgBFDQAgAkHlADYCHCACIAE2AhQgAiAANgIMQQAhAwyjAQtB1QAhAwyJAQsgAEEVRwRAIAJBADYCHCACIAE2AhQgAkG5DTYCECACQRo2AgxB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB5ABrDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0HhJw8LQaQhDwtByywPC0H+MQ8LQcAkDwtBqyQPC0GNKA8LQeImDwtBgDAPC0G5Lw8LQdckDwtB7x8PC0HhHw8LQfofDwtB8iAPC0GoLw8LQa4yDwtBiDAPC0HsJw8LQYIiDwtBjh0PC0HQLg8LQcojDwtBxTIPC0HfHA8LQdIcDwtBxCAPC0HXIA8LQaIfDwtB7S4PC0GrMA8LQdQlDwtBzC4PC0H6Lg8LQfwrDwtB0jAPC0HxHQ8LQbsgDwtB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AAADAEGUCAsFBAAAAAUAQaQICwkGAAAABwAAAAgAQdwIC4otSW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9yZXNldGAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwBB+TULAQEAQZA2C+ABAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQf03CwEBAEGROAteAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgBB/TkLAQEAQZE6C14CAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAEHwOwsNbG9zZWVlcC1hbGl2ZQBBiTwLAQEAQaA8C+ABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQYk+CwEBAEGgPgvnAQEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZABBsMAAC18BAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQBBkMIACyFlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AQcDCAAstcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAEH5wgALBQECAAEDAEGQwwAL4AEEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+cQACwUBAgABAwBBkMUAC+ABBAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAQfnGAAsEAQAAAQBBkccAC98BAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBB+sgACwQBAAACAEGQyQALXwMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAEH6ygALBAEAAAEAQZDLAAsBAQBBqssAC0ECAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBB+swACwQBAAABAEGQzQALAQEAQZrNAAsGAgAAAAACAEGxzQALOgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAQfDOAAuWAU5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==', 'base64')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvbGxodHRwX3NpbWQtd2FzbS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLGdDQUFhOztBQUV4QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxsbGh0dHBcXGxsaHR0cF9zaW1kLXdhc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyLmZyb20oJ0FHRnpiUUVBQUFBQkp3ZGdBWDhCZjJBRGYzOS9BWDlnQVg4QVlBSi9md0JnQkg5L2YzOEJmMkFBQUdBRGYzOS9BQUxMQVFnRFpXNTJHSGRoYzIxZmIyNWZhR1ZoWkdWeWMxOWpiMjF3YkdWMFpRQUVBMlZ1ZGhWM1lYTnRYMjl1WDIxbGMzTmhaMlZmWW1WbmFXNEFBQU5sYm5ZTGQyRnpiVjl2Ymw5MWNtd0FBUU5sYm5ZT2QyRnpiVjl2Ymw5emRHRjBkWE1BQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZlptbGxiR1FBQVFObGJuWVVkMkZ6YlY5dmJsOW9aV0ZrWlhKZmRtRnNkV1VBQVFObGJuWU1kMkZ6YlY5dmJsOWliMlI1QUFFRFpXNTJHSGRoYzIxZmIyNWZiV1Z6YzJGblpWOWpiMjF3YkdWMFpRQUFBeTBzQlFZQUFBSUFBQUFBQUFBQ0FRSUFBZ0lDQUFBREFBQUFBQU1EQXdNQkFRRUJBUUVCQVFFQUFBSUFBQUFFQlFGd0FSSVNCUU1CQUFJR0NBRi9BVUdBMUFRTEI5RUZJZ1p0WlcxdmNua0NBQXRmYVc1cGRHbGhiR2w2WlFBSUdWOWZhVzVrYVhKbFkzUmZablZ1WTNScGIyNWZkR0ZpYkdVQkFBdHNiR2gwZEhCZmFXNXBkQUFKR0d4c2FIUjBjRjl6YUc5MWJHUmZhMlZsY0Y5aGJHbDJaUUF2REd4c2FIUjBjRjloYkd4dll3QUxCbTFoYkd4dll3QXhDMnhzYUhSMGNGOW1jbVZsQUF3RVpuSmxaUUFNRDJ4c2FIUjBjRjluWlhSZmRIbHdaUUFORld4c2FIUjBjRjluWlhSZmFIUjBjRjl0WVdwdmNnQU9GV3hzYUhSMGNGOW5aWFJmYUhSMGNGOXRhVzV2Y2dBUEVXeHNhSFIwY0Y5blpYUmZiV1YwYUc5a0FCQVdiR3hvZEhSd1gyZGxkRjl6ZEdGMGRYTmZZMjlrWlFBUkVteHNhSFIwY0Y5blpYUmZkWEJuY21Ga1pRQVNER3hzYUhSMGNGOXlaWE5sZEFBVERteHNhSFIwY0Y5bGVHVmpkWFJsQUJRVWJHeG9kSFJ3WDNObGRIUnBibWR6WDJsdWFYUUFGUTFzYkdoMGRIQmZabWx1YVhOb0FCWU1iR3hvZEhSd1gzQmhkWE5sQUJjTmJHeG9kSFJ3WDNKbGMzVnRaUUFZRzJ4c2FIUjBjRjl5WlhOMWJXVmZZV1owWlhKZmRYQm5jbUZrWlFBWkVHeHNhSFIwY0Y5blpYUmZaWEp5Ym04QUdoZHNiR2gwZEhCZloyVjBYMlZ5Y205eVgzSmxZWE52YmdBYkYyeHNhSFIwY0Y5elpYUmZaWEp5YjNKZmNtVmhjMjl1QUJ3VWJHeG9kSFJ3WDJkbGRGOWxjbkp2Y2w5d2IzTUFIUkZzYkdoMGRIQmZaWEp5Ym05ZmJtRnRaUUFlRW14c2FIUjBjRjl0WlhSb2IyUmZibUZ0WlFBZkVteHNhSFIwY0Y5emRHRjBkWE5mYm1GdFpRQWdHbXhzYUhSMGNGOXpaWFJmYkdWdWFXVnVkRjlvWldGa1pYSnpBQ0VoYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDJOb2RXNXJaV1JmYkdWdVozUm9BQ0lkYkd4b2RIUndYM05sZEY5c1pXNXBaVzUwWDJ0bFpYQmZZV3hwZG1VQUl5UnNiR2gwZEhCZmMyVjBYMnhsYm1sbGJuUmZkSEpoYm5ObVpYSmZaVzVqYjJScGJtY0FKQmhzYkdoMGRIQmZiV1Z6YzJGblpWOXVaV1ZrYzE5bGIyWUFMZ2tYQVFCQkFRc1JBUUlEQkFVS0JnY3JMU3dxS1NnbEp5WUs3N01DTEJZQVFZalFBQ2dDQUFSQUFBdEJpTkFBUVFFMkFnQUxGQUFnQUJBd0lBQWdBallDT0NBQUlBRTZBQ2dMRkFBZ0FDQUFMd0V5SUFBdEFDNGdBQkF2RUFBTEhnRUJmMEhBQUJBeUlnRVFNQ0FCUVlBSU5nSTRJQUVnQURvQUtDQUJDNDhNQVFkL0FrQWdBRVVOQUNBQVFRaHJJZ0VnQUVFRWF5Z0NBQ0lBUVhoeElnUnFJUVVDUUNBQVFRRnhEUUFnQUVFRGNVVU5BU0FCSUFFb0FnQWlBR3NpQVVHYzBBQW9BZ0JKRFFFZ0FDQUVhaUVFQWtBQ1FFR2cwQUFvQWdBZ0FVY0VRQ0FBUWY4QlRRUkFJQUJCQTNZaEF5QUJLQUlJSWdBZ0FTZ0NEQ0lDUmdSQVFZelFBRUdNMEFBb0FnQkJmaUFEZDNFMkFnQU1CUXNnQWlBQU5nSUlJQUFnQWpZQ0RBd0VDeUFCS0FJWUlRWWdBU0FCS0FJTUlnQkhCRUFnQUNBQktBSUlJZ0kyQWdnZ0FpQUFOZ0lNREFNTElBRkJGR29pQXlnQ0FDSUNSUVJBSUFFb0FoQWlBa1VOQWlBQlFSQnFJUU1MQTBBZ0F5RUhJQUlpQUVFVWFpSURLQUlBSWdJTkFDQUFRUkJxSVFNZ0FDZ0NFQ0lDRFFBTElBZEJBRFlDQUF3Q0N5QUZLQUlFSWdCQkEzRkJBMGNOQWlBRklBQkJmbkUyQWdSQmxOQUFJQVEyQWdBZ0JTQUVOZ0lBSUFFZ0JFRUJjallDQkF3REMwRUFJUUFMSUFaRkRRQUNRQ0FCS0FJY0lnSkJBblJCdk5JQWFpSURLQUlBSUFGR0JFQWdBeUFBTmdJQUlBQU5BVUdRMEFCQmtOQUFLQUlBUVg0Z0FuZHhOZ0lBREFJTElBWkJFRUVVSUFZb0FoQWdBVVliYWlBQU5nSUFJQUJGRFFFTElBQWdCallDR0NBQktBSVFJZ0lFUUNBQUlBSTJBaEFnQWlBQU5nSVlDeUFCUVJScUtBSUFJZ0pGRFFBZ0FFRVVhaUFDTmdJQUlBSWdBRFlDR0FzZ0FTQUZUdzBBSUFVb0FnUWlBRUVCY1VVTkFBSkFBa0FDUUFKQUlBQkJBbkZGQkVCQnBOQUFLQUlBSUFWR0JFQkJwTkFBSUFFMkFnQkJtTkFBUVpqUUFDZ0NBQ0FFYWlJQU5nSUFJQUVnQUVFQmNqWUNCQ0FCUWFEUUFDZ0NBRWNOQmtHVTBBQkJBRFlDQUVHZzBBQkJBRFlDQUF3R0MwR2cwQUFvQWdBZ0JVWUVRRUdnMEFBZ0FUWUNBRUdVMEFCQmxOQUFLQUlBSUFScUlnQTJBZ0FnQVNBQVFRRnlOZ0lFSUFBZ0FXb2dBRFlDQUF3R0N5QUFRWGh4SUFScUlRUWdBRUgvQVUwRVFDQUFRUU4ySVFNZ0JTZ0NDQ0lBSUFVb0Fnd2lBa1lFUUVHTTBBQkJqTkFBS0FJQVFYNGdBM2R4TmdJQURBVUxJQUlnQURZQ0NDQUFJQUkyQWd3TUJBc2dCU2dDR0NFR0lBVWdCU2dDRENJQVJ3UkFRWnpRQUNnQ0FCb2dBQ0FGS0FJSUlnSTJBZ2dnQWlBQU5nSU1EQU1MSUFWQkZHb2lBeWdDQUNJQ1JRUkFJQVVvQWhBaUFrVU5BaUFGUVJCcUlRTUxBMEFnQXlFSElBSWlBRUVVYWlJREtBSUFJZ0lOQUNBQVFSQnFJUU1nQUNnQ0VDSUNEUUFMSUFkQkFEWUNBQXdDQ3lBRklBQkJmbkUyQWdRZ0FTQUVhaUFFTmdJQUlBRWdCRUVCY2pZQ0JBd0RDMEVBSVFBTElBWkZEUUFDUUNBRktBSWNJZ0pCQW5SQnZOSUFhaUlES0FJQUlBVkdCRUFnQXlBQU5nSUFJQUFOQVVHUTBBQkJrTkFBS0FJQVFYNGdBbmR4TmdJQURBSUxJQVpCRUVFVUlBWW9BaEFnQlVZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQmpZQ0dDQUZLQUlRSWdJRVFDQUFJQUkyQWhBZ0FpQUFOZ0lZQ3lBRlFSUnFLQUlBSWdKRkRRQWdBRUVVYWlBQ05nSUFJQUlnQURZQ0dBc2dBU0FFYWlBRU5nSUFJQUVnQkVFQmNqWUNCQ0FCUWFEUUFDZ0NBRWNOQUVHVTBBQWdCRFlDQUF3QkN5QUVRZjhCVFFSQUlBUkJlSEZCdE5BQWFpRUFBbjlCak5BQUtBSUFJZ0pCQVNBRVFRTjJkQ0lEY1VVRVFFR00wQUFnQWlBRGNqWUNBQ0FBREFFTElBQW9BZ2dMSWdJZ0FUWUNEQ0FBSUFFMkFnZ2dBU0FBTmdJTUlBRWdBallDQ0F3QkMwRWZJUUlnQkVILy8vOEhUUVJBSUFSQkppQUVRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9oQWdzZ0FTQUNOZ0ljSUFGQ0FEY0NFQ0FDUVFKMFFielNBR29oQUFKQVFaRFFBQ2dDQUNJRFFRRWdBblFpQjNGRkJFQWdBQ0FCTmdJQVFaRFFBQ0FESUFkeU5nSUFJQUVnQURZQ0dDQUJJQUUyQWdnZ0FTQUJOZ0lNREFFTElBUkJHU0FDUVFGMmEwRUFJQUpCSDBjYmRDRUNJQUFvQWdBaEFBSkFBMEFnQUNJREtBSUVRWGh4SUFSR0RRRWdBa0VkZGlFQUlBSkJBWFFoQWlBRElBQkJCSEZxUVJCcUlnY29BZ0FpQUEwQUN5QUhJQUUyQWdBZ0FTQUROZ0lZSUFFZ0FUWUNEQ0FCSUFFMkFnZ01BUXNnQXlnQ0NDSUFJQUUyQWd3Z0F5QUJOZ0lJSUFGQkFEWUNHQ0FCSUFNMkFnd2dBU0FBTmdJSUMwR3MwQUJCck5BQUtBSUFRUUZySWdCQmZ5QUFHellDQUFzTEJ3QWdBQzBBS0FzSEFDQUFMUUFxQ3djQUlBQXRBQ3NMQndBZ0FDMEFLUXNIQUNBQUx3RXlDd2NBSUFBdEFDNExRQUVFZnlBQUtBSVlJUUVnQUMwQUxTRUNJQUF0QUNnaEF5QUFLQUk0SVFRZ0FCQXdJQUFnQkRZQ09DQUFJQU02QUNnZ0FDQUNPZ0F0SUFBZ0FUWUNHQXU3NGdFQ0IzOERmaUFCSUFKcUlRUUNRQ0FBSWdJb0Fnd2lBQTBBSUFJb0FnUUVRQ0FDSUFFMkFnUUxJd0JCRUdzaUNDUUFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFJQUlvQWh3aUEwRUJhdzdkQWRvQkFka0JBZ01FQlFZSENBa0tDd3dORHRnQkR4RFhBUkVTMWdFVEZCVVdGeGdaR2h2Z0FkOEJIQjBlMVFFZklDRWlJeVFsMUFFbUp5Z3BLaXNzMHdIU0FTMHUwUUhRQVM4d01USXpORFUyTnpnNU9qczhQVDQvUUVGQ1EwUkZSdHNCUjBoSlNzOEJ6Z0ZMelFGTXpBRk5UazlRVVZKVFZGVldWMWhaV2x0Y1hWNWZZR0ZpWTJSbFptZG9hV3ByYkcxdWIzQnhjbk4wZFhaM2VIbDZlM3g5Zm4rQUFZRUJnZ0dEQVlRQmhRR0dBWWNCaUFHSkFZb0Jpd0dNQVkwQmpnR1BBWkFCa1FHU0FaTUJsQUdWQVpZQmx3R1lBWmtCbWdHYkFad0JuUUdlQVo4Qm9BR2hBYUlCb3dHa0FhVUJwZ0duQWFnQnFRR3FBYXNCckFHdEFhNEJyd0d3QWJFQnNnR3pBYlFCdFFHMkFiY0J5d0hLQWJnQnlRRzVBY2dCdWdHN0Fid0J2UUcrQWI4QndBSEJBY0lCd3dIRUFjVUJ4Z0VBM0FFTFFRQU14Z0VMUVE0TXhRRUxRUTBNeEFFTFFROE13d0VMUVJBTXdnRUxRUk1Nd1FFTFFSUU13QUVMUVJVTXZ3RUxRUllNdmdFTFFSZ012UUVMUVJrTXZBRUxRUm9NdXdFTFFSc011Z0VMUVJ3TXVRRUxRUjBNdUFFTFFRZ010d0VMUVI0TXRnRUxRU0FNdFFFTFFSOE10QUVMUVFjTXN3RUxRU0VNc2dFTFFTSU1zUUVMUVNNTXNBRUxRU1FNcndFTFFSSU1yZ0VMUVJFTXJRRUxRU1VNckFFTFFTWU1xd0VMUVNjTXFnRUxRU2dNcVFFTFFjTUJES2dCQzBFcURLY0JDMEVyREtZQkMwRXNES1VCQzBFdERLUUJDMEV1REtNQkMwRXZES0lCQzBIRUFReWhBUXRCTUF5Z0FRdEJOQXlmQVF0QkRBeWVBUXRCTVF5ZEFRdEJNZ3ljQVF0Qk13eWJBUXRCT1F5YUFRdEJOUXlaQVF0QnhRRU1tQUVMUVFzTWx3RUxRVG9NbGdFTFFUWU1sUUVMUVFvTWxBRUxRVGNNa3dFTFFUZ01rZ0VMUVR3TWtRRUxRVHNNa0FFTFFUME1qd0VMUVFrTWpnRUxRU2tNalFFTFFUNE1qQUVMUVQ4TWl3RUxRY0FBRElvQkMwSEJBQXlKQVF0QndnQU1pQUVMUWNNQURJY0JDMEhFQUF5R0FRdEJ4UUFNaFFFTFFjWUFESVFCQzBFWERJTUJDMEhIQUF5Q0FRdEJ5QUFNZ1FFTFFja0FESUFCQzBIS0FBeC9DMEhMQUF4K0MwSE5BQXg5QzBITUFBeDhDMEhPQUF4N0MwSFBBQXg2QzBIUUFBeDVDMEhSQUF4NEMwSFNBQXgzQzBIVEFBeDJDMEhVQUF4MUMwSFdBQXgwQzBIVkFBeHpDMEVHREhJTFFkY0FESEVMUVFVTWNBdEIyQUFNYnd0QkJBeHVDMEhaQUF4dEMwSGFBQXhzQzBIYkFBeHJDMEhjQUF4cUMwRURER2tMUWQwQURHZ0xRZDRBREdjTFFkOEFER1lMUWVFQURHVUxRZUFBREdRTFFlSUFER01MUWVNQURHSUxRUUlNWVF0QjVBQU1ZQXRCNVFBTVh3dEI1Z0FNWGd0QjV3QU1YUXRCNkFBTVhBdEI2UUFNV3d0QjZnQU1XZ3RCNndBTVdRdEI3QUFNV0F0QjdRQU1Wd3RCN2dBTVZndEI3d0FNVlF0QjhBQU1WQXRCOFFBTVV3dEI4Z0FNVWd0Qjh3QU1VUXRCOUFBTVVBdEI5UUFNVHd0QjlnQU1UZ3RCOXdBTVRRdEIrQUFNVEF0QitRQU1Td3RCK2dBTVNndEIrd0FNU1F0Qi9BQU1TQXRCL1FBTVJ3dEIvZ0FNUmd0Qi93QU1SUXRCZ0FFTVJBdEJnUUVNUXd0QmdnRU1RZ3RCZ3dFTVFRdEJoQUVNUUF0QmhRRU1Qd3RCaGdFTVBndEJod0VNUFF0QmlBRU1QQXRCaVFFTU93dEJpZ0VNT2d0Qml3RU1PUXRCakFFTU9BdEJqUUVNTnd0QmpnRU1OZ3RCandFTU5RdEJrQUVNTkF0QmtRRU1Nd3RCa2dFTU1ndEJrd0VNTVF0QmxBRU1NQXRCbFFFTUx3dEJsZ0VNTGd0Qmx3RU1MUXRCbUFFTUxBdEJtUUVNS3d0Qm1nRU1LZ3RCbXdFTUtRdEJuQUVNS0F0Qm5RRU1Kd3RCbmdFTUpndEJud0VNSlF0Qm9BRU1KQXRCb1FFTUl3dEJvZ0VNSWd0Qm93RU1JUXRCcEFFTUlBdEJwUUVNSHd0QnBnRU1IZ3RCcHdFTUhRdEJxQUVNSEF0QnFRRU1Hd3RCcWdFTUdndEJxd0VNR1F0QnJBRU1HQXRCclFFTUZ3dEJyZ0VNRmd0QkFRd1ZDMEd2QVF3VUMwR3dBUXdUQzBHeEFRd1NDMEd6QVF3UkMwR3lBUXdRQzBHMEFRd1BDMEcxQVF3T0MwRzJBUXdOQzBHM0FRd01DMEc0QVF3TEMwRzVBUXdLQzBHNkFRd0pDMEc3QVF3SUMwSEdBUXdIQzBHOEFRd0dDMEc5QVF3RkMwRytBUXdFQzBHL0FRd0RDMEhBQVF3Q0MwSENBUXdCQzBIQkFRc2hBd05BQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFJQ2Z3SkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKL0FrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBZ0FnSi9Ba0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDZndKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ2Z3SkFBa0FDUUFKQUFuOENRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FERHNZQkFBRUNBd1FGQmdjSUNRb0xEQTBPRHhBUkVoTVVGUllYR0JrYUd4d2RIeUFoSXlVbUtDb3JMQzh3TVRJek5EVTJOems2T3p3OWxBTkFRa1JGUmtsTFRrOVFVVkpUVkZWV1dGcGJYRjFlWDJCaFltTmtaV1puYUdwc2IzQnhjM1YyZUhsNmUzeC9nQUdCQVlJQmd3R0VBWVVCaGdHSEFZZ0JpUUdLQVlzQmpBR05BWTRCandHUUFaRUJrZ0dUQVpRQmxRR1dBWmNCbUFHWkFab0Jtd0djQVowQm5nR2ZBYUFCb1FHaUFhTUJwQUdsQWFZQnB3R29BYWtCcWdHckFhd0JyUUd1QWE4QnNBR3hBYklCc3dHMEFiVUJ0Z0czQWJnQnVRRzZBYnNCdkFHOUFiNEJ2d0hBQWNFQndnSERBY1FCeFFIR0FjY0J5QUhKQWNzQnpBSE5BYzRCendHS0E0a0RpQU9IQTRRRGd3T0FBL3NDK2dMNUF2Z0M5d0wwQXZNQzhnTExBc0VDc0FMWkFRc2dBU0FFUnczd0FrSGRBU0VERExNREN5QUJJQVJIRGNnQlFjTUJJUU1Nc2dNTElBRWdCRWNOZTBIM0FDRURETEVEQ3lBQklBUkhEWEJCN3dBaEF3eXdBd3NnQVNBRVJ3MXBRZW9BSVFNTXJ3TUxJQUVnQkVjTlpVSG9BQ0VEREs0REN5QUJJQVJIRFdKQjVnQWhBd3l0QXdzZ0FTQUVSdzBhUVJnaEF3eXNBd3NnQVNBRVJ3MFZRUkloQXd5ckF3c2dBU0FFUncxQ1FjVUFJUU1NcWdNTElBRWdCRWNOTkVFL0lRTU1xUU1MSUFFZ0JFY05Na0U4SVFNTXFBTUxJQUVnQkVjTkswRXhJUU1NcHdNTElBSXRBQzVCQVVZTm53TU13UUlMUVFBaEFBSkFBa0FDUUNBQ0xRQXFSUTBBSUFJdEFDdEZEUUFnQWk4Qk1DSURRUUp4UlEwQkRBSUxJQUl2QVRBaUEwRUJjVVVOQVF0QkFTRUFJQUl0QUNoQkFVWU5BQ0FDTHdFeUlnVkI1QUJyUWVRQVNRMEFJQVZCekFGR0RRQWdCVUd3QWtZTkFDQURRY0FBY1EwQVFRQWhBQ0FEUVlnRWNVR0FCRVlOQUNBRFFTaHhRUUJISVFBTElBSkJBRHNCTUNBQ1FRQTZBQzhnQUVVTjN3SWdBa0lBTndNZ0RPQUNDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDTENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzTUFTQUFRUlZIRGQwQ0lBSkJCRFlDSENBQ0lBRTJBaFFnQWtHd0dEWUNFQ0FDUVJVMkFneEJBQ0VEREtRREN5QUJJQVJHQkVCQkJpRURES1FEQ3lBQlFRRnFJUUZCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWxRaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUEzWkFnd2NDeUFDUWdBM0F5QkJFaUVERElrREN5QUJJQVJIRFJaQkhTRURES0VEQ3lBQklBUkhCRUFnQVVFQmFpRUJRUkFoQXd5SUF3dEJCeUVEREtBREN5QUNJQUlwQXlBaUNpQUVJQUZyclNJTGZTSU1RZ0FnQ2lBTVdoczNBeUFnQ2lBTFdBM1VBa0VJSVFNTW53TUxJQUVnQkVjRVFDQUNRUWsyQWdnZ0FpQUJOZ0lFUVJRaEF3eUdBd3RCQ1NFRERKNERDeUFDS1FNZ1FnQlNEY2NCSUFJZ0FpOEJNRUdBQVhJN0FUQU1RZ3NnQVNBRVJ3MC9RZEFBSVFNTW5BTUxJQUVnQkVZRVFFRUxJUU1NbkFNTElBRkJBV29oQVVFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1VDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQURjOENETVlCQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1NDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRM0dBU0FBUVJWSERjMENJQUpCQ3pZQ0hDQUNJQUUyQWhRZ0FrR0NHVFlDRUNBQ1FSVTJBZ3hCQUNFRERKb0RDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDU0NJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEwTUlBQkJGVWNOeWdJZ0FrRWFOZ0ljSUFJZ0FUWUNGQ0FDUVlJWk5nSVFJQUpCRlRZQ0RFRUFJUU1NbVFNTFFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSk1JZ05GRFFBZ0FpQURFUUFBSVFBTElBQkZEY1FCSUFCQkZVY054d0lnQWtFTE5nSWNJQUlnQVRZQ0ZDQUNRWkVYTmdJUUlBSkJGVFlDREVFQUlRTU1tQU1MSUFFZ0JFWUVRRUVQSVFNTW1BTUxJQUV0QUFBaUFFRTdSZzBISUFCQkRVY054QUlnQVVFQmFpRUJETU1CQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ1RDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQVJRM0RBU0FBUVJWSERjSUNJQUpCRHpZQ0hDQUNJQUUyQWhRZ0FrR1JGellDRUNBQ1FSVTJBZ3hCQUNFRERKWURDd05BSUFFdEFBQkI4RFZxTFFBQUlnQkJBVWNFUUNBQVFRSkhEY0VDSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFSUFJZ0FDQUJRUUZxSWdFUUxTSUFEY0lDRE1VQkN5QUVJQUZCQVdvaUFVY05BQXRCRWlFRERKVURDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDVENJRFJRMEFJQUlnQXhFQUFDRUFDeUFBUlEzRkFTQUFRUlZIRGIwQ0lBSkJHellDSENBQ0lBRTJBaFFnQWtHUkZ6WUNFQ0FDUVJVMkFneEJBQ0VEREpRREN5QUJJQVJHQkVCQkZpRURESlFEQ3lBQ1FRbzJBZ2dnQWlBQk5nSUVRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUpJSWdORkRRQWdBaUFERVFBQUlRQUxJQUJGRGNJQklBQkJGVWNOdVFJZ0FrRVZOZ0ljSUFJZ0FUWUNGQ0FDUVlJWk5nSVFJQUpCRlRZQ0RFRUFJUU1Na3dNTElBRWdCRWNFUUFOQUlBRXRBQUJCOERkcUxRQUFJZ0JCQWtjRVFBSkFJQUJCQVdzT0JNUUN2UUlBdmdLOUFnc2dBVUVCYWlFQlFRZ2hBd3o4QWdzZ0JDQUJRUUZxSWdGSERRQUxRUlVoQXd5VEF3dEJGU0VEREpJREN3TkFJQUV0QUFCQjhEbHFMUUFBSWdCQkFrY0VRQ0FBUVFGckRnVEZBcmNDd3dLNEFyY0NDeUFFSUFGQkFXb2lBVWNOQUF0QkdDRURESkVEQ3lBQklBUkhCRUFnQWtFTE5nSUlJQUlnQVRZQ0JFRUhJUU1NK0FJTFFSa2hBd3lRQXdzZ0FVRUJhaUVCREFJTElBRWdCRVlFUUVFYUlRTU1qd01MQWtBZ0FTMEFBRUVOYXc0VXRRRy9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3Ry9BYjhCdndHL0FiOEJ2d0cvQWI4QnZ3RUF2d0VMUVFBaEF5QUNRUUEyQWh3Z0FrR3ZDellDRUNBQ1FRSTJBZ3dnQWlBQlFRRnFOZ0lVREk0REN5QUJJQVJHQkVCQkd5RURESTREQ3lBQkxRQUFJZ0JCTzBjRVFDQUFRUTFIRGJFQ0lBRkJBV29oQVF5NkFRc2dBVUVCYWlFQkMwRWlJUU1NOHdJTElBRWdCRVlFUUVFY0lRTU1qQU1MUWdBaENnSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FnQVMwQUFFRXdhdzQzd1FMQUFnQUJBZ01FQlFZSDBBSFFBZEFCMEFIUUFkQUIwQUVJQ1FvTERBM1FBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQjBBSFFBZEFCMEFIUUFkQUIwQUhRQWRBQkRnOFFFUklUMEFFTFFnSWhDZ3pBQWd0Q0F5RUtETDhDQzBJRUlRb012Z0lMUWdVaENneTlBZ3RDQmlFS0RMd0NDMElISVFvTXV3SUxRZ2doQ2d5NkFndENDU0VLRExrQ0MwSUtJUW9NdUFJTFFnc2hDZ3kzQWd0Q0RDRUtETFlDQzBJTklRb010UUlMUWc0aENneTBBZ3RDRHlFS0RMTUNDMElLSVFvTXNnSUxRZ3NoQ2d5eEFndENEQ0VLRExBQ0MwSU5JUW9NcndJTFFnNGhDZ3l1QWd0Q0R5RUtESzBDQzBJQUlRb0NRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBSUFFdEFBQkJNR3NPTjhBQ3Z3SUFBUUlEQkFVR0I3NEN2Z0srQXI0Q3ZnSytBcjRDQ0FrS0N3d052Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FyNEN2Z0srQXI0Q3ZnSytBcjRDdmdLK0FnNFBFQkVTRTc0Q0MwSUNJUW9NdndJTFFnTWhDZ3krQWd0Q0JDRUtETDBDQzBJRklRb012QUlMUWdZaENneTdBZ3RDQnlFS0RMb0NDMElJSVFvTXVRSUxRZ2toQ2d5NEFndENDaUVLRExjQ0MwSUxJUW9NdGdJTFFnd2hDZ3kxQWd0Q0RTRUtETFFDQzBJT0lRb01zd0lMUWc4aENneXlBZ3RDQ2lFS0RMRUNDMElMSVFvTXNBSUxRZ3doQ2d5dkFndENEU0VLREs0Q0MwSU9JUW9NclFJTFFnOGhDZ3lzQWdzZ0FpQUNLUU1nSWdvZ0JDQUJhNjBpQzMwaURFSUFJQW9nREZvYk53TWdJQW9nQzFnTnB3SkJIeUVERElrREN5QUJJQVJIQkVBZ0FrRUpOZ0lJSUFJZ0FUWUNCRUVsSVFNTThBSUxRU0FoQXd5SUF3dEJBU0VGSUFJdkFUQWlBMEVJY1VVRVFDQUNLUU1nUWdCU0lRVUxBa0FnQWkwQUxnUkFRUUVoQUNBQ0xRQXBRUVZHRFFFZ0EwSEFBSEZGSUFWeFJRMEJDMEVBSVFBZ0EwSEFBSEVOQUVFQ0lRQWdBMEVJY1EwQUlBTkJnQVJ4QkVBQ1FDQUNMUUFvUVFGSERRQWdBaTBBTFVFS2NRMEFRUVVoQUF3Q0MwRUVJUUFNQVFzZ0EwRWdjVVVFUUFKQUlBSXRBQ2hCQVVZTkFDQUNMd0V5SWdCQjVBQnJRZVFBU1EwQUlBQkJ6QUZHRFFBZ0FFR3dBa1lOQUVFRUlRQWdBMEVvY1VVTkFpQURRWWdFY1VHQUJFWU5BZ3RCQUNFQURBRUxRUUJCQXlBQ0tRTWdVQnNoQUFzZ0FFRUJhdzRGdmdJQXNBRUJwQUtoQWd0QkVTRURETzBDQ3lBQ1FRRTZBQzhNaEFNTElBRWdCRWNOblFKQkpDRURESVFEQ3lBQklBUkhEUnhCeGdBaEF3eURBd3RCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWtRaUEwVU5BQ0FDSUFNUkFBQWhBQXNnQUVVTkp5QUFRUlZIRFpnQ0lBSkIwQUEyQWh3Z0FpQUJOZ0lVSUFKQmtSZzJBaEFnQWtFVk5nSU1RUUFoQXd5Q0F3c2dBU0FFUmdSQVFTZ2hBd3lDQXd0QkFDRURJQUpCQURZQ0JDQUNRUXcyQWdnZ0FpQUJJQUVRS2lJQVJRMlVBaUFDUVNjMkFod2dBaUFCTmdJVUlBSWdBRFlDREF5QkF3c2dBU0FFUmdSQVFTa2hBd3lCQXdzZ0FTMEFBQ0lBUVNCR0RSTWdBRUVKUncyVkFpQUJRUUZxSVFFTUZBc2dBU0FFUndSQUlBRkJBV29oQVF3V0MwRXFJUU1NL3dJTElBRWdCRVlFUUVFcklRTU0vd0lMSUFFdEFBQWlBRUVKUnlBQVFTQkhjUTJRQWlBQ0xRQXNRUWhIRGQwQ0lBSkJBRG9BTEF6ZEFnc2dBU0FFUmdSQVFTd2hBd3orQWdzZ0FTMEFBRUVLUncyT0FpQUJRUUZxSVFFTXNBRUxJQUVnQkVjTmlnSkJMeUVERFB3Q0N3TkFJQUV0QUFBaUFFRWdSd1JBSUFCQkNtc09CSVFDaUFLSUFvUUNoZ0lMSUFRZ0FVRUJhaUlCUncwQUMwRXhJUU1NK3dJTFFUSWhBeUFCSUFSR0Rmb0NJQUlvQWdBaUFDQUVJQUZyYWlFSElBRWdBR3RCQTJvaEJnSkFBMEFnQUVId08yb3RBQUFnQVMwQUFDSUZRU0J5SUFVZ0JVSEJBR3RCL3dGeFFScEpHMEgvQVhGSERRRWdBRUVEUmdSQVFRWWhBUXppQWdzZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQWMyQWdBTSt3SUxJQUpCQURZQ0FBeUdBZ3RCTXlFRElBUWdBU0lBUmczNUFpQUVJQUZySUFJb0FnQWlBV29oQnlBQUlBRnJRUWhxSVFZQ1FBTkFJQUZCOUR0cUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncwQklBRkJDRVlFUUVFRklRRU00UUlMSUFGQkFXb2hBU0FFSUFCQkFXb2lBRWNOQUFzZ0FpQUhOZ0lBRFBvQ0N5QUNRUUEyQWdBZ0FDRUJESVVDQzBFMElRTWdCQ0FCSWdCR0RmZ0NJQVFnQVdzZ0FpZ0NBQ0lCYWlFSElBQWdBV3RCQldvaEJnSkFBMEFnQVVIUXdnQnFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MEJJQUZCQlVZRVFFRUhJUUVNNEFJTElBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFITmdJQURQa0NDeUFDUVFBMkFnQWdBQ0VCRElRQ0N5QUJJQVJIQkVBRFFDQUJMUUFBUVlBK2FpMEFBQ0lBUVFGSEJFQWdBRUVDUmcwSkRJRUNDeUFFSUFGQkFXb2lBVWNOQUF0Qk1DRUREUGdDQzBFd0lRTU05d0lMSUFFZ0JFY0VRQU5BSUFFdEFBQWlBRUVnUndSQUlBQkJDbXNPQlA4Qi9nSCtBZjhCL2dFTElBUWdBVUVCYWlJQlJ3MEFDMEU0SVFNTTl3SUxRVGdoQXd6MkFnc0RRQ0FCTFFBQUlnQkJJRWNnQUVFSlIzRU45Z0VnQkNBQlFRRnFJZ0ZIRFFBTFFUd2hBd3oxQWdzRFFDQUJMUUFBSWdCQklFY0VRQUpBSUFCQkNtc09CUGtCQkFUNUFRQUxJQUJCTEVZTjlRRU1Bd3NnQkNBQlFRRnFJZ0ZIRFFBTFFUOGhBd3owQWd0QndBQWhBeUFCSUFSR0RmTUNJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQm1vaEJnSkFBMEFnQUVHQVFHc3RBQUFnQVMwQUFFRWdja2NOQVNBQVFRWkdEZHNDSUFCQkFXb2hBQ0FFSUFGQkFXb2lBVWNOQUFzZ0FpQUZOZ0lBRFBRQ0N5QUNRUUEyQWdBTFFUWWhBd3paQWdzZ0FTQUVSZ1JBUWNFQUlRTU04Z0lMSUFKQkREWUNDQ0FDSUFFMkFnUWdBaTBBTEVFQmF3NEUrd0h1QWV3QjZ3SFVBZ3NnQVVFQmFpRUJEUG9CQ3lBQklBUkhCRUFEUUFKQUlBRXRBQUFpQUVFZ2NpQUFJQUJCd1FCclFmOEJjVUVhU1J0Qi93RnhJZ0JCQ1VZTkFDQUFRU0JHRFFBQ1FBSkFBa0FDUUNBQVFlTUFhdzRUQUFNREF3TURBd01CQXdNREF3TURBd01EQWdNTElBRkJBV29oQVVFeElRTU0zQUlMSUFGQkFXb2hBVUV5SVFNTTJ3SUxJQUZCQVdvaEFVRXpJUU1NMmdJTERQNEJDeUFFSUFGQkFXb2lBVWNOQUF0Qk5TRUREUEFDQzBFMUlRTU03d0lMSUFFZ0JFY0VRQU5BSUFFdEFBQkJnRHhxTFFBQVFRRkhEZmNCSUFRZ0FVRUJhaUlCUncwQUMwRTlJUU1NN3dJTFFUMGhBd3p1QWd0QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0FrQWlBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVU5BU0FBUVJWSERlWUJJQUpCd2dBMkFod2dBaUFCTmdJVUlBSkI0eGcyQWhBZ0FrRVZOZ0lNUVFBaEF3enRBZ3NnQVVFQmFpRUJDMEU4SVFNTTBnSUxJQUVnQkVZRVFFSENBQ0VERE9zQ0N3SkFBMEFDUUNBQkxRQUFRUWxyRGhnQUFzd0N6QUxSQXN3Q3pBTE1Bc3dDekFMTUFzd0N6QUxNQXN3Q3pBTE1Bc3dDekFMTUFzd0N6QUxNQWdETUFnc2dCQ0FCUVFGcUlnRkhEUUFMUWNJQUlRTU02d0lMSUFGQkFXb2hBU0FDTFFBdFFRRnhSUTMrQVF0QkxDRURETkFDQ3lBQklBUkhEZDRCUWNRQUlRTU02QUlMQTBBZ0FTMEFBRUdRd0FCcUxRQUFRUUZIRFp3QklBUWdBVUVCYWlJQlJ3MEFDMEhGQUNFRERPY0NDeUFCTFFBQUlnQkJJRVlOL2dFZ0FFRTZSdzNBQWlBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFwSWdBTjNnRU0zUUVMUWNjQUlRTWdCQ0FCSWdCR0RlVUNJQVFnQVdzZ0FpZ0NBQ0lCYWlFSElBQWdBV3RCQldvaEJnTkFJQUZCa01JQWFpMEFBQ0FBTFFBQUlnVkJJSElnQlNBRlFjRUFhMEgvQVhGQkdra2JRZjhCY1VjTnZ3SWdBVUVGUmczQ0FpQUJRUUZxSVFFZ0JDQUFRUUZxSWdCSERRQUxJQUlnQnpZQ0FBemxBZ3RCeUFBaEF5QUVJQUVpQUVZTjVBSWdCQ0FCYXlBQ0tBSUFJZ0ZxSVFjZ0FDQUJhMEVKYWlFR0EwQWdBVUdXd2dCcUxRQUFJQUF0QUFBaUJVRWdjaUFGSUFWQndRQnJRZjhCY1VFYVNSdEIvd0Z4UncyK0FrRUNJQUZCQ1VZTndnSWFJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBSE5nSUFET1FDQ3lBQklBUkdCRUJCeVFBaEF3emtBZ3NDUUFKQUlBRXRBQUFpQUVFZ2NpQUFJQUJCd1FCclFmOEJjVUVhU1J0Qi93RnhRZTRBYXc0SEFMOEN2d0svQXI4Q3Z3SUJ2d0lMSUFGQkFXb2hBVUUrSVFNTXl3SUxJQUZCQVdvaEFVRS9JUU1NeWdJTFFjb0FJUU1nQkNBQklnQkdEZUlDSUFRZ0FXc2dBaWdDQUNJQmFpRUdJQUFnQVd0QkFXb2hCd05BSUFGQm9NSUFhaTBBQUNBQUxRQUFJZ1ZCSUhJZ0JTQUZRY0VBYTBIL0FYRkJHa2tiUWY4QmNVY052QUlnQVVFQlJnMitBaUFCUVFGcUlRRWdCQ0FBUVFGcUlnQkhEUUFMSUFJZ0JqWUNBQXppQWd0Qnl3QWhBeUFFSUFFaUFFWU40UUlnQkNBQmF5QUNLQUlBSWdGcUlRY2dBQ0FCYTBFT2FpRUdBMEFnQVVHaXdnQnFMUUFBSUFBdEFBQWlCVUVnY2lBRklBVkJ3UUJyUWY4QmNVRWFTUnRCL3dGeFJ3MjdBaUFCUVE1R0RiNENJQUZCQVdvaEFTQUVJQUJCQVdvaUFFY05BQXNnQWlBSE5nSUFET0VDQzBITUFDRURJQVFnQVNJQVJnM2dBaUFFSUFGcklBSW9BZ0FpQVdvaEJ5QUFJQUZyUVE5cUlRWURRQ0FCUWNEQ0FHb3RBQUFnQUMwQUFDSUZRU0J5SUFVZ0JVSEJBR3RCL3dGeFFScEpHMEgvQVhGSERib0NRUU1nQVVFUFJnMitBaG9nQVVFQmFpRUJJQVFnQUVFQmFpSUFSdzBBQ3lBQ0lBYzJBZ0FNNEFJTFFjMEFJUU1nQkNBQklnQkdEZDhDSUFRZ0FXc2dBaWdDQUNJQmFpRUhJQUFnQVd0QkJXb2hCZ05BSUFGQjBNSUFhaTBBQUNBQUxRQUFJZ1ZCSUhJZ0JTQUZRY0VBYTBIL0FYRkJHa2tiUWY4QmNVY051UUpCQkNBQlFRVkdEYjBDR2lBQlFRRnFJUUVnQkNBQVFRRnFJZ0JIRFFBTElBSWdCellDQUF6ZkFnc2dBU0FFUmdSQVFjNEFJUU1NM3dJTEFrQUNRQUpBQWtBZ0FTMEFBQ0lBUVNCeUlBQWdBRUhCQUd0Qi93RnhRUnBKRzBIL0FYRkI0d0JyRGhNQXZBSzhBcndDdkFLOEFyd0N2QUs4QXJ3Q3ZBSzhBcndDQWJ3Q3ZBSzhBZ0lEdkFJTElBRkJBV29oQVVIQkFDRURETWdDQ3lBQlFRRnFJUUZCd2dBaEF3ekhBZ3NnQVVFQmFpRUJRY01BSVFNTXhnSUxJQUZCQVdvaEFVSEVBQ0VERE1VQ0N5QUJJQVJIQkVBZ0FrRU5OZ0lJSUFJZ0FUWUNCRUhGQUNFRERNVUNDMEhQQUNFREROMENDd0pBQWtBZ0FTMEFBRUVLYXc0RUFaQUJrQUVBa0FFTElBRkJBV29oQVF0QktDRURETU1DQ3lBQklBUkdCRUJCMFFBaEF3emNBZ3NnQVMwQUFFRWdSdzBBSUFGQkFXb2hBU0FDTFFBdFFRRnhSUTNRQVF0QkZ5RURETUVDQ3lBQklBUkhEY3NCUWRJQUlRTU0yUUlMUWRNQUlRTWdBU0FFUmczWUFpQUNLQUlBSWdBZ0JDQUJhMm9oQmlBQklBQnJRUUZxSVFVRFFDQUJMUUFBSUFCQjFzSUFhaTBBQUVjTnh3RWdBRUVCUmczS0FTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQmpZQ0FBellBZ3NnQVNBRVJnUkFRZFVBSVFNTTJBSUxJQUV0QUFCQkNrY053Z0VnQVVFQmFpRUJETW9CQ3lBQklBUkdCRUJCMWdBaEF3elhBZ3NDUUFKQUlBRXRBQUJCQ21zT0JBRERBY01CQWNNQkN5QUJRUUZxSVFFTXlnRUxJQUZCQVdvaEFVSEtBQ0VEREwwQ0MwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NQQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFEYjhCUWMwQUlRTU12QUlMSUFJdEFDbEJJa1lOendJTWlRRUxJQVFnQVNJRlJnUkFRZHNBSVFNTTFBSUxRUUFoQUVFQklRRkJBU0VHUVFBaEF3SkFBbjhDUUFKQUFrQUNRQUpBQWtBQ1FDQUZMUUFBUVRCckRnckZBY1FCQUFFQ0F3UUZCZ2pEQVF0QkFnd0dDMEVEREFVTFFRUU1CQXRCQlF3REMwRUdEQUlMUVFjTUFRdEJDQXNoQTBFQUlRRkJBQ0VHREwwQkMwRUpJUU5CQVNFQVFRQWhBVUVBSVFZTXZBRUxJQUVnQkVZRVFFSGRBQ0VERE5NQ0N5QUJMUUFBUVM1SERiZ0JJQUZCQVdvaEFReUlBUXNnQVNBRVJ3MjJBVUhmQUNFRERORUNDeUFCSUFSSEJFQWdBa0VPTmdJSUlBSWdBVFlDQkVIUUFDRURETGdDQzBIZ0FDRURETkFDQzBIaEFDRURJQUVnQkVZTnp3SWdBaWdDQUNJQUlBUWdBV3RxSVFVZ0FTQUFhMEVEYWlFR0EwQWdBUzBBQUNBQVFlTENBR290QUFCSERiRUJJQUJCQTBZTnN3RWdBRUVCYWlFQUlBUWdBVUVCYWlJQlJ3MEFDeUFDSUFVMkFnQU16d0lMUWVJQUlRTWdBU0FFUmczT0FpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZRFFDQUJMUUFBSUFCQjVzSUFhaTBBQUVjTnNBRWdBRUVDUmcydkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBek9BZ3RCNHdBaEF5QUJJQVJHRGMwQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdOQUlBRXRBQUFnQUVIcHdnQnFMUUFBUncydkFTQUFRUU5HRGEwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURNMENDeUFCSUFSR0JFQkI1UUFoQXd6TkFnc2dBVUVCYWlFQlFRQWhBQUpBSUFJb0FqZ2lBMFVOQUNBREtBSXdJZ05GRFFBZ0FpQURFUUFBSVFBTElBQU5xZ0ZCMWdBaEF3eXpBZ3NnQVNBRVJ3UkFBMEFnQVMwQUFDSUFRU0JIQkVBQ1FBSkFBa0FnQUVISUFHc09Dd0FCc3dHekFiTUJzd0d6QWJNQnN3R3pBUUt6QVFzZ0FVRUJhaUVCUWRJQUlRTU10d0lMSUFGQkFXb2hBVUhUQUNFRERMWUNDeUFCUVFGcUlRRkIxQUFoQXd5MUFnc2dCQ0FCUVFGcUlnRkhEUUFMUWVRQUlRTU16QUlMUWVRQUlRTU15d0lMQTBBZ0FTMEFBRUh3d2dCcUxRQUFJZ0JCQVVjRVFDQUFRUUpyRGdPbkFhWUJwUUdrQVFzZ0JDQUJRUUZxSWdGSERRQUxRZVlBSVFNTXlnSUxJQUZCQVdvZ0FTQUVSdzBDR2tIbkFDRURETWtDQ3dOQUlBRXRBQUJCOE1RQWFpMEFBQ0lBUVFGSEJFQUNRQ0FBUVFKckRnU2lBYUVCb0FFQW53RUxRZGNBSVFNTXNRSUxJQVFnQVVFQmFpSUJSdzBBQzBIb0FDRURETWdDQ3lBQklBUkdCRUJCNlFBaEF3eklBZ3NDUUNBQkxRQUFJZ0JCQ21zT0dyY0Jtd0diQWJRQm13R2JBWnNCbXdHYkFac0Jtd0diQVpzQm13R2JBWnNCbXdHYkFac0Jtd0diQVpzQnBBR2JBWnNCQUprQkN5QUJRUUZxQ3lFQlFRWWhBd3l0QWdzRFFDQUJMUUFBUWZER0FHb3RBQUJCQVVjTmZTQUVJQUZCQVdvaUFVY05BQXRCNmdBaEF3ekZBZ3NnQVVFQmFpQUJJQVJIRFFJYVFlc0FJUU1NeEFJTElBRWdCRVlFUUVIc0FDRURETVFDQ3lBQlFRRnFEQUVMSUFFZ0JFWUVRRUh0QUNFRERNTUNDeUFCUVFGcUN5RUJRUVFoQXd5b0Fnc2dBU0FFUmdSQVFlNEFJUU1Nd1FJTEFrQUNRQUpBSUFFdEFBQkI4TWdBYWkwQUFFRUJhdzRIa0FHUEFZNEJBSHdCQW8wQkN5QUJRUUZxSVFFTUN3c2dBVUVCYWd5VEFRdEJBQ0VESUFKQkFEWUNIQ0FDUVpzU05nSVFJQUpCQnpZQ0RDQUNJQUZCQVdvMkFoUU13QUlMQWtBRFFDQUJMUUFBUWZESUFHb3RBQUFpQUVFRVJ3UkFBa0FDUUNBQVFRRnJEZ2VVQVpNQmtnR05BUUFFQVkwQkMwSGFBQ0VEREtvQ0N5QUJRUUZxSVFGQjNBQWhBd3lwQWdzZ0JDQUJRUUZxSWdGSERRQUxRZThBSVFNTXdBSUxJQUZCQVdvTWtRRUxJQVFnQVNJQVJnUkFRZkFBSVFNTXZ3SUxJQUF0QUFCQkwwY05BU0FBUVFGcUlRRU1Cd3NnQkNBQklnQkdCRUJCOFFBaEF3eStBZ3NnQUMwQUFDSUJRUzlHQkVBZ0FFRUJhaUVCUWQwQUlRTU1wUUlMSUFGQkNtc2lBMEVXU3cwQUlBQWhBVUVCSUFOMFFZbUFnQUp4RGZrQkMwRUFJUU1nQWtFQU5nSWNJQUlnQURZQ0ZDQUNRWXdjTmdJUUlBSkJCellDREF5OEFnc2dBU0FFUndSQUlBRkJBV29oQVVIZUFDRURES01DQzBIeUFDRURETHNDQ3lBQklBUkdCRUJCOUFBaEF3eTdBZ3NDUUNBQkxRQUFRZkRNQUdvdEFBQkJBV3NPQS9jQmN3Q0NBUXRCNFFBaEF3eWhBZ3NnQVNBRVJ3UkFBMEFnQVMwQUFFSHd5Z0JxTFFBQUlnQkJBMGNFUUFKQUlBQkJBV3NPQXZrQkFJVUJDMEhmQUNFRERLTUNDeUFFSUFGQkFXb2lBVWNOQUF0Qjh3QWhBd3k2QWd0Qjh3QWhBd3k1QWdzZ0FTQUVSd1JBSUFKQkR6WUNDQ0FDSUFFMkFnUkI0QUFoQXd5Z0FndEI5UUFoQXd5NEFnc2dBU0FFUmdSQVFmWUFJUU1NdUFJTElBSkJEellDQ0NBQ0lBRTJBZ1FMUVFNaEF3eWRBZ3NEUUNBQkxRQUFRU0JIRFk0Q0lBUWdBVUVCYWlJQlJ3MEFDMEgzQUNFRERMVUNDeUFCSUFSR0JFQkIrQUFoQXd5MUFnc2dBUzBBQUVFZ1J3MTZJQUZCQVdvaEFReGJDMEVBSVFBQ1FDQUNLQUk0SWdORkRRQWdBeWdDT0NJRFJRMEFJQUlnQXhFQUFDRUFDeUFBRFhnTWdBSUxJQUVnQkVZRVFFSDZBQ0VERExNQ0N5QUJMUUFBUWN3QVJ3MTBJQUZCQVdvaEFVRVRESFlMUWZzQUlRTWdBU0FFUmcyeEFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVZxSVFZRFFDQUJMUUFBSUFCQjhNNEFhaTBBQUVjTmN5QUFRUVZHRFhVZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTXNRSUxJQUVnQkVZRVFFSDhBQ0VERExFQ0N3SkFBa0FnQVMwQUFFSERBR3NPREFCMGRIUjBkSFIwZEhSMEFYUUxJQUZCQVdvaEFVSG1BQ0VEREpnQ0N5QUJRUUZxSVFGQjV3QWhBd3lYQWd0Qi9RQWhBeUFCSUFSR0RhOENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQW1vaEJnSkFBMEFnQVMwQUFDQUFRZTNQQUdvdEFBQkhEWElnQUVFQ1JnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFETEFDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUkFNY3d0Qi9nQWhBeUFCSUFSR0RhNENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQldvaEJnSkFBMEFnQVMwQUFDQUFRZmJPQUdvdEFBQkhEWEVnQUVFRlJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFESzhDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUllNY2d0Qi93QWhBeUFCSUFSR0RhMENJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQTJvaEJnSkFBMEFnQVMwQUFDQUFRZnpPQUdvdEFBQkhEWEFnQUVFRFJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFESzRDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUVVNY1FzZ0FTQUVSZ1JBUVlBQklRTU1yUUlMSUFFdEFBQkIyUUJIRFc0Z0FVRUJhaUVCUVFnTWNBc2dBU0FFUmdSQVFZRUJJUU1NckFJTEFrQUNRQ0FCTFFBQVFjNEFhdzREQUc4QmJ3c2dBVUVCYWlFQlFlc0FJUU1Na3dJTElBRkJBV29oQVVIc0FDRURESklDQ3lBQklBUkdCRUJCZ2dFaEF3eXJBZ3NDUUFKQUlBRXRBQUJCeUFCckRnZ0FibTV1Ym01dUFXNExJQUZCQVdvaEFVSHFBQ0VEREpJQ0N5QUJRUUZxSVFGQjdRQWhBd3lSQWd0Qmd3RWhBeUFCSUFSR0Rha0NJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQW1vaEJnSkFBMEFnQVMwQUFDQUFRWURQQUdvdEFBQkhEV3dnQUVFQ1JnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFES29DQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRUUFNYlF0QmhBRWhBeUFCSUFSR0RhZ0NJQUlvQWdBaUFDQUVJQUZyYWlFRklBRWdBR3RCQkdvaEJnSkFBMEFnQVMwQUFDQUFRWVBQQUdvdEFBQkhEV3NnQUVFRVJnMEJJQUJCQVdvaEFDQUVJQUZCQVdvaUFVY05BQXNnQWlBRk5nSUFES2tDQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJRU01NYkFzZ0FTQUVSZ1JBUVlVQklRTU1xQUlMQWtBQ1FDQUJMUUFBUWN3QWF3NElBR3RyYTJ0cmF3RnJDeUFCUVFGcUlRRkI3d0FoQXd5UEFnc2dBVUVCYWlFQlFmQUFJUU1NamdJTElBRWdCRVlFUUVHR0FTRURES2NDQ3lBQkxRQUFRY1VBUncxb0lBRkJBV29oQVF4Z0MwR0hBU0VESUFFZ0JFWU5wUUlnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRGFpRUdBa0FEUUNBQkxRQUFJQUJCaU04QWFpMEFBRWNOYUNBQVFRTkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNcGdJTElBSkJBRFlDQUNBR1FRRnFJUUZCTFF4cEMwR0lBU0VESUFFZ0JFWU5wQUlnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFSWFpRUdBa0FEUUNBQkxRQUFJQUJCME04QWFpMEFBRWNOWnlBQVFRaEdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNcFFJTElBSkJBRFlDQUNBR1FRRnFJUUZCS1F4b0N5QUJJQVJHQkVCQmlRRWhBd3lrQWd0QkFTQUJMUUFBUWQ4QVJ3MW5HaUFCUVFGcUlRRU1YZ3RCaWdFaEF5QUJJQVJHRGFJQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdOQUlBRXRBQUFnQUVHTXp3QnFMUUFBUncxa0lBQkJBVVlOK2dFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTW9nSUxRWXNCSVFNZ0FTQUVSZzJoQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVHT3p3QnFMUUFBUncxa0lBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5aUFnc2dBa0VBTmdJQUlBWkJBV29oQVVFQ0RHVUxRWXdCSVFNZ0FTQUVSZzJnQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVId3p3QnFMUUFBUncxaklBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5aEFnc2dBa0VBTmdJQUlBWkJBV29oQVVFZkRHUUxRWTBCSVFNZ0FTQUVSZzJmQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRRnFJUVlDUUFOQUlBRXRBQUFnQUVIeXp3QnFMUUFBUncxaUlBQkJBVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5Z0Fnc2dBa0VBTmdJQUlBWkJBV29oQVVFSkRHTUxJQUVnQkVZRVFFR09BU0VEREo4Q0N3SkFBa0FnQVMwQUFFSEpBR3NPQndCaVltSmlZZ0ZpQ3lBQlFRRnFJUUZCK0FBaEF3eUdBZ3NnQVVFQmFpRUJRZmtBSVFNTWhRSUxRWThCSVFNZ0FTQUVSZzJkQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVHUnp3QnFMUUFBUncxZ0lBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5ZUFnc2dBa0VBTmdJQUlBWkJBV29oQVVFWURHRUxRWkFCSVFNZ0FTQUVSZzJjQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVHWHp3QnFMUUFBUncxZklBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5ZEFnc2dBa0VBTmdJQUlBWkJBV29oQVVFWERHQUxRWkVCSVFNZ0FTQUVSZzJiQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRWnFJUVlDUUFOQUlBRXRBQUFnQUVHYXp3QnFMUUFBUncxZUlBQkJCa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5Y0Fnc2dBa0VBTmdJQUlBWkJBV29oQVVFVkRGOExRWklCSVFNZ0FTQUVSZzJhQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRVnFJUVlDUUFOQUlBRXRBQUFnQUVHaHp3QnFMUUFBUncxZElBQkJCVVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5YkFnc2dBa0VBTmdJQUlBWkJBV29oQVVFZURGNExJQUVnQkVZRVFFR1RBU0VEREpvQ0N5QUJMUUFBUWN3QVJ3MWJJQUZCQVdvaEFVRUtERjBMSUFFZ0JFWUVRRUdVQVNFRERKa0NDd0pBQWtBZ0FTMEFBRUhCQUdzT0R3QmNYRnhjWEZ4Y1hGeGNYRnhjQVZ3TElBRkJBV29oQVVIK0FDRURESUFDQ3lBQlFRRnFJUUZCL3dBaEF3ei9BUXNnQVNBRVJnUkFRWlVCSVFNTW1BSUxBa0FDUUNBQkxRQUFRY0VBYXc0REFGc0JXd3NnQVVFQmFpRUJRZjBBSVFNTS93RUxJQUZCQVdvaEFVR0FBU0VERFA0QkMwR1dBU0VESUFFZ0JFWU5sZ0lnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCcDg4QWFpMEFBRWNOV1NBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNbHdJTElBSkJBRFlDQUNBR1FRRnFJUUZCQ3d4YUN5QUJJQVJHQkVCQmx3RWhBd3lXQWdzQ1FBSkFBa0FDUUNBQkxRQUFRUzFyRGlNQVcxdGJXMXRiVzF0YlcxdGJXMXRiVzF0YlcxdGJXMXNCVzF0Ylcxc0NXMXRiQTFzTElBRkJBV29oQVVIN0FDRUREUDhCQ3lBQlFRRnFJUUZCL0FBaEF3eitBUXNnQVVFQmFpRUJRWUVCSVFNTS9RRUxJQUZCQVdvaEFVR0NBU0VERFB3QkMwR1lBU0VESUFFZ0JFWU5sQUlnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRWFpRUdBa0FEUUNBQkxRQUFJQUJCcWM4QWFpMEFBRWNOVnlBQVFRUkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNbFFJTElBSkJBRFlDQUNBR1FRRnFJUUZCR1F4WUMwR1pBU0VESUFFZ0JFWU5rd0lnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFRmFpRUdBa0FEUUNBQkxRQUFJQUJCcnM4QWFpMEFBRWNOVmlBQVFRVkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNbEFJTElBSkJBRFlDQUNBR1FRRnFJUUZCQmd4WEMwR2FBU0VESUFFZ0JFWU5rZ0lnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCdE04QWFpMEFBRWNOVlNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNa3dJTElBSkJBRFlDQUNBR1FRRnFJUUZCSEF4V0MwR2JBU0VESUFFZ0JFWU5rUUlnQWlnQ0FDSUFJQVFnQVd0cUlRVWdBU0FBYTBFQmFpRUdBa0FEUUNBQkxRQUFJQUJCdHM4QWFpMEFBRWNOVkNBQVFRRkdEUUVnQUVFQmFpRUFJQVFnQVVFQmFpSUJSdzBBQ3lBQ0lBVTJBZ0FNa2dJTElBSkJBRFlDQUNBR1FRRnFJUUZCSnd4VkN5QUJJQVJHQkVCQm5BRWhBd3lSQWdzQ1FBSkFJQUV0QUFCQjFBQnJEZ0lBQVZRTElBRkJBV29oQVVHR0FTRUREUGdCQ3lBQlFRRnFJUUZCaHdFaEF3ejNBUXRCblFFaEF5QUJJQVJHRFk4Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFialBBR290QUFCSERWSWdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURKQUNDeUFDUVFBMkFnQWdCa0VCYWlFQlFTWU1Vd3RCbmdFaEF5QUJJQVJHRFk0Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBV29oQmdKQUEwQWdBUzBBQUNBQVFiclBBR290QUFCSERWRWdBRUVCUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURJOENDeUFDUVFBMkFnQWdCa0VCYWlFQlFRTU1VZ3RCbndFaEF5QUJJQVJHRFkwQ0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBbW9oQmdKQUEwQWdBUzBBQUNBQVFlM1BBR290QUFCSERWQWdBRUVDUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURJNENDeUFDUVFBMkFnQWdCa0VCYWlFQlFRd01VUXRCb0FFaEF5QUJJQVJHRFl3Q0lBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFielBBR290QUFCSERVOGdBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURJMENDeUFDUVFBMkFnQWdCa0VCYWlFQlFRME1VQXNnQVNBRVJnUkFRYUVCSVFNTWpBSUxBa0FDUUNBQkxRQUFRY1lBYXc0TEFFOVBUMDlQVDA5UFR3RlBDeUFCUVFGcUlRRkJpd0VoQXd6ekFRc2dBVUVCYWlFQlFZd0JJUU1NOGdFTElBRWdCRVlFUUVHaUFTRURESXNDQ3lBQkxRQUFRZEFBUncxTUlBRkJBV29oQVF4R0N5QUJJQVJHQkVCQm93RWhBd3lLQWdzQ1FBSkFJQUV0QUFCQnlRQnJEZ2NCVFUxTlRVMEFUUXNnQVVFQmFpRUJRWTRCSVFNTThRRUxJQUZCQVdvaEFVRWlERTBMUWFRQklRTWdBU0FFUmcySUFpQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUZxSVFZQ1FBTkFJQUV0QUFBZ0FFSEF6d0JxTFFBQVJ3MUxJQUJCQVVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeUpBZ3NnQWtFQU5nSUFJQVpCQVdvaEFVRWRERXdMSUFFZ0JFWUVRRUdsQVNFRERJZ0NDd0pBQWtBZ0FTMEFBRUhTQUdzT0F3QkxBVXNMSUFGQkFXb2hBVUdRQVNFRERPOEJDeUFCUVFGcUlRRkJCQXhMQ3lBQklBUkdCRUJCcGdFaEF3eUhBZ3NDUUFKQUFrQUNRQUpBSUFFdEFBQkJ3UUJyRGhVQVRVMU5UVTFOVFUxTlRRRk5UUUpOVFFOTlRRUk5DeUFCUVFGcUlRRkJpQUVoQXd6eEFRc2dBVUVCYWlFQlFZa0JJUU1NOEFFTElBRkJBV29oQVVHS0FTRURETzhCQ3lBQlFRRnFJUUZCandFaEF3enVBUXNnQVVFQmFpRUJRWkVCSVFNTTdRRUxRYWNCSVFNZ0FTQUVSZzJGQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIdHp3QnFMUUFBUncxSUlBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5R0Fnc2dBa0VBTmdJQUlBWkJBV29oQVVFUkRFa0xRYWdCSVFNZ0FTQUVSZzJFQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIQ3p3QnFMUUFBUncxSElBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5RkFnc2dBa0VBTmdJQUlBWkJBV29oQVVFc0RFZ0xRYWtCSVFNZ0FTQUVSZzJEQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRUnFJUVlDUUFOQUlBRXRBQUFnQUVIRnp3QnFMUUFBUncxR0lBQkJCRVlOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5RUFnc2dBa0VBTmdJQUlBWkJBV29oQVVFckRFY0xRYW9CSVFNZ0FTQUVSZzJDQWlBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVIS3p3QnFMUUFBUncxRklBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5REFnc2dBa0VBTmdJQUlBWkJBV29oQVVFVURFWUxJQUVnQkVZRVFFR3JBU0VERElJQ0N3SkFBa0FDUUFKQUlBRXRBQUJCd2dCckRnOEFBUUpIUjBkSFIwZEhSMGRIUndOSEN5QUJRUUZxSVFGQmt3RWhBd3pyQVFzZ0FVRUJhaUVCUVpRQklRTU02Z0VMSUFGQkFXb2hBVUdWQVNFRERPa0JDeUFCUVFGcUlRRkJsZ0VoQXd6b0FRc2dBU0FFUmdSQVFhd0JJUU1NZ1FJTElBRXRBQUJCeFFCSERVSWdBVUVCYWlFQkREMExRYTBCSVFNZ0FTQUVSZzMvQVNBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVITnp3QnFMUUFBUncxQ0lBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF5QUFnc2dBa0VBTmdJQUlBWkJBV29oQVVFT0RFTUxJQUVnQkVZRVFFR3VBU0VERFA4QkN5QUJMUUFBUWRBQVJ3MUFJQUZCQVdvaEFVRWxERUlMUWE4QklRTWdBU0FFUmczOUFTQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUWhxSVFZQ1FBTkFJQUV0QUFBZ0FFSFF6d0JxTFFBQVJ3MUFJQUJCQ0VZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBeitBUXNnQWtFQU5nSUFJQVpCQVdvaEFVRXFERUVMSUFFZ0JFWUVRRUd3QVNFRERQMEJDd0pBQWtBZ0FTMEFBRUhWQUdzT0N3QkFRRUJBUUVCQVFFQUJRQXNnQVVFQmFpRUJRWm9CSVFNTTVBRUxJQUZCQVdvaEFVR2JBU0VERE9NQkN5QUJJQVJHQkVCQnNRRWhBd3o4QVFzQ1FBSkFJQUV0QUFCQndRQnJEaFFBUHo4L1B6OC9QejgvUHo4L1B6OC9QejgvQVQ4TElBRkJBV29oQVVHWkFTRURET01CQ3lBQlFRRnFJUUZCbkFFaEF3emlBUXRCc2dFaEF5QUJJQVJHRGZvQklBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJBMm9oQmdKQUEwQWdBUzBBQUNBQVFkblBBR290QUFCSERUMGdBRUVEUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURQc0JDeUFDUVFBMkFnQWdCa0VCYWlFQlFTRU1QZ3RCc3dFaEF5QUJJQVJHRGZrQklBSW9BZ0FpQUNBRUlBRnJhaUVGSUFFZ0FHdEJCbW9oQmdKQUEwQWdBUzBBQUNBQVFkM1BBR290QUFCSERUd2dBRUVHUmcwQklBQkJBV29oQUNBRUlBRkJBV29pQVVjTkFBc2dBaUFGTmdJQURQb0JDeUFDUVFBMkFnQWdCa0VCYWlFQlFSb01QUXNnQVNBRVJnUkFRYlFCSVFNTStRRUxBa0FDUUFKQUlBRXRBQUJCeFFCckRoRUFQVDA5UFQwOVBUMDlBVDA5UFQwOUFqMExJQUZCQVdvaEFVR2RBU0VERE9FQkN5QUJRUUZxSVFGQm5nRWhBd3pnQVFzZ0FVRUJhaUVCUVo4QklRTU0zd0VMUWJVQklRTWdBU0FFUmczM0FTQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUVZxSVFZQ1FBTkFJQUV0QUFBZ0FFSGt6d0JxTFFBQVJ3MDZJQUJCQlVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBejRBUXNnQWtFQU5nSUFJQVpCQVdvaEFVRW9ERHNMUWJZQklRTWdBU0FFUmczMkFTQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUpxSVFZQ1FBTkFJQUV0QUFBZ0FFSHF6d0JxTFFBQVJ3MDVJQUJCQWtZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBejNBUXNnQWtFQU5nSUFJQVpCQVdvaEFVRUhERG9MSUFFZ0JFWUVRRUczQVNFRERQWUJDd0pBQWtBZ0FTMEFBRUhGQUdzT0RnQTVPVGs1T1RrNU9UazVPVGtCT1FzZ0FVRUJhaUVCUWFFQklRTU0zUUVMSUFGQkFXb2hBVUdpQVNFREROd0JDMEc0QVNFRElBRWdCRVlOOUFFZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUNhaUVHQWtBRFFDQUJMUUFBSUFCQjdjOEFhaTBBQUVjTk55QUFRUUpHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTTlRRUxJQUpCQURZQ0FDQUdRUUZxSVFGQkVndzRDMEc1QVNFRElBRWdCRVlOOHdFZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUJhaUVHQWtBRFFDQUJMUUFBSUFCQjhNOEFhaTBBQUVjTk5pQUFRUUZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTTlBRUxJQUpCQURZQ0FDQUdRUUZxSVFGQklBdzNDMEc2QVNFRElBRWdCRVlOOGdFZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUJhaUVHQWtBRFFDQUJMUUFBSUFCQjhzOEFhaTBBQUVjTk5TQUFRUUZHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTTh3RUxJQUpCQURZQ0FDQUdRUUZxSVFGQkR3dzJDeUFCSUFSR0JFQkJ1d0VoQXd6eUFRc0NRQUpBSUFFdEFBQkJ5UUJyRGdjQU5UVTFOVFVCTlFzZ0FVRUJhaUVCUWFVQklRTU0yUUVMSUFGQkFXb2hBVUdtQVNFREROZ0JDMEc4QVNFRElBRWdCRVlOOEFFZ0FpZ0NBQ0lBSUFRZ0FXdHFJUVVnQVNBQWEwRUhhaUVHQWtBRFFDQUJMUUFBSUFCQjlNOEFhaTBBQUVjTk15QUFRUWRHRFFFZ0FFRUJhaUVBSUFRZ0FVRUJhaUlCUncwQUN5QUNJQVUyQWdBTThRRUxJQUpCQURZQ0FDQUdRUUZxSVFGQkd3dzBDeUFCSUFSR0JFQkJ2UUVoQXd6d0FRc0NRQUpBQWtBZ0FTMEFBRUhDQUdzT0VnQTBORFEwTkRRME5EUUJORFEwTkRRMEFqUUxJQUZCQVdvaEFVR2tBU0VERE5nQkN5QUJRUUZxSVFGQnB3RWhBd3pYQVFzZ0FVRUJhaUVCUWFnQklRTU0xZ0VMSUFFZ0JFWUVRRUcrQVNFRERPOEJDeUFCTFFBQVFjNEFSdzB3SUFGQkFXb2hBUXdzQ3lBQklBUkdCRUJCdndFaEF3enVBUXNDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FDQUJMUUFBUWNFQWF3NFZBQUVDQXo4RUJRWS9QejhIQ0FrS0N6OE1EUTRQUHdzZ0FVRUJhaUVCUWVnQUlRTU00d0VMSUFGQkFXb2hBVUhwQUNFRERPSUJDeUFCUVFGcUlRRkI3Z0FoQXd6aEFRc2dBVUVCYWlFQlFmSUFJUU1NNEFFTElBRkJBV29oQVVIekFDRURETjhCQ3lBQlFRRnFJUUZCOWdBaEF3emVBUXNnQVVFQmFpRUJRZmNBSVFNTTNRRUxJQUZCQVdvaEFVSDZBQ0VERE53QkN5QUJRUUZxSVFGQmd3RWhBd3piQVFzZ0FVRUJhaUVCUVlRQklRTU0yZ0VMSUFGQkFXb2hBVUdGQVNFREROa0JDeUFCUVFGcUlRRkJrZ0VoQXd6WUFRc2dBVUVCYWlFQlFaZ0JJUU1NMXdFTElBRkJBV29oQVVHZ0FTRURETllCQ3lBQlFRRnFJUUZCb3dFaEF3elZBUXNnQVVFQmFpRUJRYW9CSVFNTTFBRUxJQUVnQkVjRVFDQUNRUkEyQWdnZ0FpQUJOZ0lFUWFzQklRTU0xQUVMUWNBQklRTU03QUVMUVFBaEFBSkFJQUlvQWpnaUEwVU5BQ0FES0FJMElnTkZEUUFnQWlBREVRQUFJUUFMSUFCRkRWNGdBRUVWUncwSElBSkIwUUEyQWh3Z0FpQUJOZ0lVSUFKQnNCYzJBaEFnQWtFVk5nSU1RUUFoQXd6ckFRc2dBVUVCYWlBQklBUkhEUWdhUWNJQklRTU02Z0VMQTBBQ1FDQUJMUUFBUVFwckRnUUlBQUFMQUFzZ0JDQUJRUUZxSWdGSERRQUxRY01CSVFNTTZRRUxJQUVnQkVjRVFDQUNRUkUyQWdnZ0FpQUJOZ0lFUVFFaEF3elFBUXRCeEFFaEF3em9BUXNnQVNBRVJnUkFRY1VCSVFNTTZBRUxBa0FDUUNBQkxRQUFRUXByRGdRQktDZ0FLQXNnQVVFQmFnd0pDeUFCUVFGcURBVUxJQUVnQkVZRVFFSEdBU0VERE9jQkN3SkFBa0FnQVMwQUFFRUthdzRYQVFzTEFRc0xDd3NMQ3dzTEN3c0xDd3NMQ3dzTEN3QUxDeUFCUVFGcUlRRUxRYkFCSVFNTXpRRUxJQUVnQkVZRVFFSElBU0VERE9ZQkN5QUJMUUFBUVNCSERRa2dBa0VBT3dFeUlBRkJBV29oQVVHekFTRURETXdCQ3dOQUlBRWhBQUpBSUFFZ0JFY0VRQ0FCTFFBQVFUQnJRZjhCY1NJRFFRcEpEUUVNSnd0Qnh3RWhBd3ptQVFzQ1FDQUNMd0V5SWdGQm1UTkxEUUFnQWlBQlFRcHNJZ1U3QVRJZ0JVSCsvd054SUFOQi8vOERjMHNOQUNBQVFRRnFJUUVnQWlBRElBVnFJZ003QVRJZ0EwSC8vd054UWVnSFNRMEJDd3RCQUNFRElBSkJBRFlDSENBQ1FjRUpOZ0lRSUFKQkRUWUNEQ0FDSUFCQkFXbzJBaFFNNUFFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtId0REWUNFQ0FDUVJzMkFneEJBQ0VERE9NQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUJFQ1lpQUEwQklBRkJBV29MSVFGQnJRRWhBd3pJQVFzZ0FrSEJBVFlDSENBQ0lBQTJBZ3dnQWlBQlFRRnFOZ0lVUVFBaEF3emdBUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBbUlnQU5BU0FCUVFGcUN5RUJRYTRCSVFNTXhRRUxJQUpCd2dFMkFod2dBaUFBTmdJTUlBSWdBVUVCYWpZQ0ZFRUFJUU1NM1FFTElBSkJBRFlDSENBQ0lBRTJBaFFnQWtHWEN6WUNFQ0FDUVEwMkFneEJBQ0VERE53QkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjR4QTJBaEFnQWtFSk5nSU1RUUFoQXd6YkFRc2dBa0VDT2dBb0RLd0JDMEVBSVFNZ0FrRUFOZ0ljSUFKQnJ3czJBaEFnQWtFQ05nSU1JQUlnQVVFQmFqWUNGQXpaQVF0QkFpRURETDhCQzBFTklRTU12Z0VMUVNZaEF3eTlBUXRCRlNFRERMd0JDMEVXSVFNTXV3RUxRUmdoQXd5NkFRdEJIQ0VERExrQkMwRWRJUU1NdUFFTFFTQWhBd3kzQVF0QklTRURETFlCQzBFaklRTU10UUVMUWNZQUlRTU10QUVMUVM0aEF3eXpBUXRCUFNFRERMSUJDMEhMQUNFRERMRUJDMEhPQUNFRERMQUJDMEhZQUNFRERLOEJDMEhaQUNFRERLNEJDMEhiQUNFRERLMEJDMEh4QUNFRERLd0JDMEgwQUNFRERLc0JDMEdOQVNFRERLb0JDMEdYQVNFRERLa0JDMEdwQVNFRERLZ0JDMEd2QVNFRERLY0JDMEd4QVNFRERLWUJDeUFDUVFBMkFnQUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCOFJzMkFoQWdBa0VHTmdJTURMMEJDeUFDUVFBMkFnQWdCa0VCYWlFQlFTUUxPZ0FwSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUp5SUFSUVJBUWVVQUlRTU1vd0VMSUFKQitRQTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NdXdFTElBQkJGVWNFUUNBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCekE0MkFoQWdBa0VnTmdJTVFRQWhBd3k3QVFzZ0FrSDRBRFlDSENBQ0lBRTJBaFFnQWtIS0dEWUNFQ0FDUVJVMkFneEJBQ0VERExvQkN5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQmpoczJBaEFnQWtFR05nSU1RUUFoQXd5NUFRc2dBa0VBTmdJY0lBSWdBVFlDRkNBQ1FmNFJOZ0lRSUFKQkJ6WUNERUVBSVFNTXVBRUxJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR01IRFlDRUNBQ1FRYzJBZ3hCQUNFRERMY0JDeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJ3dzgyQWhBZ0FrRUhOZ0lNUVFBaEF3eTJBUXNnQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRY01QTmdJUUlBSkJCellDREVFQUlRTU10UUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBSSUFKQjVRQTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1NdEFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwZ0lBSkIwd0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXN3RUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMGlJQUpCMGdBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1zZ0VMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUpTSUFSUTBPSUFKQjVRQTJBaHdnQWlBQk5nSVVJQUlnQURZQ0RFRUFJUU1Nc1FFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwZElBSkIwd0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTXNBRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRSlNJQVJRMGZJQUpCMGdBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1yd0VMSUFCQlAwY05BU0FCUVFGcUN5RUJRUVVoQXd5VUFRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0g5RWpZQ0VDQUNRUWMyQWd3TXJBRUxJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSGNDRFlDRUNBQ1FRYzJBZ3hCQUNFRERLc0JDeUFDS0FJRUlRQWdBa0VBTmdJRUlBSWdBQ0FCRUNVaUFFVU5CeUFDUWVVQU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd4QkFDRURES29CQ3lBQ0tBSUVJUUFnQWtFQU5nSUVJQUlnQUNBQkVDVWlBRVVORmlBQ1FkTUFOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFneEJBQ0VEREtrQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUJFQ1VpQUVVTkdDQUNRZElBTmdJY0lBSWdBVFlDRkNBQ0lBQTJBZ3hCQUNFRERLZ0JDeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJ4Z28yQWhBZ0FrRUhOZ0lNUVFBaEF3eW5BUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBbElnQkZEUU1nQWtIbEFEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3ltQVFzZ0FpZ0NCQ0VBSUFKQkFEWUNCQ0FDSUFBZ0FSQWxJZ0JGRFJJZ0FrSFRBRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd5bEFRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFsSWdCRkRSUWdBa0hTQURZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNUVFBaEF3eWtBUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQVJBbElnQkZEUUFnQWtIbEFEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3lqQVF0QjFRQWhBd3lKQVFzZ0FFRVZSd1JBSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0c1RFRZQ0VDQUNRUm8yQWd4QkFDRURES0lCQ3lBQ1FlUUFOZ0ljSUFJZ0FUWUNGQ0FDUWVNWE5nSVFJQUpCRlRZQ0RFRUFJUU1Nb1FFTElBSkJBRFlDQUNBR1FRRnFJUUVnQWkwQUtTSUFRU05yUVF0SkRRUUNRQ0FBUVFaTERRQkJBU0FBZEVIS0FIRkZEUUFNQlF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSDNDVFlDRUNBQ1FRZzJBZ3dNb0FFTElBSkJBRFlDQUNBR1FRRnFJUUVnQWkwQUtVRWhSZzBESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0diQ2pZQ0VDQUNRUWcyQWd4QkFDRURESjhCQ3lBQ1FRQTJBZ0FMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQmtETTJBaEFnQWtFSU5nSU1ESjBCQ3lBQ1FRQTJBZ0FnQmtFQmFpRUJJQUl0QUNsQkkwa05BQ0FDUVFBMkFod2dBaUFCTmdJVUlBSkIwd2syQWhBZ0FrRUlOZ0lNUVFBaEF3eWNBUXRCMFFBaEF3eUNBUXNnQVMwQUFFRXdheUlBUWY4QmNVRUtTUVJBSUFJZ0FEb0FLaUFCUVFGcUlRRkJ6d0FoQXd5Q0FRc2dBaWdDQkNFQUlBSkJBRFlDQkNBQ0lBQWdBUkFvSWdCRkRZWUJJQUpCM2dBMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1tZ0VMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFFUUtDSUFSUTJHQVNBQ1Fkd0FOZ0ljSUFJZ0FUWUNGQ0FDSUFBMkFneEJBQ0VEREprQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUZFQ2dpQUVVRVFDQUZJUUVNaHdFTElBSkIyZ0EyQWh3Z0FpQUZOZ0lVSUFJZ0FEWUNEQXlZQVF0QkFDRUJRUUVoQXdzZ0FpQURPZ0FySUFWQkFXb2hBd0pBQWtBQ1FDQUNMUUF0UVJCeERRQUNRQUpBQWtBZ0FpMEFLZzREQVFBQ0JBc2dCa1VOQXd3Q0N5QUFEUUVNQWdzZ0FVVU5BUXNnQWlnQ0JDRUFJQUpCQURZQ0JDQUNJQUFnQXhBb0lnQkZCRUFnQXlFQkRBSUxJQUpCMkFBMkFod2dBaUFETmdJVUlBSWdBRFlDREVFQUlRTU1tQUVMSUFJb0FnUWhBQ0FDUVFBMkFnUWdBaUFBSUFNUUtDSUFSUVJBSUFNaEFReUhBUXNnQWtIWkFEWUNIQ0FDSUFNMkFoUWdBaUFBTmdJTVFRQWhBd3lYQVF0QnpBQWhBd3g5Q3lBQVFSVkhCRUFnQWtFQU5nSWNJQUlnQVRZQ0ZDQUNRWlFOTmdJUUlBSkJJVFlDREVFQUlRTU1sZ0VMSUFKQjF3QTJBaHdnQWlBQk5nSVVJQUpCeVJjMkFoQWdBa0VWTmdJTVFRQWhBd3lWQVF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR0FFVFlDRUNBQ1FRazJBZ3dNbEFFTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFKU0lBUlEwQUlBSkIwd0EyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTWt3RUxRY2tBSVFNTWVRc2dBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjRW9OZ0lRSUFKQkJ6WUNEQ0FDUVFBMkFnQkJBQ0VEREpFQkN5QUNLQUlFSVFCQkFDRURJQUpCQURZQ0JDQUNJQUFnQVJBbElnQkZEUUFnQWtIU0FEWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURKQUJDMEhJQUNFRERIWUxJQUpCQURZQ0FDQUZJUUVMSUFKQmdCSTdBU29nQVVFQmFpRUJRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUl3SWdORkRRQWdBaUFERVFBQUlRQUxJQUFOQVF0Qnh3QWhBd3h6Q3lBQVFSVkdCRUFnQWtIUkFEWUNIQ0FDSUFFMkFoUWdBa0hqRnpZQ0VDQUNRUlUyQWd4QkFDRURESXdCQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1Fia05OZ0lRSUFKQkdqWUNEQXlMQVF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR2dHVFlDRUNBQ1FSNDJBZ3dNaWdFTElBRXRBQUJCT2tZRVFDQUNLQUlFSVFCQkFDRURJQUpCQURZQ0JDQUNJQUFnQVJBcElnQkZEUUVnQWtIREFEWUNIQ0FDSUFBMkFnd2dBaUFCUVFGcU5nSVVESW9CQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FiRVJOZ0lRSUFKQkNqWUNEQXlKQVFzZ0FVRUJhaUVCUVRzaEF3eHZDeUFDUWNNQU5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1od0VMUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQjhBNDJBaEFnQWtFY05nSU1ESVlCQ3lBQ0lBSXZBVEJCRUhJN0FUQU1aZ3NDUUNBQ0x3RXdJZ0JCQ0hGRkRRQWdBaTBBS0VFQlJ3MEFJQUl0QUMxQkNIRkZEUU1MSUFJZ0FFSDMrd054UVlBRWNqc0JNQXdFQ3lBQklBUkhCRUFDUUFOQUlBRXRBQUJCTUdzaUFFSC9BWEZCQ2s4RVFFRTFJUU1NYmdzZ0Fpa0RJQ0lLUXBtejVzeVpzK2JNR1ZZTkFTQUNJQXBDQ240aUNqY0RJQ0FLSUFDdFF2OEJneUlMUW4rRlZnMEJJQUlnQ2lBTGZEY0RJQ0FFSUFGQkFXb2lBVWNOQUF0Qk9TRURESVVCQ3lBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBVUVCYWlJQkVDb2lBQTBNREhjTFFUa2hBd3lEQVFzZ0FpMEFNRUVnY1EwR1FjVUJJUU1NYVF0QkFDRURJQUpCQURZQ0JDQUNJQUVnQVJBcUlnQkZEUVFnQWtFNk5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1nUUVMSUFJdEFDaEJBVWNOQUNBQ0xRQXRRUWh4UlEwQkMwRTNJUU1NWmdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRZ0FpQUFJQUVRS2lJQUJFQWdBa0U3TmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWZ3c2dBVUVCYWlFQkRHNExJQUpCQ0RvQUxBd0VDeUFCUVFGcUlRRU1iUXRCQUNFRElBSkJBRFlDSENBQ0lBRTJBaFFnQWtIa0VqWUNFQ0FDUVFRMkFnd01ld3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBUlExc0lBSkJOellDSENBQ0lBRTJBaFFnQWlBQU5nSU1ESG9MSUFJZ0FpOEJNRUVnY2pzQk1BdEJNQ0VEREY4TElBSkJOallDSENBQ0lBRTJBaFFnQWlBQU5nSU1ESGNMSUFCQkxFY05BU0FCUVFGcUlRQkJBU0VCQWtBQ1FBSkFBa0FDUUNBQ0xRQXNRUVZyRGdRREFRSUVBQXNnQUNFQkRBUUxRUUloQVF3QkMwRUVJUUVMSUFKQkFUb0FMQ0FDSUFJdkFUQWdBWEk3QVRBZ0FDRUJEQUVMSUFJZ0FpOEJNRUVJY2pzQk1DQUFJUUVMUVRraEF3eGNDeUFDUVFBNkFDd0xRVFFoQXd4YUN5QUJJQVJHQkVCQkxTRURESE1MQWtBQ1FBTkFBa0FnQVMwQUFFRUthdzRFQWdBQUF3QUxJQVFnQVVFQmFpSUJSdzBBQzBFdElRTU1kQXNnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLaUlBUlEwQ0lBSkJMRFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1ESE1MSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFSUFJZ0FDQUJFQ29pQUVVRVFDQUJRUUZxSVFFTUFnc2dBa0VzTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTWNnc2dBUzBBQUVFTlJnUkFJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVJQUlnQUNBQkVDb2lBRVVFUUNBQlFRRnFJUUVNQWdzZ0FrRXNOZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNY2dzZ0FpMEFMVUVCY1FSQVFjUUJJUU1NV1FzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRZ0FpQUFJQUVRS2lJQURRRU1aUXRCTHlFRERGY0xJQUpCTGpZQ0hDQUNJQUUyQWhRZ0FpQUFOZ0lNREc4TFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkI4QlEyQWhBZ0FrRUROZ0lNREc0TFFRRWhBd0pBQWtBQ1FBSkFJQUl0QUN4QkJXc09CQU1CQWdBRUN5QUNJQUl2QVRCQkNISTdBVEFNQXd0QkFpRUREQUVMUVFRaEF3c2dBa0VCT2dBc0lBSWdBaThCTUNBRGNqc0JNQXRCS2lFRERGTUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCNFE4MkFoQWdBa0VLTmdJTURHc0xRUUVoQXdKQUFrQUNRQUpBQWtBQ1FDQUNMUUFzUVFKckRnY0ZCQVFEQVFJQUJBc2dBaUFDTHdFd1FRaHlPd0V3REFNTFFRSWhBd3dCQzBFRUlRTUxJQUpCQVRvQUxDQUNJQUl2QVRBZ0EzSTdBVEFMUVNzaEF3eFNDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWFzU05nSVFJQUpCQ3pZQ0RBeHFDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWYwTk5nSVFJQUpCSFRZQ0RBeHBDeUFCSUFSSEJFQURRQ0FCTFFBQVFTQkhEVWdnQkNBQlFRRnFJZ0ZIRFFBTFFTVWhBd3hwQzBFbElRTU1hQXNnQWkwQUxVRUJjUVJBUWNNQklRTU1Ud3NnQWlnQ0JDRUFRUUFoQXlBQ1FRQTJBZ1FnQWlBQUlBRVFLU0lBQkVBZ0FrRW1OZ0ljSUFJZ0FEWUNEQ0FDSUFGQkFXbzJBaFFNYUFzZ0FVRUJhaUVCREZ3TElBRkJBV29oQVNBQ0x3RXdJZ0JCZ0FGeEJFQkJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BbFFpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVOQmlBQVFSVkhEUjhnQWtFRk5nSWNJQUlnQVRZQ0ZDQUNRZmtYTmdJUUlBSkJGVFlDREVFQUlRTU1ad3NDUUNBQVFhQUVjVUdnQkVjTkFDQUNMUUF0UVFKeERRQkJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0dXRXpZQ0VDQUNRUVEyQWd3TVp3c2dBZ0ovSUFJdkFUQkJGSEZCRkVZRVFFRUJJQUl0QUNoQkFVWU5BUm9nQWk4Qk1rSGxBRVlNQVFzZ0FpMEFLVUVGUmdzNkFDNUJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BaVFpQTBVTkFDQUNJQU1SQUFBaEFBc0NRQUpBQWtBQ1FBSkFJQUFPRmdJQkFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBTUVDeUFDUVFFNkFDNExJQUlnQWk4Qk1FSEFBSEk3QVRBTFFTY2hBd3hQQ3lBQ1FTTTJBaHdnQWlBQk5nSVVJQUpCcFJZMkFoQWdBa0VWTmdJTVFRQWhBd3huQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FkVUxOZ0lRSUFKQkVUWUNEQXhtQzBFQUlRQUNRQ0FDS0FJNElnTkZEUUFnQXlnQ0xDSURSUTBBSUFJZ0F4RUFBQ0VBQ3lBQURRRUxRUTRoQXd4TEN5QUFRUlZHQkVBZ0FrRUNOZ0ljSUFJZ0FUWUNGQ0FDUWJBWU5nSVFJQUpCRlRZQ0RFRUFJUU1NWkF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR25EallDRUNBQ1FSSTJBZ3dNWXd0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR3FIRFlDRUNBQ1FRODJBZ3dNWWdzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRZ0FpQUFJQUVnQ3FkcUlnRVFLeUlBUlEwQUlBSkJCVFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1ER0VMUVE4aEF3eEhDMEVBSVFNZ0FrRUFOZ0ljSUFJZ0FUWUNGQ0FDUWMwVE5nSVFJQUpCRERZQ0RBeGZDMElCSVFvTElBRkJBV29oQVFKQUlBSXBBeUFpQzBMLy8vLy8vLy8vL3c5WUJFQWdBaUFMUWdTR0lBcUVOd01nREFFTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJyUWsyQWhBZ0FrRU1OZ0lNREY0TFFTUWhBd3hFQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjMFROZ0lRSUFKQkREWUNEQXhjQ3lBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkNBQ0lBQWdBUkFzSWdCRkJFQWdBVUVCYWlFQkRGSUxJQUpCRnpZQ0hDQUNJQUEyQWd3Z0FpQUJRUUZxTmdJVURGc0xJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVBa0FnQWlBQUlBRVFMQ0lBUlFSQUlBRkJBV29oQVF3QkN5QUNRUlkyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkF4YkMwRWZJUU1NUVF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR2FEellDRUNBQ1FTSTJBZ3dNV1FzZ0FpZ0NCQ0VBUVFBaEF5QUNRUUEyQWdRZ0FpQUFJQUVRTFNJQVJRUkFJQUZCQVdvaEFReFFDeUFDUVJRMkFod2dBaUFBTmdJTUlBSWdBVUVCYWpZQ0ZBeFlDeUFDS0FJRUlRQkJBQ0VESUFKQkFEWUNCQUpBSUFJZ0FDQUJFQzBpQUVVRVFDQUJRUUZxSVFFTUFRc2dBa0VUTmdJY0lBSWdBRFlDRENBQ0lBRkJBV28yQWhRTVdBdEJIaUVEREQ0TFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkJ4Z3cyQWhBZ0FrRWpOZ0lNREZZTElBSW9BZ1FoQUVFQUlRTWdBa0VBTmdJRUlBSWdBQ0FCRUMwaUFFVUVRQ0FCUVFGcUlRRU1UZ3NnQWtFUk5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1WUXNnQWtFUU5nSWNJQUlnQVRZQ0ZDQUNJQUEyQWd3TVZBdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hHRERZQ0VDQUNRU00yQWd3TVV3dEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hBRlRZQ0VDQUNRUUkyQWd3TVVnc2dBaWdDQkNFQVFRQWhBeUFDUVFBMkFnUUNRQ0FDSUFBZ0FSQXRJZ0JGQkVBZ0FVRUJhaUVCREFFTElBSkJEallDSENBQ0lBQTJBZ3dnQWlBQlFRRnFOZ0lVREZJTFFSc2hBd3c0QzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjWU1OZ0lRSUFKQkl6WUNEQXhRQ3lBQ0tBSUVJUUJCQUNFRElBSkJBRFlDQkFKQUlBSWdBQ0FCRUN3aUFFVUVRQ0FCUVFGcUlRRU1BUXNnQWtFTk5nSWNJQUlnQURZQ0RDQUNJQUZCQVdvMkFoUU1VQXRCR2lFREREWUxRUUFoQXlBQ1FRQTJBaHdnQWlBQk5nSVVJQUpCbWc4MkFoQWdBa0VpTmdJTURFNExJQUlvQWdRaEFFRUFJUU1nQWtFQU5nSUVBa0FnQWlBQUlBRVFMQ0lBUlFSQUlBRkJBV29oQVF3QkN5QUNRUXcyQWh3Z0FpQUFOZ0lNSUFJZ0FVRUJhallDRkF4T0MwRVpJUU1NTkF0QkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrR2FEellDRUNBQ1FTSTJBZ3dNVEFzZ0FFRVZSd1JBUVFBaEF5QUNRUUEyQWh3Z0FpQUJOZ0lVSUFKQmd3dzJBaEFnQWtFVE5nSU1ERXdMSUFKQkNqWUNIQ0FDSUFFMkFoUWdBa0hrRmpZQ0VDQUNRUlUyQWd4QkFDRURERXNMSUFJb0FnUWhBRUVBSVFNZ0FrRUFOZ0lFSUFJZ0FDQUJJQXFuYWlJQkVDc2lBQVJBSUFKQkJ6WUNIQ0FDSUFFMkFoUWdBaUFBTmdJTURFc0xRUk1oQXd3eEN5QUFRUlZIQkVCQkFDRURJQUpCQURZQ0hDQUNJQUUyQWhRZ0FrSGFEVFlDRUNBQ1FSUTJBZ3dNU2dzZ0FrRWVOZ0ljSUFJZ0FUWUNGQ0FDUWZrWE5nSVFJQUpCRlRZQ0RFRUFJUU1NU1F0QkFDRUFBa0FnQWlnQ09DSURSUTBBSUFNb0Fpd2lBMFVOQUNBQ0lBTVJBQUFoQUFzZ0FFVU5RU0FBUVJWR0JFQWdBa0VETmdJY0lBSWdBVFlDRkNBQ1FiQVlOZ0lRSUFKQkZUWUNERUVBSVFNTVNRdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0duRGpZQ0VDQUNRUkkyQWd3TVNBdEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hhRFRZQ0VDQUNRUlEyQWd3TVJ3dEJBQ0VESUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0duRGpZQ0VDQUNRUkkyQWd3TVJnc2dBa0VBT2dBdklBSXRBQzFCQkhGRkRUOExJQUpCQURvQUx5QUNRUUU2QURSQkFDRUREQ3NMUVFBaEF5QUNRUUEyQWh3Z0FrSGtFVFlDRUNBQ1FRYzJBZ3dnQWlBQlFRRnFOZ0lVREVNTEFrQURRQUpBSUFFdEFBQkJDbXNPQkFBQ0FnQUNDeUFFSUFGQkFXb2lBVWNOQUF0QjNRRWhBd3hEQ3dKQUFrQWdBaTBBTkVFQlJ3MEFRUUFoQUFKQUlBSW9BamdpQTBVTkFDQURLQUpZSWdORkRRQWdBaUFERVFBQUlRQUxJQUJGRFFBZ0FFRVZSdzBCSUFKQjNBRTJBaHdnQWlBQk5nSVVJQUpCMVJZMkFoQWdBa0VWTmdJTVFRQWhBd3hFQzBIQkFTRUREQ29MSUFKQkFEWUNIQ0FDSUFFMkFoUWdBa0hwQ3pZQ0VDQUNRUjgyQWd4QkFDRURERUlMQWtBQ1FDQUNMUUFvUVFGckRnSUVBUUFMUWNBQklRTU1LUXRCdVFFaEF3d29DeUFDUVFJNkFDOUJBQ0VBQWtBZ0FpZ0NPQ0lEUlEwQUlBTW9BZ0FpQTBVTkFDQUNJQU1SQUFBaEFBc2dBRVVFUUVIQ0FTRUREQ2dMSUFCQkZVY0VRQ0FDUVFBMkFod2dBaUFCTmdJVUlBSkJwQXcyQWhBZ0FrRVFOZ0lNUVFBaEF3eEJDeUFDUWRzQk5nSWNJQUlnQVRZQ0ZDQUNRZm9XTmdJUUlBSkJGVFlDREVFQUlRTU1RQXNnQVNBRVJnUkFRZG9CSVFNTVFBc2dBUzBBQUVISUFFWU5BU0FDUVFFNkFDZ0xRYXdCSVFNTUpRdEJ2d0VoQXd3a0N5QUJJQVJIQkVBZ0FrRVFOZ0lJSUFJZ0FUWUNCRUcrQVNFRERDUUxRZGtCSVFNTVBBc2dBU0FFUmdSQVFkZ0JJUU1NUEFzZ0FTMEFBRUhJQUVjTkJDQUJRUUZxSVFGQnZRRWhBd3dpQ3lBQklBUkdCRUJCMXdFaEF3dzdDd0pBQWtBZ0FTMEFBRUhGQUdzT0VBQUZCUVVGQlFVRkJRVUZCUVVGQlFFRkN5QUJRUUZxSVFGQnV3RWhBd3dpQ3lBQlFRRnFJUUZCdkFFaEF3d2hDMEhXQVNFRElBRWdCRVlOT1NBQ0tBSUFJZ0FnQkNBQmEyb2hCU0FCSUFCclFRSnFJUVlDUUFOQUlBRXRBQUFnQUVHRDBBQnFMUUFBUncwRElBQkJBa1lOQVNBQVFRRnFJUUFnQkNBQlFRRnFJZ0ZIRFFBTElBSWdCVFlDQUF3NkN5QUNLQUlFSVFBZ0FrSUFOd01BSUFJZ0FDQUdRUUZxSWdFUUp5SUFSUVJBUWNZQklRTU1JUXNnQWtIVkFUWUNIQ0FDSUFFMkFoUWdBaUFBTmdJTVFRQWhBd3c1QzBIVUFTRURJQUVnQkVZTk9DQUNLQUlBSWdBZ0JDQUJhMm9oQlNBQklBQnJRUUZxSVFZQ1FBTkFJQUV0QUFBZ0FFR0IwQUJxTFFBQVJ3MENJQUJCQVVZTkFTQUFRUUZxSVFBZ0JDQUJRUUZxSWdGSERRQUxJQUlnQlRZQ0FBdzVDeUFDUVlFRU93RW9JQUlvQWdRaEFDQUNRZ0EzQXdBZ0FpQUFJQVpCQVdvaUFSQW5JZ0FOQXd3Q0N5QUNRUUEyQWdBTFFRQWhBeUFDUVFBMkFod2dBaUFCTmdJVUlBSkIyQnMyQWhBZ0FrRUlOZ0lNRERZTFFib0JJUU1NSEFzZ0FrSFRBVFlDSENBQ0lBRTJBaFFnQWlBQU5nSU1RUUFoQXd3MEMwRUFJUUFDUUNBQ0tBSTRJZ05GRFFBZ0F5Z0NPQ0lEUlEwQUlBSWdBeEVBQUNFQUN5QUFSUTBBSUFCQkZVWU5BU0FDUVFBMkFod2dBaUFCTmdJVUlBSkJ6QTQyQWhBZ0FrRWdOZ0lNUVFBaEF3d3pDMEhrQUNFRERCa0xJQUpCK0FBMkFod2dBaUFCTmdJVUlBSkJ5aGcyQWhBZ0FrRVZOZ0lNUVFBaEF3d3hDMEhTQVNFRElBUWdBU0lBUmcwd0lBUWdBV3NnQWlnQ0FDSUJhaUVGSUFBZ0FXdEJCR29oQmdKQUEwQWdBQzBBQUNBQlFmelBBR290QUFCSERRRWdBVUVFUmcwRElBRkJBV29oQVNBRUlBQkJBV29pQUVjTkFBc2dBaUFGTmdJQURERUxJQUpCQURZQ0hDQUNJQUEyQWhRZ0FrR1FNellDRUNBQ1FRZzJBZ3dnQWtFQU5nSUFRUUFoQXd3d0N5QUJJQVJIQkVBZ0FrRU9OZ0lJSUFJZ0FUWUNCRUczQVNFRERCY0xRZEVCSVFNTUx3c2dBa0VBTmdJQUlBWkJBV29oQVF0QnVBRWhBd3dVQ3lBQklBUkdCRUJCMEFFaEF3d3RDeUFCTFFBQVFUQnJJZ0JCL3dGeFFRcEpCRUFnQWlBQU9nQXFJQUZCQVdvaEFVRzJBU0VEREJRTElBSW9BZ1FoQUNBQ1FRQTJBZ1FnQWlBQUlBRVFLQ0lBUlEwVUlBSkJ6d0UyQWh3Z0FpQUJOZ0lVSUFJZ0FEWUNERUVBSVFNTUxBc2dBU0FFUmdSQVFjNEJJUU1NTEFzQ1FDQUJMUUFBUVM1R0JFQWdBVUVCYWlFQkRBRUxJQUlvQWdRaEFDQUNRUUEyQWdRZ0FpQUFJQUVRS0NJQVJRMFZJQUpCelFFMkFod2dBaUFCTmdJVUlBSWdBRFlDREVFQUlRTU1MQXRCdFFFaEF3d1NDeUFFSUFFaUJVWUVRRUhNQVNFRERDc0xRUUFoQUVFQklRRkJBU0VHUVFBaEF3SkFBa0FDUUFKQUFrQUNmd0pBQWtBQ1FBSkFBa0FDUUFKQUlBVXRBQUJCTUdzT0Nnb0pBQUVDQXdRRkJnZ0xDMEVDREFZTFFRTU1CUXRCQkF3RUMwRUZEQU1MUVFZTUFndEJCd3dCQzBFSUN5RURRUUFoQVVFQUlRWU1BZ3RCQ1NFRFFRRWhBRUVBSVFGQkFDRUdEQUVMUVFBaEFVRUJJUU1MSUFJZ0F6b0FLeUFGUVFGcUlRTUNRQUpBSUFJdEFDMUJFSEVOQUFKQUFrQUNRQ0FDTFFBcURnTUJBQUlFQ3lBR1JRMEREQUlMSUFBTkFRd0NDeUFCUlEwQkN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQURFQ2dpQUVVRVFDQURJUUVNQXdzZ0FrSEpBVFlDSENBQ0lBTTJBaFFnQWlBQU5nSU1RUUFoQXd3dEN5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQURFQ2dpQUVVRVFDQURJUUVNR0FzZ0FrSEtBVFlDSENBQ0lBTTJBaFFnQWlBQU5nSU1RUUFoQXd3c0N5QUNLQUlFSVFBZ0FrRUFOZ0lFSUFJZ0FDQUZFQ2dpQUVVRVFDQUZJUUVNRmdzZ0FrSExBVFlDSENBQ0lBVTJBaFFnQWlBQU5nSU1EQ3NMUWJRQklRTU1FUXRCQUNFQUFrQWdBaWdDT0NJRFJRMEFJQU1vQWp3aUEwVU5BQ0FDSUFNUkFBQWhBQXNDUUNBQUJFQWdBRUVWUmcwQklBSkJBRFlDSENBQ0lBRTJBaFFnQWtHVURUWUNFQ0FDUVNFMkFneEJBQ0VERENzTFFiSUJJUU1NRVFzZ0FrSElBVFlDSENBQ0lBRTJBaFFnQWtISkZ6WUNFQ0FDUVJVMkFneEJBQ0VERENrTElBSkJBRFlDQUNBR1FRRnFJUUZCOVFBaEF3d1BDeUFDTFFBcFFRVkdCRUJCNHdBaEF3d1BDMEhpQUNFRERBNExJQUFoQVNBQ1FRQTJBZ0FMSUFKQkFEb0FMRUVKSVFNTURBc2dBa0VBTmdJQUlBZEJBV29oQVVIQUFDRUREQXNMUVFFTE9nQXNJQUpCQURZQ0FDQUdRUUZxSVFFTFFTa2hBd3dJQzBFNElRTU1Cd3NDUUNBQklBUkhCRUFEUUNBQkxRQUFRWUErYWkwQUFDSUFRUUZIQkVBZ0FFRUNSdzBESUFGQkFXb2hBUXdGQ3lBRUlBRkJBV29pQVVjTkFBdEJQaUVERENFTFFUNGhBd3dnQ3dzZ0FrRUFPZ0FzREFFTFFRc2hBd3dFQzBFNklRTU1Bd3NnQVVFQmFpRUJRUzBoQXd3Q0N5QUNJQUU2QUN3Z0FrRUFOZ0lBSUFaQkFXb2hBVUVNSVFNTUFRc2dBa0VBTmdJQUlBWkJBV29oQVVFS0lRTU1BQXNBQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjMFFOZ0lRSUFKQkNUWUNEQXdYQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1Fla0tOZ0lRSUFKQkNUWUNEQXdXQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FiY1FOZ0lRSUFKQkNUWUNEQXdWQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1Fad1JOZ0lRSUFKQkNUWUNEQXdVQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjMFFOZ0lRSUFKQkNUWUNEQXdUQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1Fla0tOZ0lRSUFKQkNUWUNEQXdTQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FiY1FOZ0lRSUFKQkNUWUNEQXdSQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1Fad1JOZ0lRSUFKQkNUWUNEQXdRQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FaY1ZOZ0lRSUFKQkR6WUNEQXdQQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FaY1ZOZ0lRSUFKQkR6WUNEQXdPQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjQVNOZ0lRSUFKQkN6WUNEQXdOQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FaVUpOZ0lRSUFKQkN6WUNEQXdNQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FlRVBOZ0lRSUFKQkNqWUNEQXdMQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1Fmc1BOZ0lRSUFKQkNqWUNEQXdLQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FmRVpOZ0lRSUFKQkFqWUNEQXdKQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FjUVVOZ0lRSUFKQkFqWUNEQXdJQzBFQUlRTWdBa0VBTmdJY0lBSWdBVFlDRkNBQ1FmSVZOZ0lRSUFKQkFqWUNEQXdIQ3lBQ1FRSTJBaHdnQWlBQk5nSVVJQUpCbkJvMkFoQWdBa0VXTmdJTVFRQWhBd3dHQzBFQklRTU1CUXRCMUFBaEF5QUJJQVJHRFFRZ0NFRUlhaUVKSUFJb0FnQWhCUUpBQWtBZ0FTQUVSd1JBSUFWQjJNSUFhaUVISUFRZ0JXb2dBV3NoQUNBRlFYOXpRUXBxSWdVZ0FXb2hCZ05BSUFFdEFBQWdCeTBBQUVjRVFFRUNJUWNNQXdzZ0JVVUVRRUVBSVFjZ0JpRUJEQU1MSUFWQkFXc2hCU0FIUVFGcUlRY2dCQ0FCUVFGcUlnRkhEUUFMSUFBaEJTQUVJUUVMSUFsQkFUWUNBQ0FDSUFVMkFnQU1BUXNnQWtFQU5nSUFJQWtnQnpZQ0FBc2dDU0FCTmdJRUlBZ29BZ3doQUNBSUtBSUlEZ01CQkFJQUN3QUxJQUpCQURZQ0hDQUNRYlVhTmdJUUlBSkJGellDRENBQ0lBQkJBV28yQWhSQkFDRUREQUlMSUFKQkFEWUNIQ0FDSUFBMkFoUWdBa0hLR2pZQ0VDQUNRUWsyQWd4QkFDRUREQUVMSUFFZ0JFWUVRRUVpSVFNTUFRc2dBa0VKTmdJSUlBSWdBVFlDQkVFaElRTUxJQWhCRUdva0FDQURSUVJBSUFJb0Fnd2hBQXdCQ3lBQ0lBTTJBaHhCQUNFQUlBSW9BZ1FpQVVVTkFDQUNJQUVnQkNBQ0tBSUlFUUVBSWdGRkRRQWdBaUFFTmdJVUlBSWdBVFlDRENBQklRQUxJQUFMdmdJQkFuOGdBRUVBT2dBQUlBQkIzQUJxSWdGQkFXdEJBRG9BQUNBQVFRQTZBQUlnQUVFQU9nQUJJQUZCQTJ0QkFEb0FBQ0FCUVFKclFRQTZBQUFnQUVFQU9nQURJQUZCQkd0QkFEb0FBRUVBSUFCclFRTnhJZ0VnQUdvaUFFRUFOZ0lBUWR3QUlBRnJRWHh4SWdJZ0FHb2lBVUVFYTBFQU5nSUFBa0FnQWtFSlNRMEFJQUJCQURZQ0NDQUFRUUEyQWdRZ0FVRUlhMEVBTmdJQUlBRkJER3RCQURZQ0FDQUNRUmxKRFFBZ0FFRUFOZ0lZSUFCQkFEWUNGQ0FBUVFBMkFoQWdBRUVBTmdJTUlBRkJFR3RCQURZQ0FDQUJRUlJyUVFBMkFnQWdBVUVZYTBFQU5nSUFJQUZCSEd0QkFEWUNBQ0FDSUFCQkJIRkJHSElpQW1zaUFVRWdTUTBBSUFBZ0Ftb2hBQU5BSUFCQ0FEY0RHQ0FBUWdBM0F4QWdBRUlBTndNSUlBQkNBRGNEQUNBQVFTQnFJUUFnQVVFZ2F5SUJRUjlMRFFBTEN3dFdBUUYvQWtBZ0FDZ0NEQTBBQWtBQ1FBSkFBa0FnQUMwQUx3NERBUUFEQWdzZ0FDZ0NPQ0lCUlEwQUlBRW9BaXdpQVVVTkFDQUFJQUVSQUFBaUFRMERDMEVBRHdzQUN5QUFRY01XTmdJUVFRNGhBUXNnQVFzYUFDQUFLQUlNUlFSQUlBQkIwUnMyQWhBZ0FFRVZOZ0lNQ3dzVUFDQUFLQUlNUVJWR0JFQWdBRUVBTmdJTUN3c1VBQ0FBS0FJTVFSWkdCRUFnQUVFQU5nSU1Dd3NIQUNBQUtBSU1Dd2NBSUFBb0FoQUxDUUFnQUNBQk5nSVFDd2NBSUFBb0FoUUxGd0FnQUVFa1R3UkFBQXNnQUVFQ2RFR2dNMm9vQWdBTEZ3QWdBRUV1VHdSQUFBc2dBRUVDZEVHd05Hb29BZ0FMdndrQkFYOUI2eWdoQVFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUlBQkI1QUJyRHZRRFkySUFBV0ZoWVdGaFlRSURCQVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaEJnY0lDUW9MREEwT0QyRmhZV0ZoRUdGaFlXRmhZV0ZoWVdGaEVXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlSSVRGQlVXRnhnWkdodGhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhIQjBlSHlBaElpTWtKU1luS0NrcUt5d3RMaTh3TVRJek5EVTJZVGM0T1RwaFlXRmhZV0ZoWVR0aFlXRThZV0ZoWVQwK1AyRmhZV0ZoWVdGaFFHRmhRV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTJGaFlXRmhZV0ZoVkZWV1YxaFpXbHRoWEYxaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmVZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhYMkJoQzBIaEp3OExRYVFoRHd0Qnl5d1BDMEgrTVE4TFFjQWtEd3RCcXlRUEMwR05LQThMUWVJbUR3dEJnREFQQzBHNUx3OExRZGNrRHd0Qjd4OFBDMEhoSHc4TFFmb2ZEd3RCOGlBUEMwR29MdzhMUWE0eUR3dEJpREFQQzBIc0p3OExRWUlpRHd0QmpoMFBDMEhRTGc4TFFjb2pEd3RCeFRJUEMwSGZIQThMUWRJY0R3dEJ4Q0FQQzBIWElBOExRYUlmRHd0QjdTNFBDMEdyTUE4TFFkUWxEd3RCekM0UEMwSDZMZzhMUWZ3ckR3dEIwakFQQzBIeEhROExRYnNnRHd0Qjl5c1BDMEdRTVE4TFFkY3hEd3RCb2kwUEMwSFVKdzhMUWVBckR3dEJueXdQQzBIck1ROExRZFVmRHd0QnlqRVBDMEhlSlE4TFFkUWVEd3RCOUJ3UEMwR25NZzhMUWJFZER3dEJvQjBQQzBHNU1ROExRYnd3RHd0QmtpRVBDMEd6Smc4TFFla3NEd3RCckI0UEMwSFVLdzhMUWZjbUR3dEJnQ1lQQzBHd0lROExRZjRlRHd0QmpTTVBDMEdKTFE4TFFmY2lEd3RCb0RFUEMwR3VIdzhMUWNZbER3dEI2QjRQQzBHVElnOExRY0l2RHd0Qnd4MFBDMEdMTEE4TFFlRWREd3RCalM4UEMwSHFJUThMUWJRdER3dEIwaThQQzBIZk1nOExRZEl5RHd0QjhEQVBDMEdwSWc4TFFma2pEd3RCbVI0UEMwRzFMQThMUVpzd0R3dEJraklQQzBHMkt3OExRY0lpRHd0QitESVBDMEdlSlE4TFFkQWlEd3RCdWg0UEMwR0JIZzhMQUF0QjFpRWhBUXNnQVFzV0FDQUFJQUF0QUMxQi9nRnhJQUZCQUVkeU9nQXRDeGtBSUFBZ0FDMEFMVUg5QVhFZ0FVRUFSMEVCZEhJNkFDMExHUUFnQUNBQUxRQXRRZnNCY1NBQlFRQkhRUUowY2pvQUxRc1pBQ0FBSUFBdEFDMUI5d0Z4SUFGQkFFZEJBM1J5T2dBdEN6NEJBbjhDUUNBQUtBSTRJZ05GRFFBZ0F5Z0NCQ0lEUlEwQUlBQWdBU0FDSUFGcklBTVJBUUFpQkVGL1J3MEFJQUJCeGhFMkFoQkJHQ0VFQ3lBRUN6NEJBbjhDUUNBQUtBSTRJZ05GRFFBZ0F5Z0NDQ0lEUlEwQUlBQWdBU0FDSUFGcklBTVJBUUFpQkVGL1J3MEFJQUJCOWdvMkFoQkJHQ0VFQ3lBRUN6NEJBbjhDUUNBQUtBSTRJZ05GRFFBZ0F5Z0NEQ0lEUlEwQUlBQWdBU0FDSUFGcklBTVJBUUFpQkVGL1J3MEFJQUJCN1JvMkFoQkJHQ0VFQ3lBRUN6NEJBbjhDUUNBQUtBSTRJZ05GRFFBZ0F5Z0NFQ0lEUlEwQUlBQWdBU0FDSUFGcklBTVJBUUFpQkVGL1J3MEFJQUJCbFJBMkFoQkJHQ0VFQ3lBRUN6NEJBbjhDUUNBQUtBSTRJZ05GRFFBZ0F5Z0NGQ0lEUlEwQUlBQWdBU0FDSUFGcklBTVJBUUFpQkVGL1J3MEFJQUJCcWhzMkFoQkJHQ0VFQ3lBRUN6NEJBbjhDUUNBQUtBSTRJZ05GRFFBZ0F5Z0NHQ0lEUlEwQUlBQWdBU0FDSUFGcklBTVJBUUFpQkVGL1J3MEFJQUJCN1JNMkFoQkJHQ0VFQ3lBRUN6NEJBbjhDUUNBQUtBSTRJZ05GRFFBZ0F5Z0NLQ0lEUlEwQUlBQWdBU0FDSUFGcklBTVJBUUFpQkVGL1J3MEFJQUJCOWdnMkFoQkJHQ0VFQ3lBRUN6NEJBbjhDUUNBQUtBSTRJZ05GRFFBZ0F5Z0NIQ0lEUlEwQUlBQWdBU0FDSUFGcklBTVJBUUFpQkVGL1J3MEFJQUJCd2hrMkFoQkJHQ0VFQ3lBRUN6NEJBbjhDUUNBQUtBSTRJZ05GRFFBZ0F5Z0NJQ0lEUlEwQUlBQWdBU0FDSUFGcklBTVJBUUFpQkVGL1J3MEFJQUJCbEJRMkFoQkJHQ0VFQ3lBRUMxa0JBbjhDUUNBQUxRQW9RUUZHRFFBZ0FDOEJNaUlCUWVRQWEwSGtBRWtOQUNBQlFjd0JSZzBBSUFGQnNBSkdEUUFnQUM4Qk1DSUFRY0FBY1EwQVFRRWhBaUFBUVlnRWNVR0FCRVlOQUNBQVFTaHhSU0VDQ3lBQ0M0d0JBUUovQWtBQ1FBSkFJQUF0QUNwRkRRQWdBQzBBSzBVTkFDQUFMd0V3SWdGQkFuRkZEUUVNQWdzZ0FDOEJNQ0lCUVFGeFJRMEJDMEVCSVFJZ0FDMEFLRUVCUmcwQUlBQXZBVElpQUVIa0FHdEI1QUJKRFFBZ0FFSE1BVVlOQUNBQVFiQUNSZzBBSUFGQndBQnhEUUJCQUNFQ0lBRkJpQVJ4UVlBRVJnMEFJQUZCS0hGQkFFY2hBZ3NnQWd0ekFDQUFRUkJxL1F3QUFBQUFBQUFBQUFBQUFBQUFBQUFBL1FzREFDQUEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNEQUNBQVFUQnEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNEQUNBQVFTQnEvUXdBQUFBQUFBQUFBQUFBQUFBQUFBQUEvUXNEQUNBQVFkMEJOZ0ljQ3dZQUlBQVFNZ3VhTFFFTGZ5TUFRUkJySWdva0FFR2swQUFvQWdBaUNVVUVRRUhrMHdBb0FnQWlCVVVFUUVIdzB3QkNmemNDQUVIbzB3QkNnSUNFZ0lDQXdBQTNBZ0JCNU5NQUlBcEJDR3BCY0hGQjJLclZxZ1Z6SWdVMkFnQkIrTk1BUVFBMkFnQkJ5Tk1BUVFBMkFnQUxRY3pUQUVHQTFBUTJBZ0JCbk5BQVFZRFVCRFlDQUVHdzBBQWdCVFlDQUVHczBBQkJmellDQUVIUTB3QkJnS3dETmdJQUEwQWdBVUhJMEFCcUlBRkJ2TkFBYWlJQ05nSUFJQUlnQVVHMDBBQnFJZ00yQWdBZ0FVSEEwQUJxSUFNMkFnQWdBVUhRMEFCcUlBRkJ4TkFBYWlJRE5nSUFJQU1nQWpZQ0FDQUJRZGpRQUdvZ0FVSE0wQUJxSWdJMkFnQWdBaUFETmdJQUlBRkIxTkFBYWlBQ05nSUFJQUZCSUdvaUFVR0FBa2NOQUF0QmpOUUVRY0dyQXpZQ0FFR28wQUJCOU5NQUtBSUFOZ0lBUVpqUUFFSEFxd00yQWdCQnBOQUFRWWpVQkRZQ0FFSE0vd2RCT0RZQ0FFR0kxQVFoQ1FzQ1FBSkFBa0FDUUFKQUFrQUNRQUpBQWtBQ1FBSkFBa0FDUUFKQUFrQUNRQ0FBUWV3QlRRUkFRWXpRQUNnQ0FDSUdRUkFnQUVFVGFrRndjU0FBUVF0Skd5SUVRUU4ySWdCMklnRkJBM0VFUUFKQUlBRkJBWEVnQUhKQkFYTWlBa0VEZENJQVFiVFFBR29pQVNBQVFielFBR29vQWdBaUFDZ0NDQ0lEUmdSQVFZelFBQ0FHUVg0Z0FuZHhOZ0lBREFFTElBRWdBellDQ0NBRElBRTJBZ3dMSUFCQkNHb2hBU0FBSUFKQkEzUWlBa0VEY2pZQ0JDQUFJQUpxSWdBZ0FDZ0NCRUVCY2pZQ0JBd1JDMEdVMEFBb0FnQWlDQ0FFVHcwQklBRUVRQUpBUVFJZ0FIUWlBa0VBSUFKcmNpQUJJQUIwY1dnaUFFRURkQ0lDUWJUUUFHb2lBU0FDUWJ6UUFHb29BZ0FpQWlnQ0NDSURSZ1JBUVl6UUFDQUdRWDRnQUhkeElnWTJBZ0FNQVFzZ0FTQUROZ0lJSUFNZ0FUWUNEQXNnQWlBRVFRTnlOZ0lFSUFCQkEzUWlBQ0FFYXlFRklBQWdBbW9nQlRZQ0FDQUNJQVJxSWdRZ0JVRUJjallDQkNBSUJFQWdDRUY0Y1VHMDBBQnFJUUJCb05BQUtBSUFJUU1DZjBFQklBaEJBM1owSWdFZ0JuRkZCRUJCak5BQUlBRWdCbkkyQWdBZ0FBd0JDeUFBS0FJSUN5SUJJQU0yQWd3Z0FDQUROZ0lJSUFNZ0FEWUNEQ0FESUFFMkFnZ0xJQUpCQ0dvaEFVR2cwQUFnQkRZQ0FFR1UwQUFnQlRZQ0FBd1JDMEdRMEFBb0FnQWlDMFVOQVNBTGFFRUNkRUc4MGdCcUtBSUFJZ0FvQWdSQmVIRWdCR3NoQlNBQUlRSURRQUpBSUFJb0FoQWlBVVVFUUNBQ1FSUnFLQUlBSWdGRkRRRUxJQUVvQWdSQmVIRWdCR3NpQXlBRlNTRUNJQU1nQlNBQ0d5RUZJQUVnQUNBQ0d5RUFJQUVoQWd3QkN3c2dBQ2dDR0NFSklBQW9BZ3dpQXlBQVJ3UkFRWnpRQUNnQ0FCb2dBeUFBS0FJSUlnRTJBZ2dnQVNBRE5nSU1EQkFMSUFCQkZHb2lBaWdDQUNJQlJRUkFJQUFvQWhBaUFVVU5BeUFBUVJCcUlRSUxBMEFnQWlFSElBRWlBMEVVYWlJQ0tBSUFJZ0VOQUNBRFFSQnFJUUlnQXlnQ0VDSUJEUUFMSUFkQkFEWUNBQXdQQzBGL0lRUWdBRUcvZjBzTkFDQUFRUk5xSWdGQmNIRWhCRUdRMEFBb0FnQWlDRVVOQUVFQUlBUnJJUVVDUUFKQUFrQUNmMEVBSUFSQmdBSkpEUUFhUVI4Z0JFSC8vLzhIU3cwQUdpQUVRU1lnQVVFSWRtY2lBR3QyUVFGeElBQkJBWFJyUVQ1cUN5SUdRUUowUWJ6U0FHb29BZ0FpQWtVRVFFRUFJUUZCQUNFRERBRUxRUUFoQVNBRVFSa2dCa0VCZG10QkFDQUdRUjlIRzNRaEFFRUFJUU1EUUFKQUlBSW9BZ1JCZUhFZ0JHc2lCeUFGVHcwQUlBSWhBeUFISWdVTkFFRUFJUVVnQWlFQkRBTUxJQUVnQWtFVWFpZ0NBQ0lISUFjZ0FpQUFRUjEyUVFSeGFrRVFhaWdDQUNJQ1Joc2dBU0FIR3lFQklBQkJBWFFoQUNBQ0RRQUxDeUFCSUFOeVJRUkFRUUFoQTBFQ0lBWjBJZ0JCQUNBQWEzSWdDSEVpQUVVTkF5QUFhRUVDZEVHODBnQnFLQUlBSVFFTElBRkZEUUVMQTBBZ0FTZ0NCRUY0Y1NBRWF5SUNJQVZKSVFBZ0FpQUZJQUFiSVFVZ0FTQURJQUFiSVFNZ0FTZ0NFQ0lBQkg4Z0FBVWdBVUVVYWlnQ0FBc2lBUTBBQ3dzZ0EwVU5BQ0FGUVpUUUFDZ0NBQ0FFYTA4TkFDQURLQUlZSVFjZ0F5QURLQUlNSWdCSEJFQkJuTkFBS0FJQUdpQUFJQU1vQWdnaUFUWUNDQ0FCSUFBMkFnd01EZ3NnQTBFVWFpSUNLQUlBSWdGRkJFQWdBeWdDRUNJQlJRMERJQU5CRUdvaEFnc0RRQ0FDSVFZZ0FTSUFRUlJxSWdJb0FnQWlBUTBBSUFCQkVHb2hBaUFBS0FJUUlnRU5BQXNnQmtFQU5nSUFEQTBMUVpUUUFDZ0NBQ0lESUFSUEJFQkJvTkFBS0FJQUlRRUNRQ0FESUFScklnSkJFRThFUUNBQklBUnFJZ0FnQWtFQmNqWUNCQ0FCSUFOcUlBSTJBZ0FnQVNBRVFRTnlOZ0lFREFFTElBRWdBMEVEY2pZQ0JDQUJJQU5xSWdBZ0FDZ0NCRUVCY2pZQ0JFRUFJUUJCQUNFQ0MwR1UwQUFnQWpZQ0FFR2cwQUFnQURZQ0FDQUJRUWhxSVFFTUR3dEJtTkFBS0FJQUlnTWdCRXNFUUNBRUlBbHFJZ0FnQXlBRWF5SUJRUUZ5TmdJRVFhVFFBQ0FBTmdJQVFaalFBQ0FCTmdJQUlBa2dCRUVEY2pZQ0JDQUpRUWhxSVFFTUR3dEJBQ0VCSUFRQ2YwSGswd0FvQWdBRVFFSHMwd0FvQWdBTUFRdEI4Tk1BUW44M0FnQkI2Tk1BUW9DQWhJQ0FnTUFBTndJQVFlVFRBQ0FLUVF4cVFYQnhRZGlxMWFvRmN6WUNBRUg0MHdCQkFEWUNBRUhJMHdCQkFEWUNBRUdBZ0FRTElnQWdCRUhIQUdvaUJXb2lCa0VBSUFCcklnZHhJZ0pQQkVCQi9OTUFRVEEyQWdBTUR3c0NRRUhFMHdBb0FnQWlBVVVOQUVHODB3QW9BZ0FpQ0NBQ2FpRUFJQUFnQVUwZ0FDQUlTM0VOQUVFQUlRRkIvTk1BUVRBMkFnQU1Ed3RCeU5NQUxRQUFRUVJ4RFFRQ1FBSkFJQWtFUUVITTB3QWhBUU5BSUFFb0FnQWlBQ0FKVFFSQUlBQWdBU2dDQkdvZ0NVc05Bd3NnQVNnQ0NDSUJEUUFMQzBFQUVETWlBRUYvUmcwRklBSWhCa0hvMHdBb0FnQWlBVUVCYXlJRElBQnhCRUFnQWlBQWF5QUFJQU5xUVFBZ0FXdHhhaUVHQ3lBRUlBWlBEUVVnQmtIKy8vLy9CMHNOQlVIRTB3QW9BZ0FpQXdSQVFielRBQ2dDQUNJSElBWnFJUUVnQVNBSFRRMEdJQUVnQTBzTkJnc2dCaEF6SWdFZ0FFY05BUXdIQ3lBR0lBTnJJQWR4SWdaQi92Ly8vd2RMRFFRZ0JoQXpJUUFnQUNBQktBSUFJQUVvQWdScVJnMERJQUFoQVFzQ1FDQUdJQVJCeUFCcVR3MEFJQUZCZjBZTkFFSHMwd0FvQWdBaUFDQUZJQVpyYWtFQUlBQnJjU0lBUWY3Ly8vOEhTd1JBSUFFaEFBd0hDeUFBRUROQmYwY0VRQ0FBSUFacUlRWWdBU0VBREFjTFFRQWdCbXNRTXhvTUJBc2dBU0lBUVg5SERRVU1Bd3RCQUNFRERBd0xRUUFoQUF3S0N5QUFRWDlIRFFJTFFjalRBRUhJMHdBb0FnQkJCSEkyQWdBTElBSkIvdi8vL3dkTERRRWdBaEF6SVFCQkFCQXpJUUVnQUVGL1JnMEJJQUZCZjBZTkFTQUFJQUZQRFFFZ0FTQUFheUlHSUFSQk9HcE5EUUVMUWJ6VEFFRzgwd0FvQWdBZ0Jtb2lBVFlDQUVIQTB3QW9BZ0FnQVVrRVFFSEEwd0FnQVRZQ0FBc0NRQUpBQWtCQnBOQUFLQUlBSWdJRVFFSE0wd0FoQVFOQUlBQWdBU2dDQUNJRElBRW9BZ1FpQldwR0RRSWdBU2dDQ0NJQkRRQUxEQUlMUVp6UUFDZ0NBQ0lCUVFCSElBQWdBVTl4UlFSQVFaelFBQ0FBTmdJQUMwRUFJUUZCME5NQUlBWTJBZ0JCek5NQUlBQTJBZ0JCck5BQVFYODJBZ0JCc05BQVFlVFRBQ2dDQURZQ0FFSFkwd0JCQURZQ0FBTkFJQUZCeU5BQWFpQUJRYnpRQUdvaUFqWUNBQ0FDSUFGQnROQUFhaUlETmdJQUlBRkJ3TkFBYWlBRE5nSUFJQUZCME5BQWFpQUJRY1RRQUdvaUF6WUNBQ0FESUFJMkFnQWdBVUhZMEFCcUlBRkJ6TkFBYWlJQ05nSUFJQUlnQXpZQ0FDQUJRZFRRQUdvZ0FqWUNBQ0FCUVNCcUlnRkJnQUpIRFFBTFFYZ2dBR3RCRDNFaUFTQUFhaUlDSUFaQk9Hc2lBeUFCYXlJQlFRRnlOZ0lFUWFqUUFFSDAwd0FvQWdBMkFnQkJtTkFBSUFFMkFnQkJwTkFBSUFJMkFnQWdBQ0FEYWtFNE5nSUVEQUlMSUFBZ0FrME5BQ0FDSUFOSkRRQWdBU2dDREVFSWNRMEFRWGdnQW10QkQzRWlBQ0FDYWlJRFFaalFBQ2dDQUNBR2FpSUhJQUJySWdCQkFYSTJBZ1FnQVNBRklBWnFOZ0lFUWFqUUFFSDAwd0FvQWdBMkFnQkJtTkFBSUFBMkFnQkJwTkFBSUFNMkFnQWdBaUFIYWtFNE5nSUVEQUVMSUFCQm5OQUFLQUlBU1FSQVFaelFBQ0FBTmdJQUN5QUFJQVpxSVFOQnpOTUFJUUVDUUFKQUFrQURRQ0FESUFFb0FnQkhCRUFnQVNnQ0NDSUJEUUVNQWdzTElBRXRBQXhCQ0hGRkRRRUxRY3pUQUNFQkEwQWdBU2dDQUNJRElBSk5CRUFnQXlBQktBSUVhaUlGSUFKTERRTUxJQUVvQWdnaEFRd0FDd0FMSUFFZ0FEWUNBQ0FCSUFFb0FnUWdCbW8yQWdRZ0FFRjRJQUJyUVE5eGFpSUpJQVJCQTNJMkFnUWdBMEY0SUFOclFROXhhaUlHSUFRZ0NXb2lCR3NoQVNBQ0lBWkdCRUJCcE5BQUlBUTJBZ0JCbU5BQVFaalFBQ2dDQUNBQmFpSUFOZ0lBSUFRZ0FFRUJjallDQkF3SUMwR2cwQUFvQWdBZ0JrWUVRRUdnMEFBZ0JEWUNBRUdVMEFCQmxOQUFLQUlBSUFGcUlnQTJBZ0FnQkNBQVFRRnlOZ0lFSUFBZ0JHb2dBRFlDQUF3SUN5QUdLQUlFSWdWQkEzRkJBVWNOQmlBRlFYaHhJUWdnQlVIL0FVMEVRQ0FGUVFOMklRTWdCaWdDQ0NJQUlBWW9BZ3dpQWtZRVFFR00wQUJCak5BQUtBSUFRWDRnQTNkeE5nSUFEQWNMSUFJZ0FEWUNDQ0FBSUFJMkFnd01CZ3NnQmlnQ0dDRUhJQVlnQmlnQ0RDSUFSd1JBSUFBZ0JpZ0NDQ0lDTmdJSUlBSWdBRFlDREF3RkN5QUdRUlJxSWdJb0FnQWlCVVVFUUNBR0tBSVFJZ1ZGRFFRZ0JrRVFhaUVDQ3dOQUlBSWhBeUFGSWdCQkZHb2lBaWdDQUNJRkRRQWdBRUVRYWlFQ0lBQW9BaEFpQlEwQUN5QURRUUEyQWdBTUJBdEJlQ0FBYTBFUGNTSUJJQUJxSWdjZ0JrRTRheUlESUFGcklnRkJBWEkyQWdRZ0FDQURha0U0TmdJRUlBSWdCVUUzSUFWclFROXhha0UvYXlJRElBTWdBa0VRYWtrYklnTkJJellDQkVHbzBBQkI5Tk1BS0FJQU5nSUFRWmpRQUNBQk5nSUFRYVRRQUNBSE5nSUFJQU5CRUdwQjFOTUFLUUlBTndJQUlBTkJ6Tk1BS1FJQU53SUlRZFRUQUNBRFFRaHFOZ0lBUWREVEFDQUdOZ0lBUWN6VEFDQUFOZ0lBUWRqVEFFRUFOZ0lBSUFOQkpHb2hBUU5BSUFGQkJ6WUNBQ0FGSUFGQkJHb2lBVXNOQUFzZ0FpQURSZzBBSUFNZ0F5Z0NCRUYrY1RZQ0JDQURJQU1nQW1zaUJUWUNBQ0FDSUFWQkFYSTJBZ1FnQlVIL0FVMEVRQ0FGUVhoeFFiVFFBR29oQUFKL1FZelFBQ2dDQUNJQlFRRWdCVUVEZG5RaUEzRkZCRUJCak5BQUlBRWdBM0kyQWdBZ0FBd0JDeUFBS0FJSUN5SUJJQUkyQWd3Z0FDQUNOZ0lJSUFJZ0FEWUNEQ0FDSUFFMkFnZ01BUXRCSHlFQklBVkIvLy8vQjAwRVFDQUZRU1lnQlVFSWRtY2lBR3QyUVFGeElBQkJBWFJyUVQ1cUlRRUxJQUlnQVRZQ0hDQUNRZ0EzQWhBZ0FVRUNkRUc4MGdCcUlRQkJrTkFBS0FJQUlnTkJBU0FCZENJR2NVVUVRQ0FBSUFJMkFnQkJrTkFBSUFNZ0JuSTJBZ0FnQWlBQU5nSVlJQUlnQWpZQ0NDQUNJQUkyQWd3TUFRc2dCVUVaSUFGQkFYWnJRUUFnQVVFZlJ4dDBJUUVnQUNnQ0FDRURBa0FEUUNBRElnQW9BZ1JCZUhFZ0JVWU5BU0FCUVIxMklRTWdBVUVCZENFQklBQWdBMEVFY1dwQkVHb2lCaWdDQUNJRERRQUxJQVlnQWpZQ0FDQUNJQUEyQWhnZ0FpQUNOZ0lNSUFJZ0FqWUNDQXdCQ3lBQUtBSUlJZ0VnQWpZQ0RDQUFJQUkyQWdnZ0FrRUFOZ0lZSUFJZ0FEWUNEQ0FDSUFFMkFnZ0xRWmpRQUNnQ0FDSUJJQVJORFFCQnBOQUFLQUlBSWdBZ0JHb2lBaUFCSUFScklnRkJBWEkyQWdSQm1OQUFJQUUyQWdCQnBOQUFJQUkyQWdBZ0FDQUVRUU55TmdJRUlBQkJDR29oQVF3SUMwRUFJUUZCL05NQVFUQTJBZ0FNQnd0QkFDRUFDeUFIUlEwQUFrQWdCaWdDSENJQ1FRSjBRYnpTQUdvaUF5Z0NBQ0FHUmdSQUlBTWdBRFlDQUNBQURRRkJrTkFBUVpEUUFDZ0NBRUYrSUFKM2NUWUNBQXdDQ3lBSFFSQkJGQ0FIS0FJUUlBWkdHMm9nQURZQ0FDQUFSUTBCQ3lBQUlBYzJBaGdnQmlnQ0VDSUNCRUFnQUNBQ05nSVFJQUlnQURZQ0dBc2dCa0VVYWlnQ0FDSUNSUTBBSUFCQkZHb2dBallDQUNBQ0lBQTJBaGdMSUFFZ0NHb2hBU0FHSUFocUlnWW9BZ1FoQlFzZ0JpQUZRWDV4TmdJRUlBRWdCR29nQVRZQ0FDQUVJQUZCQVhJMkFnUWdBVUgvQVUwRVFDQUJRWGh4UWJUUUFHb2hBQUovUVl6UUFDZ0NBQ0lDUVFFZ0FVRURkblFpQVhGRkJFQkJqTkFBSUFFZ0FuSTJBZ0FnQUF3QkN5QUFLQUlJQ3lJQklBUTJBZ3dnQUNBRU5nSUlJQVFnQURZQ0RDQUVJQUUyQWdnTUFRdEJIeUVGSUFGQi8vLy9CMDBFUUNBQlFTWWdBVUVJZG1jaUFHdDJRUUZ4SUFCQkFYUnJRVDVxSVFVTElBUWdCVFlDSENBRVFnQTNBaEFnQlVFQ2RFRzgwZ0JxSVFCQmtOQUFLQUlBSWdKQkFTQUZkQ0lEY1VVRVFDQUFJQVEyQWdCQmtOQUFJQUlnQTNJMkFnQWdCQ0FBTmdJWUlBUWdCRFlDQ0NBRUlBUTJBZ3dNQVFzZ0FVRVpJQVZCQVhaclFRQWdCVUVmUnh0MElRVWdBQ2dDQUNFQUFrQURRQ0FBSWdJb0FnUkJlSEVnQVVZTkFTQUZRUjEySVFBZ0JVRUJkQ0VGSUFJZ0FFRUVjV3BCRUdvaUF5Z0NBQ0lBRFFBTElBTWdCRFlDQUNBRUlBSTJBaGdnQkNBRU5nSU1JQVFnQkRZQ0NBd0JDeUFDS0FJSUlnQWdCRFlDRENBQ0lBUTJBZ2dnQkVFQU5nSVlJQVFnQWpZQ0RDQUVJQUEyQWdnTElBbEJDR29oQVF3Q0N3SkFJQWRGRFFBQ1FDQURLQUljSWdGQkFuUkJ2TklBYWlJQ0tBSUFJQU5HQkVBZ0FpQUFOZ0lBSUFBTkFVR1EwQUFnQ0VGK0lBRjNjU0lJTmdJQURBSUxJQWRCRUVFVUlBY29BaEFnQTBZYmFpQUFOZ0lBSUFCRkRRRUxJQUFnQnpZQ0dDQURLQUlRSWdFRVFDQUFJQUUyQWhBZ0FTQUFOZ0lZQ3lBRFFSUnFLQUlBSWdGRkRRQWdBRUVVYWlBQk5nSUFJQUVnQURZQ0dBc0NRQ0FGUVE5TkJFQWdBeUFFSUFWcUlnQkJBM0kyQWdRZ0FDQURhaUlBSUFBb0FnUkJBWEkyQWdRTUFRc2dBeUFFYWlJQ0lBVkJBWEkyQWdRZ0F5QUVRUU55TmdJRUlBSWdCV29nQlRZQ0FDQUZRZjhCVFFSQUlBVkJlSEZCdE5BQWFpRUFBbjlCak5BQUtBSUFJZ0ZCQVNBRlFRTjJkQ0lGY1VVRVFFR00wQUFnQVNBRmNqWUNBQ0FBREFFTElBQW9BZ2dMSWdFZ0FqWUNEQ0FBSUFJMkFnZ2dBaUFBTmdJTUlBSWdBVFlDQ0F3QkMwRWZJUUVnQlVILy8vOEhUUVJBSUFWQkppQUZRUWgyWnlJQWEzWkJBWEVnQUVFQmRHdEJQbW9oQVFzZ0FpQUJOZ0ljSUFKQ0FEY0NFQ0FCUVFKMFFielNBR29oQUVFQklBRjBJZ1FnQ0hGRkJFQWdBQ0FDTmdJQVFaRFFBQ0FFSUFoeU5nSUFJQUlnQURZQ0dDQUNJQUkyQWdnZ0FpQUNOZ0lNREFFTElBVkJHU0FCUVFGMmEwRUFJQUZCSDBjYmRDRUJJQUFvQWdBaEJBSkFBMEFnQkNJQUtBSUVRWGh4SUFWR0RRRWdBVUVkZGlFRUlBRkJBWFFoQVNBQUlBUkJCSEZxUVJCcUlnWW9BZ0FpQkEwQUN5QUdJQUkyQWdBZ0FpQUFOZ0lZSUFJZ0FqWUNEQ0FDSUFJMkFnZ01BUXNnQUNnQ0NDSUJJQUkyQWd3Z0FDQUNOZ0lJSUFKQkFEWUNHQ0FDSUFBMkFnd2dBaUFCTmdJSUN5QURRUWhxSVFFTUFRc0NRQ0FKUlEwQUFrQWdBQ2dDSENJQlFRSjBRYnpTQUdvaUFpZ0NBQ0FBUmdSQUlBSWdBellDQUNBRERRRkJrTkFBSUF0QmZpQUJkM0UyQWdBTUFnc2dDVUVRUVJRZ0NTZ0NFQ0FBUmh0cUlBTTJBZ0FnQTBVTkFRc2dBeUFKTmdJWUlBQW9BaEFpQVFSQUlBTWdBVFlDRUNBQklBTTJBaGdMSUFCQkZHb29BZ0FpQVVVTkFDQURRUlJxSUFFMkFnQWdBU0FETmdJWUN3SkFJQVZCRDAwRVFDQUFJQVFnQldvaUFVRURjallDQkNBQUlBRnFJZ0VnQVNnQ0JFRUJjallDQkF3QkN5QUFJQVJxSWdjZ0JVRUJjallDQkNBQUlBUkJBM0kyQWdRZ0JTQUhhaUFGTmdJQUlBZ0VRQ0FJUVhoeFFiVFFBR29oQVVHZzBBQW9BZ0FoQXdKL1FRRWdDRUVEZG5RaUFpQUdjVVVFUUVHTTBBQWdBaUFHY2pZQ0FDQUJEQUVMSUFFb0FnZ0xJZ0lnQXpZQ0RDQUJJQU0yQWdnZ0F5QUJOZ0lNSUFNZ0FqWUNDQXRCb05BQUlBYzJBZ0JCbE5BQUlBVTJBZ0FMSUFCQkNHb2hBUXNnQ2tFUWFpUUFJQUVMUXdBZ0FFVUVRRDhBUVJCMER3c0NRQ0FBUWYvL0EzRU5BQ0FBUVFCSURRQWdBRUVRZGtBQUlnQkJmMFlFUUVIODB3QkJNRFlDQUVGL0R3c2dBRUVRZEE4TEFBc0wzRDhpQUVHQUNBc0pBUUFBQUFJQUFBQURBRUdVQ0FzRkJBQUFBQVVBUWFRSUN3a0dBQUFBQndBQUFBZ0FRZHdJQzRvdFNXNTJZV3hwWkNCamFHRnlJR2x1SUhWeWJDQnhkV1Z5ZVFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDJKdlpIa0FRMjl1ZEdWdWRDMU1aVzVuZEdnZ2IzWmxjbVpzYjNjQVEyaDFibXNnYzJsNlpTQnZkbVZ5Wm14dmR3QlNaWE53YjI1elpTQnZkbVZ5Wm14dmR3QkpiblpoYkdsa0lHMWxkR2h2WkNCbWIzSWdTRlJVVUM5NExuZ2djbVZ4ZFdWemRBQkpiblpoYkdsa0lHMWxkR2h2WkNCbWIzSWdVbFJUVUM5NExuZ2djbVZ4ZFdWemRBQkZlSEJsWTNSbFpDQlRUMVZTUTBVZ2JXVjBhRzlrSUdadmNpQkpRMFV2ZUM1NElISmxjWFZsYzNRQVNXNTJZV3hwWkNCamFHRnlJR2x1SUhWeWJDQm1jbUZuYldWdWRDQnpkR0Z5ZEFCRmVIQmxZM1JsWkNCa2IzUUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOXpkR0YwZFhNQVNXNTJZV3hwWkNCeVpYTndiMjV6WlNCemRHRjBkWE1BU1c1MllXeHBaQ0JqYUdGeVlXTjBaWElnYVc0Z1kyaDFibXNnWlhoMFpXNXphVzl1Y3dCVmMyVnlJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl5WlhObGRHQWdZMkZzYkdKaFkyc2daWEp5YjNJQVlHOXVYMk5vZFc1clgyaGxZV1JsY21BZ1kyRnNiR0poWTJzZ1pYSnliM0lBWUc5dVgyMWxjM05oWjJWZlltVm5hVzVnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5amFIVnVhMTlsZUhSbGJuTnBiMjVmZG1Gc2RXVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDl6ZEdGMGRYTmZZMjl0Y0d4bGRHVmdJR05oYkd4aVlXTnJJR1Z5Y205eUFHQnZibDkyWlhKemFXOXVYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmZFhKc1gyTnZiWEJzWlhSbFlDQmpZV3hzWW1GamF5Qmxjbkp2Y2dCZ2IyNWZZMmgxYm10ZlkyOXRjR3hsZEdWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUdCdmJsOW9aV0ZrWlhKZmRtRnNkV1ZmWTI5dGNHeGxkR1ZnSUdOaGJHeGlZV05ySUdWeWNtOXlBR0J2Ymw5dFpYTnpZV2RsWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmJXVjBhRzlrWDJOdmJYQnNaWFJsWUNCallXeHNZbUZqYXlCbGNuSnZjZ0JnYjI1ZmFHVmhaR1Z5WDJacFpXeGtYMk52YlhCc1pYUmxZQ0JqWVd4c1ltRmpheUJsY25KdmNnQmdiMjVmWTJoMWJtdGZaWGgwWlc1emFXOXVYMjVoYldWZ0lHTmhiR3hpWVdOcklHVnljbTl5QUZWdVpYaHdaV04wWldRZ1kyaGhjaUJwYmlCMWNtd2djMlZ5ZG1WeUFFbHVkbUZzYVdRZ2FHVmhaR1Z5SUhaaGJIVmxJR05vWVhJQVNXNTJZV3hwWkNCb1pXRmtaWElnWm1sbGJHUWdZMmhoY2dCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDNabGNuTnBiMjRBU1c1MllXeHBaQ0J0YVc1dmNpQjJaWEp6YVc5dUFFbHVkbUZzYVdRZ2JXRnFiM0lnZG1WeWMybHZiZ0JGZUhCbFkzUmxaQ0J6Y0dGalpTQmhablJsY2lCMlpYSnphVzl1QUVWNGNHVmpkR1ZrSUVOU1RFWWdZV1owWlhJZ2RtVnljMmx2YmdCSmJuWmhiR2xrSUVoVVZGQWdkbVZ5YzJsdmJnQkpiblpoYkdsa0lHaGxZV1JsY2lCMGIydGxiZ0JUY0dGdUlHTmhiR3hpWVdOcklHVnljbTl5SUdsdUlHOXVYM1Z5YkFCSmJuWmhiR2xrSUdOb1lYSmhZM1JsY25NZ2FXNGdkWEpzQUZWdVpYaHdaV04wWldRZ2MzUmhjblFnWTJoaGNpQnBiaUIxY213QVJHOTFZbXhsSUVBZ2FXNGdkWEpzQUVWdGNIUjVJRU52Ym5SbGJuUXRUR1Z1WjNSb0FFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJRU52Ym5SbGJuUXRUR1Z1WjNSb0FFUjFjR3hwWTJGMFpTQkRiMjUwWlc1MExVeGxibWQwYUFCSmJuWmhiR2xrSUdOb1lYSWdhVzRnZFhKc0lIQmhkR2dBUTI5dWRHVnVkQzFNWlc1bmRHZ2dZMkZ1SjNRZ1ltVWdjSEpsYzJWdWRDQjNhWFJvSUZSeVlXNXpabVZ5TFVWdVkyOWthVzVuQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUhOcGVtVUFVM0JoYmlCallXeHNZbUZqYXlCbGNuSnZjaUJwYmlCdmJsOW9aV0ZrWlhKZmRtRnNkV1VBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlqYUhWdWExOWxlSFJsYm5OcGIyNWZkbUZzZFdVQVNXNTJZV3hwWkNCamFHRnlZV04wWlhJZ2FXNGdZMmgxYm1zZ1pYaDBaVzV6YVc5dWN5QjJZV3gxWlFCTmFYTnphVzVuSUdWNGNHVmpkR1ZrSUV4R0lHRm1kR1Z5SUdobFlXUmxjaUIyWVd4MVpRQkpiblpoYkdsa0lHQlVjbUZ1YzJabGNpMUZibU52WkdsdVoyQWdhR1ZoWkdWeUlIWmhiSFZsQUVsdWRtRnNhV1FnWTJoaGNtRmpkR1Z5SUdsdUlHTm9kVzVySUdWNGRHVnVjMmx2Ym5NZ2NYVnZkR1VnZG1Gc2RXVUFTVzUyWVd4cFpDQmphR0Z5WVdOMFpYSWdhVzRnWTJoMWJtc2daWGgwWlc1emFXOXVjeUJ4ZFc5MFpXUWdkbUZzZFdVQVVHRjFjMlZrSUdKNUlHOXVYMmhsWVdSbGNuTmZZMjl0Y0d4bGRHVUFTVzUyWVd4cFpDQkZUMFlnYzNSaGRHVUFiMjVmY21WelpYUWdjR0YxYzJVQWIyNWZZMmgxYm10ZmFHVmhaR1Z5SUhCaGRYTmxBRzl1WDIxbGMzTmhaMlZmWW1WbmFXNGdjR0YxYzJVQWIyNWZZMmgxYm10ZlpYaDBaVzV6YVc5dVgzWmhiSFZsSUhCaGRYTmxBRzl1WDNOMFlYUjFjMTlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDkyWlhKemFXOXVYMk52YlhCc1pYUmxJSEJoZFhObEFHOXVYM1Z5YkY5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5amFIVnVhMTlqYjIxd2JHVjBaU0J3WVhWelpRQnZibDlvWldGa1pYSmZkbUZzZFdWZlkyOXRjR3hsZEdVZ2NHRjFjMlVBYjI1ZmJXVnpjMkZuWlY5amIyMXdiR1YwWlNCd1lYVnpaUUJ2Ymw5dFpYUm9iMlJmWTI5dGNHeGxkR1VnY0dGMWMyVUFiMjVmYUdWaFpHVnlYMlpwWld4a1gyTnZiWEJzWlhSbElIQmhkWE5sQUc5dVgyTm9kVzVyWDJWNGRHVnVjMmx2Ymw5dVlXMWxJSEJoZFhObEFGVnVaWGh3WldOMFpXUWdjM0JoWTJVZ1lXWjBaWElnYzNSaGNuUWdiR2x1WlFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDJOb2RXNXJYMlY0ZEdWdWMybHZibDl1WVcxbEFFbHVkbUZzYVdRZ1kyaGhjbUZqZEdWeUlHbHVJR05vZFc1cklHVjRkR1Z1YzJsdmJuTWdibUZ0WlFCUVlYVnpaU0J2YmlCRFQwNU9SVU5VTDFWd1ozSmhaR1VBVUdGMWMyVWdiMjRnVUZKSkwxVndaM0poWkdVQVJYaHdaV04wWldRZ1NGUlVVQzh5SUVOdmJtNWxZM1JwYjI0Z1VISmxabUZqWlFCVGNHRnVJR05oYkd4aVlXTnJJR1Z5Y205eUlHbHVJRzl1WDIxbGRHaHZaQUJGZUhCbFkzUmxaQ0J6Y0dGalpTQmhablJsY2lCdFpYUm9iMlFBVTNCaGJpQmpZV3hzWW1GamF5Qmxjbkp2Y2lCcGJpQnZibDlvWldGa1pYSmZabWxsYkdRQVVHRjFjMlZrQUVsdWRtRnNhV1FnZDI5eVpDQmxibU52ZFc1MFpYSmxaQUJKYm5aaGJHbGtJRzFsZEdodlpDQmxibU52ZFc1MFpYSmxaQUJWYm1WNGNHVmpkR1ZrSUdOb1lYSWdhVzRnZFhKc0lITmphR1Z0WVFCU1pYRjFaWE4wSUdoaGN5QnBiblpoYkdsa0lHQlVjbUZ1YzJabGNpMUZibU52WkdsdVoyQUFVMWRKVkVOSVgxQlNUMWhaQUZWVFJWOVFVazlZV1FCTlMwRkRWRWxXU1ZSWkFGVk9VRkpQUTBWVFUwRkNURVZmUlU1VVNWUlpBRU5QVUZrQVRVOVdSVVJmVUVWU1RVRk9SVTVVVEZrQVZFOVBYMFZCVWt4WkFFNVBWRWxHV1FCR1FVbE1SVVJmUkVWUVJVNUVSVTVEV1FCQ1FVUmZSMEZVUlZkQldRQlFURUZaQUZCVlZBQkRTRVZEUzA5VlZBQkhRVlJGVjBGWlgxUkpUVVZQVlZRQVVrVlJWVVZUVkY5VVNVMUZUMVZVQUU1RlZGZFBVa3RmUTA5T1RrVkRWRjlVU1UxRlQxVlVBRU5QVGs1RlExUkpUMDVmVkVsTlJVOVZWQUJNVDBkSlRsOVVTVTFGVDFWVUFFNUZWRmRQVWt0ZlVrVkJSRjlVU1UxRlQxVlVBRkJQVTFRQVRVbFRSRWxTUlVOVVJVUmZVa1ZSVlVWVFZBQkRURWxGVGxSZlEweFBVMFZFWDFKRlVWVkZVMVFBUTB4SlJVNVVYME5NVDFORlJGOU1UMEZFWDBKQlRFRk9RMFZFWDFKRlVWVkZVMVFBUWtGRVgxSkZVVlZGVTFRQVNGUlVVRjlTUlZGVlJWTlVYMU5GVGxSZlZFOWZTRlJVVUZOZlVFOVNWQUJTUlZCUFVsUUFTVTFmUVY5VVJVRlFUMVFBVWtWVFJWUmZRMDlPVkVWT1ZBQk9UMTlEVDA1VVJVNVVBRkJCVWxSSlFVeGZRMDlPVkVWT1ZBQklVRVZmU1U1V1FVeEpSRjlEVDA1VFZFRk9WQUJJVUVWZlEwSmZVa1ZUUlZRQVIwVlVBRWhRUlY5VFZGSkpRMVFBUTA5T1JreEpRMVFBVkVWTlVFOVNRVkpaWDFKRlJFbFNSVU5VQUZCRlVrMUJUa1ZPVkY5U1JVUkpVa1ZEVkFCRFQwNU9SVU5VQUUxVlRGUkpYMU5VUVZSVlV3QklVRVZmU1U1V1FVeEpSRjlUVkVGVVZWTUFWRTlQWDAxQlRsbGZVa1ZSVlVWVFZGTUFSVUZTVEZsZlNFbE9WRk1BVlU1QlZrRkpURUZDVEVWZlJrOVNYMHhGUjBGTVgxSkZRVk5QVGxNQVQxQlVTVTlPVXdCVFYwbFVRMGhKVGtkZlVGSlBWRTlEVDB4VEFGWkJVa2xCVGxSZlFVeFRUMTlPUlVkUFZFbEJWRVZUQUUxVlRGUkpVRXhGWDBOSVQwbERSVk1BU1U1VVJWSk9RVXhmVTBWU1ZrVlNYMFZTVWs5U0FGZEZRbDlUUlZKV1JWSmZWVTVMVGs5WFRsOUZVbEpQVWdCU1FVbE1SMVZPWDBWU1VrOVNBRWxFUlU1VVNWUlpYMUJTVDFaSlJFVlNYMEZWVkVoRlRsUkpRMEZVU1U5T1gwVlNVazlTQUZOVFRGOURSVkpVU1VaSlEwRlVSVjlGVWxKUFVnQkpUbFpCVEVsRVgxaGZSazlTVjBGU1JFVkVYMFpQVWdCVFJWUmZVRUZTUVUxRlZFVlNBRWRGVkY5UVFWSkJUVVZVUlZJQVNGQkZYMVZUUlZJQVUwVkZYMDlVU0VWU0FFaFFSVjlEUWw5RFNGVk9TMTlJUlVGRVJWSUFUVXREUVV4RlRrUkJVZ0JUUlZSVlVBQlhSVUpmVTBWU1ZrVlNYMGxUWDBSUFYwNEFWRVZCVWtSUFYwNEFTRkJGWDBOTVQxTkZSRjlEVDA1T1JVTlVTVTlPQUVoRlZWSkpVMVJKUTE5RldGQkpVa0ZVU1U5T0FFUkpVME5QVGs1RlExUkZSRjlQVUVWU1FWUkpUMDRBVGs5T1gwRlZWRWhQVWtsVVFWUkpWa1ZmU1U1R1QxSk5RVlJKVDA0QVNGQkZYMGxPVmtGTVNVUmZWa1ZTVTBsUFRnQklVRVZmUTBKZlRVVlRVMEZIUlY5Q1JVZEpUZ0JUU1ZSRlgwbFRYMFpTVDFwRlRnQklVRVZmU1U1V1FVeEpSRjlJUlVGRVJWSmZWRTlMUlU0QVNVNVdRVXhKUkY5VVQwdEZUZ0JHVDFKQ1NVUkVSVTRBUlU1SVFVNURSVjlaVDFWU1gwTkJURTBBU0ZCRlgwbE9Wa0ZNU1VSZlZWSk1BRUpNVDBOTFJVUmZRbGxmVUVGU1JVNVVRVXhmUTA5T1ZGSlBUQUJOUzBOUFRBQkJRMHdBU0ZCRlgwbE9WRVZTVGtGTUFGSkZVVlZGVTFSZlNFVkJSRVZTWDBaSlJVeEVVMTlVVDA5ZlRFRlNSMFZmVlU1UFJrWkpRMGxCVEFCSVVFVmZUMHNBVlU1TVNVNUxBRlZPVEU5RFN3QlFVa2tBVWtWVVVsbGZWMGxVU0FCSVVFVmZTVTVXUVV4SlJGOURUMDVVUlU1VVgweEZUa2RVU0FCSVVFVmZWVTVGV0ZCRlExUkZSRjlEVDA1VVJVNVVYMHhGVGtkVVNBQkdURlZUU0FCUVVrOVFVRUZVUTBnQVRTMVRSVUZTUTBnQVZWSkpYMVJQVDE5TVQwNUhBRkJTVDBORlUxTkpUa2NBVFVsVFEwVk1URUZPUlU5VlUxOVFSVkpUU1ZOVVJVNVVYMWRCVWs1SlRrY0FUVWxUUTBWTVRFRk9SVTlWVTE5WFFWSk9TVTVIQUVoUVJWOUpUbFpCVEVsRVgxUlNRVTVUUmtWU1gwVk9RMDlFU1U1SEFFVjRjR1ZqZEdWa0lFTlNURVlBU0ZCRlgwbE9Wa0ZNU1VSZlEwaFZUa3RmVTBsYVJRQk5UMVpGQUVOUFRsUkpUbFZGQUVoUVJWOURRbDlUVkVGVVZWTmZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwaEZRVVJGVWxOZlEwOU5VRXhGVkVVQVNGQkZYME5DWDFaRlVsTkpUMDVmUTA5TlVFeEZWRVVBU0ZCRlgwTkNYMVZTVEY5RFQwMVFURVZVUlFCSVVFVmZRMEpmUTBoVlRrdGZRMDlOVUV4RlZFVUFTRkJGWDBOQ1gwaEZRVVJGVWw5V1FVeFZSVjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZRMGhWVGt0ZlJWaFVSVTVUU1U5T1gxWkJURlZGWDBOUFRWQk1SVlJGQUVoUVJWOURRbDlEU0ZWT1MxOUZXRlJGVGxOSlQwNWZUa0ZOUlY5RFQwMVFURVZVUlFCSVVFVmZRMEpmVFVWVFUwRkhSVjlEVDAxUVRFVlVSUUJJVUVWZlEwSmZUVVZVU0U5RVgwTlBUVkJNUlZSRkFFaFFSVjlEUWw5SVJVRkVSVkpmUmtsRlRFUmZRMDlOVUV4RlZFVUFSRVZNUlZSRkFFaFFSVjlKVGxaQlRFbEVYMFZQUmw5VFZFRlVSUUJKVGxaQlRFbEVYMU5UVEY5RFJWSlVTVVpKUTBGVVJRQlFRVlZUUlFCT1QxOVNSVk5RVDA1VFJRQlZUbE5WVUZCUFVsUkZSRjlOUlVSSlFWOVVXVkJGQUVkUFRrVUFUazlVWDBGRFEwVlFWRUZDVEVVQVUwVlNWa2xEUlY5VlRrRldRVWxNUVVKTVJRQlNRVTVIUlY5T1QxUmZVMEZVU1ZOR1NVRkNURVVBVDFKSlIwbE9YMGxUWDFWT1VrVkJRMGhCUWt4RkFGSkZVMUJQVGxORlgwbFRYMU5VUVV4RkFGQlZVa2RGQUUxRlVrZEZBRkpGVVZWRlUxUmZTRVZCUkVWU1gwWkpSVXhFVTE5VVQwOWZURUZTUjBVQVVrVlJWVVZUVkY5SVJVRkVSVkpmVkU5UFgweEJVa2RGQUZCQldVeFBRVVJmVkU5UFgweEJVa2RGQUVsT1UxVkdSa2xEU1VWT1ZGOVRWRTlTUVVkRkFFaFFSVjlRUVZWVFJVUmZWVkJIVWtGRVJRQklVRVZmVUVGVlUwVkVYMGd5WDFWUVIxSkJSRVVBVTA5VlVrTkZBRUZPVGs5VlRrTkZBRlJTUVVORkFFaFFSVjlWVGtWWVVFVkRWRVZFWDFOUVFVTkZBRVJGVTBOU1NVSkZBRlZPVTFWQ1UwTlNTVUpGQUZKRlEwOVNSQUJJVUVWZlNVNVdRVXhKUkY5TlJWUklUMFFBVGs5VVgwWlBWVTVFQUZCU1QxQkdTVTVFQUZWT1FrbE9SQUJTUlVKSlRrUUFWVTVCVlZSSVQxSkpXa1ZFQUUxRlZFaFBSRjlPVDFSZlFVeE1UMWRGUkFCSVZGUlFYMVpGVWxOSlQwNWZUazlVWDFOVlVGQlBVbFJGUkFCQlRGSkZRVVJaWDFKRlVFOVNWRVZFQUVGRFEwVlFWRVZFQUU1UFZGOUpUVkJNUlUxRlRsUkZSQUJNVDA5UVgwUkZWRVZEVkVWRUFFaFFSVjlEVWw5RldGQkZRMVJGUkFCSVVFVmZURVpmUlZoUVJVTlVSVVFBUTFKRlFWUkZSQUJKVFY5VlUwVkVBRWhRUlY5UVFWVlRSVVFBVkVsTlJVOVZWRjlQUTBOVlVrVkVBRkJCV1UxRlRsUmZVa1ZSVlVsU1JVUUFVRkpGUTA5T1JFbFVTVTlPWDFKRlVWVkpVa1ZFQUZCU1QxaFpYMEZWVkVoRlRsUkpRMEZVU1U5T1gxSkZVVlZKVWtWRUFFNUZWRmRQVWt0ZlFWVlVTRVZPVkVsRFFWUkpUMDVmVWtWUlZVbFNSVVFBVEVWT1IxUklYMUpGVVZWSlVrVkVBRk5UVEY5RFJWSlVTVVpKUTBGVVJWOVNSVkZWU1ZKRlJBQlZVRWRTUVVSRlgxSkZVVlZKVWtWRUFGQkJSMFZmUlZoUVNWSkZSQUJRVWtWRFQwNUVTVlJKVDA1ZlJrRkpURVZFQUVWWVVFVkRWRUZVU1U5T1gwWkJTVXhGUkFCU1JWWkJURWxFUVZSSlQwNWZSa0ZKVEVWRUFGTlRURjlJUVU1RVUwaEJTMFZmUmtGSlRFVkVBRXhQUTB0RlJBQlVVa0ZPVTBaUFVrMUJWRWxQVGw5QlVGQk1TVVZFQUU1UFZGOU5UMFJKUmtsRlJBQk9UMVJmUlZoVVJVNUVSVVFBUWtGT1JGZEpSRlJJWDB4SlRVbFVYMFZZUTBWRlJFVkVBRk5KVkVWZlNWTmZUMVpGVWt4UFFVUkZSQUJJUlVGRUFFVjRjR1ZqZEdWa0lFaFVWRkF2QUFCZUV3QUFKaE1BQURBUUFBRHdGd0FBblJNQUFCVVNBQUE1RndBQThCSUFBQW9RQUFCMUVnQUFyUklBQUlJVEFBQlBGQUFBZnhBQUFLQVZBQUFqRkFBQWlSSUFBSXNVQUFCTkZRQUExQkVBQU04VUFBQVFHQUFBeVJZQUFOd1dBQURCRVFBQTRCY0FBTHNVQUFCMEZBQUFmQlVBQU9VVUFBQUlGd0FBSHhBQUFHVVZBQUNqRkFBQUtCVUFBQUlWQUFDWkZRQUFMQkFBQUlzWkFBQlBEd0FBMUE0QUFHb1FBQURPRUFBQUFoY0FBSWtPQUFCdUV3QUFIQk1BQUdZVUFBQldGd0FBd1JNQUFNMFRBQUJzRXdBQWFCY0FBR1lYQUFCZkZ3QUFJaE1BQU00UEFBQnBEZ0FBMkE0QUFHTVdBQURMRXdBQXFnNEFBQ2dYQUFBbUZ3QUF4Uk1BQUYwV0FBRG9FUUFBWnhNQUFHVVRBQUR5RmdBQWN4TUFBQjBYQUFENUZnQUE4eEVBQU04T0FBRE9GUUFBREJJQUFMTVJBQUNsRVFBQVlSQUFBRElYQUFDN0V3QkIrVFVMQVFFQVFaQTJDK0FCQVFFQ0FRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBUWYwM0N3RUJBRUdST0F0ZUFnTUNBZ0lDQWdBQUFnSUFBZ0lBQWdJQ0FnSUNBZ0lDQWdBRUFBQUFBQUFDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0FBQUFJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FBSUFBZ0JCL1RrTEFRRUFRWkU2QzE0Q0FBSUNBZ0lDQUFBQ0FnQUNBZ0FDQWdJQ0FnSUNBZ0lDQUFNQUJBQUFBQUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBQUFBQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQUFnQUNBRUh3T3dzTmJHOXpaV1ZsY0MxaGJHbDJaUUJCaVR3TEFRRUFRYUE4QytBQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQVFZaytDd0VCQUVHZ1Bndm5BUUVCQVFFQkFRRUJBUUVCQVFJQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJZMmgxYm10bFpBQkJzTUFBQzE4QkFRQUJBUUVCQVFBQUFRRUFBUUVBQVFFQkFRRUJBUUVCQVFBQUFBQUFBQUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFBQUFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFBRUFBUUJCa01JQUN5RmxZM1JwYjI1bGJuUXRiR1Z1WjNSb2IyNXliM2g1TFdOdmJtNWxZM1JwYjI0QVFjRENBQXN0Y21GdWMyWmxjaTFsYm1OdlpHbHVaM0JuY21Ga1pRMEtEUW9OQ2xOTkRRb05DbFJVVUM5RFJTOVVVMUF2QUVINXdnQUxCUUVDQUFFREFFR1F3d0FMNEFFRUFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFCQitjUUFDd1VCQWdBQkF3QkJrTVVBQytBQkJBRUJCUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVBQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQVFmbkdBQXNFQVFBQUFRQkJrY2NBQzk4QkFRRUFBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBQUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUFCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFCQitzZ0FDd1FCQUFBQ0FFR1F5UUFMWHdNRUFBQUVCQVFFQkFRRUJBUUVCQVVFQkFRRUJBUUVCQVFFQkFRQUJBQUdCd1FFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQUFFQUFRQUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRRUJBUUVCQVFFQkFRQUFBQUVBRUg2eWdBTEJBRUFBQUVBUVpETEFBc0JBUUJCcXNzQUMwRUNBQUFBQUFBQUF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNQUFBQUFBQUFEQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd0JCK3N3QUN3UUJBQUFCQUVHUXpRQUxBUUVBUVpyTkFBc0dBZ0FBQUFBQ0FFR3h6UUFMT2dNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQUFBQUFBQUFBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TUFRZkRPQUF1V0FVNVBWVTVEUlVWRFMwOVZWRTVGUTFSRlZFVkRVa2xDUlV4VlUwaEZWRVZCUkZORlFWSkRTRkpIUlVOVVNWWkpWRmxNUlU1RVFWSldSVTlVU1VaWlVGUkpUMDVUUTBoVFJVRlpVMVJCVkVOSVIwVlBVa1JKVWtWRFZFOVNWRkpEU0ZCQlVrRk5SVlJGVWxWU1EwVkNVME5TU1VKRlFWSkVUMWRPUVVORlNVNUVUa3REUzFWQ1UwTlNTVUpGU0ZSVVVDOUJSRlJRTHc9PScsICdiYXNlNjQnKVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/llhttp_simd-wasm.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/llhttp/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/undici/lib/llhttp/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enumToMap = void 0;\nfunction enumToMap(obj) {\n    const res = {};\n    Object.keys(obj).forEach((key) => {\n        const value = obj[key];\n        if (typeof value === 'number') {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexports.enumToMap = enumToMap;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9sbGh0dHAvdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbGxodHRwXFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZW51bVRvTWFwID0gdm9pZCAwO1xuZnVuY3Rpb24gZW51bVRvTWFwKG9iaikge1xuICAgIGNvbnN0IHJlcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuZW51bVRvTWFwID0gZW51bVRvTWFwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/llhttp/utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-agent.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kClients } = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst Agent = __webpack_require__(/*! ../dispatcher/agent */ \"(rsc)/./node_modules/undici/lib/dispatcher/agent.js\")\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst MockClient = __webpack_require__(/*! ./mock-client */ \"(rsc)/./node_modules/undici/lib/mock/mock-client.js\")\nconst MockPool = __webpack_require__(/*! ./mock-pool */ \"(rsc)/./node_modules/undici/lib/mock/mock-pool.js\")\nconst { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst Dispatcher = __webpack_require__(/*! ../dispatcher/dispatcher */ \"(rsc)/./node_modules/undici/lib/dispatcher/dispatcher.js\")\nconst Pluralizer = __webpack_require__(/*! ./pluralizer */ \"(rsc)/./node_modules/undici/lib/mock/pluralizer.js\")\nconst PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ \"(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\")\n\nclass MockAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n\n    // Instantiate Agent and encapsulate\n    if ((opts?.agent && typeof opts.agent.dispatch !== 'function')) {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts?.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = buildMockOptions(opts)\n  }\n\n  get (origin) {\n    let dispatcher = this[kMockAgentGet](origin)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin)\n      this[kMockAgentSet](origin, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n    return this[kAgent].dispatch(opts, handler)\n  }\n\n  async close () {\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  // This is required to bypass issues caused by using global symbols - see:\n  // https://github.com/nodejs/undici/issues/1447\n  get isMockActive () {\n    return this[kIsMockActive]\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, dispatcher)\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const client = this[kClients].get(origin)\n    if (client) {\n      return client\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, nonExplicitDispatcher] of Array.from(this[kClients])) {\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n\n  pendingInterceptors () {\n    const mockAgentClients = this[kClients]\n\n    return Array.from(mockAgentClients.entries())\n      .flatMap(([origin, scope]) => scope[kDispatches].map(dispatch => ({ ...dispatch, origin })))\n      .filter(({ pending }) => pending)\n  }\n\n  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {\n    const pending = this.pendingInterceptors()\n\n    if (pending.length === 0) {\n      return\n    }\n\n    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length)\n\n    throw new UndiciError(`\n${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:\n\n${pendingInterceptorsFormatter.format(pending)}\n`.trim())\n  }\n}\n\nmodule.exports = MockAgent\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDOUMsY0FBYyxtQkFBTyxDQUFDLGdGQUFxQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixtQkFBbUIsbUJBQU8sQ0FBQywwRUFBZTtBQUMxQyxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBYTtBQUN0QyxRQUFRLCtCQUErQixFQUFFLG1CQUFPLENBQUMsd0VBQWM7QUFDL0QsUUFBUSxvQ0FBb0MsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjtBQUN0RSxtQkFBbUIsbUJBQU8sQ0FBQywwRkFBMEI7QUFDckQsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWM7QUFDekMscUNBQXFDLG1CQUFPLENBQUMsZ0hBQWtDOztBQUUvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLHFCQUFxQjtBQUMvRixpQkFBaUIsU0FBUztBQUMxQjs7QUFFQSxpQ0FBaUMsb0VBQW9FLElBQUk7QUFDekc7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRSxrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxlQUFlOztBQUV4RCxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2stYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsga0NsaWVudHMgfSA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCBBZ2VudCA9IHJlcXVpcmUoJy4uL2Rpc3BhdGNoZXIvYWdlbnQnKVxuY29uc3Qge1xuICBrQWdlbnQsXG4gIGtNb2NrQWdlbnRTZXQsXG4gIGtNb2NrQWdlbnRHZXQsXG4gIGtEaXNwYXRjaGVzLFxuICBrSXNNb2NrQWN0aXZlLFxuICBrTmV0Q29ubmVjdCxcbiAga0dldE5ldENvbm5lY3QsXG4gIGtPcHRpb25zLFxuICBrRmFjdG9yeVxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IE1vY2tDbGllbnQgPSByZXF1aXJlKCcuL21vY2stY2xpZW50JylcbmNvbnN0IE1vY2tQb29sID0gcmVxdWlyZSgnLi9tb2NrLXBvb2wnKVxuY29uc3QgeyBtYXRjaFZhbHVlLCBidWlsZE1vY2tPcHRpb25zIH0gPSByZXF1aXJlKCcuL21vY2stdXRpbHMnKVxuY29uc3QgeyBJbnZhbGlkQXJndW1lbnRFcnJvciwgVW5kaWNpRXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IERpc3BhdGNoZXIgPSByZXF1aXJlKCcuLi9kaXNwYXRjaGVyL2Rpc3BhdGNoZXInKVxuY29uc3QgUGx1cmFsaXplciA9IHJlcXVpcmUoJy4vcGx1cmFsaXplcicpXG5jb25zdCBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyID0gcmVxdWlyZSgnLi9wZW5kaW5nLWludGVyY2VwdG9ycy1mb3JtYXR0ZXInKVxuXG5jbGFzcyBNb2NrQWdlbnQgZXh0ZW5kcyBEaXNwYXRjaGVyIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzKVxuXG4gICAgdGhpc1trTmV0Q29ubmVjdF0gPSB0cnVlXG4gICAgdGhpc1trSXNNb2NrQWN0aXZlXSA9IHRydWVcblxuICAgIC8vIEluc3RhbnRpYXRlIEFnZW50IGFuZCBlbmNhcHN1bGF0ZVxuICAgIGlmICgob3B0cz8uYWdlbnQgJiYgdHlwZW9mIG9wdHMuYWdlbnQuZGlzcGF0Y2ggIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cbiAgICBjb25zdCBhZ2VudCA9IG9wdHM/LmFnZW50ID8gb3B0cy5hZ2VudCA6IG5ldyBBZ2VudChvcHRzKVxuICAgIHRoaXNba0FnZW50XSA9IGFnZW50XG5cbiAgICB0aGlzW2tDbGllbnRzXSA9IGFnZW50W2tDbGllbnRzXVxuICAgIHRoaXNba09wdGlvbnNdID0gYnVpbGRNb2NrT3B0aW9ucyhvcHRzKVxuICB9XG5cbiAgZ2V0IChvcmlnaW4pIHtcbiAgICBsZXQgZGlzcGF0Y2hlciA9IHRoaXNba01vY2tBZ2VudEdldF0ob3JpZ2luKVxuXG4gICAgaWYgKCFkaXNwYXRjaGVyKSB7XG4gICAgICBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3JpZ2luKVxuICAgICAgdGhpc1trTW9ja0FnZW50U2V0XShvcmlnaW4sIGRpc3BhdGNoZXIpXG4gICAgfVxuICAgIHJldHVybiBkaXNwYXRjaGVyXG4gIH1cblxuICBkaXNwYXRjaCAob3B0cywgaGFuZGxlcikge1xuICAgIC8vIENhbGwgTW9ja0FnZW50LmdldCB0byBwZXJmb3JtIGFkZGl0aW9uYWwgc2V0dXAgYmVmb3JlIGRpc3BhdGNoaW5nIGFzIG5vcm1hbFxuICAgIHRoaXMuZ2V0KG9wdHMub3JpZ2luKVxuICAgIHJldHVybiB0aGlzW2tBZ2VudF0uZGlzcGF0Y2gob3B0cywgaGFuZGxlcilcbiAgfVxuXG4gIGFzeW5jIGNsb3NlICgpIHtcbiAgICBhd2FpdCB0aGlzW2tBZ2VudF0uY2xvc2UoKVxuICAgIHRoaXNba0NsaWVudHNdLmNsZWFyKClcbiAgfVxuXG4gIGRlYWN0aXZhdGUgKCkge1xuICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSBmYWxzZVxuICB9XG5cbiAgYWN0aXZhdGUgKCkge1xuICAgIHRoaXNba0lzTW9ja0FjdGl2ZV0gPSB0cnVlXG4gIH1cblxuICBlbmFibGVOZXRDb25uZWN0IChtYXRjaGVyKSB7XG4gICAgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWF0Y2hlciA9PT0gJ2Z1bmN0aW9uJyB8fCBtYXRjaGVyIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzW2tOZXRDb25uZWN0XSkpIHtcbiAgICAgICAgdGhpc1trTmV0Q29ubmVjdF0ucHVzaChtYXRjaGVyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1trTmV0Q29ubmVjdF0gPSBbbWF0Y2hlcl1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXRjaGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1trTmV0Q29ubmVjdF0gPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignVW5zdXBwb3J0ZWQgbWF0Y2hlci4gTXVzdCBiZSBvbmUgb2YgU3RyaW5nfEZ1bmN0aW9ufFJlZ0V4cC4nKVxuICAgIH1cbiAgfVxuXG4gIGRpc2FibGVOZXRDb25uZWN0ICgpIHtcbiAgICB0aGlzW2tOZXRDb25uZWN0XSA9IGZhbHNlXG4gIH1cblxuICAvLyBUaGlzIGlzIHJlcXVpcmVkIHRvIGJ5cGFzcyBpc3N1ZXMgY2F1c2VkIGJ5IHVzaW5nIGdsb2JhbCBzeW1ib2xzIC0gc2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTQ0N1xuICBnZXQgaXNNb2NrQWN0aXZlICgpIHtcbiAgICByZXR1cm4gdGhpc1trSXNNb2NrQWN0aXZlXVxuICB9XG5cbiAgW2tNb2NrQWdlbnRTZXRdIChvcmlnaW4sIGRpc3BhdGNoZXIpIHtcbiAgICB0aGlzW2tDbGllbnRzXS5zZXQob3JpZ2luLCBkaXNwYXRjaGVyKVxuICB9XG5cbiAgW2tGYWN0b3J5XSAob3JpZ2luKSB7XG4gICAgY29uc3QgbW9ja09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgYWdlbnQ6IHRoaXMgfSwgdGhpc1trT3B0aW9uc10pXG4gICAgcmV0dXJuIHRoaXNba09wdGlvbnNdICYmIHRoaXNba09wdGlvbnNdLmNvbm5lY3Rpb25zID09PSAxXG4gICAgICA/IG5ldyBNb2NrQ2xpZW50KG9yaWdpbiwgbW9ja09wdGlvbnMpXG4gICAgICA6IG5ldyBNb2NrUG9vbChvcmlnaW4sIG1vY2tPcHRpb25zKVxuICB9XG5cbiAgW2tNb2NrQWdlbnRHZXRdIChvcmlnaW4pIHtcbiAgICAvLyBGaXJzdCBjaGVjayBpZiB3ZSBjYW4gaW1tZWRpYXRlbHkgZmluZCBpdFxuICAgIGNvbnN0IGNsaWVudCA9IHRoaXNba0NsaWVudHNdLmdldChvcmlnaW4pXG4gICAgaWYgKGNsaWVudCkge1xuICAgICAgcmV0dXJuIGNsaWVudFxuICAgIH1cblxuICAgIC8vIElmIHRoZSBvcmlnaW4gaXMgbm90IGEgc3RyaW5nIGNyZWF0ZSBhIGR1bW15IHBhcmVudCBwb29sIGFuZCByZXR1cm4gdG8gdXNlclxuICAgIGlmICh0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZGlzcGF0Y2hlciA9IHRoaXNba0ZhY3RvcnldKCdodHRwOi8vbG9jYWxob3N0Ojk5OTknKVxuICAgICAgdGhpc1trTW9ja0FnZW50U2V0XShvcmlnaW4sIGRpc3BhdGNoZXIpXG4gICAgICByZXR1cm4gZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIC8vIElmIHdlIG1hdGNoLCBjcmVhdGUgYSBwb29sIGFuZCBhc3NpZ24gdGhlIHNhbWUgZGlzcGF0Y2hlc1xuICAgIGZvciAoY29uc3QgW2tleU1hdGNoZXIsIG5vbkV4cGxpY2l0RGlzcGF0Y2hlcl0gb2YgQXJyYXkuZnJvbSh0aGlzW2tDbGllbnRzXSkpIHtcbiAgICAgIGlmIChub25FeHBsaWNpdERpc3BhdGNoZXIgJiYgdHlwZW9mIGtleU1hdGNoZXIgIT09ICdzdHJpbmcnICYmIG1hdGNoVmFsdWUoa2V5TWF0Y2hlciwgb3JpZ2luKSkge1xuICAgICAgICBjb25zdCBkaXNwYXRjaGVyID0gdGhpc1trRmFjdG9yeV0ob3JpZ2luKVxuICAgICAgICB0aGlzW2tNb2NrQWdlbnRTZXRdKG9yaWdpbiwgZGlzcGF0Y2hlcilcbiAgICAgICAgZGlzcGF0Y2hlcltrRGlzcGF0Y2hlc10gPSBub25FeHBsaWNpdERpc3BhdGNoZXJba0Rpc3BhdGNoZXNdXG4gICAgICAgIHJldHVybiBkaXNwYXRjaGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgW2tHZXROZXRDb25uZWN0XSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba05ldENvbm5lY3RdXG4gIH1cblxuICBwZW5kaW5nSW50ZXJjZXB0b3JzICgpIHtcbiAgICBjb25zdCBtb2NrQWdlbnRDbGllbnRzID0gdGhpc1trQ2xpZW50c11cblxuICAgIHJldHVybiBBcnJheS5mcm9tKG1vY2tBZ2VudENsaWVudHMuZW50cmllcygpKVxuICAgICAgLmZsYXRNYXAoKFtvcmlnaW4sIHNjb3BlXSkgPT4gc2NvcGVba0Rpc3BhdGNoZXNdLm1hcChkaXNwYXRjaCA9PiAoeyAuLi5kaXNwYXRjaCwgb3JpZ2luIH0pKSlcbiAgICAgIC5maWx0ZXIoKHsgcGVuZGluZyB9KSA9PiBwZW5kaW5nKVxuICB9XG5cbiAgYXNzZXJ0Tm9QZW5kaW5nSW50ZXJjZXB0b3JzICh7IHBlbmRpbmdJbnRlcmNlcHRvcnNGb3JtYXR0ZXIgPSBuZXcgUGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlcigpIH0gPSB7fSkge1xuICAgIGNvbnN0IHBlbmRpbmcgPSB0aGlzLnBlbmRpbmdJbnRlcmNlcHRvcnMoKVxuXG4gICAgaWYgKHBlbmRpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwbHVyYWxpemVyID0gbmV3IFBsdXJhbGl6ZXIoJ2ludGVyY2VwdG9yJywgJ2ludGVyY2VwdG9ycycpLnBsdXJhbGl6ZShwZW5kaW5nLmxlbmd0aClcblxuICAgIHRocm93IG5ldyBVbmRpY2lFcnJvcihgXG4ke3BsdXJhbGl6ZXIuY291bnR9ICR7cGx1cmFsaXplci5ub3VufSAke3BsdXJhbGl6ZXIuaXN9IHBlbmRpbmc6XG5cbiR7cGVuZGluZ0ludGVyY2VwdG9yc0Zvcm1hdHRlci5mb3JtYXQocGVuZGluZyl9XG5gLnRyaW0oKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1vY2tBZ2VudFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-client.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-client.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\")\nconst Client = __webpack_require__(/*! ../dispatcher/client */ \"(rsc)/./node_modules/undici/lib/dispatcher/client.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */\nclass MockClient extends Client {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockClient\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDekMsZUFBZSxtQkFBTyxDQUFDLGtGQUFzQjtBQUM3QyxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsd0VBQWM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixRQUFRLGtCQUFrQixFQUFFLG1CQUFPLENBQUMsb0ZBQW9CO0FBQ3hELGdCQUFnQixtQkFBTyxDQUFDLHdFQUFpQjtBQUN6QyxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xcbW9jay1jbGllbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgcHJvbWlzaWZ5IH0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgQ2xpZW50ID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9jbGllbnQnKVxuY29uc3QgeyBidWlsZE1vY2tEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtNb2NrQWdlbnQsXG4gIGtDbG9zZSxcbiAga09yaWdpbmFsQ2xvc2UsXG4gIGtPcmlnaW4sXG4gIGtPcmlnaW5hbERpc3BhdGNoLFxuICBrQ29ubmVjdGVkXG59ID0gcmVxdWlyZSgnLi9tb2NrLXN5bWJvbHMnKVxuY29uc3QgeyBNb2NrSW50ZXJjZXB0b3IgfSA9IHJlcXVpcmUoJy4vbW9jay1pbnRlcmNlcHRvcicpXG5jb25zdCBTeW1ib2xzID0gcmVxdWlyZSgnLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcblxuLyoqXG4gKiBNb2NrQ2xpZW50IHByb3ZpZGVzIGFuIEFQSSB0aGF0IGV4dGVuZHMgdGhlIENsaWVudCB0byBpbmZsdWVuY2UgdGhlIG1vY2tEaXNwYXRjaGVzLlxuICovXG5jbGFzcyBNb2NrQ2xpZW50IGV4dGVuZHMgQ2xpZW50IHtcbiAgY29uc3RydWN0b3IgKG9yaWdpbiwgb3B0cykge1xuICAgIHN1cGVyKG9yaWdpbiwgb3B0cylcblxuICAgIGlmICghb3B0cyB8fCAhb3B0cy5hZ2VudCB8fCB0eXBlb2Ygb3B0cy5hZ2VudC5kaXNwYXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCdBcmd1bWVudCBvcHRzLmFnZW50IG11c3QgaW1wbGVtZW50IEFnZW50JylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrQWdlbnRdID0gb3B0cy5hZ2VudFxuICAgIHRoaXNba09yaWdpbl0gPSBvcmlnaW5cbiAgICB0aGlzW2tEaXNwYXRjaGVzXSA9IFtdXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDFcbiAgICB0aGlzW2tPcmlnaW5hbERpc3BhdGNoXSA9IHRoaXMuZGlzcGF0Y2hcbiAgICB0aGlzW2tPcmlnaW5hbENsb3NlXSA9IHRoaXMuY2xvc2UuYmluZCh0aGlzKVxuXG4gICAgdGhpcy5kaXNwYXRjaCA9IGJ1aWxkTW9ja0Rpc3BhdGNoLmNhbGwodGhpcylcbiAgICB0aGlzLmNsb3NlID0gdGhpc1trQ2xvc2VdXG4gIH1cblxuICBnZXQgW1N5bWJvbHMua0Nvbm5lY3RlZF0gKCkge1xuICAgIHJldHVybiB0aGlzW2tDb25uZWN0ZWRdXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB1cCB0aGUgYmFzZSBpbnRlcmNlcHRvciBmb3IgbW9ja2luZyByZXBsaWVzIGZyb20gdW5kaWNpLlxuICAgKi9cbiAgaW50ZXJjZXB0IChvcHRzKSB7XG4gICAgcmV0dXJuIG5ldyBNb2NrSW50ZXJjZXB0b3Iob3B0cywgdGhpc1trRGlzcGF0Y2hlc10pXG4gIH1cblxuICBhc3luYyBba0Nsb3NlXSAoKSB7XG4gICAgYXdhaXQgcHJvbWlzaWZ5KHRoaXNba09yaWdpbmFsQ2xvc2VdKSgpXG4gICAgdGhpc1trQ29ubmVjdGVkXSA9IDBcbiAgICB0aGlzW2tNb2NrQWdlbnRdW1N5bWJvbHMua0NsaWVudHNdLmRlbGV0ZSh0aGlzW2tPcmlnaW5dKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTW9ja0NsaWVudFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-errors.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-errors.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { UndiciError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\nclass MockNotMatchedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, MockNotMatchedError)\n    this.name = 'MockNotMatchedError'\n    this.message = message || 'The request does not match any registered mock dispatches'\n    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'\n  }\n}\n\nmodule.exports = {\n  MockNotMatchedError\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsc0VBQWdCOztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2stZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFVuZGljaUVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbmNsYXNzIE1vY2tOb3RNYXRjaGVkRXJyb3IgZXh0ZW5kcyBVbmRpY2lFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBNb2NrTm90TWF0Y2hlZEVycm9yKVxuICAgIHRoaXMubmFtZSA9ICdNb2NrTm90TWF0Y2hlZEVycm9yJ1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJ1RoZSByZXF1ZXN0IGRvZXMgbm90IG1hdGNoIGFueSByZWdpc3RlcmVkIG1vY2sgZGlzcGF0Y2hlcydcbiAgICB0aGlzLmNvZGUgPSAnVU5EX01PQ0tfRVJSX01PQ0tfTk9UX01BVENIRUQnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1vY2tOb3RNYXRjaGVkRXJyb3Jcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\n/**\n * Defines the scope API for an interceptor reply\n */\nclass MockScope {\n  constructor (mockDispatch) {\n    this[kMockDispatch] = mockDispatch\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay (waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].delay = waitInMs\n    return this\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist () {\n    this[kMockDispatch].persist = true\n    return this\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times (repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].times = repeatTimes\n    return this\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor (opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object')\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined')\n    }\n    if (typeof opts.method === 'undefined') {\n      opts.method = 'GET'\n    }\n    // See https://github.com/nodejs/undici/issues/1245\n    // As per RFC 3986, clients are not supposed to send URI\n    // fragments to servers when they retrieve a document,\n    if (typeof opts.path === 'string') {\n      if (opts.query) {\n        opts.path = buildURL(opts.path, opts.query)\n      } else {\n        // Matches https://github.com/nodejs/undici/blob/main/lib/web/fetch/index.js#L1811\n        const parsedURL = new URL(opts.path, 'data://')\n        opts.path = parsedURL.pathname + parsedURL.search\n      }\n    }\n    if (typeof opts.method === 'string') {\n      opts.method = opts.method.toUpperCase()\n    }\n\n    this[kDispatchKey] = buildKey(opts)\n    this[kDispatches] = mockDispatches\n    this[kDefaultHeaders] = {}\n    this[kDefaultTrailers] = {}\n    this[kContentLength] = false\n  }\n\n  createMockScopeDispatchData ({ statusCode, data, responseOptions }) {\n    const responseData = getResponseData(data)\n    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}\n    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }\n    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }\n\n    return { statusCode, data, headers, trailers }\n  }\n\n  validateReplyParameters (replyParameters) {\n    if (typeof replyParameters.statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined')\n    }\n    if (typeof replyParameters.responseOptions !== 'object' || replyParameters.responseOptions === null) {\n      throw new InvalidArgumentError('responseOptions must be an object')\n    }\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply (replyOptionsCallbackOrStatusCode) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyOptionsCallbackOrStatusCode === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = (opts) => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyOptionsCallbackOrStatusCode(opts)\n\n        // Check if it is in the right format\n        if (typeof resolvedData !== 'object' || resolvedData === null) {\n          throw new InvalidArgumentError('reply options callback must return an object')\n        }\n\n        const replyParameters = { data: '', responseOptions: {}, ...resolvedData }\n        this.validateReplyParameters(replyParameters)\n        // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n        return {\n          ...this.createMockScopeDispatchData(replyParameters)\n        }\n      }\n\n      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback)\n      return new MockScope(newMockDispatch)\n    }\n\n    // We can have either one or three parameters, if we get here,\n    // we should have 1-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode.\n    const replyParameters = {\n      statusCode: replyOptionsCallbackOrStatusCode,\n      data: arguments[1] === undefined ? '' : arguments[1],\n      responseOptions: arguments[2] === undefined ? {} : arguments[2]\n    }\n    this.validateReplyParameters(replyParameters)\n\n    // Send in-already provided data like usual\n    const dispatchData = this.createMockScopeDispatchData(replyParameters)\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData)\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError (error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined')\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders (headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined')\n    }\n\n    this[kDefaultHeaders] = headers\n    return this\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers (trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined')\n    }\n\n    this[kDefaultTrailers] = trailers\n    return this\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength () {\n    this[kContentLength] = true\n    return this\n  }\n}\n\nmodule.exports.MockInterceptor = MockInterceptor\nmodule.exports.MockScope = MockScope\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2staW50ZXJjZXB0b3IuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSw2Q0FBNkMsRUFBRSxtQkFBTyxDQUFDLHdFQUFjO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQWdCO0FBQzVCLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyxzRUFBZ0I7QUFDekQsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxrRUFBYzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG1DQUFtQztBQUNwRTtBQUNBLG1EQUFtRCx3Q0FBd0M7QUFDM0Ysc0JBQXNCO0FBQ3RCLHVCQUF1Qjs7QUFFdkIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLDZCQUE2QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUZBQXFGLE9BQU87QUFDNUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCLHdCQUF3QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxtb2NrLWludGVyY2VwdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGdldFJlc3BvbnNlRGF0YSwgYnVpbGRLZXksIGFkZE1vY2tEaXNwYXRjaCB9ID0gcmVxdWlyZSgnLi9tb2NrLXV0aWxzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtEaXNwYXRjaEtleSxcbiAga0RlZmF1bHRIZWFkZXJzLFxuICBrRGVmYXVsdFRyYWlsZXJzLFxuICBrQ29udGVudExlbmd0aCxcbiAga01vY2tEaXNwYXRjaFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSA9IHJlcXVpcmUoJy4uL2NvcmUvZXJyb3JzJylcbmNvbnN0IHsgYnVpbGRVUkwgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5cbi8qKlxuICogRGVmaW5lcyB0aGUgc2NvcGUgQVBJIGZvciBhbiBpbnRlcmNlcHRvciByZXBseVxuICovXG5jbGFzcyBNb2NrU2NvcGUge1xuICBjb25zdHJ1Y3RvciAobW9ja0Rpc3BhdGNoKSB7XG4gICAgdGhpc1trTW9ja0Rpc3BhdGNoXSA9IG1vY2tEaXNwYXRjaFxuICB9XG5cbiAgLyoqXG4gICAqIERlbGF5IGEgcmVwbHkgYnkgYSBzZXQgYW1vdW50IGluIG1zLlxuICAgKi9cbiAgZGVsYXkgKHdhaXRJbk1zKSB7XG4gICAgaWYgKHR5cGVvZiB3YWl0SW5NcyAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIod2FpdEluTXMpIHx8IHdhaXRJbk1zIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignd2FpdEluTXMgbXVzdCBiZSBhIHZhbGlkIGludGVnZXIgPiAwJylcbiAgICB9XG5cbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLmRlbGF5ID0gd2FpdEluTXNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhIGRlZmluZWQgcmVwbHksIG5ldmVyIG1hcmsgYXMgY29uc3VtZWQuXG4gICAqL1xuICBwZXJzaXN0ICgpIHtcbiAgICB0aGlzW2tNb2NrRGlzcGF0Y2hdLnBlcnNpc3QgPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvdyBvbmUgdG8gZGVmaW5lIGEgcmVwbHkgZm9yIGEgc2V0IGFtb3VudCBvZiBtYXRjaGluZyByZXF1ZXN0cy5cbiAgICovXG4gIHRpbWVzIChyZXBlYXRUaW1lcykge1xuICAgIGlmICh0eXBlb2YgcmVwZWF0VGltZXMgIT09ICdudW1iZXInIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHJlcGVhdFRpbWVzKSB8fCByZXBlYXRUaW1lcyA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3JlcGVhdFRpbWVzIG11c3QgYmUgYSB2YWxpZCBpbnRlZ2VyID4gMCcpXG4gICAgfVxuXG4gICAgdGhpc1trTW9ja0Rpc3BhdGNoXS50aW1lcyA9IHJlcGVhdFRpbWVzXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG4vKipcbiAqIERlZmluZXMgYW4gaW50ZXJjZXB0b3IgZm9yIGEgTW9ja1xuICovXG5jbGFzcyBNb2NrSW50ZXJjZXB0b3Ige1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9ja0Rpc3BhdGNoZXMpIHtcbiAgICBpZiAodHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ29wdHMgbXVzdCBiZSBhbiBvYmplY3QnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMucGF0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignb3B0cy5wYXRoIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRob2QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRzLm1ldGhvZCA9ICdHRVQnXG4gICAgfVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTI0NVxuICAgIC8vIEFzIHBlciBSRkMgMzk4NiwgY2xpZW50cyBhcmUgbm90IHN1cHBvc2VkIHRvIHNlbmQgVVJJXG4gICAgLy8gZnJhZ21lbnRzIHRvIHNlcnZlcnMgd2hlbiB0aGV5IHJldHJpZXZlIGEgZG9jdW1lbnQsXG4gICAgaWYgKHR5cGVvZiBvcHRzLnBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAob3B0cy5xdWVyeSkge1xuICAgICAgICBvcHRzLnBhdGggPSBidWlsZFVSTChvcHRzLnBhdGgsIG9wdHMucXVlcnkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNYXRjaGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2Jsb2IvbWFpbi9saWIvd2ViL2ZldGNoL2luZGV4LmpzI0wxODExXG4gICAgICAgIGNvbnN0IHBhcnNlZFVSTCA9IG5ldyBVUkwob3B0cy5wYXRoLCAnZGF0YTovLycpXG4gICAgICAgIG9wdHMucGF0aCA9IHBhcnNlZFVSTC5wYXRobmFtZSArIHBhcnNlZFVSTC5zZWFyY2hcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLm1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdHMubWV0aG9kID0gb3B0cy5tZXRob2QudG9VcHBlckNhc2UoKVxuICAgIH1cblxuICAgIHRoaXNba0Rpc3BhdGNoS2V5XSA9IGJ1aWxkS2V5KG9wdHMpXG4gICAgdGhpc1trRGlzcGF0Y2hlc10gPSBtb2NrRGlzcGF0Y2hlc1xuICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IHt9XG4gICAgdGhpc1trRGVmYXVsdFRyYWlsZXJzXSA9IHt9XG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSBmYWxzZVxuICB9XG5cbiAgY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhICh7IHN0YXR1c0NvZGUsIGRhdGEsIHJlc3BvbnNlT3B0aW9ucyB9KSB7XG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGRhdGEpXG4gICAgY29uc3QgY29udGVudExlbmd0aCA9IHRoaXNba0NvbnRlbnRMZW5ndGhdID8geyAnY29udGVudC1sZW5ndGgnOiByZXNwb25zZURhdGEubGVuZ3RoIH0gOiB7fVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IC4uLnRoaXNba0RlZmF1bHRIZWFkZXJzXSwgLi4uY29udGVudExlbmd0aCwgLi4ucmVzcG9uc2VPcHRpb25zLmhlYWRlcnMgfVxuICAgIGNvbnN0IHRyYWlsZXJzID0geyAuLi50aGlzW2tEZWZhdWx0VHJhaWxlcnNdLCAuLi5yZXNwb25zZU9wdGlvbnMudHJhaWxlcnMgfVxuXG4gICAgcmV0dXJuIHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMgfVxuICB9XG5cbiAgdmFsaWRhdGVSZXBseVBhcmFtZXRlcnMgKHJlcGx5UGFyYW1ldGVycykge1xuICAgIGlmICh0eXBlb2YgcmVwbHlQYXJhbWV0ZXJzLnN0YXR1c0NvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3N0YXR1c0NvZGUgbXVzdCBiZSBkZWZpbmVkJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXBseVBhcmFtZXRlcnMucmVzcG9uc2VPcHRpb25zICE9PSAnb2JqZWN0JyB8fCByZXBseVBhcmFtZXRlcnMucmVzcG9uc2VPcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ3Jlc3BvbnNlT3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vY2sgYW4gdW5kaWNpIHJlcXVlc3Qgd2l0aCBhIGRlZmluZWQgcmVwbHkuXG4gICAqL1xuICByZXBseSAocmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUpIHtcbiAgICAvLyBWYWx1ZXMgb2YgcmVwbHkgYXJlbid0IGF2YWlsYWJsZSByaWdodCBub3cgYXMgdGhleVxuICAgIC8vIGNhbiBvbmx5IGJlIGF2YWlsYWJsZSB3aGVuIHRoZSByZXBseSBjYWxsYmFjayBpcyBpbnZva2VkLlxuICAgIGlmICh0eXBlb2YgcmVwbHlPcHRpb25zQ2FsbGJhY2tPclN0YXR1c0NvZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFdlJ2xsIGZpcnN0IHdyYXAgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGluIGFub3RoZXIgZnVuY3Rpb24sXG4gICAgICAvLyB0aGlzIGZ1bmN0aW9uIHdpbGwgcHJvcGVybHkgcmVzb2x2ZSB0aGUgZGF0YSBmcm9tIHRoZSBjYWxsYmFja1xuICAgICAgLy8gd2hlbiBpbnZva2VkLlxuICAgICAgY29uc3Qgd3JhcHBlZERlZmF1bHRzQ2FsbGJhY2sgPSAob3B0cykgPT4ge1xuICAgICAgICAvLyBPdXIgcmVwbHkgb3B0aW9ucyBjYWxsYmFjayBjb250YWlucyB0aGUgcGFyYW1ldGVyIGZvciBzdGF0dXNDb2RlLCBkYXRhIGFuZCBvcHRpb25zLlxuICAgICAgICBjb25zdCByZXNvbHZlZERhdGEgPSByZXBseU9wdGlvbnNDYWxsYmFja09yU3RhdHVzQ29kZShvcHRzKVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGl0IGlzIGluIHRoZSByaWdodCBmb3JtYXRcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlZERhdGEgIT09ICdvYmplY3QnIHx8IHJlc29sdmVkRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcigncmVwbHkgb3B0aW9ucyBjYWxsYmFjayBtdXN0IHJldHVybiBhbiBvYmplY3QnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVwbHlQYXJhbWV0ZXJzID0geyBkYXRhOiAnJywgcmVzcG9uc2VPcHRpb25zOiB7fSwgLi4ucmVzb2x2ZWREYXRhIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlcGx5UGFyYW1ldGVycyhyZXBseVBhcmFtZXRlcnMpXG4gICAgICAgIC8vIFNpbmNlIHRoZSB2YWx1ZXMgY2FuIGJlIG9idGFpbmVkIGltbWVkaWF0ZWx5IHdlIHJldHVybiB0aGVtXG4gICAgICAgIC8vIGZyb20gdGhpcyBoaWdoZXIgb3JkZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHJlc29sdmVkIGxhdGVyLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRoaXMuY3JlYXRlTW9ja1Njb3BlRGlzcGF0Y2hEYXRhKHJlcGx5UGFyYW1ldGVycylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdXN1YWwgZGlzcGF0Y2ggZGF0YSwgYnV0IHRoaXMgdGltZSBzZXQgdGhlIGRhdGEgcGFyYW1ldGVyIHRvIGZ1bmN0aW9uIHRoYXQgd2lsbCBldmVudHVhbGx5IHByb3ZpZGUgZGF0YS5cbiAgICAgIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IGFkZE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwgdGhpc1trRGlzcGF0Y2hLZXldLCB3cmFwcGVkRGVmYXVsdHNDYWxsYmFjaylcbiAgICAgIHJldHVybiBuZXcgTW9ja1Njb3BlKG5ld01vY2tEaXNwYXRjaClcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4gaGF2ZSBlaXRoZXIgb25lIG9yIHRocmVlIHBhcmFtZXRlcnMsIGlmIHdlIGdldCBoZXJlLFxuICAgIC8vIHdlIHNob3VsZCBoYXZlIDEtMyBwYXJhbWV0ZXJzLiBTbyB3ZSBzcHJlYWQgdGhlIGFyZ3VtZW50cyBvZlxuICAgIC8vIHRoaXMgZnVuY3Rpb24gdG8gb2J0YWluIHRoZSBwYXJhbWV0ZXJzLCBzaW5jZSByZXBseURhdGEgd2lsbCBhbHdheXNcbiAgICAvLyBqdXN0IGJlIHRoZSBzdGF0dXNDb2RlLlxuICAgIGNvbnN0IHJlcGx5UGFyYW1ldGVycyA9IHtcbiAgICAgIHN0YXR1c0NvZGU6IHJlcGx5T3B0aW9uc0NhbGxiYWNrT3JTdGF0dXNDb2RlLFxuICAgICAgZGF0YTogYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyAnJyA6IGFyZ3VtZW50c1sxXSxcbiAgICAgIHJlc3BvbnNlT3B0aW9uczogYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1syXVxuICAgIH1cbiAgICB0aGlzLnZhbGlkYXRlUmVwbHlQYXJhbWV0ZXJzKHJlcGx5UGFyYW1ldGVycylcblxuICAgIC8vIFNlbmQgaW4tYWxyZWFkeSBwcm92aWRlZCBkYXRhIGxpa2UgdXN1YWxcbiAgICBjb25zdCBkaXNwYXRjaERhdGEgPSB0aGlzLmNyZWF0ZU1vY2tTY29wZURpc3BhdGNoRGF0YShyZXBseVBhcmFtZXRlcnMpXG4gICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIGRpc3BhdGNoRGF0YSlcbiAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpXG4gIH1cblxuICAvKipcbiAgICogTW9jayBhbiB1bmRpY2kgcmVxdWVzdCB3aXRoIGEgZGVmaW5lZCBlcnJvci5cbiAgICovXG4gIHJlcGx5V2l0aEVycm9yIChlcnJvcikge1xuICAgIGlmICh0eXBlb2YgZXJyb3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ2Vycm9yIG11c3QgYmUgZGVmaW5lZCcpXG4gICAgfVxuXG4gICAgY29uc3QgbmV3TW9ja0Rpc3BhdGNoID0gYWRkTW9ja0Rpc3BhdGNoKHRoaXNba0Rpc3BhdGNoZXNdLCB0aGlzW2tEaXNwYXRjaEtleV0sIHsgZXJyb3IgfSlcbiAgICByZXR1cm4gbmV3IE1vY2tTY29wZShuZXdNb2NrRGlzcGF0Y2gpXG4gIH1cblxuICAvKipcbiAgICogU2V0IGRlZmF1bHQgcmVwbHkgaGVhZGVycyBvbiB0aGUgaW50ZXJjZXB0b3IgZm9yIHN1YnNlcXVlbnQgcmVwbGllc1xuICAgKi9cbiAgZGVmYXVsdFJlcGx5SGVhZGVycyAoaGVhZGVycykge1xuICAgIGlmICh0eXBlb2YgaGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcignaGVhZGVycyBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIHRoaXNba0RlZmF1bHRIZWFkZXJzXSA9IGhlYWRlcnNcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IHJlcGx5IHRyYWlsZXJzIG9uIHRoZSBpbnRlcmNlcHRvciBmb3Igc3Vic2VxdWVudCByZXBsaWVzXG4gICAqL1xuICBkZWZhdWx0UmVwbHlUcmFpbGVycyAodHJhaWxlcnMpIHtcbiAgICBpZiAodHlwZW9mIHRyYWlsZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKCd0cmFpbGVycyBtdXN0IGJlIGRlZmluZWQnKVxuICAgIH1cblxuICAgIHRoaXNba0RlZmF1bHRUcmFpbGVyc10gPSB0cmFpbGVyc1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogU2V0IHJlcGx5IGNvbnRlbnQgbGVuZ3RoIGhlYWRlciBmb3IgcmVwbGllcyBvbiB0aGUgaW50ZXJjZXB0b3JcbiAgICovXG4gIHJlcGx5Q29udGVudExlbmd0aCAoKSB7XG4gICAgdGhpc1trQ29udGVudExlbmd0aF0gPSB0cnVlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5Nb2NrSW50ZXJjZXB0b3IgPSBNb2NrSW50ZXJjZXB0b3Jcbm1vZHVsZS5leHBvcnRzLk1vY2tTY29wZSA9IE1vY2tTY29wZVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-pool.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-pool.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { promisify } = __webpack_require__(/*! node:util */ \"node:util\")\nconst Pool = __webpack_require__(/*! ../dispatcher/pool */ \"(rsc)/./node_modules/undici/lib/dispatcher/pool.js\")\nconst { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ \"(rsc)/./node_modules/undici/lib/mock/mock-utils.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ \"(rsc)/./node_modules/undici/lib/mock/mock-interceptor.js\")\nconst Symbols = __webpack_require__(/*! ../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ \"(rsc)/./node_modules/undici/lib/core/errors.js\")\n\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\nclass MockPool extends Pool {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockPool\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stcG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQ3pDLGFBQWEsbUJBQU8sQ0FBQyw4RUFBb0I7QUFDekMsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLHdFQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0RUFBZ0I7QUFDNUIsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLG9GQUFvQjtBQUN4RCxnQkFBZ0IsbUJBQU8sQ0FBQyx3RUFBaUI7QUFDekMsUUFBUSx1QkFBdUIsRUFBRSxtQkFBTyxDQUFDLHNFQUFnQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXG1vY2tcXG1vY2stcG9vbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBwcm9taXNpZnkgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCBQb29sID0gcmVxdWlyZSgnLi4vZGlzcGF0Y2hlci9wb29sJylcbmNvbnN0IHsgYnVpbGRNb2NrRGlzcGF0Y2ggfSA9IHJlcXVpcmUoJy4vbW9jay11dGlscycpXG5jb25zdCB7XG4gIGtEaXNwYXRjaGVzLFxuICBrTW9ja0FnZW50LFxuICBrQ2xvc2UsXG4gIGtPcmlnaW5hbENsb3NlLFxuICBrT3JpZ2luLFxuICBrT3JpZ2luYWxEaXNwYXRjaCxcbiAga0Nvbm5lY3RlZFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgTW9ja0ludGVyY2VwdG9yIH0gPSByZXF1aXJlKCcuL21vY2staW50ZXJjZXB0b3InKVxuY29uc3QgU3ltYm9scyA9IHJlcXVpcmUoJy4uL2NvcmUvc3ltYm9scycpXG5jb25zdCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gPSByZXF1aXJlKCcuLi9jb3JlL2Vycm9ycycpXG5cbi8qKlxuICogTW9ja1Bvb2wgcHJvdmlkZXMgYW4gQVBJIHRoYXQgZXh0ZW5kcyB0aGUgUG9vbCB0byBpbmZsdWVuY2UgdGhlIG1vY2tEaXNwYXRjaGVzLlxuICovXG5jbGFzcyBNb2NrUG9vbCBleHRlbmRzIFBvb2wge1xuICBjb25zdHJ1Y3RvciAob3JpZ2luLCBvcHRzKSB7XG4gICAgc3VwZXIob3JpZ2luLCBvcHRzKVxuXG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLmFnZW50IHx8IHR5cGVvZiBvcHRzLmFnZW50LmRpc3BhdGNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3IoJ0FyZ3VtZW50IG9wdHMuYWdlbnQgbXVzdCBpbXBsZW1lbnQgQWdlbnQnKVxuICAgIH1cblxuICAgIHRoaXNba01vY2tBZ2VudF0gPSBvcHRzLmFnZW50XG4gICAgdGhpc1trT3JpZ2luXSA9IG9yaWdpblxuICAgIHRoaXNba0Rpc3BhdGNoZXNdID0gW11cbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMVxuICAgIHRoaXNba09yaWdpbmFsRGlzcGF0Y2hdID0gdGhpcy5kaXNwYXRjaFxuICAgIHRoaXNba09yaWdpbmFsQ2xvc2VdID0gdGhpcy5jbG9zZS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmRpc3BhdGNoID0gYnVpbGRNb2NrRGlzcGF0Y2guY2FsbCh0aGlzKVxuICAgIHRoaXMuY2xvc2UgPSB0aGlzW2tDbG9zZV1cbiAgfVxuXG4gIGdldCBbU3ltYm9scy5rQ29ubmVjdGVkXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNba0Nvbm5lY3RlZF1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoZSBiYXNlIGludGVyY2VwdG9yIGZvciBtb2NraW5nIHJlcGxpZXMgZnJvbSB1bmRpY2kuXG4gICAqL1xuICBpbnRlcmNlcHQgKG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IE1vY2tJbnRlcmNlcHRvcihvcHRzLCB0aGlzW2tEaXNwYXRjaGVzXSlcbiAgfVxuXG4gIGFzeW5jIFtrQ2xvc2VdICgpIHtcbiAgICBhd2FpdCBwcm9taXNpZnkodGhpc1trT3JpZ2luYWxDbG9zZV0pKClcbiAgICB0aGlzW2tDb25uZWN0ZWRdID0gMFxuICAgIHRoaXNba01vY2tBZ2VudF1bU3ltYm9scy5rQ2xpZW50c10uZGVsZXRlKHRoaXNba09yaWdpbl0pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNb2NrUG9vbFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-pool.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kAgent: Symbol('agent'),\n  kOptions: Symbol('options'),\n  kFactory: Symbol('factory'),\n  kDispatches: Symbol('dispatches'),\n  kDispatchKey: Symbol('dispatch key'),\n  kDefaultHeaders: Symbol('default headers'),\n  kDefaultTrailers: Symbol('default trailers'),\n  kContentLength: Symbol('content length'),\n  kMockAgent: Symbol('mock agent'),\n  kMockAgentSet: Symbol('mock agent set'),\n  kMockAgentGet: Symbol('mock agent get'),\n  kMockDispatch: Symbol('mock dispatch'),\n  kClose: Symbol('close'),\n  kOriginalClose: Symbol('original agent close'),\n  kOrigin: Symbol('origin'),\n  kIsMockActive: Symbol('is mock active'),\n  kNetConnect: Symbol('net connect'),\n  kGetNetConnect: Symbol('get net connect'),\n  kConnected: Symbol('connected')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xcbW9jay1zeW1ib2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga0FnZW50OiBTeW1ib2woJ2FnZW50JyksXG4gIGtPcHRpb25zOiBTeW1ib2woJ29wdGlvbnMnKSxcbiAga0ZhY3Rvcnk6IFN5bWJvbCgnZmFjdG9yeScpLFxuICBrRGlzcGF0Y2hlczogU3ltYm9sKCdkaXNwYXRjaGVzJyksXG4gIGtEaXNwYXRjaEtleTogU3ltYm9sKCdkaXNwYXRjaCBrZXknKSxcbiAga0RlZmF1bHRIZWFkZXJzOiBTeW1ib2woJ2RlZmF1bHQgaGVhZGVycycpLFxuICBrRGVmYXVsdFRyYWlsZXJzOiBTeW1ib2woJ2RlZmF1bHQgdHJhaWxlcnMnKSxcbiAga0NvbnRlbnRMZW5ndGg6IFN5bWJvbCgnY29udGVudCBsZW5ndGgnKSxcbiAga01vY2tBZ2VudDogU3ltYm9sKCdtb2NrIGFnZW50JyksXG4gIGtNb2NrQWdlbnRTZXQ6IFN5bWJvbCgnbW9jayBhZ2VudCBzZXQnKSxcbiAga01vY2tBZ2VudEdldDogU3ltYm9sKCdtb2NrIGFnZW50IGdldCcpLFxuICBrTW9ja0Rpc3BhdGNoOiBTeW1ib2woJ21vY2sgZGlzcGF0Y2gnKSxcbiAga0Nsb3NlOiBTeW1ib2woJ2Nsb3NlJyksXG4gIGtPcmlnaW5hbENsb3NlOiBTeW1ib2woJ29yaWdpbmFsIGFnZW50IGNsb3NlJyksXG4gIGtPcmlnaW46IFN5bWJvbCgnb3JpZ2luJyksXG4gIGtJc01vY2tBY3RpdmU6IFN5bWJvbCgnaXMgbW9jayBhY3RpdmUnKSxcbiAga05ldENvbm5lY3Q6IFN5bWJvbCgnbmV0IGNvbm5lY3QnKSxcbiAga0dldE5ldENvbm5lY3Q6IFN5bWJvbCgnZ2V0IG5ldCBjb25uZWN0JyksXG4gIGtDb25uZWN0ZWQ6IFN5bWJvbCgnY29ubmVjdGVkJylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/mock-utils.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/mock-utils.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ \"(rsc)/./node_modules/undici/lib/mock/mock-errors.js\")\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kGetNetConnect\n} = __webpack_require__(/*! ./mock-symbols */ \"(rsc)/./node_modules/undici/lib/mock/mock-symbols.js\")\nconst { buildURL } = __webpack_require__(/*! ../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\")\nconst {\n  types: {\n    isPromise\n  }\n} = __webpack_require__(/*! node:util */ \"node:util\")\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction lowerCaseEntries (headers) {\n  return Object.fromEntries(\n    Object.entries(headers).map(([headerName, headerValue]) => {\n      return [headerName.toLocaleLowerCase(), headerValue]\n    })\n  )\n}\n\n/**\n * @param {import('../../index').Headers|string[]|Record<string, string>} headers\n * @param {string} key\n */\nfunction getHeaderByName (headers, key) {\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {\n        return headers[i + 1]\n      }\n    }\n\n    return undefined\n  } else if (typeof headers.get === 'function') {\n    return headers.get(key)\n  } else {\n    return lowerCaseEntries(headers)[key.toLocaleLowerCase()]\n  }\n}\n\n/** @param {string[]} headers */\nfunction buildHeadersFromArray (headers) { // fetch HeadersList\n  const clone = headers.slice()\n  const entries = []\n  for (let index = 0; index < clone.length; index += 2) {\n    entries.push([clone[index], clone[index + 1]])\n  }\n  return Object.fromEntries(entries)\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'function') {\n    if (Array.isArray(headers)) { // fetch HeadersList\n      headers = buildHeadersFromArray(headers)\n    }\n    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})\n  }\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const headerValue = getHeaderByName(headers, matchHeaderName)\n\n    if (!matchValue(matchHeaderValue, headerValue)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction safeUrl (path) {\n  if (typeof path !== 'string') {\n    return path\n  }\n\n  const pathSegments = path.split('?')\n\n  if (pathSegments.length !== 2) {\n    return path\n  }\n\n  const qp = new URLSearchParams(pathSegments.pop())\n  qp.sort()\n  return [...pathSegments, qp.toString()].join('?')\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (data instanceof Uint8Array) {\n    return data\n  } else if (data instanceof ArrayBuffer) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else {\n    return data.toString()\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  const basePath = key.query ? buildURL(key.path, key.query) : key.path\n  const resolvedPath = typeof basePath === 'string' ? safeUrl(basePath) : basePath\n\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}' on path '${resolvedPath}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}' on path '${resolvedPath}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    const headers = typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${headers}' on path '${resolvedPath}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data) {\n  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data }\n  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers, query } = opts\n  return {\n    path,\n    method,\n    body,\n    headers,\n    query\n  }\n}\n\nfunction generateKeyValues (data) {\n  const keys = Object.keys(data)\n  const result = []\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i]\n    const value = data[key]\n    const name = Buffer.from(`${key}`)\n    if (Array.isArray(value)) {\n      for (let j = 0; j < value.length; ++j) {\n        result.push(name, Buffer.from(`${value[j]}`))\n      }\n    } else {\n      result.push(name, Buffer.from(`${value}`))\n    }\n  }\n  return result\n}\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status\n * @param {number} statusCode\n */\nfunction getStatusText (statusCode) {\n  return STATUS_CODES[statusCode] || 'unknown'\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  const mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  mockDispatch.timesInvoked++\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  const { timesInvoked, times } = mockDispatch\n\n  // If it's used up and not persistent, mark as consumed\n  mockDispatch.consumed = !persist && timesInvoked >= times\n  mockDispatch.pending = timesInvoked < times\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches, _data = data) {\n    // fetch's HeadersList is a 1D string array\n    const optsHeaders = Array.isArray(opts.headers)\n      ? buildHeadersFromArray(opts.headers)\n      : opts.headers\n    const body = typeof _data === 'function'\n      ? _data({ ...opts, headers: optsHeaders })\n      : _data\n\n    // util.types.isPromise is likely needed for jest.\n    if (isPromise(body)) {\n      // If handleReply is asynchronous, throwing an error\n      // in the callback will reject the promise, rather than\n      // synchronously throw the error, which breaks some tests.\n      // Rather, we wait for the callback to resolve if it is a\n      // promise, and then re-run handleReply with the new body.\n      body.then((newData) => handleReply(mockDispatches, newData))\n      return\n    }\n\n    const responseData = getResponseData(body)\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.onConnect?.(err => handler.onError(err), null)\n    handler.onHeaders?.(statusCode, responseHeaders, resume, getStatusText(statusCode))\n    handler.onData?.(Buffer.from(responseData))\n    handler.onComplete?.(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent.isMockActive) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  getStatusText,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions,\n  getHeaderByName,\n  buildHeadersFromArray\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL21vY2stdXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLDBFQUFlO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDRFQUFnQjtBQUM1QixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLGtFQUFjO0FBQzNDLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0QkFBVzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLCtEQUErRDtBQUMxRSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxVQUFVO0FBQ3RCLDJDQUEyQztBQUMzQztBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyw2QkFBNkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELFVBQVUsMEJBQTBCLE1BQU07QUFDakc7QUFDQSx5RUFBeUUsYUFBYTtBQUN0Rjs7QUFFQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0EsMkVBQTJFLFdBQVcsYUFBYSxhQUFhO0FBQ2hIOztBQUVBO0FBQ0EsMERBQTBELE1BQU07QUFDaEU7QUFDQSx5RUFBeUUsU0FBUyxhQUFhLGFBQWE7QUFDNUc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsUUFBUSxhQUFhLGFBQWE7QUFDOUc7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjtBQUNyQixtREFBbUQsaUJBQWlCLElBQUk7QUFDeEUsNEJBQTRCLDRDQUE0QztBQUN4RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxxQ0FBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQSxnQ0FBZ0MsSUFBSTtBQUNwQztBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEMseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQSxNQUFNO0FBQ04sdUNBQXVDLE1BQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0EsVUFBVSxRQUFRLDRDQUE0QyxtQkFBbUI7QUFDakYsVUFBVSxzQkFBc0I7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGNBQWMsaUNBQWlDLFFBQVE7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLDZDQUE2QyxjQUFjLGlDQUFpQyxRQUFRO0FBQ3BHO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xcbW9jay11dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBNb2NrTm90TWF0Y2hlZEVycm9yIH0gPSByZXF1aXJlKCcuL21vY2stZXJyb3JzJylcbmNvbnN0IHtcbiAga0Rpc3BhdGNoZXMsXG4gIGtNb2NrQWdlbnQsXG4gIGtPcmlnaW5hbERpc3BhdGNoLFxuICBrT3JpZ2luLFxuICBrR2V0TmV0Q29ubmVjdFxufSA9IHJlcXVpcmUoJy4vbW9jay1zeW1ib2xzJylcbmNvbnN0IHsgYnVpbGRVUkwgfSA9IHJlcXVpcmUoJy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IFNUQVRVU19DT0RFUyB9ID0gcmVxdWlyZSgnbm9kZTpodHRwJylcbmNvbnN0IHtcbiAgdHlwZXM6IHtcbiAgICBpc1Byb21pc2VcbiAgfVxufSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5cbmZ1bmN0aW9uIG1hdGNoVmFsdWUgKG1hdGNoLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIG1hdGNoID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtYXRjaCA9PT0gdmFsdWVcbiAgfVxuICBpZiAobWF0Y2ggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gbWF0Y2gudGVzdCh2YWx1ZSlcbiAgfVxuICBpZiAodHlwZW9mIG1hdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1hdGNoKHZhbHVlKSA9PT0gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBsb3dlckNhc2VFbnRyaWVzIChoZWFkZXJzKSB7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgT2JqZWN0LmVudHJpZXMoaGVhZGVycykubWFwKChbaGVhZGVyTmFtZSwgaGVhZGVyVmFsdWVdKSA9PiB7XG4gICAgICByZXR1cm4gW2hlYWRlck5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKSwgaGVhZGVyVmFsdWVdXG4gICAgfSlcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi9pbmRleCcpLkhlYWRlcnN8c3RyaW5nW118UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gaGVhZGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5mdW5jdGlvbiBnZXRIZWFkZXJCeU5hbWUgKGhlYWRlcnMsIGtleSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgaWYgKGhlYWRlcnNbaV0udG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0ga2V5LnRvTG9jYWxlTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnNbaSArIDFdXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9IGVsc2UgaWYgKHR5cGVvZiBoZWFkZXJzLmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBoZWFkZXJzLmdldChrZXkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycylba2V5LnRvTG9jYWxlTG93ZXJDYXNlKCldXG4gIH1cbn1cblxuLyoqIEBwYXJhbSB7c3RyaW5nW119IGhlYWRlcnMgKi9cbmZ1bmN0aW9uIGJ1aWxkSGVhZGVyc0Zyb21BcnJheSAoaGVhZGVycykgeyAvLyBmZXRjaCBIZWFkZXJzTGlzdFxuICBjb25zdCBjbG9uZSA9IGhlYWRlcnMuc2xpY2UoKVxuICBjb25zdCBlbnRyaWVzID0gW11cbiAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGNsb25lLmxlbmd0aDsgaW5kZXggKz0gMikge1xuICAgIGVudHJpZXMucHVzaChbY2xvbmVbaW5kZXhdLCBjbG9uZVtpbmRleCArIDFdXSlcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGVudHJpZXMpXG59XG5cbmZ1bmN0aW9uIG1hdGNoSGVhZGVycyAobW9ja0Rpc3BhdGNoLCBoZWFkZXJzKSB7XG4gIGlmICh0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkgeyAvLyBmZXRjaCBIZWFkZXJzTGlzdFxuICAgICAgaGVhZGVycyA9IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShoZWFkZXJzKVxuICAgIH1cbiAgICByZXR1cm4gbW9ja0Rpc3BhdGNoLmhlYWRlcnMoaGVhZGVycyA/IGxvd2VyQ2FzZUVudHJpZXMoaGVhZGVycykgOiB7fSlcbiAgfVxuICBpZiAodHlwZW9mIG1vY2tEaXNwYXRjaC5oZWFkZXJzID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgaWYgKHR5cGVvZiBoZWFkZXJzICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgbW9ja0Rpc3BhdGNoLmhlYWRlcnMgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGNvbnN0IFttYXRjaEhlYWRlck5hbWUsIG1hdGNoSGVhZGVyVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1vY2tEaXNwYXRjaC5oZWFkZXJzKSkge1xuICAgIGNvbnN0IGhlYWRlclZhbHVlID0gZ2V0SGVhZGVyQnlOYW1lKGhlYWRlcnMsIG1hdGNoSGVhZGVyTmFtZSlcblxuICAgIGlmICghbWF0Y2hWYWx1ZShtYXRjaEhlYWRlclZhbHVlLCBoZWFkZXJWYWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBzYWZlVXJsIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgcGF0aFNlZ21lbnRzID0gcGF0aC5zcGxpdCgnPycpXG5cbiAgaWYgKHBhdGhTZWdtZW50cy5sZW5ndGggIT09IDIpIHtcbiAgICByZXR1cm4gcGF0aFxuICB9XG5cbiAgY29uc3QgcXAgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhdGhTZWdtZW50cy5wb3AoKSlcbiAgcXAuc29ydCgpXG4gIHJldHVybiBbLi4ucGF0aFNlZ21lbnRzLCBxcC50b1N0cmluZygpXS5qb2luKCc/Jylcbn1cblxuZnVuY3Rpb24gbWF0Y2hLZXkgKG1vY2tEaXNwYXRjaCwgeyBwYXRoLCBtZXRob2QsIGJvZHksIGhlYWRlcnMgfSkge1xuICBjb25zdCBwYXRoTWF0Y2ggPSBtYXRjaFZhbHVlKG1vY2tEaXNwYXRjaC5wYXRoLCBwYXRoKVxuICBjb25zdCBtZXRob2RNYXRjaCA9IG1hdGNoVmFsdWUobW9ja0Rpc3BhdGNoLm1ldGhvZCwgbWV0aG9kKVxuICBjb25zdCBib2R5TWF0Y2ggPSB0eXBlb2YgbW9ja0Rpc3BhdGNoLmJvZHkgIT09ICd1bmRlZmluZWQnID8gbWF0Y2hWYWx1ZShtb2NrRGlzcGF0Y2guYm9keSwgYm9keSkgOiB0cnVlXG4gIGNvbnN0IGhlYWRlcnNNYXRjaCA9IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gsIGhlYWRlcnMpXG4gIHJldHVybiBwYXRoTWF0Y2ggJiYgbWV0aG9kTWF0Y2ggJiYgYm9keU1hdGNoICYmIGhlYWRlcnNNYXRjaFxufVxuXG5mdW5jdGlvbiBnZXRSZXNwb25zZURhdGEgKGRhdGEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgIHJldHVybiBkYXRhXG4gIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gZGF0YVxuICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBkYXRhXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1vY2tEaXNwYXRjaCAobW9ja0Rpc3BhdGNoZXMsIGtleSkge1xuICBjb25zdCBiYXNlUGF0aCA9IGtleS5xdWVyeSA/IGJ1aWxkVVJMKGtleS5wYXRoLCBrZXkucXVlcnkpIDoga2V5LnBhdGhcbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gdHlwZW9mIGJhc2VQYXRoID09PSAnc3RyaW5nJyA/IHNhZmVVcmwoYmFzZVBhdGgpIDogYmFzZVBhdGhcblxuICAvLyBNYXRjaCBwYXRoXG4gIGxldCBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgY29uc3VtZWQgfSkgPT4gIWNvbnN1bWVkKS5maWx0ZXIoKHsgcGF0aCB9KSA9PiBtYXRjaFZhbHVlKHNhZmVVcmwocGF0aCksIHJlc29sdmVkUGF0aCkpXG4gIGlmIChtYXRjaGVkTW9ja0Rpc3BhdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggbWV0aG9kXG4gIG1hdGNoZWRNb2NrRGlzcGF0Y2hlcyA9IG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5maWx0ZXIoKHsgbWV0aG9kIH0pID0+IG1hdGNoVmFsdWUobWV0aG9kLCBrZXkubWV0aG9kKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgbWV0aG9kICcke2tleS5tZXRob2R9JyBvbiBwYXRoICcke3Jlc29sdmVkUGF0aH0nYClcbiAgfVxuXG4gIC8vIE1hdGNoIGJvZHlcbiAgbWF0Y2hlZE1vY2tEaXNwYXRjaGVzID0gbWF0Y2hlZE1vY2tEaXNwYXRjaGVzLmZpbHRlcigoeyBib2R5IH0pID0+IHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJyA/IG1hdGNoVmFsdWUoYm9keSwga2V5LmJvZHkpIDogdHJ1ZSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgTW9ja05vdE1hdGNoZWRFcnJvcihgTW9jayBkaXNwYXRjaCBub3QgbWF0Y2hlZCBmb3IgYm9keSAnJHtrZXkuYm9keX0nIG9uIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgLy8gTWF0Y2ggaGVhZGVyc1xuICBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMgPSBtYXRjaGVkTW9ja0Rpc3BhdGNoZXMuZmlsdGVyKChtb2NrRGlzcGF0Y2gpID0+IG1hdGNoSGVhZGVycyhtb2NrRGlzcGF0Y2gsIGtleS5oZWFkZXJzKSlcbiAgaWYgKG1hdGNoZWRNb2NrRGlzcGF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdHlwZW9mIGtleS5oZWFkZXJzID09PSAnb2JqZWN0JyA/IEpTT04uc3RyaW5naWZ5KGtleS5oZWFkZXJzKSA6IGtleS5oZWFkZXJzXG4gICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYE1vY2sgZGlzcGF0Y2ggbm90IG1hdGNoZWQgZm9yIGhlYWRlcnMgJyR7aGVhZGVyc30nIG9uIHBhdGggJyR7cmVzb2x2ZWRQYXRofSdgKVxuICB9XG5cbiAgcmV0dXJuIG1hdGNoZWRNb2NrRGlzcGF0Y2hlc1swXVxufVxuXG5mdW5jdGlvbiBhZGRNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXksIGRhdGEpIHtcbiAgY29uc3QgYmFzZURhdGEgPSB7IHRpbWVzSW52b2tlZDogMCwgdGltZXM6IDEsIHBlcnNpc3Q6IGZhbHNlLCBjb25zdW1lZDogZmFsc2UgfVxuICBjb25zdCByZXBseURhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyA/IHsgY2FsbGJhY2s6IGRhdGEgfSA6IHsgLi4uZGF0YSB9XG4gIGNvbnN0IG5ld01vY2tEaXNwYXRjaCA9IHsgLi4uYmFzZURhdGEsIC4uLmtleSwgcGVuZGluZzogdHJ1ZSwgZGF0YTogeyBlcnJvcjogbnVsbCwgLi4ucmVwbHlEYXRhIH0gfVxuICBtb2NrRGlzcGF0Y2hlcy5wdXNoKG5ld01vY2tEaXNwYXRjaClcbiAgcmV0dXJuIG5ld01vY2tEaXNwYXRjaFxufVxuXG5mdW5jdGlvbiBkZWxldGVNb2NrRGlzcGF0Y2ggKG1vY2tEaXNwYXRjaGVzLCBrZXkpIHtcbiAgY29uc3QgaW5kZXggPSBtb2NrRGlzcGF0Y2hlcy5maW5kSW5kZXgoZGlzcGF0Y2ggPT4ge1xuICAgIGlmICghZGlzcGF0Y2guY29uc3VtZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hLZXkoZGlzcGF0Y2gsIGtleSlcbiAgfSlcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIG1vY2tEaXNwYXRjaGVzLnNwbGljZShpbmRleCwgMSlcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEtleSAob3B0cykge1xuICBjb25zdCB7IHBhdGgsIG1ldGhvZCwgYm9keSwgaGVhZGVycywgcXVlcnkgfSA9IG9wdHNcbiAgcmV0dXJuIHtcbiAgICBwYXRoLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIGhlYWRlcnMsXG4gICAgcXVlcnlcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUtleVZhbHVlcyAoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSlcbiAgY29uc3QgcmVzdWx0ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgIGNvbnN0IHZhbHVlID0gZGF0YVtrZXldXG4gICAgY29uc3QgbmFtZSA9IEJ1ZmZlci5mcm9tKGAke2tleX1gKVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7ICsraikge1xuICAgICAgICByZXN1bHQucHVzaChuYW1lLCBCdWZmZXIuZnJvbShgJHt2YWx1ZVtqXX1gKSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gobmFtZSwgQnVmZmVyLmZyb20oYCR7dmFsdWV9YCkpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhdHVzQ29kZVxuICovXG5mdW5jdGlvbiBnZXRTdGF0dXNUZXh0IChzdGF0dXNDb2RlKSB7XG4gIHJldHVybiBTVEFUVVNfQ09ERVNbc3RhdHVzQ29kZV0gfHwgJ3Vua25vd24nXG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFJlc3BvbnNlIChib2R5KSB7XG4gIGNvbnN0IGJ1ZmZlcnMgPSBbXVxuICBmb3IgYXdhaXQgKGNvbnN0IGRhdGEgb2YgYm9keSkge1xuICAgIGJ1ZmZlcnMucHVzaChkYXRhKVxuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpLnRvU3RyaW5nKCd1dGY4Jylcbn1cblxuLyoqXG4gKiBNb2NrIGRpc3BhdGNoIGZ1bmN0aW9uIHVzZWQgdG8gc2ltdWxhdGUgdW5kaWNpIGRpc3BhdGNoZXNcbiAqL1xuZnVuY3Rpb24gbW9ja0Rpc3BhdGNoIChvcHRzLCBoYW5kbGVyKSB7XG4gIC8vIEdldCBtb2NrIGRpc3BhdGNoIGZyb20gYnVpbHQga2V5XG4gIGNvbnN0IGtleSA9IGJ1aWxkS2V5KG9wdHMpXG4gIGNvbnN0IG1vY2tEaXNwYXRjaCA9IGdldE1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KVxuXG4gIG1vY2tEaXNwYXRjaC50aW1lc0ludm9rZWQrK1xuXG4gIC8vIEhlcmUncyB3aGVyZSB3ZSByZXNvbHZlIGEgY2FsbGJhY2sgaWYgYSBjYWxsYmFjayBpcyBwcmVzZW50IGZvciB0aGUgZGlzcGF0Y2ggZGF0YS5cbiAgaWYgKG1vY2tEaXNwYXRjaC5kYXRhLmNhbGxiYWNrKSB7XG4gICAgbW9ja0Rpc3BhdGNoLmRhdGEgPSB7IC4uLm1vY2tEaXNwYXRjaC5kYXRhLCAuLi5tb2NrRGlzcGF0Y2guZGF0YS5jYWxsYmFjayhvcHRzKSB9XG4gIH1cblxuICAvLyBQYXJzZSBtb2NrRGlzcGF0Y2ggZGF0YVxuICBjb25zdCB7IGRhdGE6IHsgc3RhdHVzQ29kZSwgZGF0YSwgaGVhZGVycywgdHJhaWxlcnMsIGVycm9yIH0sIGRlbGF5LCBwZXJzaXN0IH0gPSBtb2NrRGlzcGF0Y2hcbiAgY29uc3QgeyB0aW1lc0ludm9rZWQsIHRpbWVzIH0gPSBtb2NrRGlzcGF0Y2hcblxuICAvLyBJZiBpdCdzIHVzZWQgdXAgYW5kIG5vdCBwZXJzaXN0ZW50LCBtYXJrIGFzIGNvbnN1bWVkXG4gIG1vY2tEaXNwYXRjaC5jb25zdW1lZCA9ICFwZXJzaXN0ICYmIHRpbWVzSW52b2tlZCA+PSB0aW1lc1xuICBtb2NrRGlzcGF0Y2gucGVuZGluZyA9IHRpbWVzSW52b2tlZCA8IHRpbWVzXG5cbiAgLy8gSWYgc3BlY2lmaWVkLCB0cmlnZ2VyIGRpc3BhdGNoIGVycm9yXG4gIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaCh0aGlzW2tEaXNwYXRjaGVzXSwga2V5KVxuICAgIGhhbmRsZXIub25FcnJvcihlcnJvcilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSGFuZGxlIHRoZSByZXF1ZXN0IHdpdGggYSBkZWxheSBpZiBuZWNlc3NhcnlcbiAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSlcbiAgICB9LCBkZWxheSlcbiAgfSBlbHNlIHtcbiAgICBoYW5kbGVSZXBseSh0aGlzW2tEaXNwYXRjaGVzXSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZVJlcGx5IChtb2NrRGlzcGF0Y2hlcywgX2RhdGEgPSBkYXRhKSB7XG4gICAgLy8gZmV0Y2gncyBIZWFkZXJzTGlzdCBpcyBhIDFEIHN0cmluZyBhcnJheVxuICAgIGNvbnN0IG9wdHNIZWFkZXJzID0gQXJyYXkuaXNBcnJheShvcHRzLmhlYWRlcnMpXG4gICAgICA/IGJ1aWxkSGVhZGVyc0Zyb21BcnJheShvcHRzLmhlYWRlcnMpXG4gICAgICA6IG9wdHMuaGVhZGVyc1xuICAgIGNvbnN0IGJvZHkgPSB0eXBlb2YgX2RhdGEgPT09ICdmdW5jdGlvbidcbiAgICAgID8gX2RhdGEoeyAuLi5vcHRzLCBoZWFkZXJzOiBvcHRzSGVhZGVycyB9KVxuICAgICAgOiBfZGF0YVxuXG4gICAgLy8gdXRpbC50eXBlcy5pc1Byb21pc2UgaXMgbGlrZWx5IG5lZWRlZCBmb3IgamVzdC5cbiAgICBpZiAoaXNQcm9taXNlKGJvZHkpKSB7XG4gICAgICAvLyBJZiBoYW5kbGVSZXBseSBpcyBhc3luY2hyb25vdXMsIHRocm93aW5nIGFuIGVycm9yXG4gICAgICAvLyBpbiB0aGUgY2FsbGJhY2sgd2lsbCByZWplY3QgdGhlIHByb21pc2UsIHJhdGhlciB0aGFuXG4gICAgICAvLyBzeW5jaHJvbm91c2x5IHRocm93IHRoZSBlcnJvciwgd2hpY2ggYnJlYWtzIHNvbWUgdGVzdHMuXG4gICAgICAvLyBSYXRoZXIsIHdlIHdhaXQgZm9yIHRoZSBjYWxsYmFjayB0byByZXNvbHZlIGlmIGl0IGlzIGFcbiAgICAgIC8vIHByb21pc2UsIGFuZCB0aGVuIHJlLXJ1biBoYW5kbGVSZXBseSB3aXRoIHRoZSBuZXcgYm9keS5cbiAgICAgIGJvZHkudGhlbigobmV3RGF0YSkgPT4gaGFuZGxlUmVwbHkobW9ja0Rpc3BhdGNoZXMsIG5ld0RhdGEpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gZ2V0UmVzcG9uc2VEYXRhKGJvZHkpXG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXMoaGVhZGVycylcbiAgICBjb25zdCByZXNwb25zZVRyYWlsZXJzID0gZ2VuZXJhdGVLZXlWYWx1ZXModHJhaWxlcnMpXG5cbiAgICBoYW5kbGVyLm9uQ29ubmVjdD8uKGVyciA9PiBoYW5kbGVyLm9uRXJyb3IoZXJyKSwgbnVsbClcbiAgICBoYW5kbGVyLm9uSGVhZGVycz8uKHN0YXR1c0NvZGUsIHJlc3BvbnNlSGVhZGVycywgcmVzdW1lLCBnZXRTdGF0dXNUZXh0KHN0YXR1c0NvZGUpKVxuICAgIGhhbmRsZXIub25EYXRhPy4oQnVmZmVyLmZyb20ocmVzcG9uc2VEYXRhKSlcbiAgICBoYW5kbGVyLm9uQ29tcGxldGU/LihyZXNwb25zZVRyYWlsZXJzKVxuICAgIGRlbGV0ZU1vY2tEaXNwYXRjaChtb2NrRGlzcGF0Y2hlcywga2V5KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdW1lICgpIHt9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gYnVpbGRNb2NrRGlzcGF0Y2ggKCkge1xuICBjb25zdCBhZ2VudCA9IHRoaXNba01vY2tBZ2VudF1cbiAgY29uc3Qgb3JpZ2luID0gdGhpc1trT3JpZ2luXVxuICBjb25zdCBvcmlnaW5hbERpc3BhdGNoID0gdGhpc1trT3JpZ2luYWxEaXNwYXRjaF1cblxuICByZXR1cm4gZnVuY3Rpb24gZGlzcGF0Y2ggKG9wdHMsIGhhbmRsZXIpIHtcbiAgICBpZiAoYWdlbnQuaXNNb2NrQWN0aXZlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtb2NrRGlzcGF0Y2guY2FsbCh0aGlzLCBvcHRzLCBoYW5kbGVyKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgTW9ja05vdE1hdGNoZWRFcnJvcikge1xuICAgICAgICAgIGNvbnN0IG5ldENvbm5lY3QgPSBhZ2VudFtrR2V0TmV0Q29ubmVjdF0oKVxuICAgICAgICAgIGlmIChuZXRDb25uZWN0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgZGlzYWJsZWQpYClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoZWNrTmV0Q29ubmVjdChuZXRDb25uZWN0LCBvcmlnaW4pKSB7XG4gICAgICAgICAgICBvcmlnaW5hbERpc3BhdGNoLmNhbGwodGhpcywgb3B0cywgaGFuZGxlcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1vY2tOb3RNYXRjaGVkRXJyb3IoYCR7ZXJyb3IubWVzc2FnZX06IHN1YnNlcXVlbnQgcmVxdWVzdCB0byBvcmlnaW4gJHtvcmlnaW59IHdhcyBub3QgYWxsb3dlZCAobmV0LmNvbm5lY3QgaXMgbm90IGVuYWJsZWQgZm9yIHRoaXMgb3JpZ2luKWApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3JpZ2luYWxEaXNwYXRjaC5jYWxsKHRoaXMsIG9wdHMsIGhhbmRsZXIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTmV0Q29ubmVjdCAobmV0Q29ubmVjdCwgb3JpZ2luKSB7XG4gIGNvbnN0IHVybCA9IG5ldyBVUkwob3JpZ2luKVxuICBpZiAobmV0Q29ubmVjdCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXRDb25uZWN0KSAmJiBuZXRDb25uZWN0LnNvbWUoKG1hdGNoZXIpID0+IG1hdGNoVmFsdWUobWF0Y2hlciwgdXJsLmhvc3QpKSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGJ1aWxkTW9ja09wdGlvbnMgKG9wdHMpIHtcbiAgaWYgKG9wdHMpIHtcbiAgICBjb25zdCB7IGFnZW50LCAuLi5tb2NrT3B0aW9ucyB9ID0gb3B0c1xuICAgIHJldHVybiBtb2NrT3B0aW9uc1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRSZXNwb25zZURhdGEsXG4gIGdldE1vY2tEaXNwYXRjaCxcbiAgYWRkTW9ja0Rpc3BhdGNoLFxuICBkZWxldGVNb2NrRGlzcGF0Y2gsXG4gIGJ1aWxkS2V5LFxuICBnZW5lcmF0ZUtleVZhbHVlcyxcbiAgbWF0Y2hWYWx1ZSxcbiAgZ2V0UmVzcG9uc2UsXG4gIGdldFN0YXR1c1RleHQsXG4gIG1vY2tEaXNwYXRjaCxcbiAgYnVpbGRNb2NrRGlzcGF0Y2gsXG4gIGNoZWNrTmV0Q29ubmVjdCxcbiAgYnVpbGRNb2NrT3B0aW9ucyxcbiAgZ2V0SGVhZGVyQnlOYW1lLFxuICBidWlsZEhlYWRlcnNGcm9tQXJyYXlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/mock-utils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!************************************************************************!*\
  !*** ./node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { Console } = __webpack_require__(/*! node:console */ \"node:console\")\n\nconst PERSISTENT = process.versions.icu ? '✅' : 'Y '\nconst NOT_PERSISTENT = process.versions.icu ? '❌' : 'N '\n\n/**\n * Gets the output of `console.table(…)` as a string.\n */\nmodule.exports = class PendingInterceptorsFormatter {\n  constructor ({ disableColors } = {}) {\n    this.transform = new Transform({\n      transform (chunk, _enc, cb) {\n        cb(null, chunk)\n      }\n    })\n\n    this.logger = new Console({\n      stdout: this.transform,\n      inspectOptions: {\n        colors: !disableColors && !process.env.CI\n      }\n    })\n  }\n\n  format (pendingInterceptors) {\n    const withPrettyHeaders = pendingInterceptors.map(\n      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({\n        Method: method,\n        Origin: origin,\n        Path: path,\n        'Status code': statusCode,\n        Persistent: persist ? PERSISTENT : NOT_PERSISTENT,\n        Invocations: timesInvoked,\n        Remaining: persist ? Infinity : times - timesInvoked\n      }))\n\n    this.logger.table(withPrettyHeaders)\n    return this.transform.read().toString()\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BlbmRpbmctaW50ZXJjZXB0b3JzLWZvcm1hdHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzNDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsa0NBQWM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFNBQVMsc0JBQXNCLFlBQVksd0NBQXdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFxtb2NrXFxwZW5kaW5nLWludGVyY2VwdG9ycy1mb3JtYXR0ZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgVHJhbnNmb3JtIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IENvbnNvbGUgfSA9IHJlcXVpcmUoJ25vZGU6Y29uc29sZScpXG5cbmNvbnN0IFBFUlNJU1RFTlQgPSBwcm9jZXNzLnZlcnNpb25zLmljdSA/ICfinIUnIDogJ1kgJ1xuY29uc3QgTk9UX1BFUlNJU1RFTlQgPSBwcm9jZXNzLnZlcnNpb25zLmljdSA/ICfinYwnIDogJ04gJ1xuXG4vKipcbiAqIEdldHMgdGhlIG91dHB1dCBvZiBgY29uc29sZS50YWJsZSjigKYpYCBhcyBhIHN0cmluZy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBQZW5kaW5nSW50ZXJjZXB0b3JzRm9ybWF0dGVyIHtcbiAgY29uc3RydWN0b3IgKHsgZGlzYWJsZUNvbG9ycyB9ID0ge30pIHtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oe1xuICAgICAgdHJhbnNmb3JtIChjaHVuaywgX2VuYywgY2IpIHtcbiAgICAgICAgY2IobnVsbCwgY2h1bmspXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMubG9nZ2VyID0gbmV3IENvbnNvbGUoe1xuICAgICAgc3Rkb3V0OiB0aGlzLnRyYW5zZm9ybSxcbiAgICAgIGluc3BlY3RPcHRpb25zOiB7XG4gICAgICAgIGNvbG9yczogIWRpc2FibGVDb2xvcnMgJiYgIXByb2Nlc3MuZW52LkNJXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZvcm1hdCAocGVuZGluZ0ludGVyY2VwdG9ycykge1xuICAgIGNvbnN0IHdpdGhQcmV0dHlIZWFkZXJzID0gcGVuZGluZ0ludGVyY2VwdG9ycy5tYXAoXG4gICAgICAoeyBtZXRob2QsIHBhdGgsIGRhdGE6IHsgc3RhdHVzQ29kZSB9LCBwZXJzaXN0LCB0aW1lcywgdGltZXNJbnZva2VkLCBvcmlnaW4gfSkgPT4gKHtcbiAgICAgICAgTWV0aG9kOiBtZXRob2QsXG4gICAgICAgIE9yaWdpbjogb3JpZ2luLFxuICAgICAgICBQYXRoOiBwYXRoLFxuICAgICAgICAnU3RhdHVzIGNvZGUnOiBzdGF0dXNDb2RlLFxuICAgICAgICBQZXJzaXN0ZW50OiBwZXJzaXN0ID8gUEVSU0lTVEVOVCA6IE5PVF9QRVJTSVNURU5ULFxuICAgICAgICBJbnZvY2F0aW9uczogdGltZXNJbnZva2VkLFxuICAgICAgICBSZW1haW5pbmc6IHBlcnNpc3QgPyBJbmZpbml0eSA6IHRpbWVzIC0gdGltZXNJbnZva2VkXG4gICAgICB9KSlcblxuICAgIHRoaXMubG9nZ2VyLnRhYmxlKHdpdGhQcmV0dHlIZWFkZXJzKVxuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yZWFkKCkudG9TdHJpbmcoKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/pending-interceptors-formatter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/mock/pluralizer.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/mock/pluralizer.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst singulars = {\n  pronoun: 'it',\n  is: 'is',\n  was: 'was',\n  this: 'this'\n}\n\nconst plurals = {\n  pronoun: 'they',\n  is: 'are',\n  was: 'were',\n  this: 'these'\n}\n\nmodule.exports = class Pluralizer {\n  constructor (singular, plural) {\n    this.singular = singular\n    this.plural = plural\n  }\n\n  pluralize (count) {\n    const one = count === 1\n    const keys = one ? singulars : plurals\n    const noun = one ? this.singular : this.plural\n    return { ...keys, count, noun }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi9tb2NrL3BsdXJhbGl6ZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcbW9ja1xccGx1cmFsaXplci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3Qgc2luZ3VsYXJzID0ge1xuICBwcm9ub3VuOiAnaXQnLFxuICBpczogJ2lzJyxcbiAgd2FzOiAnd2FzJyxcbiAgdGhpczogJ3RoaXMnXG59XG5cbmNvbnN0IHBsdXJhbHMgPSB7XG4gIHByb25vdW46ICd0aGV5JyxcbiAgaXM6ICdhcmUnLFxuICB3YXM6ICd3ZXJlJyxcbiAgdGhpczogJ3RoZXNlJ1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFBsdXJhbGl6ZXIge1xuICBjb25zdHJ1Y3RvciAoc2luZ3VsYXIsIHBsdXJhbCkge1xuICAgIHRoaXMuc2luZ3VsYXIgPSBzaW5ndWxhclxuICAgIHRoaXMucGx1cmFsID0gcGx1cmFsXG4gIH1cblxuICBwbHVyYWxpemUgKGNvdW50KSB7XG4gICAgY29uc3Qgb25lID0gY291bnQgPT09IDFcbiAgICBjb25zdCBrZXlzID0gb25lID8gc2luZ3VsYXJzIDogcGx1cmFsc1xuICAgIGNvbnN0IG5vdW4gPSBvbmUgPyB0aGlzLnNpbmd1bGFyIDogdGhpcy5wbHVyYWxcbiAgICByZXR1cm4geyAuLi5rZXlzLCBjb3VudCwgbm91biB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/mock/pluralizer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/util/timers.js":
/*!************************************************!*\
  !*** ./node_modules/undici/lib/util/timers.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * This module offers an optimized timer implementation designed for scenarios\n * where high precision is not critical.\n *\n * The timer achieves faster performance by using a low-resolution approach,\n * with an accuracy target of within 500ms. This makes it particularly useful\n * for timers with delays of 1 second or more, where exact timing is less\n * crucial.\n *\n * It's important to note that Node.js timers are inherently imprecise, as\n * delays can occur due to the event loop being blocked by other operations.\n * Consequently, timers may trigger later than their scheduled time.\n */\n\n/**\n * The fastNow variable contains the internal fast timer clock value.\n *\n * @type {number}\n */\nlet fastNow = 0\n\n/**\n * RESOLUTION_MS represents the target resolution time in milliseconds.\n *\n * @type {number}\n * @default 1000\n */\nconst RESOLUTION_MS = 1e3\n\n/**\n * TICK_MS defines the desired interval in milliseconds between each tick.\n * The target value is set to half the resolution time, minus 1 ms, to account\n * for potential event loop overhead.\n *\n * @type {number}\n * @default 499\n */\nconst TICK_MS = (RESOLUTION_MS >> 1) - 1\n\n/**\n * fastNowTimeout is a Node.js timer used to manage and process\n * the FastTimers stored in the `fastTimers` array.\n *\n * @type {NodeJS.Timeout}\n */\nlet fastNowTimeout\n\n/**\n * The kFastTimer symbol is used to identify FastTimer instances.\n *\n * @type {Symbol}\n */\nconst kFastTimer = Symbol('kFastTimer')\n\n/**\n * The fastTimers array contains all active FastTimers.\n *\n * @type {FastTimer[]}\n */\nconst fastTimers = []\n\n/**\n * These constants represent the various states of a FastTimer.\n */\n\n/**\n * The `NOT_IN_LIST` constant indicates that the FastTimer is not included\n * in the `fastTimers` array. Timers with this status will not be processed\n * during the next tick by the `onTick` function.\n *\n * A FastTimer can be re-added to the `fastTimers` array by invoking the\n * `refresh` method on the FastTimer instance.\n *\n * @type {-2}\n */\nconst NOT_IN_LIST = -2\n\n/**\n * The `TO_BE_CLEARED` constant indicates that the FastTimer is scheduled\n * for removal from the `fastTimers` array. A FastTimer in this state will\n * be removed in the next tick by the `onTick` function and will no longer\n * be processed.\n *\n * This status is also set when the `clear` method is called on the FastTimer instance.\n *\n * @type {-1}\n */\nconst TO_BE_CLEARED = -1\n\n/**\n * The `PENDING` constant signifies that the FastTimer is awaiting processing\n * in the next tick by the `onTick` function. Timers with this status will have\n * their `_idleStart` value set and their status updated to `ACTIVE` in the next tick.\n *\n * @type {0}\n */\nconst PENDING = 0\n\n/**\n * The `ACTIVE` constant indicates that the FastTimer is active and waiting\n * for its timer to expire. During the next tick, the `onTick` function will\n * check if the timer has expired, and if so, it will execute the associated callback.\n *\n * @type {1}\n */\nconst ACTIVE = 1\n\n/**\n * The onTick function processes the fastTimers array.\n *\n * @returns {void}\n */\nfunction onTick () {\n  /**\n   * Increment the fastNow value by the TICK_MS value, despite the actual time\n   * that has passed since the last tick. This approach ensures independence\n   * from the system clock and delays caused by a blocked event loop.\n   *\n   * @type {number}\n   */\n  fastNow += TICK_MS\n\n  /**\n   * The `idx` variable is used to iterate over the `fastTimers` array.\n   * Expired timers are removed by replacing them with the last element in the array.\n   * Consequently, `idx` is only incremented when the current element is not removed.\n   *\n   * @type {number}\n   */\n  let idx = 0\n\n  /**\n   * The len variable will contain the length of the fastTimers array\n   * and will be decremented when a FastTimer should be removed from the\n   * fastTimers array.\n   *\n   * @type {number}\n   */\n  let len = fastTimers.length\n\n  while (idx < len) {\n    /**\n     * @type {FastTimer}\n     */\n    const timer = fastTimers[idx]\n\n    // If the timer is in the ACTIVE state and the timer has expired, it will\n    // be processed in the next tick.\n    if (timer._state === PENDING) {\n      // Set the _idleStart value to the fastNow value minus the TICK_MS value\n      // to account for the time the timer was in the PENDING state.\n      timer._idleStart = fastNow - TICK_MS\n      timer._state = ACTIVE\n    } else if (\n      timer._state === ACTIVE &&\n      fastNow >= timer._idleStart + timer._idleTimeout\n    ) {\n      timer._state = TO_BE_CLEARED\n      timer._idleStart = -1\n      timer._onTimeout(timer._timerArg)\n    }\n\n    if (timer._state === TO_BE_CLEARED) {\n      timer._state = NOT_IN_LIST\n\n      // Move the last element to the current index and decrement len if it is\n      // not the only element in the array.\n      if (--len !== 0) {\n        fastTimers[idx] = fastTimers[len]\n      }\n    } else {\n      ++idx\n    }\n  }\n\n  // Set the length of the fastTimers array to the new length and thus\n  // removing the excess FastTimers elements from the array.\n  fastTimers.length = len\n\n  // If there are still active FastTimers in the array, refresh the Timer.\n  // If there are no active FastTimers, the timer will be refreshed again\n  // when a new FastTimer is instantiated.\n  if (fastTimers.length !== 0) {\n    refreshTimeout()\n  }\n}\n\nfunction refreshTimeout () {\n  // If the fastNowTimeout is already set, refresh it.\n  if (fastNowTimeout) {\n    fastNowTimeout.refresh()\n  // fastNowTimeout is not instantiated yet, create a new Timer.\n  } else {\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = setTimeout(onTick, TICK_MS)\n\n    // If the Timer has an unref method, call it to allow the process to exit if\n    // there are no other active handles.\n    if (fastNowTimeout.unref) {\n      fastNowTimeout.unref()\n    }\n  }\n}\n\n/**\n * The `FastTimer` class is a data structure designed to store and manage\n * timer information.\n */\nclass FastTimer {\n  [kFastTimer] = true\n\n  /**\n   * The state of the timer, which can be one of the following:\n   * - NOT_IN_LIST (-2)\n   * - TO_BE_CLEARED (-1)\n   * - PENDING (0)\n   * - ACTIVE (1)\n   *\n   * @type {-2|-1|0|1}\n   * @private\n   */\n  _state = NOT_IN_LIST\n\n  /**\n   * The number of milliseconds to wait before calling the callback.\n   *\n   * @type {number}\n   * @private\n   */\n  _idleTimeout = -1\n\n  /**\n   * The time in milliseconds when the timer was started. This value is used to\n   * calculate when the timer should expire.\n   *\n   * @type {number}\n   * @default -1\n   * @private\n   */\n  _idleStart = -1\n\n  /**\n   * The function to be executed when the timer expires.\n   * @type {Function}\n   * @private\n   */\n  _onTimeout\n\n  /**\n   * The argument to be passed to the callback when the timer expires.\n   *\n   * @type {*}\n   * @private\n   */\n  _timerArg\n\n  /**\n   * @constructor\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should wait\n   * before the specified function or code is executed.\n   * @param {*} arg\n   */\n  constructor (callback, delay, arg) {\n    this._onTimeout = callback\n    this._idleTimeout = delay\n    this._timerArg = arg\n\n    this.refresh()\n  }\n\n  /**\n   * Sets the timer's start time to the current time, and reschedules the timer\n   * to call its callback at the previously specified duration adjusted to the\n   * current time.\n   * Using this on a timer that has already called its callback will reactivate\n   * the timer.\n   *\n   * @returns {void}\n   */\n  refresh () {\n    // In the special case that the timer is not in the list of active timers,\n    // add it back to the array to be processed in the next tick by the onTick\n    // function.\n    if (this._state === NOT_IN_LIST) {\n      fastTimers.push(this)\n    }\n\n    // If the timer is the only active timer, refresh the fastNowTimeout for\n    // better resolution.\n    if (!fastNowTimeout || fastTimers.length === 1) {\n      refreshTimeout()\n    }\n\n    // Setting the state to PENDING will cause the timer to be reset in the\n    // next tick by the onTick function.\n    this._state = PENDING\n  }\n\n  /**\n   * The `clear` method cancels the timer, preventing it from executing.\n   *\n   * @returns {void}\n   * @private\n   */\n  clear () {\n    // Set the state to TO_BE_CLEARED to mark the timer for removal in the next\n    // tick by the onTick function.\n    this._state = TO_BE_CLEARED\n\n    // Reset the _idleStart value to -1 to indicate that the timer is no longer\n    // active.\n    this._idleStart = -1\n  }\n}\n\n/**\n * This module exports a setTimeout and clearTimeout function that can be\n * used as a drop-in replacement for the native functions.\n */\nmodule.exports = {\n  /**\n   * The setTimeout() method sets a timer which executes a function once the\n   * timer expires.\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should\n   * wait before the specified function or code is executed.\n   * @param {*} [arg] An optional argument to be passed to the callback function\n   * when the timer expires.\n   * @returns {NodeJS.Timeout|FastTimer}\n   */\n  setTimeout (callback, delay, arg) {\n    // If the delay is less than or equal to the RESOLUTION_MS value return a\n    // native Node.js Timer instance.\n    return delay <= RESOLUTION_MS\n      ? setTimeout(callback, delay, arg)\n      : new FastTimer(callback, delay, arg)\n  },\n  /**\n   * The clearTimeout method cancels an instantiated Timer previously created\n   * by calling setTimeout.\n   *\n   * @param {NodeJS.Timeout|FastTimer} timeout\n   */\n  clearTimeout (timeout) {\n    // If the timeout is a FastTimer, call its own clear method.\n    if (timeout[kFastTimer]) {\n      /**\n       * @type {FastTimer}\n       */\n      timeout.clear()\n      // Otherwise it is an instance of a native NodeJS.Timeout, so call the\n      // Node.js native clearTimeout function.\n    } else {\n      clearTimeout(timeout)\n    }\n  },\n  /**\n   * The setFastTimeout() method sets a fastTimer which executes a function once\n   * the timer expires.\n   * @param {Function} callback A function to be executed after the timer\n   * expires.\n   * @param {number} delay The time, in milliseconds that the timer should\n   * wait before the specified function or code is executed.\n   * @param {*} [arg] An optional argument to be passed to the callback function\n   * when the timer expires.\n   * @returns {FastTimer}\n   */\n  setFastTimeout (callback, delay, arg) {\n    return new FastTimer(callback, delay, arg)\n  },\n  /**\n   * The clearTimeout method cancels an instantiated FastTimer previously\n   * created by calling setFastTimeout.\n   *\n   * @param {FastTimer} timeout\n   */\n  clearFastTimeout (timeout) {\n    timeout.clear()\n  },\n  /**\n   * The now method returns the value of the internal fast timer clock.\n   *\n   * @returns {number}\n   */\n  now () {\n    return fastNow\n  },\n  /**\n   * Trigger the onTick function to process the fastTimers array.\n   * Exported for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   * @param {number} [delay=0] The delay in milliseconds to add to the now value.\n   */\n  tick (delay = 0) {\n    fastNow += delay - RESOLUTION_MS + 1\n    onTick()\n    onTick()\n  },\n  /**\n   * Reset FastTimers.\n   * Exported for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   */\n  reset () {\n    fastNow = 0\n    fastTimers.length = 0\n    clearTimeout(fastNowTimeout)\n    fastNowTimeout = null\n  },\n  /**\n   * Exporting for testing purposes only.\n   * Marking as deprecated to discourage any use outside of testing.\n   * @deprecated\n   */\n  kFastTimer\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi91dGlsL3RpbWVycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcdXRpbFxcdGltZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIG9mZmVycyBhbiBvcHRpbWl6ZWQgdGltZXIgaW1wbGVtZW50YXRpb24gZGVzaWduZWQgZm9yIHNjZW5hcmlvc1xuICogd2hlcmUgaGlnaCBwcmVjaXNpb24gaXMgbm90IGNyaXRpY2FsLlxuICpcbiAqIFRoZSB0aW1lciBhY2hpZXZlcyBmYXN0ZXIgcGVyZm9ybWFuY2UgYnkgdXNpbmcgYSBsb3ctcmVzb2x1dGlvbiBhcHByb2FjaCxcbiAqIHdpdGggYW4gYWNjdXJhY3kgdGFyZ2V0IG9mIHdpdGhpbiA1MDBtcy4gVGhpcyBtYWtlcyBpdCBwYXJ0aWN1bGFybHkgdXNlZnVsXG4gKiBmb3IgdGltZXJzIHdpdGggZGVsYXlzIG9mIDEgc2Vjb25kIG9yIG1vcmUsIHdoZXJlIGV4YWN0IHRpbWluZyBpcyBsZXNzXG4gKiBjcnVjaWFsLlxuICpcbiAqIEl0J3MgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCBOb2RlLmpzIHRpbWVycyBhcmUgaW5oZXJlbnRseSBpbXByZWNpc2UsIGFzXG4gKiBkZWxheXMgY2FuIG9jY3VyIGR1ZSB0byB0aGUgZXZlbnQgbG9vcCBiZWluZyBibG9ja2VkIGJ5IG90aGVyIG9wZXJhdGlvbnMuXG4gKiBDb25zZXF1ZW50bHksIHRpbWVycyBtYXkgdHJpZ2dlciBsYXRlciB0aGFuIHRoZWlyIHNjaGVkdWxlZCB0aW1lLlxuICovXG5cbi8qKlxuICogVGhlIGZhc3ROb3cgdmFyaWFibGUgY29udGFpbnMgdGhlIGludGVybmFsIGZhc3QgdGltZXIgY2xvY2sgdmFsdWUuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xubGV0IGZhc3ROb3cgPSAwXG5cbi8qKlxuICogUkVTT0xVVElPTl9NUyByZXByZXNlbnRzIHRoZSB0YXJnZXQgcmVzb2x1dGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgMTAwMFxuICovXG5jb25zdCBSRVNPTFVUSU9OX01TID0gMWUzXG5cbi8qKlxuICogVElDS19NUyBkZWZpbmVzIHRoZSBkZXNpcmVkIGludGVydmFsIGluIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIGVhY2ggdGljay5cbiAqIFRoZSB0YXJnZXQgdmFsdWUgaXMgc2V0IHRvIGhhbGYgdGhlIHJlc29sdXRpb24gdGltZSwgbWludXMgMSBtcywgdG8gYWNjb3VudFxuICogZm9yIHBvdGVudGlhbCBldmVudCBsb29wIG92ZXJoZWFkLlxuICpcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdCA0OTlcbiAqL1xuY29uc3QgVElDS19NUyA9IChSRVNPTFVUSU9OX01TID4+IDEpIC0gMVxuXG4vKipcbiAqIGZhc3ROb3dUaW1lb3V0IGlzIGEgTm9kZS5qcyB0aW1lciB1c2VkIHRvIG1hbmFnZSBhbmQgcHJvY2Vzc1xuICogdGhlIEZhc3RUaW1lcnMgc3RvcmVkIGluIHRoZSBgZmFzdFRpbWVyc2AgYXJyYXkuXG4gKlxuICogQHR5cGUge05vZGVKUy5UaW1lb3V0fVxuICovXG5sZXQgZmFzdE5vd1RpbWVvdXRcblxuLyoqXG4gKiBUaGUga0Zhc3RUaW1lciBzeW1ib2wgaXMgdXNlZCB0byBpZGVudGlmeSBGYXN0VGltZXIgaW5zdGFuY2VzLlxuICpcbiAqIEB0eXBlIHtTeW1ib2x9XG4gKi9cbmNvbnN0IGtGYXN0VGltZXIgPSBTeW1ib2woJ2tGYXN0VGltZXInKVxuXG4vKipcbiAqIFRoZSBmYXN0VGltZXJzIGFycmF5IGNvbnRhaW5zIGFsbCBhY3RpdmUgRmFzdFRpbWVycy5cbiAqXG4gKiBAdHlwZSB7RmFzdFRpbWVyW119XG4gKi9cbmNvbnN0IGZhc3RUaW1lcnMgPSBbXVxuXG4vKipcbiAqIFRoZXNlIGNvbnN0YW50cyByZXByZXNlbnQgdGhlIHZhcmlvdXMgc3RhdGVzIG9mIGEgRmFzdFRpbWVyLlxuICovXG5cbi8qKlxuICogVGhlIGBOT1RfSU5fTElTVGAgY29uc3RhbnQgaW5kaWNhdGVzIHRoYXQgdGhlIEZhc3RUaW1lciBpcyBub3QgaW5jbHVkZWRcbiAqIGluIHRoZSBgZmFzdFRpbWVyc2AgYXJyYXkuIFRpbWVycyB3aXRoIHRoaXMgc3RhdHVzIHdpbGwgbm90IGJlIHByb2Nlc3NlZFxuICogZHVyaW5nIHRoZSBuZXh0IHRpY2sgYnkgdGhlIGBvblRpY2tgIGZ1bmN0aW9uLlxuICpcbiAqIEEgRmFzdFRpbWVyIGNhbiBiZSByZS1hZGRlZCB0byB0aGUgYGZhc3RUaW1lcnNgIGFycmF5IGJ5IGludm9raW5nIHRoZVxuICogYHJlZnJlc2hgIG1ldGhvZCBvbiB0aGUgRmFzdFRpbWVyIGluc3RhbmNlLlxuICpcbiAqIEB0eXBlIHstMn1cbiAqL1xuY29uc3QgTk9UX0lOX0xJU1QgPSAtMlxuXG4vKipcbiAqIFRoZSBgVE9fQkVfQ0xFQVJFRGAgY29uc3RhbnQgaW5kaWNhdGVzIHRoYXQgdGhlIEZhc3RUaW1lciBpcyBzY2hlZHVsZWRcbiAqIGZvciByZW1vdmFsIGZyb20gdGhlIGBmYXN0VGltZXJzYCBhcnJheS4gQSBGYXN0VGltZXIgaW4gdGhpcyBzdGF0ZSB3aWxsXG4gKiBiZSByZW1vdmVkIGluIHRoZSBuZXh0IHRpY2sgYnkgdGhlIGBvblRpY2tgIGZ1bmN0aW9uIGFuZCB3aWxsIG5vIGxvbmdlclxuICogYmUgcHJvY2Vzc2VkLlxuICpcbiAqIFRoaXMgc3RhdHVzIGlzIGFsc28gc2V0IHdoZW4gdGhlIGBjbGVhcmAgbWV0aG9kIGlzIGNhbGxlZCBvbiB0aGUgRmFzdFRpbWVyIGluc3RhbmNlLlxuICpcbiAqIEB0eXBlIHstMX1cbiAqL1xuY29uc3QgVE9fQkVfQ0xFQVJFRCA9IC0xXG5cbi8qKlxuICogVGhlIGBQRU5ESU5HYCBjb25zdGFudCBzaWduaWZpZXMgdGhhdCB0aGUgRmFzdFRpbWVyIGlzIGF3YWl0aW5nIHByb2Nlc3NpbmdcbiAqIGluIHRoZSBuZXh0IHRpY2sgYnkgdGhlIGBvblRpY2tgIGZ1bmN0aW9uLiBUaW1lcnMgd2l0aCB0aGlzIHN0YXR1cyB3aWxsIGhhdmVcbiAqIHRoZWlyIGBfaWRsZVN0YXJ0YCB2YWx1ZSBzZXQgYW5kIHRoZWlyIHN0YXR1cyB1cGRhdGVkIHRvIGBBQ1RJVkVgIGluIHRoZSBuZXh0IHRpY2suXG4gKlxuICogQHR5cGUgezB9XG4gKi9cbmNvbnN0IFBFTkRJTkcgPSAwXG5cbi8qKlxuICogVGhlIGBBQ1RJVkVgIGNvbnN0YW50IGluZGljYXRlcyB0aGF0IHRoZSBGYXN0VGltZXIgaXMgYWN0aXZlIGFuZCB3YWl0aW5nXG4gKiBmb3IgaXRzIHRpbWVyIHRvIGV4cGlyZS4gRHVyaW5nIHRoZSBuZXh0IHRpY2ssIHRoZSBgb25UaWNrYCBmdW5jdGlvbiB3aWxsXG4gKiBjaGVjayBpZiB0aGUgdGltZXIgaGFzIGV4cGlyZWQsIGFuZCBpZiBzbywgaXQgd2lsbCBleGVjdXRlIHRoZSBhc3NvY2lhdGVkIGNhbGxiYWNrLlxuICpcbiAqIEB0eXBlIHsxfVxuICovXG5jb25zdCBBQ1RJVkUgPSAxXG5cbi8qKlxuICogVGhlIG9uVGljayBmdW5jdGlvbiBwcm9jZXNzZXMgdGhlIGZhc3RUaW1lcnMgYXJyYXkuXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIG9uVGljayAoKSB7XG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIGZhc3ROb3cgdmFsdWUgYnkgdGhlIFRJQ0tfTVMgdmFsdWUsIGRlc3BpdGUgdGhlIGFjdHVhbCB0aW1lXG4gICAqIHRoYXQgaGFzIHBhc3NlZCBzaW5jZSB0aGUgbGFzdCB0aWNrLiBUaGlzIGFwcHJvYWNoIGVuc3VyZXMgaW5kZXBlbmRlbmNlXG4gICAqIGZyb20gdGhlIHN5c3RlbSBjbG9jayBhbmQgZGVsYXlzIGNhdXNlZCBieSBhIGJsb2NrZWQgZXZlbnQgbG9vcC5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGZhc3ROb3cgKz0gVElDS19NU1xuXG4gIC8qKlxuICAgKiBUaGUgYGlkeGAgdmFyaWFibGUgaXMgdXNlZCB0byBpdGVyYXRlIG92ZXIgdGhlIGBmYXN0VGltZXJzYCBhcnJheS5cbiAgICogRXhwaXJlZCB0aW1lcnMgYXJlIHJlbW92ZWQgYnkgcmVwbGFjaW5nIHRoZW0gd2l0aCB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBhcnJheS5cbiAgICogQ29uc2VxdWVudGx5LCBgaWR4YCBpcyBvbmx5IGluY3JlbWVudGVkIHdoZW4gdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBub3QgcmVtb3ZlZC5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGxldCBpZHggPSAwXG5cbiAgLyoqXG4gICAqIFRoZSBsZW4gdmFyaWFibGUgd2lsbCBjb250YWluIHRoZSBsZW5ndGggb2YgdGhlIGZhc3RUaW1lcnMgYXJyYXlcbiAgICogYW5kIHdpbGwgYmUgZGVjcmVtZW50ZWQgd2hlbiBhIEZhc3RUaW1lciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIHRoZVxuICAgKiBmYXN0VGltZXJzIGFycmF5LlxuICAgKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGV0IGxlbiA9IGZhc3RUaW1lcnMubGVuZ3RoXG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtGYXN0VGltZXJ9XG4gICAgICovXG4gICAgY29uc3QgdGltZXIgPSBmYXN0VGltZXJzW2lkeF1cblxuICAgIC8vIElmIHRoZSB0aW1lciBpcyBpbiB0aGUgQUNUSVZFIHN0YXRlIGFuZCB0aGUgdGltZXIgaGFzIGV4cGlyZWQsIGl0IHdpbGxcbiAgICAvLyBiZSBwcm9jZXNzZWQgaW4gdGhlIG5leHQgdGljay5cbiAgICBpZiAodGltZXIuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICAvLyBTZXQgdGhlIF9pZGxlU3RhcnQgdmFsdWUgdG8gdGhlIGZhc3ROb3cgdmFsdWUgbWludXMgdGhlIFRJQ0tfTVMgdmFsdWVcbiAgICAgIC8vIHRvIGFjY291bnQgZm9yIHRoZSB0aW1lIHRoZSB0aW1lciB3YXMgaW4gdGhlIFBFTkRJTkcgc3RhdGUuXG4gICAgICB0aW1lci5faWRsZVN0YXJ0ID0gZmFzdE5vdyAtIFRJQ0tfTVNcbiAgICAgIHRpbWVyLl9zdGF0ZSA9IEFDVElWRVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aW1lci5fc3RhdGUgPT09IEFDVElWRSAmJlxuICAgICAgZmFzdE5vdyA+PSB0aW1lci5faWRsZVN0YXJ0ICsgdGltZXIuX2lkbGVUaW1lb3V0XG4gICAgKSB7XG4gICAgICB0aW1lci5fc3RhdGUgPSBUT19CRV9DTEVBUkVEXG4gICAgICB0aW1lci5faWRsZVN0YXJ0ID0gLTFcbiAgICAgIHRpbWVyLl9vblRpbWVvdXQodGltZXIuX3RpbWVyQXJnKVxuICAgIH1cblxuICAgIGlmICh0aW1lci5fc3RhdGUgPT09IFRPX0JFX0NMRUFSRUQpIHtcbiAgICAgIHRpbWVyLl9zdGF0ZSA9IE5PVF9JTl9MSVNUXG5cbiAgICAgIC8vIE1vdmUgdGhlIGxhc3QgZWxlbWVudCB0byB0aGUgY3VycmVudCBpbmRleCBhbmQgZGVjcmVtZW50IGxlbiBpZiBpdCBpc1xuICAgICAgLy8gbm90IHRoZSBvbmx5IGVsZW1lbnQgaW4gdGhlIGFycmF5LlxuICAgICAgaWYgKC0tbGVuICE9PSAwKSB7XG4gICAgICAgIGZhc3RUaW1lcnNbaWR4XSA9IGZhc3RUaW1lcnNbbGVuXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICArK2lkeFxuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aGUgbGVuZ3RoIG9mIHRoZSBmYXN0VGltZXJzIGFycmF5IHRvIHRoZSBuZXcgbGVuZ3RoIGFuZCB0aHVzXG4gIC8vIHJlbW92aW5nIHRoZSBleGNlc3MgRmFzdFRpbWVycyBlbGVtZW50cyBmcm9tIHRoZSBhcnJheS5cbiAgZmFzdFRpbWVycy5sZW5ndGggPSBsZW5cblxuICAvLyBJZiB0aGVyZSBhcmUgc3RpbGwgYWN0aXZlIEZhc3RUaW1lcnMgaW4gdGhlIGFycmF5LCByZWZyZXNoIHRoZSBUaW1lci5cbiAgLy8gSWYgdGhlcmUgYXJlIG5vIGFjdGl2ZSBGYXN0VGltZXJzLCB0aGUgdGltZXIgd2lsbCBiZSByZWZyZXNoZWQgYWdhaW5cbiAgLy8gd2hlbiBhIG5ldyBGYXN0VGltZXIgaXMgaW5zdGFudGlhdGVkLlxuICBpZiAoZmFzdFRpbWVycy5sZW5ndGggIT09IDApIHtcbiAgICByZWZyZXNoVGltZW91dCgpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVmcmVzaFRpbWVvdXQgKCkge1xuICAvLyBJZiB0aGUgZmFzdE5vd1RpbWVvdXQgaXMgYWxyZWFkeSBzZXQsIHJlZnJlc2ggaXQuXG4gIGlmIChmYXN0Tm93VGltZW91dCkge1xuICAgIGZhc3ROb3dUaW1lb3V0LnJlZnJlc2goKVxuICAvLyBmYXN0Tm93VGltZW91dCBpcyBub3QgaW5zdGFudGlhdGVkIHlldCwgY3JlYXRlIGEgbmV3IFRpbWVyLlxuICB9IGVsc2Uge1xuICAgIGNsZWFyVGltZW91dChmYXN0Tm93VGltZW91dClcbiAgICBmYXN0Tm93VGltZW91dCA9IHNldFRpbWVvdXQob25UaWNrLCBUSUNLX01TKVxuXG4gICAgLy8gSWYgdGhlIFRpbWVyIGhhcyBhbiB1bnJlZiBtZXRob2QsIGNhbGwgaXQgdG8gYWxsb3cgdGhlIHByb2Nlc3MgdG8gZXhpdCBpZlxuICAgIC8vIHRoZXJlIGFyZSBubyBvdGhlciBhY3RpdmUgaGFuZGxlcy5cbiAgICBpZiAoZmFzdE5vd1RpbWVvdXQudW5yZWYpIHtcbiAgICAgIGZhc3ROb3dUaW1lb3V0LnVucmVmKClcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYEZhc3RUaW1lcmAgY2xhc3MgaXMgYSBkYXRhIHN0cnVjdHVyZSBkZXNpZ25lZCB0byBzdG9yZSBhbmQgbWFuYWdlXG4gKiB0aW1lciBpbmZvcm1hdGlvbi5cbiAqL1xuY2xhc3MgRmFzdFRpbWVyIHtcbiAgW2tGYXN0VGltZXJdID0gdHJ1ZVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhdGUgb2YgdGhlIHRpbWVyLCB3aGljaCBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqIC0gTk9UX0lOX0xJU1QgKC0yKVxuICAgKiAtIFRPX0JFX0NMRUFSRUQgKC0xKVxuICAgKiAtIFBFTkRJTkcgKDApXG4gICAqIC0gQUNUSVZFICgxKVxuICAgKlxuICAgKiBAdHlwZSB7LTJ8LTF8MHwxfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3N0YXRlID0gTk9UX0lOX0xJU1RcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyB0aGUgY2FsbGJhY2suXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaWRsZVRpbWVvdXQgPSAtMVxuXG4gIC8qKlxuICAgKiBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgd2hlbiB0aGUgdGltZXIgd2FzIHN0YXJ0ZWQuIFRoaXMgdmFsdWUgaXMgdXNlZCB0b1xuICAgKiBjYWxjdWxhdGUgd2hlbiB0aGUgdGltZXIgc2hvdWxkIGV4cGlyZS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgLTFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pZGxlU3RhcnQgPSAtMVxuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgdGltZXIgZXhwaXJlcy5cbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uVGltZW91dFxuXG4gIC8qKlxuICAgKiBUaGUgYXJndW1lbnQgdG8gYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayB3aGVuIHRoZSB0aW1lciBleHBpcmVzLlxuICAgKlxuICAgKiBAdHlwZSB7Kn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90aW1lckFyZ1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgdGltZXJcbiAgICogZXhwaXJlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRoZSB0aW1lLCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0aGUgdGltZXIgc2hvdWxkIHdhaXRcbiAgICogYmVmb3JlIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gb3IgY29kZSBpcyBleGVjdXRlZC5cbiAgICogQHBhcmFtIHsqfSBhcmdcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjYWxsYmFjaywgZGVsYXksIGFyZykge1xuICAgIHRoaXMuX29uVGltZW91dCA9IGNhbGxiYWNrXG4gICAgdGhpcy5faWRsZVRpbWVvdXQgPSBkZWxheVxuICAgIHRoaXMuX3RpbWVyQXJnID0gYXJnXG5cbiAgICB0aGlzLnJlZnJlc2goKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRpbWVyJ3Mgc3RhcnQgdGltZSB0byB0aGUgY3VycmVudCB0aW1lLCBhbmQgcmVzY2hlZHVsZXMgdGhlIHRpbWVyXG4gICAqIHRvIGNhbGwgaXRzIGNhbGxiYWNrIGF0IHRoZSBwcmV2aW91c2x5IHNwZWNpZmllZCBkdXJhdGlvbiBhZGp1c3RlZCB0byB0aGVcbiAgICogY3VycmVudCB0aW1lLlxuICAgKiBVc2luZyB0aGlzIG9uIGEgdGltZXIgdGhhdCBoYXMgYWxyZWFkeSBjYWxsZWQgaXRzIGNhbGxiYWNrIHdpbGwgcmVhY3RpdmF0ZVxuICAgKiB0aGUgdGltZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgcmVmcmVzaCAoKSB7XG4gICAgLy8gSW4gdGhlIHNwZWNpYWwgY2FzZSB0aGF0IHRoZSB0aW1lciBpcyBub3QgaW4gdGhlIGxpc3Qgb2YgYWN0aXZlIHRpbWVycyxcbiAgICAvLyBhZGQgaXQgYmFjayB0byB0aGUgYXJyYXkgdG8gYmUgcHJvY2Vzc2VkIGluIHRoZSBuZXh0IHRpY2sgYnkgdGhlIG9uVGlja1xuICAgIC8vIGZ1bmN0aW9uLlxuICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gTk9UX0lOX0xJU1QpIHtcbiAgICAgIGZhc3RUaW1lcnMucHVzaCh0aGlzKVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB0aW1lciBpcyB0aGUgb25seSBhY3RpdmUgdGltZXIsIHJlZnJlc2ggdGhlIGZhc3ROb3dUaW1lb3V0IGZvclxuICAgIC8vIGJldHRlciByZXNvbHV0aW9uLlxuICAgIGlmICghZmFzdE5vd1RpbWVvdXQgfHwgZmFzdFRpbWVycy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJlZnJlc2hUaW1lb3V0KClcbiAgICB9XG5cbiAgICAvLyBTZXR0aW5nIHRoZSBzdGF0ZSB0byBQRU5ESU5HIHdpbGwgY2F1c2UgdGhlIHRpbWVyIHRvIGJlIHJlc2V0IGluIHRoZVxuICAgIC8vIG5leHQgdGljayBieSB0aGUgb25UaWNrIGZ1bmN0aW9uLlxuICAgIHRoaXMuX3N0YXRlID0gUEVORElOR1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBgY2xlYXJgIG1ldGhvZCBjYW5jZWxzIHRoZSB0aW1lciwgcHJldmVudGluZyBpdCBmcm9tIGV4ZWN1dGluZy5cbiAgICpcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjbGVhciAoKSB7XG4gICAgLy8gU2V0IHRoZSBzdGF0ZSB0byBUT19CRV9DTEVBUkVEIHRvIG1hcmsgdGhlIHRpbWVyIGZvciByZW1vdmFsIGluIHRoZSBuZXh0XG4gICAgLy8gdGljayBieSB0aGUgb25UaWNrIGZ1bmN0aW9uLlxuICAgIHRoaXMuX3N0YXRlID0gVE9fQkVfQ0xFQVJFRFxuXG4gICAgLy8gUmVzZXQgdGhlIF9pZGxlU3RhcnQgdmFsdWUgdG8gLTEgdG8gaW5kaWNhdGUgdGhhdCB0aGUgdGltZXIgaXMgbm8gbG9uZ2VyXG4gICAgLy8gYWN0aXZlLlxuICAgIHRoaXMuX2lkbGVTdGFydCA9IC0xXG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBleHBvcnRzIGEgc2V0VGltZW91dCBhbmQgY2xlYXJUaW1lb3V0IGZ1bmN0aW9uIHRoYXQgY2FuIGJlXG4gKiB1c2VkIGFzIGEgZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgdGhlIG5hdGl2ZSBmdW5jdGlvbnMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKipcbiAgICogVGhlIHNldFRpbWVvdXQoKSBtZXRob2Qgc2V0cyBhIHRpbWVyIHdoaWNoIGV4ZWN1dGVzIGEgZnVuY3Rpb24gb25jZSB0aGVcbiAgICogdGltZXIgZXhwaXJlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBhZnRlciB0aGUgdGltZXJcbiAgICogZXhwaXJlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRoZSB0aW1lLCBpbiBtaWxsaXNlY29uZHMgdGhhdCB0aGUgdGltZXIgc2hvdWxkXG4gICAqIHdhaXQgYmVmb3JlIHRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gb3IgY29kZSBpcyBleGVjdXRlZC5cbiAgICogQHBhcmFtIHsqfSBbYXJnXSBBbiBvcHRpb25hbCBhcmd1bWVudCB0byBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAqIHdoZW4gdGhlIHRpbWVyIGV4cGlyZXMuXG4gICAqIEByZXR1cm5zIHtOb2RlSlMuVGltZW91dHxGYXN0VGltZXJ9XG4gICAqL1xuICBzZXRUaW1lb3V0IChjYWxsYmFjaywgZGVsYXksIGFyZykge1xuICAgIC8vIElmIHRoZSBkZWxheSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIFJFU09MVVRJT05fTVMgdmFsdWUgcmV0dXJuIGFcbiAgICAvLyBuYXRpdmUgTm9kZS5qcyBUaW1lciBpbnN0YW5jZS5cbiAgICByZXR1cm4gZGVsYXkgPD0gUkVTT0xVVElPTl9NU1xuICAgICAgPyBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSwgYXJnKVxuICAgICAgOiBuZXcgRmFzdFRpbWVyKGNhbGxiYWNrLCBkZWxheSwgYXJnKVxuICB9LFxuICAvKipcbiAgICogVGhlIGNsZWFyVGltZW91dCBtZXRob2QgY2FuY2VscyBhbiBpbnN0YW50aWF0ZWQgVGltZXIgcHJldmlvdXNseSBjcmVhdGVkXG4gICAqIGJ5IGNhbGxpbmcgc2V0VGltZW91dC5cbiAgICpcbiAgICogQHBhcmFtIHtOb2RlSlMuVGltZW91dHxGYXN0VGltZXJ9IHRpbWVvdXRcbiAgICovXG4gIGNsZWFyVGltZW91dCAodGltZW91dCkge1xuICAgIC8vIElmIHRoZSB0aW1lb3V0IGlzIGEgRmFzdFRpbWVyLCBjYWxsIGl0cyBvd24gY2xlYXIgbWV0aG9kLlxuICAgIGlmICh0aW1lb3V0W2tGYXN0VGltZXJdKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtGYXN0VGltZXJ9XG4gICAgICAgKi9cbiAgICAgIHRpbWVvdXQuY2xlYXIoKVxuICAgICAgLy8gT3RoZXJ3aXNlIGl0IGlzIGFuIGluc3RhbmNlIG9mIGEgbmF0aXZlIE5vZGVKUy5UaW1lb3V0LCBzbyBjYWxsIHRoZVxuICAgICAgLy8gTm9kZS5qcyBuYXRpdmUgY2xlYXJUaW1lb3V0IGZ1bmN0aW9uLlxuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dClcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgc2V0RmFzdFRpbWVvdXQoKSBtZXRob2Qgc2V0cyBhIGZhc3RUaW1lciB3aGljaCBleGVjdXRlcyBhIGZ1bmN0aW9uIG9uY2VcbiAgICogdGhlIHRpbWVyIGV4cGlyZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIHRpbWVyXG4gICAqIGV4cGlyZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSBUaGUgdGltZSwgaW4gbWlsbGlzZWNvbmRzIHRoYXQgdGhlIHRpbWVyIHNob3VsZFxuICAgKiB3YWl0IGJlZm9yZSB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIG9yIGNvZGUgaXMgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSB7Kn0gW2FyZ10gQW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvblxuICAgKiB3aGVuIHRoZSB0aW1lciBleHBpcmVzLlxuICAgKiBAcmV0dXJucyB7RmFzdFRpbWVyfVxuICAgKi9cbiAgc2V0RmFzdFRpbWVvdXQgKGNhbGxiYWNrLCBkZWxheSwgYXJnKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0VGltZXIoY2FsbGJhY2ssIGRlbGF5LCBhcmcpXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgY2xlYXJUaW1lb3V0IG1ldGhvZCBjYW5jZWxzIGFuIGluc3RhbnRpYXRlZCBGYXN0VGltZXIgcHJldmlvdXNseVxuICAgKiBjcmVhdGVkIGJ5IGNhbGxpbmcgc2V0RmFzdFRpbWVvdXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RmFzdFRpbWVyfSB0aW1lb3V0XG4gICAqL1xuICBjbGVhckZhc3RUaW1lb3V0ICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbGVhcigpXG4gIH0sXG4gIC8qKlxuICAgKiBUaGUgbm93IG1ldGhvZCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgaW50ZXJuYWwgZmFzdCB0aW1lciBjbG9jay5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIG5vdyAoKSB7XG4gICAgcmV0dXJuIGZhc3ROb3dcbiAgfSxcbiAgLyoqXG4gICAqIFRyaWdnZXIgdGhlIG9uVGljayBmdW5jdGlvbiB0byBwcm9jZXNzIHRoZSBmYXN0VGltZXJzIGFycmF5LlxuICAgKiBFeHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuICAgKiBNYXJraW5nIGFzIGRlcHJlY2F0ZWQgdG8gZGlzY291cmFnZSBhbnkgdXNlIG91dHNpZGUgb2YgdGVzdGluZy5cbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXSBUaGUgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIHRvIGFkZCB0byB0aGUgbm93IHZhbHVlLlxuICAgKi9cbiAgdGljayAoZGVsYXkgPSAwKSB7XG4gICAgZmFzdE5vdyArPSBkZWxheSAtIFJFU09MVVRJT05fTVMgKyAxXG4gICAgb25UaWNrKClcbiAgICBvblRpY2soKVxuICB9LFxuICAvKipcbiAgICogUmVzZXQgRmFzdFRpbWVycy5cbiAgICogRXhwb3J0ZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cbiAgICogTWFya2luZyBhcyBkZXByZWNhdGVkIHRvIGRpc2NvdXJhZ2UgYW55IHVzZSBvdXRzaWRlIG9mIHRlc3RpbmcuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICByZXNldCAoKSB7XG4gICAgZmFzdE5vdyA9IDBcbiAgICBmYXN0VGltZXJzLmxlbmd0aCA9IDBcbiAgICBjbGVhclRpbWVvdXQoZmFzdE5vd1RpbWVvdXQpXG4gICAgZmFzdE5vd1RpbWVvdXQgPSBudWxsXG4gIH0sXG4gIC8qKlxuICAgKiBFeHBvcnRpbmcgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cbiAgICogTWFya2luZyBhcyBkZXByZWNhdGVkIHRvIGRpc2NvdXJhZ2UgYW55IHVzZSBvdXRzaWRlIG9mIHRlc3RpbmcuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBrRmFzdFRpbWVyXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/util/timers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cache/cache.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cache.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/cache/symbols.js\")\nconst { urlEquals, getFieldValues } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/cache/util.js\")\nconst { kEnumerableProperty, isDisturbed } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { Response, cloneResponse, fromInnerResponse } = __webpack_require__(/*! ../fetch/response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { Request, fromInnerRequest } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { kState } = __webpack_require__(/*! ../fetch/symbols */ \"(rsc)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-cache-batch-operation\n * @typedef {Object} CacheBatchOperation\n * @property {'delete' | 'put'} type\n * @property {any} request\n * @property {any} response\n * @property {import('../../types/cache').CacheQueryOptions} options\n */\n\n/**\n * @see https://w3c.github.io/ServiceWorker/#dfn-request-response-list\n * @typedef {[any, any][]} requestResponseList\n */\n\nclass Cache {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list\n   * @type {requestResponseList}\n   */\n  #relevantRequestResponseList\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    webidl.util.markAsUncloneable(this)\n    this.#relevantRequestResponseList = arguments[1]\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.match'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    const p = this.#internalMatchAll(request, options, 1)\n\n    if (p.length === 0) {\n      return\n    }\n\n    return p[0]\n  }\n\n  async matchAll (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.matchAll'\n    if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    return this.#internalMatchAll(request, options)\n  }\n\n  async add (request) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.add'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n\n    // 1.\n    const requests = [request]\n\n    // 2.\n    const responseArrayPromise = this.addAll(requests)\n\n    // 3.\n    return await responseArrayPromise\n  }\n\n  async addAll (requests) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.addAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    // 1.\n    const responsePromises = []\n\n    // 2.\n    const requestList = []\n\n    // 3.\n    for (let request of requests) {\n      if (request === undefined) {\n        throw webidl.errors.conversionFailed({\n          prefix,\n          argument: 'Argument 1',\n          types: ['undefined is not allowed']\n        })\n      }\n\n      request = webidl.converters.RequestInfo(request)\n\n      if (typeof request === 'string') {\n        continue\n      }\n\n      // 3.1\n      const r = request[kState]\n\n      // 3.2\n      if (!urlIsHttpHttpsScheme(r.url) || r.method !== 'GET') {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme when method is not GET.'\n        })\n      }\n    }\n\n    // 4.\n    /** @type {ReturnType<typeof fetching>[]} */\n    const fetchControllers = []\n\n    // 5.\n    for (const request of requests) {\n      // 5.1\n      const r = new Request(request)[kState]\n\n      // 5.2\n      if (!urlIsHttpHttpsScheme(r.url)) {\n        throw webidl.errors.exception({\n          header: prefix,\n          message: 'Expected http/s scheme.'\n        })\n      }\n\n      // 5.4\n      r.initiator = 'fetch'\n      r.destination = 'subresource'\n\n      // 5.5\n      requestList.push(r)\n\n      // 5.6\n      const responsePromise = createDeferredPromise()\n\n      // 5.7\n      fetchControllers.push(fetching({\n        request: r,\n        processResponse (response) {\n          // 1.\n          if (response.type === 'error' || response.status === 206 || response.status < 200 || response.status > 299) {\n            responsePromise.reject(webidl.errors.exception({\n              header: 'Cache.addAll',\n              message: 'Received an invalid status code or the request failed.'\n            }))\n          } else if (response.headersList.contains('vary')) { // 2.\n            // 2.1\n            const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n            // 2.2\n            for (const fieldValue of fieldValues) {\n              // 2.2.1\n              if (fieldValue === '*') {\n                responsePromise.reject(webidl.errors.exception({\n                  header: 'Cache.addAll',\n                  message: 'invalid vary field value'\n                }))\n\n                for (const controller of fetchControllers) {\n                  controller.abort()\n                }\n\n                return\n              }\n            }\n          }\n        },\n        processResponseEndOfBody (response) {\n          // 1.\n          if (response.aborted) {\n            responsePromise.reject(new DOMException('aborted', 'AbortError'))\n            return\n          }\n\n          // 2.\n          responsePromise.resolve(response)\n        }\n      }))\n\n      // 5.8\n      responsePromises.push(responsePromise.promise)\n    }\n\n    // 6.\n    const p = Promise.all(responsePromises)\n\n    // 7.\n    const responses = await p\n\n    // 7.1\n    const operations = []\n\n    // 7.2\n    let index = 0\n\n    // 7.3\n    for (const response of responses) {\n      // 7.3.1\n      /** @type {CacheBatchOperation} */\n      const operation = {\n        type: 'put', // 7.3.2\n        request: requestList[index], // 7.3.3\n        response // 7.3.4\n      }\n\n      operations.push(operation) // 7.3.5\n\n      index++ // 7.3.6\n    }\n\n    // 7.5\n    const cacheJobPromise = createDeferredPromise()\n\n    // 7.6.1\n    let errorData = null\n\n    // 7.6.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 7.6.3\n    queueMicrotask(() => {\n      // 7.6.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve(undefined)\n      } else {\n        // 7.6.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    // 7.7\n    return cacheJobPromise.promise\n  }\n\n  async put (request, response) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.put'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    response = webidl.converters.Response(response, prefix, 'response')\n\n    // 1.\n    let innerRequest = null\n\n    // 2.\n    if (request instanceof Request) {\n      innerRequest = request[kState]\n    } else { // 3.\n      innerRequest = new Request(request)[kState]\n    }\n\n    // 4.\n    if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== 'GET') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Expected an http/s scheme when method is not GET'\n      })\n    }\n\n    // 5.\n    const innerResponse = response[kState]\n\n    // 6.\n    if (innerResponse.status === 206) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Got 206 status'\n      })\n    }\n\n    // 7.\n    if (innerResponse.headersList.contains('vary')) {\n      // 7.1.\n      const fieldValues = getFieldValues(innerResponse.headersList.get('vary'))\n\n      // 7.2.\n      for (const fieldValue of fieldValues) {\n        // 7.2.1\n        if (fieldValue === '*') {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: 'Got * vary field value'\n          })\n        }\n      }\n    }\n\n    // 8.\n    if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: 'Response body is locked or disturbed'\n      })\n    }\n\n    // 9.\n    const clonedResponse = cloneResponse(innerResponse)\n\n    // 10.\n    const bodyReadPromise = createDeferredPromise()\n\n    // 11.\n    if (innerResponse.body != null) {\n      // 11.1\n      const stream = innerResponse.body.stream\n\n      // 11.2\n      const reader = stream.getReader()\n\n      // 11.3\n      readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject)\n    } else {\n      bodyReadPromise.resolve(undefined)\n    }\n\n    // 12.\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    // 13.\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'put', // 14.\n      request: innerRequest, // 15.\n      response: clonedResponse // 16.\n    }\n\n    // 17.\n    operations.push(operation)\n\n    // 19.\n    const bytes = await bodyReadPromise.promise\n\n    if (clonedResponse.body != null) {\n      clonedResponse.body.source = bytes\n    }\n\n    // 19.1\n    const cacheJobPromise = createDeferredPromise()\n\n    // 19.2.1\n    let errorData = null\n\n    // 19.2.2\n    try {\n      this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    // 19.2.3\n    queueMicrotask(() => {\n      // 19.2.3.1\n      if (errorData === null) {\n        cacheJobPromise.resolve()\n      } else { // 19.2.3.2\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  async delete (request, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    /**\n     * @type {Request}\n     */\n    let r = null\n\n    if (request instanceof Request) {\n      r = request[kState]\n\n      if (r.method !== 'GET' && !options.ignoreMethod) {\n        return false\n      }\n    } else {\n      assert(typeof request === 'string')\n\n      r = new Request(request)[kState]\n    }\n\n    /** @type {CacheBatchOperation[]} */\n    const operations = []\n\n    /** @type {CacheBatchOperation} */\n    const operation = {\n      type: 'delete',\n      request: r,\n      options\n    }\n\n    operations.push(operation)\n\n    const cacheJobPromise = createDeferredPromise()\n\n    let errorData = null\n    let requestResponses\n\n    try {\n      requestResponses = this.#batchCacheOperations(operations)\n    } catch (e) {\n      errorData = e\n    }\n\n    queueMicrotask(() => {\n      if (errorData === null) {\n        cacheJobPromise.resolve(!!requestResponses?.length)\n      } else {\n        cacheJobPromise.reject(errorData)\n      }\n    })\n\n    return cacheJobPromise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys\n   * @param {any} request\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @returns {Promise<readonly Request[]>}\n   */\n  async keys (request = undefined, options = {}) {\n    webidl.brandCheck(this, Cache)\n\n    const prefix = 'Cache.keys'\n\n    if (request !== undefined) request = webidl.converters.RequestInfo(request, prefix, 'request')\n    options = webidl.converters.CacheQueryOptions(options, prefix, 'options')\n\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      // 2.1\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') { // 2.2\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 4.\n    const promise = createDeferredPromise()\n\n    // 5.\n    // 5.1\n    const requests = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        // 5.2.1.1\n        requests.push(requestResponse[0])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        // 5.3.2.1\n        requests.push(requestResponse[0])\n      }\n    }\n\n    // 5.4\n    queueMicrotask(() => {\n      // 5.4.1\n      const requestList = []\n\n      // 5.4.2\n      for (const request of requests) {\n        const requestObject = fromInnerRequest(\n          request,\n          new AbortController().signal,\n          'immutable'\n        )\n        // 5.4.2.1\n        requestList.push(requestObject)\n      }\n\n      // 5.4.3\n      promise.resolve(Object.freeze(requestList))\n    })\n\n    return promise.promise\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm\n   * @param {CacheBatchOperation[]} operations\n   * @returns {requestResponseList}\n   */\n  #batchCacheOperations (operations) {\n    // 1.\n    const cache = this.#relevantRequestResponseList\n\n    // 2.\n    const backupCache = [...cache]\n\n    // 3.\n    const addedItems = []\n\n    // 4.1\n    const resultList = []\n\n    try {\n      // 4.2\n      for (const operation of operations) {\n        // 4.2.1\n        if (operation.type !== 'delete' && operation.type !== 'put') {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'operation type does not match \"delete\" or \"put\"'\n          })\n        }\n\n        // 4.2.2\n        if (operation.type === 'delete' && operation.response != null) {\n          throw webidl.errors.exception({\n            header: 'Cache.#batchCacheOperations',\n            message: 'delete operation should not have an associated response'\n          })\n        }\n\n        // 4.2.3\n        if (this.#queryCache(operation.request, operation.options, addedItems).length) {\n          throw new DOMException('???', 'InvalidStateError')\n        }\n\n        // 4.2.4\n        let requestResponses\n\n        // 4.2.5\n        if (operation.type === 'delete') {\n          // 4.2.5.1\n          requestResponses = this.#queryCache(operation.request, operation.options)\n\n          // TODO: the spec is wrong, this is needed to pass WPTs\n          if (requestResponses.length === 0) {\n            return []\n          }\n\n          // 4.2.5.2\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.5.2.1\n            cache.splice(idx, 1)\n          }\n        } else if (operation.type === 'put') { // 4.2.6\n          // 4.2.6.1\n          if (operation.response == null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'put operation should have an associated response'\n            })\n          }\n\n          // 4.2.6.2\n          const r = operation.request\n\n          // 4.2.6.3\n          if (!urlIsHttpHttpsScheme(r.url)) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'expected http or https scheme'\n            })\n          }\n\n          // 4.2.6.4\n          if (r.method !== 'GET') {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'not get method'\n            })\n          }\n\n          // 4.2.6.5\n          if (operation.options != null) {\n            throw webidl.errors.exception({\n              header: 'Cache.#batchCacheOperations',\n              message: 'options must not be defined'\n            })\n          }\n\n          // 4.2.6.6\n          requestResponses = this.#queryCache(operation.request)\n\n          // 4.2.6.7\n          for (const requestResponse of requestResponses) {\n            const idx = cache.indexOf(requestResponse)\n            assert(idx !== -1)\n\n            // 4.2.6.7.1\n            cache.splice(idx, 1)\n          }\n\n          // 4.2.6.8\n          cache.push([operation.request, operation.response])\n\n          // 4.2.6.10\n          addedItems.push([operation.request, operation.response])\n        }\n\n        // 4.2.7\n        resultList.push([operation.request, operation.response])\n      }\n\n      // 4.3\n      return resultList\n    } catch (e) { // 5.\n      // 5.1\n      this.#relevantRequestResponseList.length = 0\n\n      // 5.2\n      this.#relevantRequestResponseList = backupCache\n\n      // 5.3\n      throw e\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#query-cache\n   * @param {any} requestQuery\n   * @param {import('../../types/cache').CacheQueryOptions} options\n   * @param {requestResponseList} targetStorage\n   * @returns {requestResponseList}\n   */\n  #queryCache (requestQuery, options, targetStorage) {\n    /** @type {requestResponseList} */\n    const resultList = []\n\n    const storage = targetStorage ?? this.#relevantRequestResponseList\n\n    for (const requestResponse of storage) {\n      const [cachedRequest, cachedResponse] = requestResponse\n      if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {\n        resultList.push(requestResponse)\n      }\n    }\n\n    return resultList\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm\n   * @param {any} requestQuery\n   * @param {any} request\n   * @param {any | null} response\n   * @param {import('../../types/cache').CacheQueryOptions | undefined} options\n   * @returns {boolean}\n   */\n  #requestMatchesCachedItem (requestQuery, request, response = null, options) {\n    // if (options?.ignoreMethod === false && request.method === 'GET') {\n    //   return false\n    // }\n\n    const queryURL = new URL(requestQuery.url)\n\n    const cachedURL = new URL(request.url)\n\n    if (options?.ignoreSearch) {\n      cachedURL.search = ''\n\n      queryURL.search = ''\n    }\n\n    if (!urlEquals(queryURL, cachedURL, true)) {\n      return false\n    }\n\n    if (\n      response == null ||\n      options?.ignoreVary ||\n      !response.headersList.contains('vary')\n    ) {\n      return true\n    }\n\n    const fieldValues = getFieldValues(response.headersList.get('vary'))\n\n    for (const fieldValue of fieldValues) {\n      if (fieldValue === '*') {\n        return false\n      }\n\n      const requestValue = request.headersList.get(fieldValue)\n      const queryValue = requestQuery.headersList.get(fieldValue)\n\n      // If one has the header and the other doesn't, or one has\n      // a different value than the other, return false\n      if (requestValue !== queryValue) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  #internalMatchAll (request, options, maxResponses = Infinity) {\n    // 1.\n    let r = null\n\n    // 2.\n    if (request !== undefined) {\n      if (request instanceof Request) {\n        // 2.1.1\n        r = request[kState]\n\n        // 2.1.2\n        if (r.method !== 'GET' && !options.ignoreMethod) {\n          return []\n        }\n      } else if (typeof request === 'string') {\n        // 2.2.1\n        r = new Request(request)[kState]\n      }\n    }\n\n    // 5.\n    // 5.1\n    const responses = []\n\n    // 5.2\n    if (request === undefined) {\n      // 5.2.1\n      for (const requestResponse of this.#relevantRequestResponseList) {\n        responses.push(requestResponse[1])\n      }\n    } else { // 5.3\n      // 5.3.1\n      const requestResponses = this.#queryCache(r, options)\n\n      // 5.3.2\n      for (const requestResponse of requestResponses) {\n        responses.push(requestResponse[1])\n      }\n    }\n\n    // 5.4\n    // We don't implement CORs so we don't need to loop over the responses, yay!\n\n    // 5.5.1\n    const responseList = []\n\n    // 5.5.2\n    for (const response of responses) {\n      // 5.5.2.1\n      const responseObject = fromInnerResponse(response, 'immutable')\n\n      responseList.push(responseObject.clone())\n\n      if (responseList.length >= maxResponses) {\n        break\n      }\n    }\n\n    // 6.\n    return Object.freeze(responseList)\n  }\n}\n\nObject.defineProperties(Cache.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'Cache',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  matchAll: kEnumerableProperty,\n  add: kEnumerableProperty,\n  addAll: kEnumerableProperty,\n  put: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nconst cacheQueryOptionConverters = [\n  {\n    key: 'ignoreSearch',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreMethod',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'ignoreVary',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters)\n\nwebidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([\n  ...cacheQueryOptionConverters,\n  {\n    key: 'cacheName',\n    converter: webidl.converters.DOMString\n  }\n])\n\nwebidl.converters.Response = webidl.interfaceConverter(Response)\n\nwebidl.converters['sequence<RequestInfo>'] = webidl.sequenceConverter(\n  webidl.converters.RequestInfo\n)\n\nmodule.exports = {\n  Cache\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUMxQyxRQUFRLDRCQUE0QixFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDdEQsUUFBUSxtQ0FBbUMsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0RSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjtBQUM1QyxRQUFRLDZDQUE2QyxFQUFFLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ2xGLFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDaEUsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDN0MsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQywwRUFBZ0I7QUFDN0MsUUFBUSw0REFBNEQsRUFBRSxtQkFBTyxDQUFDLHdFQUFlO0FBQzdGLGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFcEM7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLEtBQUs7QUFDbkIsY0FBYyxLQUFLO0FBQ25CLGNBQWMsK0NBQStDO0FBQzdEOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbURBQW1EO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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QUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGNhY2hlXFxjYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB1cmxFcXVhbHMsIGdldEZpZWxkVmFsdWVzIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5LCBpc0Rpc3R1cmJlZCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBSZXNwb25zZSwgY2xvbmVSZXNwb25zZSwgZnJvbUlubmVyUmVzcG9uc2UgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3Jlc3BvbnNlJylcbmNvbnN0IHsgUmVxdWVzdCwgZnJvbUlubmVyUmVxdWVzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVxdWVzdCcpXG5jb25zdCB7IGtTdGF0ZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvc3ltYm9scycpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9pbmRleCcpXG5jb25zdCB7IHVybElzSHR0cEh0dHBzU2NoZW1lLCBjcmVhdGVEZWZlcnJlZFByb21pc2UsIHJlYWRBbGxCeXRlcyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvdXRpbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLWNhY2hlLWJhdGNoLW9wZXJhdGlvblxuICogQHR5cGVkZWYge09iamVjdH0gQ2FjaGVCYXRjaE9wZXJhdGlvblxuICogQHByb3BlcnR5IHsnZGVsZXRlJyB8ICdwdXQnfSB0eXBlXG4gKiBAcHJvcGVydHkge2FueX0gcmVxdWVzdFxuICogQHByb3BlcnR5IHthbnl9IHJlc3BvbnNlXG4gKiBAcHJvcGVydHkge2ltcG9ydCgnLi4vLi4vdHlwZXMvY2FjaGUnKS5DYWNoZVF1ZXJ5T3B0aW9uc30gb3B0aW9uc1xuICovXG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZGZuLXJlcXVlc3QtcmVzcG9uc2UtbGlzdFxuICogQHR5cGVkZWYge1thbnksIGFueV1bXX0gcmVxdWVzdFJlc3BvbnNlTGlzdFxuICovXG5cbmNsYXNzIENhY2hlIHtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1yZWxldmFudC1yZXF1ZXN0LXJlc3BvbnNlLWxpc3RcbiAgICogQHR5cGUge3JlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0XG5cbiAgY29uc3RydWN0b3IgKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gIT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHdlYmlkbC5pbGxlZ2FsQ29uc3RydWN0b3IoKVxuICAgIH1cblxuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG4gICAgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0ID0gYXJndW1lbnRzWzFdXG4gIH1cblxuICBhc3luYyBtYXRjaCAocmVxdWVzdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUubWF0Y2gnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgY29uc3QgcCA9IHRoaXMuI2ludGVybmFsTWF0Y2hBbGwocmVxdWVzdCwgb3B0aW9ucywgMSlcblxuICAgIGlmIChwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcmV0dXJuIHBbMF1cbiAgfVxuXG4gIGFzeW5jIG1hdGNoQWxsIChyZXF1ZXN0ID0gdW5kZWZpbmVkLCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5tYXRjaEFsbCdcbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgcmV0dXJuIHRoaXMuI2ludGVybmFsTWF0Y2hBbGwocmVxdWVzdCwgb3B0aW9ucylcbiAgfVxuXG4gIGFzeW5jIGFkZCAocmVxdWVzdCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlLmFkZCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0LCBwcmVmaXgsICdyZXF1ZXN0JylcblxuICAgIC8vIDEuXG4gICAgY29uc3QgcmVxdWVzdHMgPSBbcmVxdWVzdF1cblxuICAgIC8vIDIuXG4gICAgY29uc3QgcmVzcG9uc2VBcnJheVByb21pc2UgPSB0aGlzLmFkZEFsbChyZXF1ZXN0cylcblxuICAgIC8vIDMuXG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlQXJyYXlQcm9taXNlXG4gIH1cblxuICBhc3luYyBhZGRBbGwgKHJlcXVlc3RzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGUpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnQ2FjaGUuYWRkQWxsJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgLy8gMS5cbiAgICBjb25zdCByZXNwb25zZVByb21pc2VzID0gW11cblxuICAgIC8vIDIuXG4gICAgY29uc3QgcmVxdWVzdExpc3QgPSBbXVxuXG4gICAgLy8gMy5cbiAgICBmb3IgKGxldCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgICAgcHJlZml4LFxuICAgICAgICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgICAgICAgdHlwZXM6IFsndW5kZWZpbmVkIGlzIG5vdCBhbGxvd2VkJ11cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QpXG5cbiAgICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMy4xXG4gICAgICBjb25zdCByID0gcmVxdWVzdFtrU3RhdGVdXG5cbiAgICAgIC8vIDMuMlxuICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyLnVybCkgfHwgci5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgaHR0cC9zIHNjaGVtZSB3aGVuIG1ldGhvZCBpcyBub3QgR0VULidcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIC8qKiBAdHlwZSB7UmV0dXJuVHlwZTx0eXBlb2YgZmV0Y2hpbmc+W119ICovXG4gICAgY29uc3QgZmV0Y2hDb250cm9sbGVycyA9IFtdXG5cbiAgICAvLyA1LlxuICAgIGZvciAoY29uc3QgcmVxdWVzdCBvZiByZXF1ZXN0cykge1xuICAgICAgLy8gNS4xXG4gICAgICBjb25zdCByID0gbmV3IFJlcXVlc3QocmVxdWVzdClba1N0YXRlXVxuXG4gICAgICAvLyA1LjJcbiAgICAgIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUoci51cmwpKSB7XG4gICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgaHR0cC9zIHNjaGVtZS4nXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIDUuNFxuICAgICAgci5pbml0aWF0b3IgPSAnZmV0Y2gnXG4gICAgICByLmRlc3RpbmF0aW9uID0gJ3N1YnJlc291cmNlJ1xuXG4gICAgICAvLyA1LjVcbiAgICAgIHJlcXVlc3RMaXN0LnB1c2gocilcblxuICAgICAgLy8gNS42XG4gICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgICAvLyA1LjdcbiAgICAgIGZldGNoQ29udHJvbGxlcnMucHVzaChmZXRjaGluZyh7XG4gICAgICAgIHJlcXVlc3Q6IHIsXG4gICAgICAgIHByb2Nlc3NSZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgICAgICAgICAvLyAxLlxuICAgICAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2IHx8IHJlc3BvbnNlLnN0YXR1cyA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXMgPiAyOTkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlUHJvbWlzZS5yZWplY3Qod2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS5hZGRBbGwnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnUmVjZWl2ZWQgYW4gaW52YWxpZCBzdGF0dXMgY29kZSBvciB0aGUgcmVxdWVzdCBmYWlsZWQuJ1xuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5oZWFkZXJzTGlzdC5jb250YWlucygndmFyeScpKSB7IC8vIDIuXG4gICAgICAgICAgICAvLyAyLjFcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZXMocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCd2YXJ5JykpXG5cbiAgICAgICAgICAgIC8vIDIuMlxuICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZFZhbHVlIG9mIGZpZWxkVmFsdWVzKSB7XG4gICAgICAgICAgICAgIC8vIDIuMi4xXG4gICAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZVByb21pc2UucmVqZWN0KHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLmFkZEFsbCcsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnaW52YWxpZCB2YXJ5IGZpZWxkIHZhbHVlJ1xuICAgICAgICAgICAgICAgIH0pKVxuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIGZldGNoQ29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgLy8gMS5cbiAgICAgICAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChuZXcgRE9NRXhjZXB0aW9uKCdhYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDIuXG4gICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpXG4gICAgICAgIH1cbiAgICAgIH0pKVxuXG4gICAgICAvLyA1LjhcbiAgICAgIHJlc3BvbnNlUHJvbWlzZXMucHVzaChyZXNwb25zZVByb21pc2UucHJvbWlzZSlcbiAgICB9XG5cbiAgICAvLyA2LlxuICAgIGNvbnN0IHAgPSBQcm9taXNlLmFsbChyZXNwb25zZVByb21pc2VzKVxuXG4gICAgLy8gNy5cbiAgICBjb25zdCByZXNwb25zZXMgPSBhd2FpdCBwXG5cbiAgICAvLyA3LjFcbiAgICBjb25zdCBvcGVyYXRpb25zID0gW11cblxuICAgIC8vIDcuMlxuICAgIGxldCBpbmRleCA9IDBcblxuICAgIC8vIDcuM1xuICAgIGZvciAoY29uc3QgcmVzcG9uc2Ugb2YgcmVzcG9uc2VzKSB7XG4gICAgICAvLyA3LjMuMVxuICAgICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9ufSAqL1xuICAgICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgICB0eXBlOiAncHV0JywgLy8gNy4zLjJcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdExpc3RbaW5kZXhdLCAvLyA3LjMuM1xuICAgICAgICByZXNwb25zZSAvLyA3LjMuNFxuICAgICAgfVxuXG4gICAgICBvcGVyYXRpb25zLnB1c2gob3BlcmF0aW9uKSAvLyA3LjMuNVxuXG4gICAgICBpbmRleCsrIC8vIDcuMy42XG4gICAgfVxuXG4gICAgLy8gNy41XG4gICAgY29uc3QgY2FjaGVKb2JQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDcuNi4xXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcblxuICAgIC8vIDcuNi4yXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuI2JhdGNoQ2FjaGVPcGVyYXRpb25zKG9wZXJhdGlvbnMpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JEYXRhID0gZVxuICAgIH1cblxuICAgIC8vIDcuNi4zXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gNy42LjMuMVxuICAgICAgaWYgKGVycm9yRGF0YSA9PT0gbnVsbCkge1xuICAgICAgICBjYWNoZUpvYlByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyA3LjYuMy4yXG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZWplY3QoZXJyb3JEYXRhKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyA3LjdcbiAgICByZXR1cm4gY2FjaGVKb2JQcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIGFzeW5jIHB1dCAocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5wdXQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCBwcmVmaXgpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG4gICAgcmVzcG9uc2UgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZShyZXNwb25zZSwgcHJlZml4LCAncmVzcG9uc2UnKVxuXG4gICAgLy8gMS5cbiAgICBsZXQgaW5uZXJSZXF1ZXN0ID0gbnVsbFxuXG4gICAgLy8gMi5cbiAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlubmVyUmVxdWVzdCA9IHJlcXVlc3Rba1N0YXRlXVxuICAgIH0gZWxzZSB7IC8vIDMuXG4gICAgICBpbm5lclJlcXVlc3QgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgfVxuXG4gICAgLy8gNC5cbiAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKGlubmVyUmVxdWVzdC51cmwpIHx8IGlubmVyUmVxdWVzdC5tZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiAnRXhwZWN0ZWQgYW4gaHR0cC9zIHNjaGVtZSB3aGVuIG1ldGhvZCBpcyBub3QgR0VUJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA1LlxuICAgIGNvbnN0IGlubmVyUmVzcG9uc2UgPSByZXNwb25zZVtrU3RhdGVdXG5cbiAgICAvLyA2LlxuICAgIGlmIChpbm5lclJlc3BvbnNlLnN0YXR1cyA9PT0gMjA2KSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiAnR290IDIwNiBzdGF0dXMnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDcuXG4gICAgaWYgKGlubmVyUmVzcG9uc2UuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3ZhcnknKSkge1xuICAgICAgLy8gNy4xLlxuICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZFZhbHVlcyhpbm5lclJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgndmFyeScpKVxuXG4gICAgICAvLyA3LjIuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWUgb2YgZmllbGRWYWx1ZXMpIHtcbiAgICAgICAgLy8gNy4yLjFcbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT09ICcqJykge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICAgICAgbWVzc2FnZTogJ0dvdCAqIHZhcnkgZmllbGQgdmFsdWUnXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDguXG4gICAgaWYgKGlubmVyUmVzcG9uc2UuYm9keSAmJiAoaXNEaXN0dXJiZWQoaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbSkgfHwgaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbS5sb2NrZWQpKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiAnUmVzcG9uc2UgYm9keSBpcyBsb2NrZWQgb3IgZGlzdHVyYmVkJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA5LlxuICAgIGNvbnN0IGNsb25lZFJlc3BvbnNlID0gY2xvbmVSZXNwb25zZShpbm5lclJlc3BvbnNlKVxuXG4gICAgLy8gMTAuXG4gICAgY29uc3QgYm9keVJlYWRQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDExLlxuICAgIGlmIChpbm5lclJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMTEuMVxuICAgICAgY29uc3Qgc3RyZWFtID0gaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbVxuXG4gICAgICAvLyAxMS4yXG4gICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKClcblxuICAgICAgLy8gMTEuM1xuICAgICAgcmVhZEFsbEJ5dGVzKHJlYWRlcikudGhlbihib2R5UmVhZFByb21pc2UucmVzb2x2ZSwgYm9keVJlYWRQcm9taXNlLnJlamVjdClcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keVJlYWRQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgIH1cblxuICAgIC8vIDEyLlxuICAgIC8qKiBAdHlwZSB7Q2FjaGVCYXRjaE9wZXJhdGlvbltdfSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBbXVxuXG4gICAgLy8gMTMuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9ufSAqL1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgIHR5cGU6ICdwdXQnLCAvLyAxNC5cbiAgICAgIHJlcXVlc3Q6IGlubmVyUmVxdWVzdCwgLy8gMTUuXG4gICAgICByZXNwb25zZTogY2xvbmVkUmVzcG9uc2UgLy8gMTYuXG4gICAgfVxuXG4gICAgLy8gMTcuXG4gICAgb3BlcmF0aW9ucy5wdXNoKG9wZXJhdGlvbilcblxuICAgIC8vIDE5LlxuICAgIGNvbnN0IGJ5dGVzID0gYXdhaXQgYm9keVJlYWRQcm9taXNlLnByb21pc2VcblxuICAgIGlmIChjbG9uZWRSZXNwb25zZS5ib2R5ICE9IG51bGwpIHtcbiAgICAgIGNsb25lZFJlc3BvbnNlLmJvZHkuc291cmNlID0gYnl0ZXNcbiAgICB9XG5cbiAgICAvLyAxOS4xXG4gICAgY29uc3QgY2FjaGVKb2JQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlKClcblxuICAgIC8vIDE5LjIuMVxuICAgIGxldCBlcnJvckRhdGEgPSBudWxsXG5cbiAgICAvLyAxOS4yLjJcbiAgICB0cnkge1xuICAgICAgdGhpcy4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMob3BlcmF0aW9ucylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvckRhdGEgPSBlXG4gICAgfVxuXG4gICAgLy8gMTkuMi4zXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgLy8gMTkuMi4zLjFcbiAgICAgIGlmIChlcnJvckRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfSBlbHNlIHsgLy8gMTkuMi4zLjJcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlIChyZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5kZWxldGUnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICByZXF1ZXN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluZm8ocmVxdWVzdCwgcHJlZml4LCAncmVxdWVzdCcpXG4gICAgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzLkNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMsIHByZWZpeCwgJ29wdGlvbnMnKVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1JlcXVlc3R9XG4gICAgICovXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJyAmJiAhb3B0aW9ucy5pZ25vcmVNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydCh0eXBlb2YgcmVxdWVzdCA9PT0gJ3N0cmluZycpXG5cbiAgICAgIHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119ICovXG4gICAgY29uc3Qgb3BlcmF0aW9ucyA9IFtdXG5cbiAgICAvKiogQHR5cGUge0NhY2hlQmF0Y2hPcGVyYXRpb259ICovXG4gICAgY29uc3Qgb3BlcmF0aW9uID0ge1xuICAgICAgdHlwZTogJ2RlbGV0ZScsXG4gICAgICByZXF1ZXN0OiByLFxuICAgICAgb3B0aW9uc1xuICAgIH1cblxuICAgIG9wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pXG5cbiAgICBjb25zdCBjYWNoZUpvYlByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgbGV0IGVycm9yRGF0YSA9IG51bGxcbiAgICBsZXQgcmVxdWVzdFJlc3BvbnNlc1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlcXVlc3RSZXNwb25zZXMgPSB0aGlzLiNiYXRjaENhY2hlT3BlcmF0aW9ucyhvcGVyYXRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9yRGF0YSA9IGVcbiAgICB9XG5cbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICBpZiAoZXJyb3JEYXRhID09PSBudWxsKSB7XG4gICAgICAgIGNhY2hlSm9iUHJvbWlzZS5yZXNvbHZlKCEhcmVxdWVzdFJlc3BvbnNlcz8ubGVuZ3RoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVKb2JQcm9taXNlLnJlamVjdChlcnJvckRhdGEpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBjYWNoZUpvYlByb21pc2UucHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2RvbS1jYWNoZS1rZXlzXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7aW1wb3J0KCcuLi8uLi90eXBlcy9jYWNoZScpLkNhY2hlUXVlcnlPcHRpb25zfSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHJlYWRvbmx5IFJlcXVlc3RbXT59XG4gICAqL1xuICBhc3luYyBrZXlzIChyZXF1ZXN0ID0gdW5kZWZpbmVkLCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZS5rZXlzJ1xuXG4gICAgaWYgKHJlcXVlc3QgIT09IHVuZGVmaW5lZCkgcmVxdWVzdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvKHJlcXVlc3QsIHByZWZpeCwgJ3JlcXVlc3QnKVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyhvcHRpb25zLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIC8vIDEuXG4gICAgbGV0IHIgPSBudWxsXG5cbiAgICAvLyAyLlxuICAgIGlmIChyZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIDIuMVxuICAgICAgaWYgKHJlcXVlc3QgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgIC8vIDIuMS4xXG4gICAgICAgIHIgPSByZXF1ZXN0W2tTdGF0ZV1cblxuICAgICAgICAvLyAyLjEuMlxuICAgICAgICBpZiAoci5tZXRob2QgIT09ICdHRVQnICYmICFvcHRpb25zLmlnbm9yZU1ldGhvZCkge1xuICAgICAgICAgIHJldHVybiBbXVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0ID09PSAnc3RyaW5nJykgeyAvLyAyLjJcbiAgICAgICAgciA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QpW2tTdGF0ZV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LlxuICAgIGNvbnN0IHByb21pc2UgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gICAgLy8gNS5cbiAgICAvLyA1LjFcbiAgICBjb25zdCByZXF1ZXN0cyA9IFtdXG5cbiAgICAvLyA1LjJcbiAgICBpZiAocmVxdWVzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyA1LjIuMVxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0KSB7XG4gICAgICAgIC8vIDUuMi4xLjFcbiAgICAgICAgcmVxdWVzdHMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMF0pXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gNS4zXG4gICAgICAvLyA1LjMuMVxuICAgICAgY29uc3QgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUociwgb3B0aW9ucylcblxuICAgICAgLy8gNS4zLjJcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgLy8gNS4zLjIuMVxuICAgICAgICByZXF1ZXN0cy5wdXNoKHJlcXVlc3RSZXNwb25zZVswXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LjRcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAvLyA1LjQuMVxuICAgICAgY29uc3QgcmVxdWVzdExpc3QgPSBbXVxuXG4gICAgICAvLyA1LjQuMlxuICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RPYmplY3QgPSBmcm9tSW5uZXJSZXF1ZXN0KFxuICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgbmV3IEFib3J0Q29udHJvbGxlcigpLnNpZ25hbCxcbiAgICAgICAgICAnaW1tdXRhYmxlJ1xuICAgICAgICApXG4gICAgICAgIC8vIDUuNC4yLjFcbiAgICAgICAgcmVxdWVzdExpc3QucHVzaChyZXF1ZXN0T2JqZWN0KVxuICAgICAgfVxuXG4gICAgICAvLyA1LjQuM1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKE9iamVjdC5mcmVlemUocmVxdWVzdExpc3QpKVxuICAgIH0pXG5cbiAgICByZXR1cm4gcHJvbWlzZS5wcm9taXNlXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jYmF0Y2gtY2FjaGUtb3BlcmF0aW9ucy1hbGdvcml0aG1cbiAgICogQHBhcmFtIHtDYWNoZUJhdGNoT3BlcmF0aW9uW119IG9wZXJhdGlvbnNcbiAgICogQHJldHVybnMge3JlcXVlc3RSZXNwb25zZUxpc3R9XG4gICAqL1xuICAjYmF0Y2hDYWNoZU9wZXJhdGlvbnMgKG9wZXJhdGlvbnMpIHtcbiAgICAvLyAxLlxuICAgIGNvbnN0IGNhY2hlID0gdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0XG5cbiAgICAvLyAyLlxuICAgIGNvbnN0IGJhY2t1cENhY2hlID0gWy4uLmNhY2hlXVxuXG4gICAgLy8gMy5cbiAgICBjb25zdCBhZGRlZEl0ZW1zID0gW11cblxuICAgIC8vIDQuMVxuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIDQuMlxuICAgICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3BlcmF0aW9ucykge1xuICAgICAgICAvLyA0LjIuMVxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgIT09ICdkZWxldGUnICYmIG9wZXJhdGlvbi50eXBlICE9PSAncHV0Jykge1xuICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgIGhlYWRlcjogJ0NhY2hlLiNiYXRjaENhY2hlT3BlcmF0aW9ucycsXG4gICAgICAgICAgICBtZXNzYWdlOiAnb3BlcmF0aW9uIHR5cGUgZG9lcyBub3QgbWF0Y2ggXCJkZWxldGVcIiBvciBcInB1dFwiJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuMlxuICAgICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkZWxldGUnICYmIG9wZXJhdGlvbi5yZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdkZWxldGUgb3BlcmF0aW9uIHNob3VsZCBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIHJlc3BvbnNlJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuM1xuICAgICAgICBpZiAodGhpcy4jcXVlcnlDYWNoZShvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLm9wdGlvbnMsIGFkZGVkSXRlbXMpLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJz8/PycsICdJbnZhbGlkU3RhdGVFcnJvcicpXG4gICAgICAgIH1cblxuICAgICAgICAvLyA0LjIuNFxuICAgICAgICBsZXQgcmVxdWVzdFJlc3BvbnNlc1xuXG4gICAgICAgIC8vIDQuMi41XG4gICAgICAgIGlmIChvcGVyYXRpb24udHlwZSA9PT0gJ2RlbGV0ZScpIHtcbiAgICAgICAgICAvLyA0LjIuNS4xXG4gICAgICAgICAgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5vcHRpb25zKVxuXG4gICAgICAgICAgLy8gVE9ETzogdGhlIHNwZWMgaXMgd3JvbmcsIHRoaXMgaXMgbmVlZGVkIHRvIHBhc3MgV1BUc1xuICAgICAgICAgIGlmIChyZXF1ZXN0UmVzcG9uc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gNC4yLjUuMlxuICAgICAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGNhY2hlLmluZGV4T2YocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgICAgICAgYXNzZXJ0KGlkeCAhPT0gLTEpXG5cbiAgICAgICAgICAgIC8vIDQuMi41LjIuMVxuICAgICAgICAgICAgY2FjaGUuc3BsaWNlKGlkeCwgMSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdwdXQnKSB7IC8vIDQuMi42XG4gICAgICAgICAgLy8gNC4yLjYuMVxuICAgICAgICAgIGlmIChvcGVyYXRpb24ucmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAncHV0IG9wZXJhdGlvbiBzaG91bGQgaGF2ZSBhbiBhc3NvY2lhdGVkIHJlc3BvbnNlJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi4yXG4gICAgICAgICAgY29uc3QgciA9IG9wZXJhdGlvbi5yZXF1ZXN0XG5cbiAgICAgICAgICAvLyA0LjIuNi4zXG4gICAgICAgICAgaWYgKCF1cmxJc0h0dHBIdHRwc1NjaGVtZShyLnVybCkpIHtcbiAgICAgICAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgICAgICAgaGVhZGVyOiAnQ2FjaGUuI2JhdGNoQ2FjaGVPcGVyYXRpb25zJyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ2V4cGVjdGVkIGh0dHAgb3IgaHR0cHMgc2NoZW1lJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi40XG4gICAgICAgICAgaWYgKHIubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnbm90IGdldCBtZXRob2QnXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjVcbiAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICAgICAgICBoZWFkZXI6ICdDYWNoZS4jYmF0Y2hDYWNoZU9wZXJhdGlvbnMnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnb3B0aW9ucyBtdXN0IG5vdCBiZSBkZWZpbmVkJ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LjIuNi42XG4gICAgICAgICAgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUob3BlcmF0aW9uLnJlcXVlc3QpXG5cbiAgICAgICAgICAvLyA0LjIuNi43XG4gICAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2YgcmVxdWVzdFJlc3BvbnNlcykge1xuICAgICAgICAgICAgY29uc3QgaWR4ID0gY2FjaGUuaW5kZXhPZihyZXF1ZXN0UmVzcG9uc2UpXG4gICAgICAgICAgICBhc3NlcnQoaWR4ICE9PSAtMSlcblxuICAgICAgICAgICAgLy8gNC4yLjYuNy4xXG4gICAgICAgICAgICBjYWNoZS5zcGxpY2UoaWR4LCAxKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDQuMi42LjhcbiAgICAgICAgICBjYWNoZS5wdXNoKFtvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLnJlc3BvbnNlXSlcblxuICAgICAgICAgIC8vIDQuMi42LjEwXG4gICAgICAgICAgYWRkZWRJdGVtcy5wdXNoKFtvcGVyYXRpb24ucmVxdWVzdCwgb3BlcmF0aW9uLnJlc3BvbnNlXSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuMi43XG4gICAgICAgIHJlc3VsdExpc3QucHVzaChbb3BlcmF0aW9uLnJlcXVlc3QsIG9wZXJhdGlvbi5yZXNwb25zZV0pXG4gICAgICB9XG5cbiAgICAgIC8vIDQuM1xuICAgICAgcmV0dXJuIHJlc3VsdExpc3RcbiAgICB9IGNhdGNoIChlKSB7IC8vIDUuXG4gICAgICAvLyA1LjFcbiAgICAgIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdC5sZW5ndGggPSAwXG5cbiAgICAgIC8vIDUuMlxuICAgICAgdGhpcy4jcmVsZXZhbnRSZXF1ZXN0UmVzcG9uc2VMaXN0ID0gYmFja3VwQ2FjaGVcblxuICAgICAgLy8gNS4zXG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI3F1ZXJ5LWNhY2hlXG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0UXVlcnlcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnN9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fSB0YXJnZXRTdG9yYWdlXG4gICAqIEByZXR1cm5zIHtyZXF1ZXN0UmVzcG9uc2VMaXN0fVxuICAgKi9cbiAgI3F1ZXJ5Q2FjaGUgKHJlcXVlc3RRdWVyeSwgb3B0aW9ucywgdGFyZ2V0U3RvcmFnZSkge1xuICAgIC8qKiBAdHlwZSB7cmVxdWVzdFJlc3BvbnNlTGlzdH0gKi9cbiAgICBjb25zdCByZXN1bHRMaXN0ID0gW11cblxuICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXRTdG9yYWdlID8/IHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdFxuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0UmVzcG9uc2Ugb2Ygc3RvcmFnZSkge1xuICAgICAgY29uc3QgW2NhY2hlZFJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlXSA9IHJlcXVlc3RSZXNwb25zZVxuICAgICAgaWYgKHRoaXMuI3JlcXVlc3RNYXRjaGVzQ2FjaGVkSXRlbShyZXF1ZXN0UXVlcnksIGNhY2hlZFJlcXVlc3QsIGNhY2hlZFJlc3BvbnNlLCBvcHRpb25zKSkge1xuICAgICAgICByZXN1bHRMaXN0LnB1c2gocmVxdWVzdFJlc3BvbnNlKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRMaXN0XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jcmVxdWVzdC1tYXRjaGVzLWNhY2hlZC1pdGVtLWFsZ29yaXRobVxuICAgKiBAcGFyYW0ge2FueX0gcmVxdWVzdFF1ZXJ5XG4gICAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gICAqIEBwYXJhbSB7YW55IHwgbnVsbH0gcmVzcG9uc2VcbiAgICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3R5cGVzL2NhY2hlJykuQ2FjaGVRdWVyeU9wdGlvbnMgfCB1bmRlZmluZWR9IG9wdGlvbnNcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICAjcmVxdWVzdE1hdGNoZXNDYWNoZWRJdGVtIChyZXF1ZXN0UXVlcnksIHJlcXVlc3QsIHJlc3BvbnNlID0gbnVsbCwgb3B0aW9ucykge1xuICAgIC8vIGlmIChvcHRpb25zPy5pZ25vcmVNZXRob2QgPT09IGZhbHNlICYmIHJlcXVlc3QubWV0aG9kID09PSAnR0VUJykge1xuICAgIC8vICAgcmV0dXJuIGZhbHNlXG4gICAgLy8gfVxuXG4gICAgY29uc3QgcXVlcnlVUkwgPSBuZXcgVVJMKHJlcXVlc3RRdWVyeS51cmwpXG5cbiAgICBjb25zdCBjYWNoZWRVUkwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKVxuXG4gICAgaWYgKG9wdGlvbnM/Lmlnbm9yZVNlYXJjaCkge1xuICAgICAgY2FjaGVkVVJMLnNlYXJjaCA9ICcnXG5cbiAgICAgIHF1ZXJ5VVJMLnNlYXJjaCA9ICcnXG4gICAgfVxuXG4gICAgaWYgKCF1cmxFcXVhbHMocXVlcnlVUkwsIGNhY2hlZFVSTCwgdHJ1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHJlc3BvbnNlID09IG51bGwgfHxcbiAgICAgIG9wdGlvbnM/Lmlnbm9yZVZhcnkgfHxcbiAgICAgICFyZXNwb25zZS5oZWFkZXJzTGlzdC5jb250YWlucygndmFyeScpXG4gICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0RmllbGRWYWx1ZXMocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCd2YXJ5JykpXG5cbiAgICBmb3IgKGNvbnN0IGZpZWxkVmFsdWUgb2YgZmllbGRWYWx1ZXMpIHtcbiAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnKicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlcXVlc3RWYWx1ZSA9IHJlcXVlc3QuaGVhZGVyc0xpc3QuZ2V0KGZpZWxkVmFsdWUpXG4gICAgICBjb25zdCBxdWVyeVZhbHVlID0gcmVxdWVzdFF1ZXJ5LmhlYWRlcnNMaXN0LmdldChmaWVsZFZhbHVlKVxuXG4gICAgICAvLyBJZiBvbmUgaGFzIHRoZSBoZWFkZXIgYW5kIHRoZSBvdGhlciBkb2Vzbid0LCBvciBvbmUgaGFzXG4gICAgICAvLyBhIGRpZmZlcmVudCB2YWx1ZSB0aGFuIHRoZSBvdGhlciwgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAocmVxdWVzdFZhbHVlICE9PSBxdWVyeVZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAjaW50ZXJuYWxNYXRjaEFsbCAocmVxdWVzdCwgb3B0aW9ucywgbWF4UmVzcG9uc2VzID0gSW5maW5pdHkpIHtcbiAgICAvLyAxLlxuICAgIGxldCByID0gbnVsbFxuXG4gICAgLy8gMi5cbiAgICBpZiAocmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAocmVxdWVzdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgLy8gMi4xLjFcbiAgICAgICAgciA9IHJlcXVlc3Rba1N0YXRlXVxuXG4gICAgICAgIC8vIDIuMS4yXG4gICAgICAgIGlmIChyLm1ldGhvZCAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuaWdub3JlTWV0aG9kKSB7XG4gICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIDIuMi4xXG4gICAgICAgIHIgPSBuZXcgUmVxdWVzdChyZXF1ZXN0KVtrU3RhdGVdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNS5cbiAgICAvLyA1LjFcbiAgICBjb25zdCByZXNwb25zZXMgPSBbXVxuXG4gICAgLy8gNS4yXG4gICAgaWYgKHJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gNS4yLjFcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHRoaXMuI3JlbGV2YW50UmVxdWVzdFJlc3BvbnNlTGlzdCkge1xuICAgICAgICByZXNwb25zZXMucHVzaChyZXF1ZXN0UmVzcG9uc2VbMV0pXG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gNS4zXG4gICAgICAvLyA1LjMuMVxuICAgICAgY29uc3QgcmVxdWVzdFJlc3BvbnNlcyA9IHRoaXMuI3F1ZXJ5Q2FjaGUociwgb3B0aW9ucylcblxuICAgICAgLy8gNS4zLjJcbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdFJlc3BvbnNlIG9mIHJlcXVlc3RSZXNwb25zZXMpIHtcbiAgICAgICAgcmVzcG9uc2VzLnB1c2gocmVxdWVzdFJlc3BvbnNlWzFdKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuNFxuICAgIC8vIFdlIGRvbid0IGltcGxlbWVudCBDT1JzIHNvIHdlIGRvbid0IG5lZWQgdG8gbG9vcCBvdmVyIHRoZSByZXNwb25zZXMsIHlheSFcblxuICAgIC8vIDUuNS4xXG4gICAgY29uc3QgcmVzcG9uc2VMaXN0ID0gW11cblxuICAgIC8vIDUuNS4yXG4gICAgZm9yIChjb25zdCByZXNwb25zZSBvZiByZXNwb25zZXMpIHtcbiAgICAgIC8vIDUuNS4yLjFcbiAgICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gZnJvbUlubmVyUmVzcG9uc2UocmVzcG9uc2UsICdpbW11dGFibGUnKVxuXG4gICAgICByZXNwb25zZUxpc3QucHVzaChyZXNwb25zZU9iamVjdC5jbG9uZSgpKVxuXG4gICAgICBpZiAocmVzcG9uc2VMaXN0Lmxlbmd0aCA+PSBtYXhSZXNwb25zZXMpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA2LlxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3BvbnNlTGlzdClcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDYWNoZS5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0NhY2hlJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgbWF0Y2g6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG1hdGNoQWxsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBhZGQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGFkZEFsbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcHV0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGtleXM6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbmNvbnN0IGNhY2hlUXVlcnlPcHRpb25Db252ZXJ0ZXJzID0gW1xuICB7XG4gICAga2V5OiAnaWdub3JlU2VhcmNoJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnaWdub3JlTWV0aG9kJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnaWdub3JlVmFyeScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfVxuXVxuXG53ZWJpZGwuY29udmVydGVycy5DYWNoZVF1ZXJ5T3B0aW9ucyA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKGNhY2hlUXVlcnlPcHRpb25Db252ZXJ0ZXJzKVxuXG53ZWJpZGwuY29udmVydGVycy5NdWx0aUNhY2hlUXVlcnlPcHRpb25zID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5jYWNoZVF1ZXJ5T3B0aW9uQ29udmVydGVycyxcbiAge1xuICAgIGtleTogJ2NhY2hlTmFtZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuUmVzcG9uc2UgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFJlc3BvbnNlKVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8UmVxdWVzdEluZm8+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLlJlcXVlc3RJbmZvXG4pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDYWNoZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cache/cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cache/cachestorage.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/cachestorage.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kConstruct } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/cache/symbols.js\")\nconst { Cache } = __webpack_require__(/*! ./cache */ \"(rsc)/./node_modules/undici/lib/web/cache/cache.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nclass CacheStorage {\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map\n   * @type {Map<string, import('./cache').requestResponseList}\n   */\n  #caches = new Map()\n\n  constructor () {\n    if (arguments[0] !== kConstruct) {\n      webidl.illegalConstructor()\n    }\n\n    webidl.util.markAsUncloneable(this)\n  }\n\n  async match (request, options = {}) {\n    webidl.brandCheck(this, CacheStorage)\n    webidl.argumentLengthCheck(arguments, 1, 'CacheStorage.match')\n\n    request = webidl.converters.RequestInfo(request)\n    options = webidl.converters.MultiCacheQueryOptions(options)\n\n    // 1.\n    if (options.cacheName != null) {\n      // 1.1.1.1\n      if (this.#caches.has(options.cacheName)) {\n        // 1.1.1.1.1\n        const cacheList = this.#caches.get(options.cacheName)\n        const cache = new Cache(kConstruct, cacheList)\n\n        return await cache.match(request, options)\n      }\n    } else { // 2.\n      // 2.2\n      for (const cacheList of this.#caches.values()) {\n        const cache = new Cache(kConstruct, cacheList)\n\n        // 2.2.1.2\n        const response = await cache.match(request, options)\n\n        if (response !== undefined) {\n          return response\n        }\n      }\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-has\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async has (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.has'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    // 2.1.1\n    // 2.2\n    return this.#caches.has(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open\n   * @param {string} cacheName\n   * @returns {Promise<Cache>}\n   */\n  async open (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.open'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    // 2.1\n    if (this.#caches.has(cacheName)) {\n      // await caches.open('v1') !== await caches.open('v1')\n\n      // 2.1.1\n      const cache = this.#caches.get(cacheName)\n\n      // 2.1.1.1\n      return new Cache(kConstruct, cache)\n    }\n\n    // 2.2\n    const cache = []\n\n    // 2.3\n    this.#caches.set(cacheName, cache)\n\n    // 2.4\n    return new Cache(kConstruct, cache)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete\n   * @param {string} cacheName\n   * @returns {Promise<boolean>}\n   */\n  async delete (cacheName) {\n    webidl.brandCheck(this, CacheStorage)\n\n    const prefix = 'CacheStorage.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    cacheName = webidl.converters.DOMString(cacheName, prefix, 'cacheName')\n\n    return this.#caches.delete(cacheName)\n  }\n\n  /**\n   * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys\n   * @returns {Promise<string[]>}\n   */\n  async keys () {\n    webidl.brandCheck(this, CacheStorage)\n\n    // 2.1\n    const keys = this.#caches.keys()\n\n    // 2.2\n    return [...keys]\n  }\n}\n\nObject.defineProperties(CacheStorage.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CacheStorage',\n    configurable: true\n  },\n  match: kEnumerableProperty,\n  has: kEnumerableProperty,\n  open: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  keys: kEnumerableProperty\n})\n\nmodule.exports = {\n  CacheStorage\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvY2FjaGVzdG9yYWdlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsdUVBQVc7QUFDMUMsUUFBUSxRQUFRLEVBQUUsbUJBQU8sQ0FBQyxtRUFBUztBQUNuQyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjtBQUM1QyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCOztBQUV6RDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcY2FjaGVcXGNhY2hlc3RvcmFnZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyBDYWNoZSB9ID0gcmVxdWlyZSgnLi9jYWNoZScpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcblxuY2xhc3MgQ2FjaGVTdG9yYWdlIHtcbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2Rmbi1yZWxldmFudC1uYW1lLXRvLWNhY2hlLW1hcFxuICAgKiBAdHlwZSB7TWFwPHN0cmluZywgaW1wb3J0KCcuL2NhY2hlJykucmVxdWVzdFJlc3BvbnNlTGlzdH1cbiAgICovXG4gICNjYWNoZXMgPSBuZXcgTWFwKClcblxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAhPT0ga0NvbnN0cnVjdCkge1xuICAgICAgd2ViaWRsLmlsbGVnYWxDb25zdHJ1Y3RvcigpXG4gICAgfVxuXG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcbiAgfVxuXG4gIGFzeW5jIG1hdGNoIChyZXF1ZXN0LCBvcHRpb25zID0ge30pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDYWNoZVN0b3JhZ2UpXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnQ2FjaGVTdG9yYWdlLm1hdGNoJylcblxuICAgIHJlcXVlc3QgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhyZXF1ZXN0KVxuICAgIG9wdGlvbnMgPSB3ZWJpZGwuY29udmVydGVycy5NdWx0aUNhY2hlUXVlcnlPcHRpb25zKG9wdGlvbnMpXG5cbiAgICAvLyAxLlxuICAgIGlmIChvcHRpb25zLmNhY2hlTmFtZSAhPSBudWxsKSB7XG4gICAgICAvLyAxLjEuMS4xXG4gICAgICBpZiAodGhpcy4jY2FjaGVzLmhhcyhvcHRpb25zLmNhY2hlTmFtZSkpIHtcbiAgICAgICAgLy8gMS4xLjEuMS4xXG4gICAgICAgIGNvbnN0IGNhY2hlTGlzdCA9IHRoaXMuI2NhY2hlcy5nZXQob3B0aW9ucy5jYWNoZU5hbWUpXG4gICAgICAgIGNvbnN0IGNhY2hlID0gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlTGlzdClcblxuICAgICAgICByZXR1cm4gYXdhaXQgY2FjaGUubWF0Y2gocmVxdWVzdCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyAyLlxuICAgICAgLy8gMi4yXG4gICAgICBmb3IgKGNvbnN0IGNhY2hlTGlzdCBvZiB0aGlzLiNjYWNoZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBuZXcgQ2FjaGUoa0NvbnN0cnVjdCwgY2FjaGVMaXN0KVxuXG4gICAgICAgIC8vIDIuMi4xLjJcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjYWNoZS5tYXRjaChyZXF1ZXN0LCBvcHRpb25zKVxuXG4gICAgICAgIGlmIChyZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jY2FjaGUtc3RvcmFnZS1oYXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG4gIGFzeW5jIGhhcyAoY2FjaGVOYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlU3RvcmFnZS5oYXMnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBjYWNoZU5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoY2FjaGVOYW1lLCBwcmVmaXgsICdjYWNoZU5hbWUnKVxuXG4gICAgLy8gMi4xLjFcbiAgICAvLyAyLjJcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVzLmhhcyhjYWNoZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vU2VydmljZVdvcmtlci8jZG9tLWNhY2hlc3RvcmFnZS1vcGVuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Q2FjaGU+fVxuICAgKi9cbiAgYXN5bmMgb3BlbiAoY2FjaGVOYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0NhY2hlU3RvcmFnZS5vcGVuJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSwgcHJlZml4LCAnY2FjaGVOYW1lJylcblxuICAgIC8vIDIuMVxuICAgIGlmICh0aGlzLiNjYWNoZXMuaGFzKGNhY2hlTmFtZSkpIHtcbiAgICAgIC8vIGF3YWl0IGNhY2hlcy5vcGVuKCd2MScpICE9PSBhd2FpdCBjYWNoZXMub3BlbigndjEnKVxuXG4gICAgICAvLyAyLjEuMVxuICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLiNjYWNoZXMuZ2V0KGNhY2hlTmFtZSlcblxuICAgICAgLy8gMi4xLjEuMVxuICAgICAgcmV0dXJuIG5ldyBDYWNoZShrQ29uc3RydWN0LCBjYWNoZSlcbiAgICB9XG5cbiAgICAvLyAyLjJcbiAgICBjb25zdCBjYWNoZSA9IFtdXG5cbiAgICAvLyAyLjNcbiAgICB0aGlzLiNjYWNoZXMuc2V0KGNhY2hlTmFtZSwgY2FjaGUpXG5cbiAgICAvLyAyLjRcbiAgICByZXR1cm4gbmV3IENhY2hlKGtDb25zdHJ1Y3QsIGNhY2hlKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL1NlcnZpY2VXb3JrZXIvI2NhY2hlLXN0b3JhZ2UtZGVsZXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBkZWxldGUgKGNhY2hlTmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIENhY2hlU3RvcmFnZSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdDYWNoZVN0b3JhZ2UuZGVsZXRlJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgY2FjaGVOYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKGNhY2hlTmFtZSwgcHJlZml4LCAnY2FjaGVOYW1lJylcblxuICAgIHJldHVybiB0aGlzLiNjYWNoZXMuZGVsZXRlKGNhY2hlTmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9TZXJ2aWNlV29ya2VyLyNjYWNoZS1zdG9yYWdlLWtleXNcbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nW10+fVxuICAgKi9cbiAgYXN5bmMga2V5cyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2FjaGVTdG9yYWdlKVxuXG4gICAgLy8gMi4xXG4gICAgY29uc3Qga2V5cyA9IHRoaXMuI2NhY2hlcy5rZXlzKClcblxuICAgIC8vIDIuMlxuICAgIHJldHVybiBbLi4ua2V5c11cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDYWNoZVN0b3JhZ2UucHJvdG90eXBlLCB7XG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdDYWNoZVN0b3JhZ2UnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBtYXRjaDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGFzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvcGVuOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGtleXM6IGtFbnVtZXJhYmxlUHJvcGVydHlcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBDYWNoZVN0b3JhZ2Vcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cache/cachestorage.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cache/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/symbols.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports = {\n  kConstruct: (__webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\").kConstruct)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBLGNBQWMsNkdBQXdDO0FBQ3REIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcY2FjaGVcXHN5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrQ29uc3RydWN0OiByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKS5rQ29uc3RydWN0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cache/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cache/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/cache/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { isValidHeaderName } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\n\n/**\n * @see https://url.spec.whatwg.org/#concept-url-equals\n * @param {URL} A\n * @param {URL} B\n * @param {boolean | undefined} excludeFragment\n * @returns {boolean}\n */\nfunction urlEquals (A, B, excludeFragment = false) {\n  const serializedA = URLSerializer(A, excludeFragment)\n\n  const serializedB = URLSerializer(B, excludeFragment)\n\n  return serializedA === serializedB\n}\n\n/**\n * @see https://github.com/chromium/chromium/blob/694d20d134cb553d8d89e5500b9148012b1ba299/content/browser/cache_storage/cache_storage_cache.cc#L260-L262\n * @param {string} header\n */\nfunction getFieldValues (header) {\n  assert(header !== null)\n\n  const values = []\n\n  for (let value of header.split(',')) {\n    value = value.trim()\n\n    if (isValidHeaderName(value)) {\n      values.push(value)\n    }\n  }\n\n  return values\n}\n\nmodule.exports = {\n  urlEquals,\n  getFieldValues\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY2FjaGUvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjtBQUNyRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsd0VBQWU7O0FBRXJEO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcscUJBQXFCO0FBQ2hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjYWNoZVxcdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhLXVybCcpXG5jb25zdCB7IGlzVmFsaWRIZWFkZXJOYW1lIH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC11cmwtZXF1YWxzXG4gKiBAcGFyYW0ge1VSTH0gQVxuICogQHBhcmFtIHtVUkx9IEJcbiAqIEBwYXJhbSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gZXhjbHVkZUZyYWdtZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gdXJsRXF1YWxzIChBLCBCLCBleGNsdWRlRnJhZ21lbnQgPSBmYWxzZSkge1xuICBjb25zdCBzZXJpYWxpemVkQSA9IFVSTFNlcmlhbGl6ZXIoQSwgZXhjbHVkZUZyYWdtZW50KVxuXG4gIGNvbnN0IHNlcmlhbGl6ZWRCID0gVVJMU2VyaWFsaXplcihCLCBleGNsdWRlRnJhZ21lbnQpXG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWRBID09PSBzZXJpYWxpemVkQlxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2Nocm9taXVtL2Nocm9taXVtL2Jsb2IvNjk0ZDIwZDEzNGNiNTUzZDhkODllNTUwMGI5MTQ4MDEyYjFiYTI5OS9jb250ZW50L2Jyb3dzZXIvY2FjaGVfc3RvcmFnZS9jYWNoZV9zdG9yYWdlX2NhY2hlLmNjI0wyNjAtTDI2MlxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICovXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlcyAoaGVhZGVyKSB7XG4gIGFzc2VydChoZWFkZXIgIT09IG51bGwpXG5cbiAgY29uc3QgdmFsdWVzID0gW11cblxuICBmb3IgKGxldCB2YWx1ZSBvZiBoZWFkZXIuc3BsaXQoJywnKSkge1xuICAgIHZhbHVlID0gdmFsdWUudHJpbSgpXG5cbiAgICBpZiAoaXNWYWxpZEhlYWRlck5hbWUodmFsdWUpKSB7XG4gICAgICB2YWx1ZXMucHVzaCh2YWx1ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB1cmxFcXVhbHMsXG4gIGdldEZpZWxkVmFsdWVzXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cache/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/constants.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/constants.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-attribute-value-size\nconst maxAttributeValueSize = 1024\n\n// https://wicg.github.io/cookie-store/#cookie-maximum-name-value-pair-size\nconst maxNameValuePairSize = 4096\n\nmodule.exports = {\n  maxAttributeValueSize,\n  maxNameValuePairSize\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcY29va2llc1xcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBodHRwczovL3dpY2cuZ2l0aHViLmlvL2Nvb2tpZS1zdG9yZS8jY29va2llLW1heGltdW0tYXR0cmlidXRlLXZhbHVlLXNpemVcbmNvbnN0IG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSA9IDEwMjRcblxuLy8gaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9jb29raWUtc3RvcmUvI2Nvb2tpZS1tYXhpbXVtLW5hbWUtdmFsdWUtcGFpci1zaXplXG5jb25zdCBtYXhOYW1lVmFsdWVQYWlyU2l6ZSA9IDQwOTZcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSxcbiAgbWF4TmFtZVZhbHVlUGFpclNpemVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/index.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { parseSetCookie } = __webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/undici/lib/web/cookies/parse.js\")\nconst { stringify } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/cookies/util.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { Headers } = __webpack_require__(/*! ../fetch/headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\n\n/**\n * @typedef {Object} Cookie\n * @property {string} name\n * @property {string} value\n * @property {Date|number|undefined} expires\n * @property {number|undefined} maxAge\n * @property {string|undefined} domain\n * @property {string|undefined} path\n * @property {boolean|undefined} secure\n * @property {boolean|undefined} httpOnly\n * @property {'Strict'|'Lax'|'None'} sameSite\n * @property {string[]} unparsed\n */\n\n/**\n * @param {Headers} headers\n * @returns {Record<string, string>}\n */\nfunction getCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, 'getCookies')\n\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  const cookie = headers.get('cookie')\n  const out = {}\n\n  if (!cookie) {\n    return out\n  }\n\n  for (const piece of cookie.split(';')) {\n    const [name, ...value] = piece.split('=')\n\n    out[name.trim()] = value.join('=')\n  }\n\n  return out\n}\n\n/**\n * @param {Headers} headers\n * @param {string} name\n * @param {{ path?: string, domain?: string }|undefined} attributes\n * @returns {void}\n */\nfunction deleteCookie (headers, name, attributes) {\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  const prefix = 'deleteCookie'\n  webidl.argumentLengthCheck(arguments, 2, prefix)\n\n  name = webidl.converters.DOMString(name, prefix, 'name')\n  attributes = webidl.converters.DeleteCookieAttributes(attributes)\n\n  // Matches behavior of\n  // https://github.com/denoland/deno_std/blob/63827b16330b82489a04614027c33b7904e08be5/http/cookie.ts#L278\n  setCookie(headers, {\n    name,\n    value: '',\n    expires: new Date(0),\n    ...attributes\n  })\n}\n\n/**\n * @param {Headers} headers\n * @returns {Cookie[]}\n */\nfunction getSetCookies (headers) {\n  webidl.argumentLengthCheck(arguments, 1, 'getSetCookies')\n\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  const cookies = headers.getSetCookie()\n\n  if (!cookies) {\n    return []\n  }\n\n  return cookies.map((pair) => parseSetCookie(pair))\n}\n\n/**\n * @param {Headers} headers\n * @param {Cookie} cookie\n * @returns {void}\n */\nfunction setCookie (headers, cookie) {\n  webidl.argumentLengthCheck(arguments, 2, 'setCookie')\n\n  webidl.brandCheck(headers, Headers, { strict: false })\n\n  cookie = webidl.converters.Cookie(cookie)\n\n  const str = stringify(cookie)\n\n  if (str) {\n    headers.append('Set-Cookie', str)\n  }\n}\n\nwebidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: () => null\n  }\n])\n\nwebidl.converters.Cookie = webidl.dictionaryConverter([\n  {\n    converter: webidl.converters.DOMString,\n    key: 'name'\n  },\n  {\n    converter: webidl.converters.DOMString,\n    key: 'value'\n  },\n  {\n    converter: webidl.nullableConverter((value) => {\n      if (typeof value === 'number') {\n        return webidl.converters['unsigned long long'](value)\n      }\n\n      return new Date(value)\n    }),\n    key: 'expires',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters['long long']),\n    key: 'maxAge',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'domain',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.DOMString),\n    key: 'path',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'secure',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.nullableConverter(webidl.converters.boolean),\n    key: 'httpOnly',\n    defaultValue: () => null\n  },\n  {\n    converter: webidl.converters.USVString,\n    key: 'sameSite',\n    allowedValues: ['Strict', 'Lax', 'None']\n  },\n  {\n    converter: webidl.sequenceConverter(webidl.converters.DOMString),\n    key: 'unparsed',\n    defaultValue: () => new Array(0)\n  }\n])\n\nmodule.exports = {\n  getCookies,\n  deleteCookie,\n  getSetCookies,\n  setCookie\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMscUVBQVM7QUFDNUMsUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxtRUFBUTtBQUN0QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjtBQUM1QyxRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDhFQUFrQjs7QUFFOUM7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLGtCQUFrQjtBQUNoQyxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLG1CQUFtQjtBQUNqQyxjQUFjLHVCQUF1QjtBQUNyQyxjQUFjLFVBQVU7QUFDeEI7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsZUFBZTs7QUFFdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxnQ0FBZ0MsWUFBWTtBQUN6RCxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdDQUF3QyxlQUFlOztBQUV2RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsZUFBZTs7QUFFdkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLGVBQWU7O0FBRXZEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGNvb2tpZXNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHBhcnNlU2V0Q29va2llIH0gPSByZXF1aXJlKCcuL3BhcnNlJylcbmNvbnN0IHsgc3RyaW5naWZ5IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5jb25zdCB7IEhlYWRlcnMgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL2hlYWRlcnMnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENvb2tpZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2YWx1ZVxuICogQHByb3BlcnR5IHtEYXRlfG51bWJlcnx1bmRlZmluZWR9IGV4cGlyZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfHVuZGVmaW5lZH0gbWF4QWdlXG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IGRvbWFpblxuICogQHByb3BlcnR5IHtzdHJpbmd8dW5kZWZpbmVkfSBwYXRoXG4gKiBAcHJvcGVydHkge2Jvb2xlYW58dW5kZWZpbmVkfSBzZWN1cmVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnx1bmRlZmluZWR9IGh0dHBPbmx5XG4gKiBAcHJvcGVydHkgeydTdHJpY3QnfCdMYXgnfCdOb25lJ30gc2FtZVNpdGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IHVucGFyc2VkXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0hlYWRlcnN9IGhlYWRlcnNcbiAqIEByZXR1cm5zIHtSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBnZXRDb29raWVzIChoZWFkZXJzKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ2dldENvb2tpZXMnKVxuXG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIGNvbnN0IGNvb2tpZSA9IGhlYWRlcnMuZ2V0KCdjb29raWUnKVxuICBjb25zdCBvdXQgPSB7fVxuXG4gIGlmICghY29va2llKSB7XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgZm9yIChjb25zdCBwaWVjZSBvZiBjb29raWUuc3BsaXQoJzsnKSkge1xuICAgIGNvbnN0IFtuYW1lLCAuLi52YWx1ZV0gPSBwaWVjZS5zcGxpdCgnPScpXG5cbiAgICBvdXRbbmFtZS50cmltKCldID0gdmFsdWUuam9pbignPScpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtIZWFkZXJzfSBoZWFkZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7IHBhdGg/OiBzdHJpbmcsIGRvbWFpbj86IHN0cmluZyB9fHVuZGVmaW5lZH0gYXR0cmlidXRlc1xuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZUNvb2tpZSAoaGVhZGVycywgbmFtZSwgYXR0cmlidXRlcykge1xuICB3ZWJpZGwuYnJhbmRDaGVjayhoZWFkZXJzLCBIZWFkZXJzLCB7IHN0cmljdDogZmFsc2UgfSlcblxuICBjb25zdCBwcmVmaXggPSAnZGVsZXRlQ29va2llJ1xuICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsIHByZWZpeClcblxuICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuICBhdHRyaWJ1dGVzID0gd2ViaWRsLmNvbnZlcnRlcnMuRGVsZXRlQ29va2llQXR0cmlidXRlcyhhdHRyaWJ1dGVzKVxuXG4gIC8vIE1hdGNoZXMgYmVoYXZpb3Igb2ZcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rlbm9sYW5kL2Rlbm9fc3RkL2Jsb2IvNjM4MjdiMTYzMzBiODI0ODlhMDQ2MTQwMjdjMzNiNzkwNGUwOGJlNS9odHRwL2Nvb2tpZS50cyNMMjc4XG4gIHNldENvb2tpZShoZWFkZXJzLCB7XG4gICAgbmFtZSxcbiAgICB2YWx1ZTogJycsXG4gICAgZXhwaXJlczogbmV3IERhdGUoMCksXG4gICAgLi4uYXR0cmlidXRlc1xuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHJldHVybnMge0Nvb2tpZVtdfVxuICovXG5mdW5jdGlvbiBnZXRTZXRDb29raWVzIChoZWFkZXJzKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ2dldFNldENvb2tpZXMnKVxuXG4gIHdlYmlkbC5icmFuZENoZWNrKGhlYWRlcnMsIEhlYWRlcnMsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gIGNvbnN0IGNvb2tpZXMgPSBoZWFkZXJzLmdldFNldENvb2tpZSgpXG5cbiAgaWYgKCFjb29raWVzKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICByZXR1cm4gY29va2llcy5tYXAoKHBhaXIpID0+IHBhcnNlU2V0Q29va2llKHBhaXIpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SGVhZGVyc30gaGVhZGVyc1xuICogQHBhcmFtIHtDb29raWV9IGNvb2tpZVxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHNldENvb2tpZSAoaGVhZGVycywgY29va2llKSB7XG4gIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgJ3NldENvb2tpZScpXG5cbiAgd2ViaWRsLmJyYW5kQ2hlY2soaGVhZGVycywgSGVhZGVycywgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgY29va2llID0gd2ViaWRsLmNvbnZlcnRlcnMuQ29va2llKGNvb2tpZSlcblxuICBjb25zdCBzdHIgPSBzdHJpbmdpZnkoY29va2llKVxuXG4gIGlmIChzdHIpIHtcbiAgICBoZWFkZXJzLmFwcGVuZCgnU2V0LUNvb2tpZScsIHN0cilcbiAgfVxufVxuXG53ZWJpZGwuY29udmVydGVycy5EZWxldGVDb29raWVBdHRyaWJ1dGVzID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nKSxcbiAgICBrZXk6ICdwYXRoJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyksXG4gICAga2V5OiAnZG9tYWluJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuQ29va2llID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAga2V5OiAnbmFtZSdcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGtleTogJ3ZhbHVlJ1xuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcgbG9uZyddKHZhbHVlKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUpXG4gICAgfSksXG4gICAga2V5OiAnZXhwaXJlcycsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVyc1snbG9uZyBsb25nJ10pLFxuICAgIGtleTogJ21heEFnZScsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ2RvbWFpbicsXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ3BhdGgnLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbiksXG4gICAga2V5OiAnc2VjdXJlJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4pLFxuICAgIGtleTogJ2h0dHBPbmx5JyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG51bGxcbiAgfSxcbiAge1xuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGtleTogJ3NhbWVTaXRlJyxcbiAgICBhbGxvd2VkVmFsdWVzOiBbJ1N0cmljdCcsICdMYXgnLCAnTm9uZSddXG4gIH0sXG4gIHtcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcpLFxuICAgIGtleTogJ3VucGFyc2VkJyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IG5ldyBBcnJheSgwKVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29va2llcyxcbiAgZGVsZXRlQ29va2llLFxuICBnZXRTZXRDb29raWVzLFxuICBzZXRDb29raWVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/parse.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/parse.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { maxNameValuePairSize, maxAttributeValueSize } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/cookies/constants.js\")\nconst { isCTLExcludingHtab } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/cookies/util.js\")\nconst { collectASequenceOfCodePointsFast } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\n/**\n * @description Parses the field-value attributes of a set-cookie header string.\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} header\n * @returns if the header is invalid, null will be returned\n */\nfunction parseSetCookie (header) {\n  // 1. If the set-cookie-string contains a %x00-08 / %x0A-1F / %x7F\n  //    character (CTL characters excluding HTAB): Abort these steps and\n  //    ignore the set-cookie-string entirely.\n  if (isCTLExcludingHtab(header)) {\n    return null\n  }\n\n  let nameValuePair = ''\n  let unparsedAttributes = ''\n  let name = ''\n  let value = ''\n\n  // 2. If the set-cookie-string contains a %x3B (\";\") character:\n  if (header.includes(';')) {\n    // 1. The name-value-pair string consists of the characters up to,\n    //    but not including, the first %x3B (\";\"), and the unparsed-\n    //    attributes consist of the remainder of the set-cookie-string\n    //    (including the %x3B (\";\") in question).\n    const position = { position: 0 }\n\n    nameValuePair = collectASequenceOfCodePointsFast(';', header, position)\n    unparsedAttributes = header.slice(position.position)\n  } else {\n    // Otherwise:\n\n    // 1. The name-value-pair string consists of all the characters\n    //    contained in the set-cookie-string, and the unparsed-\n    //    attributes is the empty string.\n    nameValuePair = header\n  }\n\n  // 3. If the name-value-pair string lacks a %x3D (\"=\") character, then\n  //    the name string is empty, and the value string is the value of\n  //    name-value-pair.\n  if (!nameValuePair.includes('=')) {\n    value = nameValuePair\n  } else {\n    //    Otherwise, the name string consists of the characters up to, but\n    //    not including, the first %x3D (\"=\") character, and the (possibly\n    //    empty) value string consists of the characters after the first\n    //    %x3D (\"=\") character.\n    const position = { position: 0 }\n    name = collectASequenceOfCodePointsFast(\n      '=',\n      nameValuePair,\n      position\n    )\n    value = nameValuePair.slice(position.position + 1)\n  }\n\n  // 4. Remove any leading or trailing WSP characters from the name\n  //    string and the value string.\n  name = name.trim()\n  value = value.trim()\n\n  // 5. If the sum of the lengths of the name string and the value string\n  //    is more than 4096 octets, abort these steps and ignore the set-\n  //    cookie-string entirely.\n  if (name.length + value.length > maxNameValuePairSize) {\n    return null\n  }\n\n  // 6. The cookie-name is the name string, and the cookie-value is the\n  //    value string.\n  return {\n    name, value, ...parseUnparsedAttributes(unparsedAttributes)\n  }\n}\n\n/**\n * Parses the remaining attributes of a set-cookie header\n * @see https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4\n * @param {string} unparsedAttributes\n * @param {[Object.<string, unknown>]={}} cookieAttributeList\n */\nfunction parseUnparsedAttributes (unparsedAttributes, cookieAttributeList = {}) {\n  // 1. If the unparsed-attributes string is empty, skip the rest of\n  //    these steps.\n  if (unparsedAttributes.length === 0) {\n    return cookieAttributeList\n  }\n\n  // 2. Discard the first character of the unparsed-attributes (which\n  //    will be a %x3B (\";\") character).\n  assert(unparsedAttributes[0] === ';')\n  unparsedAttributes = unparsedAttributes.slice(1)\n\n  let cookieAv = ''\n\n  // 3. If the remaining unparsed-attributes contains a %x3B (\";\")\n  //    character:\n  if (unparsedAttributes.includes(';')) {\n    // 1. Consume the characters of the unparsed-attributes up to, but\n    //    not including, the first %x3B (\";\") character.\n    cookieAv = collectASequenceOfCodePointsFast(\n      ';',\n      unparsedAttributes,\n      { position: 0 }\n    )\n    unparsedAttributes = unparsedAttributes.slice(cookieAv.length)\n  } else {\n    // Otherwise:\n\n    // 1. Consume the remainder of the unparsed-attributes.\n    cookieAv = unparsedAttributes\n    unparsedAttributes = ''\n  }\n\n  // Let the cookie-av string be the characters consumed in this step.\n\n  let attributeName = ''\n  let attributeValue = ''\n\n  // 4. If the cookie-av string contains a %x3D (\"=\") character:\n  if (cookieAv.includes('=')) {\n    // 1. The (possibly empty) attribute-name string consists of the\n    //    characters up to, but not including, the first %x3D (\"=\")\n    //    character, and the (possibly empty) attribute-value string\n    //    consists of the characters after the first %x3D (\"=\")\n    //    character.\n    const position = { position: 0 }\n\n    attributeName = collectASequenceOfCodePointsFast(\n      '=',\n      cookieAv,\n      position\n    )\n    attributeValue = cookieAv.slice(position.position + 1)\n  } else {\n    // Otherwise:\n\n    // 1. The attribute-name string consists of the entire cookie-av\n    //    string, and the attribute-value string is empty.\n    attributeName = cookieAv\n  }\n\n  // 5. Remove any leading or trailing WSP characters from the attribute-\n  //    name string and the attribute-value string.\n  attributeName = attributeName.trim()\n  attributeValue = attributeValue.trim()\n\n  // 6. If the attribute-value is longer than 1024 octets, ignore the\n  //    cookie-av string and return to Step 1 of this algorithm.\n  if (attributeValue.length > maxAttributeValueSize) {\n    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n  }\n\n  // 7. Process the attribute-name and attribute-value according to the\n  //    requirements in the following subsections.  (Notice that\n  //    attributes with unrecognized attribute-names are ignored.)\n  const attributeNameLowercase = attributeName.toLowerCase()\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.1\n  // If the attribute-name case-insensitively matches the string\n  // \"Expires\", the user agent MUST process the cookie-av as follows.\n  if (attributeNameLowercase === 'expires') {\n    // 1. Let the expiry-time be the result of parsing the attribute-value\n    //    as cookie-date (see Section 5.1.1).\n    const expiryTime = new Date(attributeValue)\n\n    // 2. If the attribute-value failed to parse as a cookie date, ignore\n    //    the cookie-av.\n\n    cookieAttributeList.expires = expiryTime\n  } else if (attributeNameLowercase === 'max-age') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.2\n    // If the attribute-name case-insensitively matches the string \"Max-\n    // Age\", the user agent MUST process the cookie-av as follows.\n\n    // 1. If the first character of the attribute-value is not a DIGIT or a\n    //    \"-\" character, ignore the cookie-av.\n    const charCode = attributeValue.charCodeAt(0)\n\n    if ((charCode < 48 || charCode > 57) && attributeValue[0] !== '-') {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 2. If the remainder of attribute-value contains a non-DIGIT\n    //    character, ignore the cookie-av.\n    if (!/^\\d+$/.test(attributeValue)) {\n      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n    }\n\n    // 3. Let delta-seconds be the attribute-value converted to an integer.\n    const deltaSeconds = Number(attributeValue)\n\n    // 4. Let cookie-age-limit be the maximum age of the cookie (which\n    //    SHOULD be 400 days or less, see Section 4.1.2.2).\n\n    // 5. Set delta-seconds to the smaller of its present value and cookie-\n    //    age-limit.\n    // deltaSeconds = Math.min(deltaSeconds * 1000, maxExpiresMs)\n\n    // 6. If delta-seconds is less than or equal to zero (0), let expiry-\n    //    time be the earliest representable date and time.  Otherwise, let\n    //    the expiry-time be the current date and time plus delta-seconds\n    //    seconds.\n    // const expiryTime = deltaSeconds <= 0 ? Date.now() : Date.now() + deltaSeconds\n\n    // 7. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Max-Age and an attribute-value of expiry-time.\n    cookieAttributeList.maxAge = deltaSeconds\n  } else if (attributeNameLowercase === 'domain') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.3\n    // If the attribute-name case-insensitively matches the string \"Domain\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. Let cookie-domain be the attribute-value.\n    let cookieDomain = attributeValue\n\n    // 2. If cookie-domain starts with %x2E (\".\"), let cookie-domain be\n    //    cookie-domain without its leading %x2E (\".\").\n    if (cookieDomain[0] === '.') {\n      cookieDomain = cookieDomain.slice(1)\n    }\n\n    // 3. Convert the cookie-domain to lower case.\n    cookieDomain = cookieDomain.toLowerCase()\n\n    // 4. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Domain and an attribute-value of cookie-domain.\n    cookieAttributeList.domain = cookieDomain\n  } else if (attributeNameLowercase === 'path') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.4\n    // If the attribute-name case-insensitively matches the string \"Path\",\n    // the user agent MUST process the cookie-av as follows.\n\n    // 1. If the attribute-value is empty or if the first character of the\n    //    attribute-value is not %x2F (\"/\"):\n    let cookiePath = ''\n    if (attributeValue.length === 0 || attributeValue[0] !== '/') {\n      // 1. Let cookie-path be the default-path.\n      cookiePath = '/'\n    } else {\n      // Otherwise:\n\n      // 1. Let cookie-path be the attribute-value.\n      cookiePath = attributeValue\n    }\n\n    // 2. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of Path and an attribute-value of cookie-path.\n    cookieAttributeList.path = cookiePath\n  } else if (attributeNameLowercase === 'secure') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.5\n    // If the attribute-name case-insensitively matches the string \"Secure\",\n    // the user agent MUST append an attribute to the cookie-attribute-list\n    // with an attribute-name of Secure and an empty attribute-value.\n\n    cookieAttributeList.secure = true\n  } else if (attributeNameLowercase === 'httponly') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.6\n    // If the attribute-name case-insensitively matches the string\n    // \"HttpOnly\", the user agent MUST append an attribute to the cookie-\n    // attribute-list with an attribute-name of HttpOnly and an empty\n    // attribute-value.\n\n    cookieAttributeList.httpOnly = true\n  } else if (attributeNameLowercase === 'samesite') {\n    // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-rfc6265bis#section-5.4.7\n    // If the attribute-name case-insensitively matches the string\n    // \"SameSite\", the user agent MUST process the cookie-av as follows:\n\n    // 1. Let enforcement be \"Default\".\n    let enforcement = 'Default'\n\n    const attributeValueLowercase = attributeValue.toLowerCase()\n    // 2. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"None\", set enforcement to \"None\".\n    if (attributeValueLowercase.includes('none')) {\n      enforcement = 'None'\n    }\n\n    // 3. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Strict\", set enforcement to \"Strict\".\n    if (attributeValueLowercase.includes('strict')) {\n      enforcement = 'Strict'\n    }\n\n    // 4. If cookie-av's attribute-value is a case-insensitive match for\n    //    \"Lax\", set enforcement to \"Lax\".\n    if (attributeValueLowercase.includes('lax')) {\n      enforcement = 'Lax'\n    }\n\n    // 5. Append an attribute to the cookie-attribute-list with an\n    //    attribute-name of \"SameSite\" and an attribute-value of\n    //    enforcement.\n    cookieAttributeList.sameSite = enforcement\n  } else {\n    cookieAttributeList.unparsed ??= []\n\n    cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`)\n  }\n\n  // 8. Return to Step 1 of this algorithm.\n  return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList)\n}\n\nmodule.exports = {\n  parseSetCookie,\n  parseUnparsedAttributes\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy9wYXJzZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLDhDQUE4QyxFQUFFLG1CQUFPLENBQUMsNkVBQWE7QUFDN0UsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLG1FQUFRO0FBQy9DLFFBQVEsbUNBQW1DLEVBQUUsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDeEUsZUFBZSxtQkFBTyxDQUFDLGdDQUFhOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRDtBQUNwRCx3QkFBd0I7QUFDeEI7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxpQ0FBaUM7QUFDakMsdUJBQXVCOztBQUV2Qix1REFBdUQ7QUFDdkQ7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsK0JBQStCO0FBQzFDO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7QUFDMUIscUNBQXFDO0FBQ3JDOztBQUVBOztBQUVBLGdFQUFnRTtBQUNoRTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLDJDQUEyQztBQUMzQztBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSx5Q0FBeUMsY0FBYyxHQUFHLGVBQWU7QUFDekU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcY29va2llc1xccGFyc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbWF4TmFtZVZhbHVlUGFpclNpemUsIG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBpc0NUTEV4Y2x1ZGluZ0h0YWIgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhLXVybCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFBhcnNlcyB0aGUgZmllbGQtdmFsdWUgYXR0cmlidXRlcyBvZiBhIHNldC1jb29raWUgaGVhZGVyIHN0cmluZy5cbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNFxuICogQHBhcmFtIHtzdHJpbmd9IGhlYWRlclxuICogQHJldHVybnMgaWYgdGhlIGhlYWRlciBpcyBpbnZhbGlkLCBudWxsIHdpbGwgYmUgcmV0dXJuZWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VTZXRDb29raWUgKGhlYWRlcikge1xuICAvLyAxLiBJZiB0aGUgc2V0LWNvb2tpZS1zdHJpbmcgY29udGFpbnMgYSAleDAwLTA4IC8gJXgwQS0xRiAvICV4N0ZcbiAgLy8gICAgY2hhcmFjdGVyIChDVEwgY2hhcmFjdGVycyBleGNsdWRpbmcgSFRBQik6IEFib3J0IHRoZXNlIHN0ZXBzIGFuZFxuICAvLyAgICBpZ25vcmUgdGhlIHNldC1jb29raWUtc3RyaW5nIGVudGlyZWx5LlxuICBpZiAoaXNDVExFeGNsdWRpbmdIdGFiKGhlYWRlcikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGV0IG5hbWVWYWx1ZVBhaXIgPSAnJ1xuICBsZXQgdW5wYXJzZWRBdHRyaWJ1dGVzID0gJydcbiAgbGV0IG5hbWUgPSAnJ1xuICBsZXQgdmFsdWUgPSAnJ1xuXG4gIC8vIDIuIElmIHRoZSBzZXQtY29va2llLXN0cmluZyBjb250YWlucyBhICV4M0IgKFwiO1wiKSBjaGFyYWN0ZXI6XG4gIGlmIChoZWFkZXIuaW5jbHVkZXMoJzsnKSkge1xuICAgIC8vIDEuIFRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBjaGFyYWN0ZXJzIHVwIHRvLFxuICAgIC8vICAgIGJ1dCBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzQiAoXCI7XCIpLCBhbmQgdGhlIHVucGFyc2VkLVxuICAgIC8vICAgIGF0dHJpYnV0ZXMgY29uc2lzdCBvZiB0aGUgcmVtYWluZGVyIG9mIHRoZSBzZXQtY29va2llLXN0cmluZ1xuICAgIC8vICAgIChpbmNsdWRpbmcgdGhlICV4M0IgKFwiO1wiKSBpbiBxdWVzdGlvbikuXG4gICAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAgIG5hbWVWYWx1ZVBhaXIgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCgnOycsIGhlYWRlciwgcG9zaXRpb24pXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gaGVhZGVyLnNsaWNlKHBvc2l0aW9uLnBvc2l0aW9uKVxuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIFRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGNvbnNpc3RzIG9mIGFsbCB0aGUgY2hhcmFjdGVyc1xuICAgIC8vICAgIGNvbnRhaW5lZCBpbiB0aGUgc2V0LWNvb2tpZS1zdHJpbmcsIGFuZCB0aGUgdW5wYXJzZWQtXG4gICAgLy8gICAgYXR0cmlidXRlcyBpcyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgIG5hbWVWYWx1ZVBhaXIgPSBoZWFkZXJcbiAgfVxuXG4gIC8vIDMuIElmIHRoZSBuYW1lLXZhbHVlLXBhaXIgc3RyaW5nIGxhY2tzIGEgJXgzRCAoXCI9XCIpIGNoYXJhY3RlciwgdGhlblxuICAvLyAgICB0aGUgbmFtZSBzdHJpbmcgaXMgZW1wdHksIGFuZCB0aGUgdmFsdWUgc3RyaW5nIGlzIHRoZSB2YWx1ZSBvZlxuICAvLyAgICBuYW1lLXZhbHVlLXBhaXIuXG4gIGlmICghbmFtZVZhbHVlUGFpci5pbmNsdWRlcygnPScpKSB7XG4gICAgdmFsdWUgPSBuYW1lVmFsdWVQYWlyXG4gIH0gZWxzZSB7XG4gICAgLy8gICAgT3RoZXJ3aXNlLCB0aGUgbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgdXAgdG8sIGJ1dFxuICAgIC8vICAgIG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNEIChcIj1cIikgY2hhcmFjdGVyLCBhbmQgdGhlIChwb3NzaWJseVxuICAgIC8vICAgIGVtcHR5KSB2YWx1ZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGZpcnN0XG4gICAgLy8gICAgJXgzRCAoXCI9XCIpIGNoYXJhY3Rlci5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuICAgIG5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICc9JyxcbiAgICAgIG5hbWVWYWx1ZVBhaXIsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXIuc2xpY2UocG9zaXRpb24ucG9zaXRpb24gKyAxKVxuICB9XG5cbiAgLy8gNC4gUmVtb3ZlIGFueSBsZWFkaW5nIG9yIHRyYWlsaW5nIFdTUCBjaGFyYWN0ZXJzIGZyb20gdGhlIG5hbWVcbiAgLy8gICAgc3RyaW5nIGFuZCB0aGUgdmFsdWUgc3RyaW5nLlxuICBuYW1lID0gbmFtZS50cmltKClcbiAgdmFsdWUgPSB2YWx1ZS50cmltKClcblxuICAvLyA1LiBJZiB0aGUgc3VtIG9mIHRoZSBsZW5ndGhzIG9mIHRoZSBuYW1lIHN0cmluZyBhbmQgdGhlIHZhbHVlIHN0cmluZ1xuICAvLyAgICBpcyBtb3JlIHRoYW4gNDA5NiBvY3RldHMsIGFib3J0IHRoZXNlIHN0ZXBzIGFuZCBpZ25vcmUgdGhlIHNldC1cbiAgLy8gICAgY29va2llLXN0cmluZyBlbnRpcmVseS5cbiAgaWYgKG5hbWUubGVuZ3RoICsgdmFsdWUubGVuZ3RoID4gbWF4TmFtZVZhbHVlUGFpclNpemUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLy8gNi4gVGhlIGNvb2tpZS1uYW1lIGlzIHRoZSBuYW1lIHN0cmluZywgYW5kIHRoZSBjb29raWUtdmFsdWUgaXMgdGhlXG4gIC8vICAgIHZhbHVlIHN0cmluZy5cbiAgcmV0dXJuIHtcbiAgICBuYW1lLCB2YWx1ZSwgLi4ucGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzKVxuICB9XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSByZW1haW5pbmcgYXR0cmlidXRlcyBvZiBhIHNldC1jb29raWUgaGVhZGVyXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjRcbiAqIEBwYXJhbSB7c3RyaW5nfSB1bnBhcnNlZEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7W09iamVjdC48c3RyaW5nLCB1bmtub3duPl09e319IGNvb2tpZUF0dHJpYnV0ZUxpc3RcbiAqL1xuZnVuY3Rpb24gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXMgKHVucGFyc2VkQXR0cmlidXRlcywgY29va2llQXR0cmlidXRlTGlzdCA9IHt9KSB7XG4gIC8vIDEuIElmIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzIHN0cmluZyBpcyBlbXB0eSwgc2tpcCB0aGUgcmVzdCBvZlxuICAvLyAgICB0aGVzZSBzdGVwcy5cbiAgaWYgKHVucGFyc2VkQXR0cmlidXRlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gY29va2llQXR0cmlidXRlTGlzdFxuICB9XG5cbiAgLy8gMi4gRGlzY2FyZCB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzICh3aGljaFxuICAvLyAgICB3aWxsIGJlIGEgJXgzQiAoXCI7XCIpIGNoYXJhY3RlcikuXG4gIGFzc2VydCh1bnBhcnNlZEF0dHJpYnV0ZXNbMF0gPT09ICc7JylcbiAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gdW5wYXJzZWRBdHRyaWJ1dGVzLnNsaWNlKDEpXG5cbiAgbGV0IGNvb2tpZUF2ID0gJydcblxuICAvLyAzLiBJZiB0aGUgcmVtYWluaW5nIHVucGFyc2VkLWF0dHJpYnV0ZXMgY29udGFpbnMgYSAleDNCIChcIjtcIilcbiAgLy8gICAgY2hhcmFjdGVyOlxuICBpZiAodW5wYXJzZWRBdHRyaWJ1dGVzLmluY2x1ZGVzKCc7JykpIHtcbiAgICAvLyAxLiBDb25zdW1lIHRoZSBjaGFyYWN0ZXJzIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzIHVwIHRvLCBidXRcbiAgICAvLyAgICBub3QgaW5jbHVkaW5nLCB0aGUgZmlyc3QgJXgzQiAoXCI7XCIpIGNoYXJhY3Rlci5cbiAgICBjb29raWVBdiA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgJzsnLFxuICAgICAgdW5wYXJzZWRBdHRyaWJ1dGVzLFxuICAgICAgeyBwb3NpdGlvbjogMCB9XG4gICAgKVxuICAgIHVucGFyc2VkQXR0cmlidXRlcyA9IHVucGFyc2VkQXR0cmlidXRlcy5zbGljZShjb29raWVBdi5sZW5ndGgpXG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gQ29uc3VtZSB0aGUgcmVtYWluZGVyIG9mIHRoZSB1bnBhcnNlZC1hdHRyaWJ1dGVzLlxuICAgIGNvb2tpZUF2ID0gdW5wYXJzZWRBdHRyaWJ1dGVzXG4gICAgdW5wYXJzZWRBdHRyaWJ1dGVzID0gJydcbiAgfVxuXG4gIC8vIExldCB0aGUgY29va2llLWF2IHN0cmluZyBiZSB0aGUgY2hhcmFjdGVycyBjb25zdW1lZCBpbiB0aGlzIHN0ZXAuXG5cbiAgbGV0IGF0dHJpYnV0ZU5hbWUgPSAnJ1xuICBsZXQgYXR0cmlidXRlVmFsdWUgPSAnJ1xuXG4gIC8vIDQuIElmIHRoZSBjb29raWUtYXYgc3RyaW5nIGNvbnRhaW5zIGEgJXgzRCAoXCI9XCIpIGNoYXJhY3RlcjpcbiAgaWYgKGNvb2tpZUF2LmluY2x1ZGVzKCc9JykpIHtcbiAgICAvLyAxLiBUaGUgKHBvc3NpYmx5IGVtcHR5KSBhdHRyaWJ1dGUtbmFtZSBzdHJpbmcgY29uc2lzdHMgb2YgdGhlXG4gICAgLy8gICAgY2hhcmFjdGVycyB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNEIChcIj1cIilcbiAgICAvLyAgICBjaGFyYWN0ZXIsIGFuZCB0aGUgKHBvc3NpYmx5IGVtcHR5KSBhdHRyaWJ1dGUtdmFsdWUgc3RyaW5nXG4gICAgLy8gICAgY29uc2lzdHMgb2YgdGhlIGNoYXJhY3RlcnMgYWZ0ZXIgdGhlIGZpcnN0ICV4M0QgKFwiPVwiKVxuICAgIC8vICAgIGNoYXJhY3Rlci5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gICAgYXR0cmlidXRlTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KFxuICAgICAgJz0nLFxuICAgICAgY29va2llQXYsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgICBhdHRyaWJ1dGVWYWx1ZSA9IGNvb2tpZUF2LnNsaWNlKHBvc2l0aW9uLnBvc2l0aW9uICsgMSlcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2U6XG5cbiAgICAvLyAxLiBUaGUgYXR0cmlidXRlLW5hbWUgc3RyaW5nIGNvbnNpc3RzIG9mIHRoZSBlbnRpcmUgY29va2llLWF2XG4gICAgLy8gICAgc3RyaW5nLCBhbmQgdGhlIGF0dHJpYnV0ZS12YWx1ZSBzdHJpbmcgaXMgZW1wdHkuXG4gICAgYXR0cmlidXRlTmFtZSA9IGNvb2tpZUF2XG4gIH1cblxuICAvLyA1LiBSZW1vdmUgYW55IGxlYWRpbmcgb3IgdHJhaWxpbmcgV1NQIGNoYXJhY3RlcnMgZnJvbSB0aGUgYXR0cmlidXRlLVxuICAvLyAgICBuYW1lIHN0cmluZyBhbmQgdGhlIGF0dHJpYnV0ZS12YWx1ZSBzdHJpbmcuXG4gIGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lLnRyaW0oKVxuICBhdHRyaWJ1dGVWYWx1ZSA9IGF0dHJpYnV0ZVZhbHVlLnRyaW0oKVxuXG4gIC8vIDYuIElmIHRoZSBhdHRyaWJ1dGUtdmFsdWUgaXMgbG9uZ2VyIHRoYW4gMTAyNCBvY3RldHMsIGlnbm9yZSB0aGVcbiAgLy8gICAgY29va2llLWF2IHN0cmluZyBhbmQgcmV0dXJuIHRvIFN0ZXAgMSBvZiB0aGlzIGFsZ29yaXRobS5cbiAgaWYgKGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCA+IG1heEF0dHJpYnV0ZVZhbHVlU2l6ZSkge1xuICAgIHJldHVybiBwYXJzZVVucGFyc2VkQXR0cmlidXRlcyh1bnBhcnNlZEF0dHJpYnV0ZXMsIGNvb2tpZUF0dHJpYnV0ZUxpc3QpXG4gIH1cblxuICAvLyA3LiBQcm9jZXNzIHRoZSBhdHRyaWJ1dGUtbmFtZSBhbmQgYXR0cmlidXRlLXZhbHVlIGFjY29yZGluZyB0byB0aGVcbiAgLy8gICAgcmVxdWlyZW1lbnRzIGluIHRoZSBmb2xsb3dpbmcgc3Vic2VjdGlvbnMuICAoTm90aWNlIHRoYXRcbiAgLy8gICAgYXR0cmlidXRlcyB3aXRoIHVucmVjb2duaXplZCBhdHRyaWJ1dGUtbmFtZXMgYXJlIGlnbm9yZWQuKVxuICBjb25zdCBhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID0gYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC4xXG4gIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nXG4gIC8vIFwiRXhwaXJlc1wiLCB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuICBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ2V4cGlyZXMnKSB7XG4gICAgLy8gMS4gTGV0IHRoZSBleHBpcnktdGltZSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIGF0dHJpYnV0ZS12YWx1ZVxuICAgIC8vICAgIGFzIGNvb2tpZS1kYXRlIChzZWUgU2VjdGlvbiA1LjEuMSkuXG4gICAgY29uc3QgZXhwaXJ5VGltZSA9IG5ldyBEYXRlKGF0dHJpYnV0ZVZhbHVlKVxuXG4gICAgLy8gMi4gSWYgdGhlIGF0dHJpYnV0ZS12YWx1ZSBmYWlsZWQgdG8gcGFyc2UgYXMgYSBjb29raWUgZGF0ZSwgaWdub3JlXG4gICAgLy8gICAgdGhlIGNvb2tpZS1hdi5cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QuZXhwaXJlcyA9IGV4cGlyeVRpbWVcbiAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lTG93ZXJjYXNlID09PSAnbWF4LWFnZScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjJcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIk1heC1cbiAgICAvLyBBZ2VcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93cy5cblxuICAgIC8vIDEuIElmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlIGF0dHJpYnV0ZS12YWx1ZSBpcyBub3QgYSBESUdJVCBvciBhXG4gICAgLy8gICAgXCItXCIgY2hhcmFjdGVyLCBpZ25vcmUgdGhlIGNvb2tpZS1hdi5cbiAgICBjb25zdCBjaGFyQ29kZSA9IGF0dHJpYnV0ZVZhbHVlLmNoYXJDb2RlQXQoMClcblxuICAgIGlmICgoY2hhckNvZGUgPCA0OCB8fCBjaGFyQ29kZSA+IDU3KSAmJiBhdHRyaWJ1dGVWYWx1ZVswXSAhPT0gJy0nKSB7XG4gICAgICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxuICAgIH1cblxuICAgIC8vIDIuIElmIHRoZSByZW1haW5kZXIgb2YgYXR0cmlidXRlLXZhbHVlIGNvbnRhaW5zIGEgbm9uLURJR0lUXG4gICAgLy8gICAgY2hhcmFjdGVyLCBpZ25vcmUgdGhlIGNvb2tpZS1hdi5cbiAgICBpZiAoIS9eXFxkKyQvLnRlc3QoYXR0cmlidXRlVmFsdWUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxuICAgIH1cblxuICAgIC8vIDMuIExldCBkZWx0YS1zZWNvbmRzIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUgY29udmVydGVkIHRvIGFuIGludGVnZXIuXG4gICAgY29uc3QgZGVsdGFTZWNvbmRzID0gTnVtYmVyKGF0dHJpYnV0ZVZhbHVlKVxuXG4gICAgLy8gNC4gTGV0IGNvb2tpZS1hZ2UtbGltaXQgYmUgdGhlIG1heGltdW0gYWdlIG9mIHRoZSBjb29raWUgKHdoaWNoXG4gICAgLy8gICAgU0hPVUxEIGJlIDQwMCBkYXlzIG9yIGxlc3MsIHNlZSBTZWN0aW9uIDQuMS4yLjIpLlxuXG4gICAgLy8gNS4gU2V0IGRlbHRhLXNlY29uZHMgdG8gdGhlIHNtYWxsZXIgb2YgaXRzIHByZXNlbnQgdmFsdWUgYW5kIGNvb2tpZS1cbiAgICAvLyAgICBhZ2UtbGltaXQuXG4gICAgLy8gZGVsdGFTZWNvbmRzID0gTWF0aC5taW4oZGVsdGFTZWNvbmRzICogMTAwMCwgbWF4RXhwaXJlc01zKVxuXG4gICAgLy8gNi4gSWYgZGVsdGEtc2Vjb25kcyBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVybyAoMCksIGxldCBleHBpcnktXG4gICAgLy8gICAgdGltZSBiZSB0aGUgZWFybGllc3QgcmVwcmVzZW50YWJsZSBkYXRlIGFuZCB0aW1lLiAgT3RoZXJ3aXNlLCBsZXRcbiAgICAvLyAgICB0aGUgZXhwaXJ5LXRpbWUgYmUgdGhlIGN1cnJlbnQgZGF0ZSBhbmQgdGltZSBwbHVzIGRlbHRhLXNlY29uZHNcbiAgICAvLyAgICBzZWNvbmRzLlxuICAgIC8vIGNvbnN0IGV4cGlyeVRpbWUgPSBkZWx0YVNlY29uZHMgPD0gMCA/IERhdGUubm93KCkgOiBEYXRlLm5vdygpICsgZGVsdGFTZWNvbmRzXG5cbiAgICAvLyA3LiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIE1heC1BZ2UgYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZiBleHBpcnktdGltZS5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0Lm1heEFnZSA9IGRlbHRhU2Vjb25kc1xuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdkb21haW4nKSB7XG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtcmZjNjI2NWJpcyNzZWN0aW9uLTUuNC4zXG4gICAgLy8gSWYgdGhlIGF0dHJpYnV0ZS1uYW1lIGNhc2UtaW5zZW5zaXRpdmVseSBtYXRjaGVzIHRoZSBzdHJpbmcgXCJEb21haW5cIixcbiAgICAvLyB0aGUgdXNlciBhZ2VudCBNVVNUIHByb2Nlc3MgdGhlIGNvb2tpZS1hdiBhcyBmb2xsb3dzLlxuXG4gICAgLy8gMS4gTGV0IGNvb2tpZS1kb21haW4gYmUgdGhlIGF0dHJpYnV0ZS12YWx1ZS5cbiAgICBsZXQgY29va2llRG9tYWluID0gYXR0cmlidXRlVmFsdWVcblxuICAgIC8vIDIuIElmIGNvb2tpZS1kb21haW4gc3RhcnRzIHdpdGggJXgyRSAoXCIuXCIpLCBsZXQgY29va2llLWRvbWFpbiBiZVxuICAgIC8vICAgIGNvb2tpZS1kb21haW4gd2l0aG91dCBpdHMgbGVhZGluZyAleDJFIChcIi5cIikuXG4gICAgaWYgKGNvb2tpZURvbWFpblswXSA9PT0gJy4nKSB7XG4gICAgICBjb29raWVEb21haW4gPSBjb29raWVEb21haW4uc2xpY2UoMSlcbiAgICB9XG5cbiAgICAvLyAzLiBDb252ZXJ0IHRoZSBjb29raWUtZG9tYWluIHRvIGxvd2VyIGNhc2UuXG4gICAgY29va2llRG9tYWluID0gY29va2llRG9tYWluLnRvTG93ZXJDYXNlKClcblxuICAgIC8vIDQuIEFwcGVuZCBhbiBhdHRyaWJ1dGUgdG8gdGhlIGNvb2tpZS1hdHRyaWJ1dGUtbGlzdCB3aXRoIGFuXG4gICAgLy8gICAgYXR0cmlidXRlLW5hbWUgb2YgRG9tYWluIGFuZCBhbiBhdHRyaWJ1dGUtdmFsdWUgb2YgY29va2llLWRvbWFpbi5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LmRvbWFpbiA9IGNvb2tpZURvbWFpblxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdwYXRoJykge1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaWV0Zi1odHRwYmlzLXJmYzYyNjViaXMjc2VjdGlvbi01LjQuNFxuICAgIC8vIElmIHRoZSBhdHRyaWJ1dGUtbmFtZSBjYXNlLWluc2Vuc2l0aXZlbHkgbWF0Y2hlcyB0aGUgc3RyaW5nIFwiUGF0aFwiLFxuICAgIC8vIHRoZSB1c2VyIGFnZW50IE1VU1QgcHJvY2VzcyB0aGUgY29va2llLWF2IGFzIGZvbGxvd3MuXG5cbiAgICAvLyAxLiBJZiB0aGUgYXR0cmlidXRlLXZhbHVlIGlzIGVtcHR5IG9yIGlmIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgdGhlXG4gICAgLy8gICAgYXR0cmlidXRlLXZhbHVlIGlzIG5vdCAleDJGIChcIi9cIik6XG4gICAgbGV0IGNvb2tpZVBhdGggPSAnJ1xuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZS5sZW5ndGggPT09IDAgfHwgYXR0cmlidXRlVmFsdWVbMF0gIT09ICcvJykge1xuICAgICAgLy8gMS4gTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBkZWZhdWx0LXBhdGguXG4gICAgICBjb29raWVQYXRoID0gJy8nXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZTpcblxuICAgICAgLy8gMS4gTGV0IGNvb2tpZS1wYXRoIGJlIHRoZSBhdHRyaWJ1dGUtdmFsdWUuXG4gICAgICBjb29raWVQYXRoID0gYXR0cmlidXRlVmFsdWVcbiAgICB9XG5cbiAgICAvLyAyLiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIFBhdGggYW5kIGFuIGF0dHJpYnV0ZS12YWx1ZSBvZiBjb29raWUtcGF0aC5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0LnBhdGggPSBjb29raWVQYXRoXG4gIH0gZWxzZSBpZiAoYXR0cmlidXRlTmFtZUxvd2VyY2FzZSA9PT0gJ3NlY3VyZScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjVcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZyBcIlNlY3VyZVwiLFxuICAgIC8vIHRoZSB1c2VyIGFnZW50IE1VU1QgYXBwZW5kIGFuIGF0dHJpYnV0ZSB0byB0aGUgY29va2llLWF0dHJpYnV0ZS1saXN0XG4gICAgLy8gd2l0aCBhbiBhdHRyaWJ1dGUtbmFtZSBvZiBTZWN1cmUgYW5kIGFuIGVtcHR5IGF0dHJpYnV0ZS12YWx1ZS5cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3Quc2VjdXJlID0gdHJ1ZVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdodHRwb25seScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjZcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZ1xuICAgIC8vIFwiSHR0cE9ubHlcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBhcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtXG4gICAgLy8gYXR0cmlidXRlLWxpc3Qgd2l0aCBhbiBhdHRyaWJ1dGUtbmFtZSBvZiBIdHRwT25seSBhbmQgYW4gZW1wdHlcbiAgICAvLyBhdHRyaWJ1dGUtdmFsdWUuXG5cbiAgICBjb29raWVBdHRyaWJ1dGVMaXN0Lmh0dHBPbmx5ID0gdHJ1ZVxuICB9IGVsc2UgaWYgKGF0dHJpYnV0ZU5hbWVMb3dlcmNhc2UgPT09ICdzYW1lc2l0ZScpIHtcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1yZmM2MjY1YmlzI3NlY3Rpb24tNS40LjdcbiAgICAvLyBJZiB0aGUgYXR0cmlidXRlLW5hbWUgY2FzZS1pbnNlbnNpdGl2ZWx5IG1hdGNoZXMgdGhlIHN0cmluZ1xuICAgIC8vIFwiU2FtZVNpdGVcIiwgdGhlIHVzZXIgYWdlbnQgTVVTVCBwcm9jZXNzIHRoZSBjb29raWUtYXYgYXMgZm9sbG93czpcblxuICAgIC8vIDEuIExldCBlbmZvcmNlbWVudCBiZSBcIkRlZmF1bHRcIi5cbiAgICBsZXQgZW5mb3JjZW1lbnQgPSAnRGVmYXVsdCdcblxuICAgIGNvbnN0IGF0dHJpYnV0ZVZhbHVlTG93ZXJjYXNlID0gYXR0cmlidXRlVmFsdWUudG9Mb3dlckNhc2UoKVxuICAgIC8vIDIuIElmIGNvb2tpZS1hdidzIGF0dHJpYnV0ZS12YWx1ZSBpcyBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gICAgLy8gICAgXCJOb25lXCIsIHNldCBlbmZvcmNlbWVudCB0byBcIk5vbmVcIi5cbiAgICBpZiAoYXR0cmlidXRlVmFsdWVMb3dlcmNhc2UuaW5jbHVkZXMoJ25vbmUnKSkge1xuICAgICAgZW5mb3JjZW1lbnQgPSAnTm9uZSdcbiAgICB9XG5cbiAgICAvLyAzLiBJZiBjb29raWUtYXYncyBhdHRyaWJ1dGUtdmFsdWUgaXMgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAgIC8vICAgIFwiU3RyaWN0XCIsIHNldCBlbmZvcmNlbWVudCB0byBcIlN0cmljdFwiLlxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZS5pbmNsdWRlcygnc3RyaWN0JykpIHtcbiAgICAgIGVuZm9yY2VtZW50ID0gJ1N0cmljdCdcbiAgICB9XG5cbiAgICAvLyA0LiBJZiBjb29raWUtYXYncyBhdHRyaWJ1dGUtdmFsdWUgaXMgYSBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvclxuICAgIC8vICAgIFwiTGF4XCIsIHNldCBlbmZvcmNlbWVudCB0byBcIkxheFwiLlxuICAgIGlmIChhdHRyaWJ1dGVWYWx1ZUxvd2VyY2FzZS5pbmNsdWRlcygnbGF4JykpIHtcbiAgICAgIGVuZm9yY2VtZW50ID0gJ0xheCdcbiAgICB9XG5cbiAgICAvLyA1LiBBcHBlbmQgYW4gYXR0cmlidXRlIHRvIHRoZSBjb29raWUtYXR0cmlidXRlLWxpc3Qgd2l0aCBhblxuICAgIC8vICAgIGF0dHJpYnV0ZS1uYW1lIG9mIFwiU2FtZVNpdGVcIiBhbmQgYW4gYXR0cmlidXRlLXZhbHVlIG9mXG4gICAgLy8gICAgZW5mb3JjZW1lbnQuXG4gICAgY29va2llQXR0cmlidXRlTGlzdC5zYW1lU2l0ZSA9IGVuZm9yY2VtZW50XG4gIH0gZWxzZSB7XG4gICAgY29va2llQXR0cmlidXRlTGlzdC51bnBhcnNlZCA/Pz0gW11cblxuICAgIGNvb2tpZUF0dHJpYnV0ZUxpc3QudW5wYXJzZWQucHVzaChgJHthdHRyaWJ1dGVOYW1lfT0ke2F0dHJpYnV0ZVZhbHVlfWApXG4gIH1cblxuICAvLyA4LiBSZXR1cm4gdG8gU3RlcCAxIG9mIHRoaXMgYWxnb3JpdGhtLlxuICByZXR1cm4gcGFyc2VVbnBhcnNlZEF0dHJpYnV0ZXModW5wYXJzZWRBdHRyaWJ1dGVzLCBjb29raWVBdHRyaWJ1dGVMaXN0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcGFyc2VTZXRDb29raWUsXG4gIHBhcnNlVW5wYXJzZWRBdHRyaWJ1dGVzXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/cookies/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/cookies/util.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nfunction isCTLExcludingHtab (value) {\n  for (let i = 0; i < value.length; ++i) {\n    const code = value.charCodeAt(i)\n\n    if (\n      (code >= 0x00 && code <= 0x08) ||\n      (code >= 0x0A && code <= 0x1F) ||\n      code === 0x7F\n    ) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n CHAR           = <any US-ASCII character (octets 0 - 127)>\n token          = 1*<any CHAR except CTLs or separators>\n separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n                | \",\" | \";\" | \":\" | \"\\\" | <\">\n                | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n                | \"{\" | \"}\" | SP | HT\n * @param {string} name\n */\nfunction validateCookieName (name) {\n  for (let i = 0; i < name.length; ++i) {\n    const code = name.charCodeAt(i)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31), SP and HT\n      code > 0x7E || // exclude non-ascii and DEL\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x3C || // <\n      code === 0x3E || // >\n      code === 0x40 || // @\n      code === 0x2C || // ,\n      code === 0x3B || // ;\n      code === 0x3A || // :\n      code === 0x5C || // \\\n      code === 0x2F || // /\n      code === 0x5B || // [\n      code === 0x5D || // ]\n      code === 0x3F || // ?\n      code === 0x3D || // =\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      throw new Error('Invalid cookie name')\n    }\n  }\n}\n\n/**\n cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )\n cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n                       ; US-ASCII characters excluding CTLs,\n                       ; whitespace DQUOTE, comma, semicolon,\n                       ; and backslash\n * @param {string} value\n */\nfunction validateCookieValue (value) {\n  let len = value.length\n  let i = 0\n\n  // if the value is wrapped in DQUOTE\n  if (value[0] === '\"') {\n    if (len === 1 || value[len - 1] !== '\"') {\n      throw new Error('Invalid cookie value')\n    }\n    --len\n    ++i\n  }\n\n  while (i < len) {\n    const code = value.charCodeAt(i++)\n\n    if (\n      code < 0x21 || // exclude CTLs (0-31)\n      code > 0x7E || // non-ascii and DEL (127)\n      code === 0x22 || // \"\n      code === 0x2C || // ,\n      code === 0x3B || // ;\n      code === 0x5C // \\\n    ) {\n      throw new Error('Invalid cookie value')\n    }\n  }\n}\n\n/**\n * path-value        = <any CHAR except CTLs or \";\">\n * @param {string} path\n */\nfunction validateCookiePath (path) {\n  for (let i = 0; i < path.length; ++i) {\n    const code = path.charCodeAt(i)\n\n    if (\n      code < 0x20 || // exclude CTLs (0-31)\n      code === 0x7F || // DEL\n      code === 0x3B // ;\n    ) {\n      throw new Error('Invalid cookie path')\n    }\n  }\n}\n\n/**\n * I have no idea why these values aren't allowed to be honest,\n * but Deno tests these. - Khafra\n * @param {string} domain\n */\nfunction validateCookieDomain (domain) {\n  if (\n    domain.startsWith('-') ||\n    domain.endsWith('.') ||\n    domain.endsWith('-')\n  ) {\n    throw new Error('Invalid cookie domain')\n  }\n}\n\nconst IMFDays = [\n  'Sun', 'Mon', 'Tue', 'Wed',\n  'Thu', 'Fri', 'Sat'\n]\n\nconst IMFMonths = [\n  'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\n  'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'\n]\n\nconst IMFPaddedNumbers = Array(61).fill(0).map((_, i) => i.toString().padStart(2, '0'))\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1\n * @param {number|Date} date\n  IMF-fixdate  = day-name \",\" SP date1 SP time-of-day SP GMT\n  ; fixed length/zone/capitalization subset of the format\n  ; see Section 3.3 of [RFC5322]\n\n  day-name     = %x4D.6F.6E ; \"Mon\", case-sensitive\n              / %x54.75.65 ; \"Tue\", case-sensitive\n              / %x57.65.64 ; \"Wed\", case-sensitive\n              / %x54.68.75 ; \"Thu\", case-sensitive\n              / %x46.72.69 ; \"Fri\", case-sensitive\n              / %x53.61.74 ; \"Sat\", case-sensitive\n              / %x53.75.6E ; \"Sun\", case-sensitive\n  date1        = day SP month SP year\n                  ; e.g., 02 Jun 1982\n\n  day          = 2DIGIT\n  month        = %x4A.61.6E ; \"Jan\", case-sensitive\n              / %x46.65.62 ; \"Feb\", case-sensitive\n              / %x4D.61.72 ; \"Mar\", case-sensitive\n              / %x41.70.72 ; \"Apr\", case-sensitive\n              / %x4D.61.79 ; \"May\", case-sensitive\n              / %x4A.75.6E ; \"Jun\", case-sensitive\n              / %x4A.75.6C ; \"Jul\", case-sensitive\n              / %x41.75.67 ; \"Aug\", case-sensitive\n              / %x53.65.70 ; \"Sep\", case-sensitive\n              / %x4F.63.74 ; \"Oct\", case-sensitive\n              / %x4E.6F.76 ; \"Nov\", case-sensitive\n              / %x44.65.63 ; \"Dec\", case-sensitive\n  year         = 4DIGIT\n\n  GMT          = %x47.4D.54 ; \"GMT\", case-sensitive\n\n  time-of-day  = hour \":\" minute \":\" second\n              ; 00:00:00 - 23:59:60 (leap second)\n\n  hour         = 2DIGIT\n  minute       = 2DIGIT\n  second       = 2DIGIT\n */\nfunction toIMFDate (date) {\n  if (typeof date === 'number') {\n    date = new Date(date)\n  }\n\n  return `${IMFDays[date.getUTCDay()]}, ${IMFPaddedNumbers[date.getUTCDate()]} ${IMFMonths[date.getUTCMonth()]} ${date.getUTCFullYear()} ${IMFPaddedNumbers[date.getUTCHours()]}:${IMFPaddedNumbers[date.getUTCMinutes()]}:${IMFPaddedNumbers[date.getUTCSeconds()]} GMT`\n}\n\n/**\n max-age-av        = \"Max-Age=\" non-zero-digit *DIGIT\n                       ; In practice, both expires-av and max-age-av\n                       ; are limited to dates representable by the\n                       ; user agent.\n * @param {number} maxAge\n */\nfunction validateCookieMaxAge (maxAge) {\n  if (maxAge < 0) {\n    throw new Error('Invalid cookie max-age')\n  }\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc6265#section-4.1.1\n * @param {import('./index').Cookie} cookie\n */\nfunction stringify (cookie) {\n  if (cookie.name.length === 0) {\n    return null\n  }\n\n  validateCookieName(cookie.name)\n  validateCookieValue(cookie.value)\n\n  const out = [`${cookie.name}=${cookie.value}`]\n\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.1\n  // https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-cookie-prefixes-00#section-3.2\n  if (cookie.name.startsWith('__Secure-')) {\n    cookie.secure = true\n  }\n\n  if (cookie.name.startsWith('__Host-')) {\n    cookie.secure = true\n    cookie.domain = null\n    cookie.path = '/'\n  }\n\n  if (cookie.secure) {\n    out.push('Secure')\n  }\n\n  if (cookie.httpOnly) {\n    out.push('HttpOnly')\n  }\n\n  if (typeof cookie.maxAge === 'number') {\n    validateCookieMaxAge(cookie.maxAge)\n    out.push(`Max-Age=${cookie.maxAge}`)\n  }\n\n  if (cookie.domain) {\n    validateCookieDomain(cookie.domain)\n    out.push(`Domain=${cookie.domain}`)\n  }\n\n  if (cookie.path) {\n    validateCookiePath(cookie.path)\n    out.push(`Path=${cookie.path}`)\n  }\n\n  if (cookie.expires && cookie.expires.toString() !== 'Invalid Date') {\n    out.push(`Expires=${toIMFDate(cookie.expires)}`)\n  }\n\n  if (cookie.sameSite) {\n    out.push(`SameSite=${cookie.sameSite}`)\n  }\n\n  for (const part of cookie.unparsed) {\n    if (!part.includes('=')) {\n      throw new Error('Invalid unparsed')\n    }\n\n    const [key, ...value] = part.split('=')\n\n    out.push(`${key.trim()}=${value.join('=')}`)\n  }\n\n  return out.join('; ')\n}\n\nmodule.exports = {\n  isCTLExcludingHtab,\n  validateCookieName,\n  validateCookiePath,\n  validateCookieValue,\n  toIMFDate,\n  stringify\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvY29va2llcy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLG9CQUFvQixNQUFNO0FBQzFCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRCxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsSUFBSTtBQUNKLElBQUk7O0FBRUosOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBQzdCOztBQUVBLDhCQUE4Qjs7QUFFOUI7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSwwQkFBMEIsSUFBSSxxQ0FBcUMsRUFBRSwrQkFBK0IsRUFBRSx1QkFBdUIsRUFBRSxxQ0FBcUMsR0FBRyx1Q0FBdUMsR0FBRyx3Q0FBd0M7QUFDclE7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWSxHQUFHLGFBQWE7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixZQUFZO0FBQ2pDOztBQUVBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDs7QUFFQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFdBQVcsR0FBRyxnQkFBZ0I7QUFDOUM7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxjb29raWVzXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ1RMRXhjbHVkaW5nSHRhYiAodmFsdWUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGkpXG5cbiAgICBpZiAoXG4gICAgICAoY29kZSA+PSAweDAwICYmIGNvZGUgPD0gMHgwOCkgfHxcbiAgICAgIChjb2RlID49IDB4MEEgJiYgY29kZSA8PSAweDFGKSB8fFxuICAgICAgY29kZSA9PT0gMHg3RlxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuIENIQVIgICAgICAgICAgID0gPGFueSBVUy1BU0NJSSBjaGFyYWN0ZXIgKG9jdGV0cyAwIC0gMTI3KT5cbiB0b2tlbiAgICAgICAgICA9IDEqPGFueSBDSEFSIGV4Y2VwdCBDVExzIG9yIHNlcGFyYXRvcnM+XG4gc2VwYXJhdG9ycyAgICAgPSBcIihcIiB8IFwiKVwiIHwgXCI8XCIgfCBcIj5cIiB8IFwiQFwiXG4gICAgICAgICAgICAgICAgfCBcIixcIiB8IFwiO1wiIHwgXCI6XCIgfCBcIlxcXCIgfCA8XCI+XG4gICAgICAgICAgICAgICAgfCBcIi9cIiB8IFwiW1wiIHwgXCJdXCIgfCBcIj9cIiB8IFwiPVwiXG4gICAgICAgICAgICAgICAgfCBcIntcIiB8IFwifVwiIHwgU1AgfCBIVFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVOYW1lIChuYW1lKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZS5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBuYW1lLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIxIHx8IC8vIGV4Y2x1ZGUgQ1RMcyAoMC0zMSksIFNQIGFuZCBIVFxuICAgICAgY29kZSA+IDB4N0UgfHwgLy8gZXhjbHVkZSBub24tYXNjaWkgYW5kIERFTFxuICAgICAgY29kZSA9PT0gMHgyMiB8fCAvLyBcIlxuICAgICAgY29kZSA9PT0gMHgyOCB8fCAvLyAoXG4gICAgICBjb2RlID09PSAweDI5IHx8IC8vIClcbiAgICAgIGNvZGUgPT09IDB4M0MgfHwgLy8gPFxuICAgICAgY29kZSA9PT0gMHgzRSB8fCAvLyA+XG4gICAgICBjb2RlID09PSAweDQwIHx8IC8vIEBcbiAgICAgIGNvZGUgPT09IDB4MkMgfHwgLy8gLFxuICAgICAgY29kZSA9PT0gMHgzQiB8fCAvLyA7XG4gICAgICBjb2RlID09PSAweDNBIHx8IC8vIDpcbiAgICAgIGNvZGUgPT09IDB4NUMgfHwgLy8gXFxcbiAgICAgIGNvZGUgPT09IDB4MkYgfHwgLy8gL1xuICAgICAgY29kZSA9PT0gMHg1QiB8fCAvLyBbXG4gICAgICBjb2RlID09PSAweDVEIHx8IC8vIF1cbiAgICAgIGNvZGUgPT09IDB4M0YgfHwgLy8gP1xuICAgICAgY29kZSA9PT0gMHgzRCB8fCAvLyA9XG4gICAgICBjb2RlID09PSAweDdCIHx8IC8vIHtcbiAgICAgIGNvZGUgPT09IDB4N0QgLy8gfVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvb2tpZSBuYW1lJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gY29va2llLXZhbHVlICAgICAgPSAqY29va2llLW9jdGV0IC8gKCBEUVVPVEUgKmNvb2tpZS1vY3RldCBEUVVPVEUgKVxuIGNvb2tpZS1vY3RldCAgICAgID0gJXgyMSAvICV4MjMtMkIgLyAleDJELTNBIC8gJXgzQy01QiAvICV4NUQtN0VcbiAgICAgICAgICAgICAgICAgICAgICAgOyBVUy1BU0NJSSBjaGFyYWN0ZXJzIGV4Y2x1ZGluZyBDVExzLFxuICAgICAgICAgICAgICAgICAgICAgICA7IHdoaXRlc3BhY2UgRFFVT1RFLCBjb21tYSwgc2VtaWNvbG9uLFxuICAgICAgICAgICAgICAgICAgICAgICA7IGFuZCBiYWNrc2xhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvb2tpZVZhbHVlICh2YWx1ZSkge1xuICBsZXQgbGVuID0gdmFsdWUubGVuZ3RoXG4gIGxldCBpID0gMFxuXG4gIC8vIGlmIHRoZSB2YWx1ZSBpcyB3cmFwcGVkIGluIERRVU9URVxuICBpZiAodmFsdWVbMF0gPT09ICdcIicpIHtcbiAgICBpZiAobGVuID09PSAxIHx8IHZhbHVlW2xlbiAtIDFdICE9PSAnXCInKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIHZhbHVlJylcbiAgICB9XG4gICAgLS1sZW5cbiAgICArK2lcbiAgfVxuXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgY29uc3QgY29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaSsrKVxuXG4gICAgaWYgKFxuICAgICAgY29kZSA8IDB4MjEgfHwgLy8gZXhjbHVkZSBDVExzICgwLTMxKVxuICAgICAgY29kZSA+IDB4N0UgfHwgLy8gbm9uLWFzY2lpIGFuZCBERUwgKDEyNylcbiAgICAgIGNvZGUgPT09IDB4MjIgfHwgLy8gXCJcbiAgICAgIGNvZGUgPT09IDB4MkMgfHwgLy8gLFxuICAgICAgY29kZSA9PT0gMHgzQiB8fCAvLyA7XG4gICAgICBjb2RlID09PSAweDVDIC8vIFxcXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIHZhbHVlJylcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBwYXRoLXZhbHVlICAgICAgICA9IDxhbnkgQ0hBUiBleGNlcHQgQ1RMcyBvciBcIjtcIj5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llUGF0aCAocGF0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpXG5cbiAgICBpZiAoXG4gICAgICBjb2RlIDwgMHgyMCB8fCAvLyBleGNsdWRlIENUTHMgKDAtMzEpXG4gICAgICBjb2RlID09PSAweDdGIHx8IC8vIERFTFxuICAgICAgY29kZSA9PT0gMHgzQiAvLyA7XG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29va2llIHBhdGgnKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEkgaGF2ZSBubyBpZGVhIHdoeSB0aGVzZSB2YWx1ZXMgYXJlbid0IGFsbG93ZWQgdG8gYmUgaG9uZXN0LFxuICogYnV0IERlbm8gdGVzdHMgdGhlc2UuIC0gS2hhZnJhXG4gKiBAcGFyYW0ge3N0cmluZ30gZG9tYWluXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ29va2llRG9tYWluIChkb21haW4pIHtcbiAgaWYgKFxuICAgIGRvbWFpbi5zdGFydHNXaXRoKCctJykgfHxcbiAgICBkb21haW4uZW5kc1dpdGgoJy4nKSB8fFxuICAgIGRvbWFpbi5lbmRzV2l0aCgnLScpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgZG9tYWluJylcbiAgfVxufVxuXG5jb25zdCBJTUZEYXlzID0gW1xuICAnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJyxcbiAgJ1RodScsICdGcmknLCAnU2F0J1xuXVxuXG5jb25zdCBJTUZNb250aHMgPSBbXG4gICdKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsXG4gICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYydcbl1cblxuY29uc3QgSU1GUGFkZGVkTnVtYmVycyA9IEFycmF5KDYxKS5maWxsKDApLm1hcCgoXywgaSkgPT4gaS50b1N0cmluZygpLnBhZFN0YXJ0KDIsICcwJykpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzIzMSNzZWN0aW9uLTcuMS4xLjFcbiAqIEBwYXJhbSB7bnVtYmVyfERhdGV9IGRhdGVcbiAgSU1GLWZpeGRhdGUgID0gZGF5LW5hbWUgXCIsXCIgU1AgZGF0ZTEgU1AgdGltZS1vZi1kYXkgU1AgR01UXG4gIDsgZml4ZWQgbGVuZ3RoL3pvbmUvY2FwaXRhbGl6YXRpb24gc3Vic2V0IG9mIHRoZSBmb3JtYXRcbiAgOyBzZWUgU2VjdGlvbiAzLjMgb2YgW1JGQzUzMjJdXG5cbiAgZGF5LW5hbWUgICAgID0gJXg0RC42Ri42RSA7IFwiTW9uXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1NC43NS42NSA7IFwiVHVlXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1Ny42NS42NCA7IFwiV2VkXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1NC42OC43NSA7IFwiVGh1XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg0Ni43Mi42OSA7IFwiRnJpXCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My42MS43NCA7IFwiU2F0XCIsIGNhc2Utc2Vuc2l0aXZlXG4gICAgICAgICAgICAgIC8gJXg1My43NS42RSA7IFwiU3VuXCIsIGNhc2Utc2Vuc2l0aXZlXG4gIGRhdGUxICAgICAgICA9IGRheSBTUCBtb250aCBTUCB5ZWFyXG4gICAgICAgICAgICAgICAgICA7IGUuZy4sIDAyIEp1biAxOTgyXG5cbiAgZGF5ICAgICAgICAgID0gMkRJR0lUXG4gIG1vbnRoICAgICAgICA9ICV4NEEuNjEuNkUgOyBcIkphblwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDYuNjUuNjIgOyBcIkZlYlwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEQuNjEuNzIgOyBcIk1hclwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDEuNzAuNzIgOyBcIkFwclwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEQuNjEuNzkgOyBcIk1heVwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEEuNzUuNkUgOyBcIkp1blwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEEuNzUuNkMgOyBcIkp1bFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDEuNzUuNjcgOyBcIkF1Z1wiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NTMuNjUuNzAgOyBcIlNlcFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEYuNjMuNzQgOyBcIk9jdFwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NEUuNkYuNzYgOyBcIk5vdlwiLCBjYXNlLXNlbnNpdGl2ZVxuICAgICAgICAgICAgICAvICV4NDQuNjUuNjMgOyBcIkRlY1wiLCBjYXNlLXNlbnNpdGl2ZVxuICB5ZWFyICAgICAgICAgPSA0RElHSVRcblxuICBHTVQgICAgICAgICAgPSAleDQ3LjRELjU0IDsgXCJHTVRcIiwgY2FzZS1zZW5zaXRpdmVcblxuICB0aW1lLW9mLWRheSAgPSBob3VyIFwiOlwiIG1pbnV0ZSBcIjpcIiBzZWNvbmRcbiAgICAgICAgICAgICAgOyAwMDowMDowMCAtIDIzOjU5OjYwIChsZWFwIHNlY29uZClcblxuICBob3VyICAgICAgICAgPSAyRElHSVRcbiAgbWludXRlICAgICAgID0gMkRJR0lUXG4gIHNlY29uZCAgICAgICA9IDJESUdJVFxuICovXG5mdW5jdGlvbiB0b0lNRkRhdGUgKGRhdGUpIHtcbiAgaWYgKHR5cGVvZiBkYXRlID09PSAnbnVtYmVyJykge1xuICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKVxuICB9XG5cbiAgcmV0dXJuIGAke0lNRkRheXNbZGF0ZS5nZXRVVENEYXkoKV19LCAke0lNRlBhZGRlZE51bWJlcnNbZGF0ZS5nZXRVVENEYXRlKCldfSAke0lNRk1vbnRoc1tkYXRlLmdldFVUQ01vbnRoKCldfSAke2RhdGUuZ2V0VVRDRnVsbFllYXIoKX0gJHtJTUZQYWRkZWROdW1iZXJzW2RhdGUuZ2V0VVRDSG91cnMoKV19OiR7SU1GUGFkZGVkTnVtYmVyc1tkYXRlLmdldFVUQ01pbnV0ZXMoKV19OiR7SU1GUGFkZGVkTnVtYmVyc1tkYXRlLmdldFVUQ1NlY29uZHMoKV19IEdNVGBcbn1cblxuLyoqXG4gbWF4LWFnZS1hdiAgICAgICAgPSBcIk1heC1BZ2U9XCIgbm9uLXplcm8tZGlnaXQgKkRJR0lUXG4gICAgICAgICAgICAgICAgICAgICAgIDsgSW4gcHJhY3RpY2UsIGJvdGggZXhwaXJlcy1hdiBhbmQgbWF4LWFnZS1hdlxuICAgICAgICAgICAgICAgICAgICAgICA7IGFyZSBsaW1pdGVkIHRvIGRhdGVzIHJlcHJlc2VudGFibGUgYnkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgIDsgdXNlciBhZ2VudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhBZ2VcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb29raWVNYXhBZ2UgKG1heEFnZSkge1xuICBpZiAobWF4QWdlIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb29raWUgbWF4LWFnZScpXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2MjY1I3NlY3Rpb24tNC4xLjFcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuQ29va2llfSBjb29raWVcbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5IChjb29raWUpIHtcbiAgaWYgKGNvb2tpZS5uYW1lLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICB2YWxpZGF0ZUNvb2tpZU5hbWUoY29va2llLm5hbWUpXG4gIHZhbGlkYXRlQ29va2llVmFsdWUoY29va2llLnZhbHVlKVxuXG4gIGNvbnN0IG91dCA9IFtgJHtjb29raWUubmFtZX09JHtjb29raWUudmFsdWV9YF1cblxuICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlldGYtaHR0cGJpcy1jb29raWUtcHJlZml4ZXMtMDAjc2VjdGlvbi0zLjFcbiAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pZXRmLWh0dHBiaXMtY29va2llLXByZWZpeGVzLTAwI3NlY3Rpb24tMy4yXG4gIGlmIChjb29raWUubmFtZS5zdGFydHNXaXRoKCdfX1NlY3VyZS0nKSkge1xuICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlXG4gIH1cblxuICBpZiAoY29va2llLm5hbWUuc3RhcnRzV2l0aCgnX19Ib3N0LScpKSB7XG4gICAgY29va2llLnNlY3VyZSA9IHRydWVcbiAgICBjb29raWUuZG9tYWluID0gbnVsbFxuICAgIGNvb2tpZS5wYXRoID0gJy8nXG4gIH1cblxuICBpZiAoY29va2llLnNlY3VyZSkge1xuICAgIG91dC5wdXNoKCdTZWN1cmUnKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5odHRwT25seSkge1xuICAgIG91dC5wdXNoKCdIdHRwT25seScpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvb2tpZS5tYXhBZ2UgPT09ICdudW1iZXInKSB7XG4gICAgdmFsaWRhdGVDb29raWVNYXhBZ2UoY29va2llLm1heEFnZSlcbiAgICBvdXQucHVzaChgTWF4LUFnZT0ke2Nvb2tpZS5tYXhBZ2V9YClcbiAgfVxuXG4gIGlmIChjb29raWUuZG9tYWluKSB7XG4gICAgdmFsaWRhdGVDb29raWVEb21haW4oY29va2llLmRvbWFpbilcbiAgICBvdXQucHVzaChgRG9tYWluPSR7Y29va2llLmRvbWFpbn1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5wYXRoKSB7XG4gICAgdmFsaWRhdGVDb29raWVQYXRoKGNvb2tpZS5wYXRoKVxuICAgIG91dC5wdXNoKGBQYXRoPSR7Y29va2llLnBhdGh9YClcbiAgfVxuXG4gIGlmIChjb29raWUuZXhwaXJlcyAmJiBjb29raWUuZXhwaXJlcy50b1N0cmluZygpICE9PSAnSW52YWxpZCBEYXRlJykge1xuICAgIG91dC5wdXNoKGBFeHBpcmVzPSR7dG9JTUZEYXRlKGNvb2tpZS5leHBpcmVzKX1gKVxuICB9XG5cbiAgaWYgKGNvb2tpZS5zYW1lU2l0ZSkge1xuICAgIG91dC5wdXNoKGBTYW1lU2l0ZT0ke2Nvb2tpZS5zYW1lU2l0ZX1gKVxuICB9XG5cbiAgZm9yIChjb25zdCBwYXJ0IG9mIGNvb2tpZS51bnBhcnNlZCkge1xuICAgIGlmICghcGFydC5pbmNsdWRlcygnPScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5wYXJzZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IFtrZXksIC4uLnZhbHVlXSA9IHBhcnQuc3BsaXQoJz0nKVxuXG4gICAgb3V0LnB1c2goYCR7a2V5LnRyaW0oKX09JHt2YWx1ZS5qb2luKCc9Jyl9YClcbiAgfVxuXG4gIHJldHVybiBvdXQuam9pbignOyAnKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNDVExFeGNsdWRpbmdIdGFiLFxuICB2YWxpZGF0ZUNvb2tpZU5hbWUsXG4gIHZhbGlkYXRlQ29va2llUGF0aCxcbiAgdmFsaWRhdGVDb29raWVWYWx1ZSxcbiAgdG9JTUZEYXRlLFxuICBzdHJpbmdpZnlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/cookies/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js":
/*!***********************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource-stream.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { isASCIINumber, isValidLastEventId } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/eventsource/util.js\")\n\n/**\n * @type {number[]} BOM\n */\nconst BOM = [0xEF, 0xBB, 0xBF]\n/**\n * @type {10} LF\n */\nconst LF = 0x0A\n/**\n * @type {13} CR\n */\nconst CR = 0x0D\n/**\n * @type {58} COLON\n */\nconst COLON = 0x3A\n/**\n * @type {32} SPACE\n */\nconst SPACE = 0x20\n\n/**\n * @typedef {object} EventSourceStreamEvent\n * @type {object}\n * @property {string} [event] The event type.\n * @property {string} [data] The data of the message.\n * @property {string} [id] A unique ID for the event.\n * @property {string} [retry] The reconnection time, in milliseconds.\n */\n\n/**\n * @typedef eventSourceSettings\n * @type {object}\n * @property {string} lastEventId The last event ID received from the server.\n * @property {string} origin The origin of the event source.\n * @property {number} reconnectionTime The reconnection time, in milliseconds.\n */\n\nclass EventSourceStream extends Transform {\n  /**\n   * @type {eventSourceSettings}\n   */\n  state = null\n\n  /**\n   * Leading byte-order-mark check.\n   * @type {boolean}\n   */\n  checkBOM = true\n\n  /**\n   * @type {boolean}\n   */\n  crlfCheck = false\n\n  /**\n   * @type {boolean}\n   */\n  eventEndCheck = false\n\n  /**\n   * @type {Buffer}\n   */\n  buffer = null\n\n  pos = 0\n\n  event = {\n    data: undefined,\n    event: undefined,\n    id: undefined,\n    retry: undefined\n  }\n\n  /**\n   * @param {object} options\n   * @param {eventSourceSettings} options.eventSourceSettings\n   * @param {Function} [options.push]\n   */\n  constructor (options = {}) {\n    // Enable object mode as EventSourceStream emits objects of shape\n    // EventSourceStreamEvent\n    options.readableObjectMode = true\n\n    super(options)\n\n    this.state = options.eventSourceSettings || {}\n    if (options.push) {\n      this.push = options.push\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {string} _encoding\n   * @param {Function} callback\n   * @returns {void}\n   */\n  _transform (chunk, _encoding, callback) {\n    if (chunk.length === 0) {\n      callback()\n      return\n    }\n\n    // Cache the chunk in the buffer, as the data might not be complete while\n    // processing it\n    // TODO: Investigate if there is a more performant way to handle\n    // incoming chunks\n    // see: https://github.com/nodejs/undici/issues/2630\n    if (this.buffer) {\n      this.buffer = Buffer.concat([this.buffer, chunk])\n    } else {\n      this.buffer = chunk\n    }\n\n    // Strip leading byte-order-mark if we opened the stream and started\n    // the processing of the incoming data\n    if (this.checkBOM) {\n      switch (this.buffer.length) {\n        case 1:\n          // Check if the first byte is the same as the first byte of the BOM\n          if (this.buffer[0] === BOM[0]) {\n            // If it is, we need to wait for more data\n            callback()\n            return\n          }\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n\n          // The buffer only contains one byte so we need to wait for more data\n          callback()\n          return\n        case 2:\n          // Check if the first two bytes are the same as the first two bytes\n          // of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1]\n          ) {\n            // If it is, we need to wait for more data, because the third byte\n            // is needed to determine if it is the BOM or not\n            callback()\n            return\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          // BOM anymore\n          this.checkBOM = false\n          break\n        case 3:\n          // Check if the first three bytes are the same as the first three\n          // bytes of the BOM\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // If it is, we can drop the buffered data, as it is only the BOM\n            this.buffer = Buffer.alloc(0)\n            // Set the checkBOM flag to false as we don't need to check for the\n            // BOM anymore\n            this.checkBOM = false\n\n            // Await more data\n            callback()\n            return\n          }\n          // If it is not the BOM, we can start processing the data\n          this.checkBOM = false\n          break\n        default:\n          // The buffer is longer than 3 bytes, so we can drop the BOM if it is\n          // present\n          if (\n            this.buffer[0] === BOM[0] &&\n            this.buffer[1] === BOM[1] &&\n            this.buffer[2] === BOM[2]\n          ) {\n            // Remove the BOM from the buffer\n            this.buffer = this.buffer.subarray(3)\n          }\n\n          // Set the checkBOM flag to false as we don't need to check for the\n          this.checkBOM = false\n          break\n      }\n    }\n\n    while (this.pos < this.buffer.length) {\n      // If the previous line ended with an end-of-line, we need to check\n      // if the next character is also an end-of-line.\n      if (this.eventEndCheck) {\n        // If the the current character is an end-of-line, then the event\n        // is finished and we can process it\n\n        // If the previous line ended with a carriage return, we need to\n        // check if the current character is a line feed and remove it\n        // from the buffer.\n        if (this.crlfCheck) {\n          // If the current character is a line feed, we can remove it\n          // from the buffer and reset the crlfCheck flag\n          if (this.buffer[this.pos] === LF) {\n            this.buffer = this.buffer.subarray(this.pos + 1)\n            this.pos = 0\n            this.crlfCheck = false\n\n            // It is possible that the line feed is not the end of the\n            // event. We need to check if the next character is an\n            // end-of-line character to determine if the event is\n            // finished. We simply continue the loop to check the next\n            // character.\n\n            // As we removed the line feed from the buffer and set the\n            // crlfCheck flag to false, we basically don't make any\n            // distinction between a line feed and a carriage return.\n            continue\n          }\n          this.crlfCheck = false\n        }\n\n        if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n          // If the current character is a carriage return, we need to\n          // set the crlfCheck flag to true, as we need to check if the\n          // next character is a line feed so we can remove it from the\n          // buffer\n          if (this.buffer[this.pos] === CR) {\n            this.crlfCheck = true\n          }\n\n          this.buffer = this.buffer.subarray(this.pos + 1)\n          this.pos = 0\n          if (\n            this.event.data !== undefined || this.event.event || this.event.id || this.event.retry) {\n            this.processEvent(this.event)\n          }\n          this.clearEvent()\n          continue\n        }\n        // If the current character is not an end-of-line, then the event\n        // is not finished and we have to reset the eventEndCheck flag\n        this.eventEndCheck = false\n        continue\n      }\n\n      // If the current character is an end-of-line, we can process the\n      // line\n      if (this.buffer[this.pos] === LF || this.buffer[this.pos] === CR) {\n        // If the current character is a carriage return, we need to\n        // set the crlfCheck flag to true, as we need to check if the\n        // next character is a line feed\n        if (this.buffer[this.pos] === CR) {\n          this.crlfCheck = true\n        }\n\n        // In any case, we can process the line as we reached an\n        // end-of-line character\n        this.parseLine(this.buffer.subarray(0, this.pos), this.event)\n\n        // Remove the processed line from the buffer\n        this.buffer = this.buffer.subarray(this.pos + 1)\n        // Reset the position as we removed the processed line from the buffer\n        this.pos = 0\n        // A line was processed and this could be the end of the event. We need\n        // to check if the next line is empty to determine if the event is\n        // finished.\n        this.eventEndCheck = true\n        continue\n      }\n\n      this.pos++\n    }\n\n    callback()\n  }\n\n  /**\n   * @param {Buffer} line\n   * @param {EventStreamEvent} event\n   */\n  parseLine (line, event) {\n    // If the line is empty (a blank line)\n    // Dispatch the event, as defined below.\n    // This will be handled in the _transform method\n    if (line.length === 0) {\n      return\n    }\n\n    // If the line starts with a U+003A COLON character (:)\n    // Ignore the line.\n    const colonPosition = line.indexOf(COLON)\n    if (colonPosition === 0) {\n      return\n    }\n\n    let field = ''\n    let value = ''\n\n    // If the line contains a U+003A COLON character (:)\n    if (colonPosition !== -1) {\n      // Collect the characters on the line before the first U+003A COLON\n      // character (:), and let field be that string.\n      // TODO: Investigate if there is a more performant way to extract the\n      // field\n      // see: https://github.com/nodejs/undici/issues/2630\n      field = line.subarray(0, colonPosition).toString('utf8')\n\n      // Collect the characters on the line after the first U+003A COLON\n      // character (:), and let value be that string.\n      // If value starts with a U+0020 SPACE character, remove it from value.\n      let valueStart = colonPosition + 1\n      if (line[valueStart] === SPACE) {\n        ++valueStart\n      }\n      // TODO: Investigate if there is a more performant way to extract the\n      // value\n      // see: https://github.com/nodejs/undici/issues/2630\n      value = line.subarray(valueStart).toString('utf8')\n\n      // Otherwise, the string is not empty but does not contain a U+003A COLON\n      // character (:)\n    } else {\n      // Process the field using the steps described below, using the whole\n      // line as the field name, and the empty string as the field value.\n      field = line.toString('utf8')\n      value = ''\n    }\n\n    // Modify the event with the field name and value. The value is also\n    // decoded as UTF-8\n    switch (field) {\n      case 'data':\n        if (event[field] === undefined) {\n          event[field] = value\n        } else {\n          event[field] += `\\n${value}`\n        }\n        break\n      case 'retry':\n        if (isASCIINumber(value)) {\n          event[field] = value\n        }\n        break\n      case 'id':\n        if (isValidLastEventId(value)) {\n          event[field] = value\n        }\n        break\n      case 'event':\n        if (value.length > 0) {\n          event[field] = value\n        }\n        break\n    }\n  }\n\n  /**\n   * @param {EventSourceStreamEvent} event\n   */\n  processEvent (event) {\n    if (event.retry && isASCIINumber(event.retry)) {\n      this.state.reconnectionTime = parseInt(event.retry, 10)\n    }\n\n    if (event.id && isValidLastEventId(event.id)) {\n      this.state.lastEventId = event.id\n    }\n\n    // only dispatch event, when data is provided\n    if (event.data !== undefined) {\n      this.push({\n        type: event.event || 'message',\n        options: {\n          data: event.data,\n          lastEventId: this.state.lastEventId,\n          origin: this.state.origin\n        }\n      })\n    }\n  }\n\n  clearEvent () {\n    this.event = {\n      data: undefined,\n      event: undefined,\n      id: undefined,\n      retry: undefined\n    }\n  }\n}\n\nmodule.exports = {\n  EventSourceStream\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2Utc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osUUFBUSxZQUFZLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzQyxRQUFRLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsdUVBQVE7O0FBRTlEO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVUsSUFBSTtBQUNkO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsVUFBVTtBQUNWLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEscUJBQXFCO0FBQ2xDLGFBQWEsVUFBVTtBQUN2QjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGV2ZW50c291cmNlXFxldmVudHNvdXJjZS1zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCB7IFRyYW5zZm9ybSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBpc0FTQ0lJTnVtYmVyLCBpc1ZhbGlkTGFzdEV2ZW50SWQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKlxuICogQHR5cGUge251bWJlcltdfSBCT01cbiAqL1xuY29uc3QgQk9NID0gWzB4RUYsIDB4QkIsIDB4QkZdXG4vKipcbiAqIEB0eXBlIHsxMH0gTEZcbiAqL1xuY29uc3QgTEYgPSAweDBBXG4vKipcbiAqIEB0eXBlIHsxM30gQ1JcbiAqL1xuY29uc3QgQ1IgPSAweDBEXG4vKipcbiAqIEB0eXBlIHs1OH0gQ09MT05cbiAqL1xuY29uc3QgQ09MT04gPSAweDNBXG4vKipcbiAqIEB0eXBlIHszMn0gU1BBQ0VcbiAqL1xuY29uc3QgU1BBQ0UgPSAweDIwXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRXZlbnRTb3VyY2VTdHJlYW1FdmVudFxuICogQHR5cGUge29iamVjdH1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXZlbnRdIFRoZSBldmVudCB0eXBlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtkYXRhXSBUaGUgZGF0YSBvZiB0aGUgbWVzc2FnZS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaWRdIEEgdW5pcXVlIElEIGZvciB0aGUgZXZlbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3JldHJ5XSBUaGUgcmVjb25uZWN0aW9uIHRpbWUsIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIGV2ZW50U291cmNlU2V0dGluZ3NcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvcGVydHkge3N0cmluZ30gbGFzdEV2ZW50SWQgVGhlIGxhc3QgZXZlbnQgSUQgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9yaWdpbiBUaGUgb3JpZ2luIG9mIHRoZSBldmVudCBzb3VyY2UuXG4gKiBAcHJvcGVydHkge251bWJlcn0gcmVjb25uZWN0aW9uVGltZSBUaGUgcmVjb25uZWN0aW9uIHRpbWUsIGluIG1pbGxpc2Vjb25kcy5cbiAqL1xuXG5jbGFzcyBFdmVudFNvdXJjZVN0cmVhbSBleHRlbmRzIFRyYW5zZm9ybSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7ZXZlbnRTb3VyY2VTZXR0aW5nc31cbiAgICovXG4gIHN0YXRlID0gbnVsbFxuXG4gIC8qKlxuICAgKiBMZWFkaW5nIGJ5dGUtb3JkZXItbWFyayBjaGVjay5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBjaGVja0JPTSA9IHRydWVcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBjcmxmQ2hlY2sgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGV2ZW50RW5kQ2hlY2sgPSBmYWxzZVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7QnVmZmVyfVxuICAgKi9cbiAgYnVmZmVyID0gbnVsbFxuXG4gIHBvcyA9IDBcblxuICBldmVudCA9IHtcbiAgICBkYXRhOiB1bmRlZmluZWQsXG4gICAgZXZlbnQ6IHVuZGVmaW5lZCxcbiAgICBpZDogdW5kZWZpbmVkLFxuICAgIHJldHJ5OiB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge2V2ZW50U291cmNlU2V0dGluZ3N9IG9wdGlvbnMuZXZlbnRTb3VyY2VTZXR0aW5nc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5wdXNoXVxuICAgKi9cbiAgY29uc3RydWN0b3IgKG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIEVuYWJsZSBvYmplY3QgbW9kZSBhcyBFdmVudFNvdXJjZVN0cmVhbSBlbWl0cyBvYmplY3RzIG9mIHNoYXBlXG4gICAgLy8gRXZlbnRTb3VyY2VTdHJlYW1FdmVudFxuICAgIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlID0gdHJ1ZVxuXG4gICAgc3VwZXIob3B0aW9ucylcblxuICAgIHRoaXMuc3RhdGUgPSBvcHRpb25zLmV2ZW50U291cmNlU2V0dGluZ3MgfHwge31cbiAgICBpZiAob3B0aW9ucy5wdXNoKSB7XG4gICAgICB0aGlzLnB1c2ggPSBvcHRpb25zLnB1c2hcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBfZW5jb2RpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfdHJhbnNmb3JtIChjaHVuaywgX2VuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmIChjaHVuay5sZW5ndGggPT09IDApIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIENhY2hlIHRoZSBjaHVuayBpbiB0aGUgYnVmZmVyLCBhcyB0aGUgZGF0YSBtaWdodCBub3QgYmUgY29tcGxldGUgd2hpbGVcbiAgICAvLyBwcm9jZXNzaW5nIGl0XG4gICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgdGhlcmUgaXMgYSBtb3JlIHBlcmZvcm1hbnQgd2F5IHRvIGhhbmRsZVxuICAgIC8vIGluY29taW5nIGNodW5rc1xuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzI2MzBcbiAgICBpZiAodGhpcy5idWZmZXIpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbdGhpcy5idWZmZXIsIGNodW5rXSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5idWZmZXIgPSBjaHVua1xuICAgIH1cblxuICAgIC8vIFN0cmlwIGxlYWRpbmcgYnl0ZS1vcmRlci1tYXJrIGlmIHdlIG9wZW5lZCB0aGUgc3RyZWFtIGFuZCBzdGFydGVkXG4gICAgLy8gdGhlIHByb2Nlc3Npbmcgb2YgdGhlIGluY29taW5nIGRhdGFcbiAgICBpZiAodGhpcy5jaGVja0JPTSkge1xuICAgICAgc3dpdGNoICh0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCBieXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCBieXRlIG9mIHRoZSBCT01cbiAgICAgICAgICBpZiAodGhpcy5idWZmZXJbMF0gPT09IEJPTVswXSkge1xuICAgICAgICAgICAgLy8gSWYgaXQgaXMsIHdlIG5lZWQgdG8gd2FpdCBmb3IgbW9yZSBkYXRhXG4gICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2V0IHRoZSBjaGVja0JPTSBmbGFnIHRvIGZhbHNlIGFzIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIHRoZVxuICAgICAgICAgIC8vIEJPTSBhbnltb3JlXG4gICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG5cbiAgICAgICAgICAvLyBUaGUgYnVmZmVyIG9ubHkgY29udGFpbnMgb25lIGJ5dGUgc28gd2UgbmVlZCB0byB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZmlyc3QgdHdvIGJ5dGVzIGFyZSB0aGUgc2FtZSBhcyB0aGUgZmlyc3QgdHdvIGJ5dGVzXG4gICAgICAgICAgLy8gb2YgdGhlIEJPTVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzBdID09PSBCT01bMF0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzFdID09PSBCT01bMV1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIG1vcmUgZGF0YSwgYmVjYXVzZSB0aGUgdGhpcmQgYnl0ZVxuICAgICAgICAgICAgLy8gaXMgbmVlZGVkIHRvIGRldGVybWluZSBpZiBpdCBpcyB0aGUgQk9NIG9yIG5vdFxuICAgICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2V0IHRoZSBjaGVja0JPTSBmbGFnIHRvIGZhbHNlIGFzIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIHRoZVxuICAgICAgICAgIC8vIEJPTSBhbnltb3JlXG4gICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBmaXJzdCB0aHJlZSBieXRlcyBhcmUgdGhlIHNhbWUgYXMgdGhlIGZpcnN0IHRocmVlXG4gICAgICAgICAgLy8gYnl0ZXMgb2YgdGhlIEJPTVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzBdID09PSBCT01bMF0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzFdID09PSBCT01bMV0gJiZcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyWzJdID09PSBCT01bMl1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGlzLCB3ZSBjYW4gZHJvcCB0aGUgYnVmZmVyZWQgZGF0YSwgYXMgaXQgaXMgb25seSB0aGUgQk9NXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygwKVxuICAgICAgICAgICAgLy8gU2V0IHRoZSBjaGVja0JPTSBmbGFnIHRvIGZhbHNlIGFzIHdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIHRoZVxuICAgICAgICAgICAgLy8gQk9NIGFueW1vcmVcbiAgICAgICAgICAgIHRoaXMuY2hlY2tCT00gPSBmYWxzZVxuXG4gICAgICAgICAgICAvLyBBd2FpdCBtb3JlIGRhdGFcbiAgICAgICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBJZiBpdCBpcyBub3QgdGhlIEJPTSwgd2UgY2FuIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIGRhdGFcbiAgICAgICAgICB0aGlzLmNoZWNrQk9NID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIFRoZSBidWZmZXIgaXMgbG9uZ2VyIHRoYW4gMyBieXRlcywgc28gd2UgY2FuIGRyb3AgdGhlIEJPTSBpZiBpdCBpc1xuICAgICAgICAgIC8vIHByZXNlbnRcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclswXSA9PT0gQk9NWzBdICYmXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclsxXSA9PT0gQk9NWzFdICYmXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclsyXSA9PT0gQk9NWzJdXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIEJPTSBmcm9tIHRoZSBidWZmZXJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3ViYXJyYXkoMylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZXQgdGhlIGNoZWNrQk9NIGZsYWcgdG8gZmFsc2UgYXMgd2UgZG9uJ3QgbmVlZCB0byBjaGVjayBmb3IgdGhlXG4gICAgICAgICAgdGhpcy5jaGVja0JPTSA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBsaW5lIGVuZGVkIHdpdGggYW4gZW5kLW9mLWxpbmUsIHdlIG5lZWQgdG8gY2hlY2tcbiAgICAgIC8vIGlmIHRoZSBuZXh0IGNoYXJhY3RlciBpcyBhbHNvIGFuIGVuZC1vZi1saW5lLlxuICAgICAgaWYgKHRoaXMuZXZlbnRFbmRDaGVjaykge1xuICAgICAgICAvLyBJZiB0aGUgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGFuIGVuZC1vZi1saW5lLCB0aGVuIHRoZSBldmVudFxuICAgICAgICAvLyBpcyBmaW5pc2hlZCBhbmQgd2UgY2FuIHByb2Nlc3MgaXRcblxuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgbGluZSBlbmRlZCB3aXRoIGEgY2FycmlhZ2UgcmV0dXJuLCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGxpbmUgZmVlZCBhbmQgcmVtb3ZlIGl0XG4gICAgICAgIC8vIGZyb20gdGhlIGJ1ZmZlci5cbiAgICAgICAgaWYgKHRoaXMuY3JsZkNoZWNrKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGEgbGluZSBmZWVkLCB3ZSBjYW4gcmVtb3ZlIGl0XG4gICAgICAgICAgLy8gZnJvbSB0aGUgYnVmZmVyIGFuZCByZXNldCB0aGUgY3JsZkNoZWNrIGZsYWdcbiAgICAgICAgICBpZiAodGhpcy5idWZmZXJbdGhpcy5wb3NdID09PSBMRikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5zdWJhcnJheSh0aGlzLnBvcyArIDEpXG4gICAgICAgICAgICB0aGlzLnBvcyA9IDBcbiAgICAgICAgICAgIHRoaXMuY3JsZkNoZWNrID0gZmFsc2VcblxuICAgICAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdGhhdCB0aGUgbGluZSBmZWVkIGlzIG5vdCB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgLy8gZXZlbnQuIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIG5leHQgY2hhcmFjdGVyIGlzIGFuXG4gICAgICAgICAgICAvLyBlbmQtb2YtbGluZSBjaGFyYWN0ZXIgdG8gZGV0ZXJtaW5lIGlmIHRoZSBldmVudCBpc1xuICAgICAgICAgICAgLy8gZmluaXNoZWQuIFdlIHNpbXBseSBjb250aW51ZSB0aGUgbG9vcCB0byBjaGVjayB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gY2hhcmFjdGVyLlxuXG4gICAgICAgICAgICAvLyBBcyB3ZSByZW1vdmVkIHRoZSBsaW5lIGZlZWQgZnJvbSB0aGUgYnVmZmVyIGFuZCBzZXQgdGhlXG4gICAgICAgICAgICAvLyBjcmxmQ2hlY2sgZmxhZyB0byBmYWxzZSwgd2UgYmFzaWNhbGx5IGRvbid0IG1ha2UgYW55XG4gICAgICAgICAgICAvLyBkaXN0aW5jdGlvbiBiZXR3ZWVuIGEgbGluZSBmZWVkIGFuZCBhIGNhcnJpYWdlIHJldHVybi5cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuY3JsZkNoZWNrID0gZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IExGIHx8IHRoaXMuYnVmZmVyW3RoaXMucG9zXSA9PT0gQ1IpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgYSBjYXJyaWFnZSByZXR1cm4sIHdlIG5lZWQgdG9cbiAgICAgICAgICAvLyBzZXQgdGhlIGNybGZDaGVjayBmbGFnIHRvIHRydWUsIGFzIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlXG4gICAgICAgICAgLy8gbmV4dCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGZlZWQgc28gd2UgY2FuIHJlbW92ZSBpdCBmcm9tIHRoZVxuICAgICAgICAgIC8vIGJ1ZmZlclxuICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IENSKSB7XG4gICAgICAgICAgICB0aGlzLmNybGZDaGVjayA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YmFycmF5KHRoaXMucG9zICsgMSlcbiAgICAgICAgICB0aGlzLnBvcyA9IDBcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmV2ZW50LmRhdGEgIT09IHVuZGVmaW5lZCB8fCB0aGlzLmV2ZW50LmV2ZW50IHx8IHRoaXMuZXZlbnQuaWQgfHwgdGhpcy5ldmVudC5yZXRyeSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzRXZlbnQodGhpcy5ldmVudClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jbGVhckV2ZW50KClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBub3QgYW4gZW5kLW9mLWxpbmUsIHRoZW4gdGhlIGV2ZW50XG4gICAgICAgIC8vIGlzIG5vdCBmaW5pc2hlZCBhbmQgd2UgaGF2ZSB0byByZXNldCB0aGUgZXZlbnRFbmRDaGVjayBmbGFnXG4gICAgICAgIHRoaXMuZXZlbnRFbmRDaGVjayA9IGZhbHNlXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhbiBlbmQtb2YtbGluZSwgd2UgY2FuIHByb2Nlc3MgdGhlXG4gICAgICAvLyBsaW5lXG4gICAgICBpZiAodGhpcy5idWZmZXJbdGhpcy5wb3NdID09PSBMRiB8fCB0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IENSKSB7XG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBhIGNhcnJpYWdlIHJldHVybiwgd2UgbmVlZCB0b1xuICAgICAgICAvLyBzZXQgdGhlIGNybGZDaGVjayBmbGFnIHRvIHRydWUsIGFzIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlXG4gICAgICAgIC8vIG5leHQgY2hhcmFjdGVyIGlzIGEgbGluZSBmZWVkXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclt0aGlzLnBvc10gPT09IENSKSB7XG4gICAgICAgICAgdGhpcy5jcmxmQ2hlY2sgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbiBhbnkgY2FzZSwgd2UgY2FuIHByb2Nlc3MgdGhlIGxpbmUgYXMgd2UgcmVhY2hlZCBhblxuICAgICAgICAvLyBlbmQtb2YtbGluZSBjaGFyYWN0ZXJcbiAgICAgICAgdGhpcy5wYXJzZUxpbmUodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3MpLCB0aGlzLmV2ZW50KVxuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgcHJvY2Vzc2VkIGxpbmUgZnJvbSB0aGUgYnVmZmVyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3ViYXJyYXkodGhpcy5wb3MgKyAxKVxuICAgICAgICAvLyBSZXNldCB0aGUgcG9zaXRpb24gYXMgd2UgcmVtb3ZlZCB0aGUgcHJvY2Vzc2VkIGxpbmUgZnJvbSB0aGUgYnVmZmVyXG4gICAgICAgIHRoaXMucG9zID0gMFxuICAgICAgICAvLyBBIGxpbmUgd2FzIHByb2Nlc3NlZCBhbmQgdGhpcyBjb3VsZCBiZSB0aGUgZW5kIG9mIHRoZSBldmVudC4gV2UgbmVlZFxuICAgICAgICAvLyB0byBjaGVjayBpZiB0aGUgbmV4dCBsaW5lIGlzIGVtcHR5IHRvIGRldGVybWluZSBpZiB0aGUgZXZlbnQgaXNcbiAgICAgICAgLy8gZmluaXNoZWQuXG4gICAgICAgIHRoaXMuZXZlbnRFbmRDaGVjayA9IHRydWVcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdGhpcy5wb3MrK1xuICAgIH1cblxuICAgIGNhbGxiYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gbGluZVxuICAgKiBAcGFyYW0ge0V2ZW50U3RyZWFtRXZlbnR9IGV2ZW50XG4gICAqL1xuICBwYXJzZUxpbmUgKGxpbmUsIGV2ZW50KSB7XG4gICAgLy8gSWYgdGhlIGxpbmUgaXMgZW1wdHkgKGEgYmxhbmsgbGluZSlcbiAgICAvLyBEaXNwYXRjaCB0aGUgZXZlbnQsIGFzIGRlZmluZWQgYmVsb3cuXG4gICAgLy8gVGhpcyB3aWxsIGJlIGhhbmRsZWQgaW4gdGhlIF90cmFuc2Zvcm0gbWV0aG9kXG4gICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbGluZSBzdGFydHMgd2l0aCBhIFUrMDAzQSBDT0xPTiBjaGFyYWN0ZXIgKDopXG4gICAgLy8gSWdub3JlIHRoZSBsaW5lLlxuICAgIGNvbnN0IGNvbG9uUG9zaXRpb24gPSBsaW5lLmluZGV4T2YoQ09MT04pXG4gICAgaWYgKGNvbG9uUG9zaXRpb24gPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBmaWVsZCA9ICcnXG4gICAgbGV0IHZhbHVlID0gJydcblxuICAgIC8vIElmIHRoZSBsaW5lIGNvbnRhaW5zIGEgVSswMDNBIENPTE9OIGNoYXJhY3RlciAoOilcbiAgICBpZiAoY29sb25Qb3NpdGlvbiAhPT0gLTEpIHtcbiAgICAgIC8vIENvbGxlY3QgdGhlIGNoYXJhY3RlcnMgb24gdGhlIGxpbmUgYmVmb3JlIHRoZSBmaXJzdCBVKzAwM0EgQ09MT05cbiAgICAgIC8vIGNoYXJhY3RlciAoOiksIGFuZCBsZXQgZmllbGQgYmUgdGhhdCBzdHJpbmcuXG4gICAgICAvLyBUT0RPOiBJbnZlc3RpZ2F0ZSBpZiB0aGVyZSBpcyBhIG1vcmUgcGVyZm9ybWFudCB3YXkgdG8gZXh0cmFjdCB0aGVcbiAgICAgIC8vIGZpZWxkXG4gICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yNjMwXG4gICAgICBmaWVsZCA9IGxpbmUuc3ViYXJyYXkoMCwgY29sb25Qb3NpdGlvbikudG9TdHJpbmcoJ3V0ZjgnKVxuXG4gICAgICAvLyBDb2xsZWN0IHRoZSBjaGFyYWN0ZXJzIG9uIHRoZSBsaW5lIGFmdGVyIHRoZSBmaXJzdCBVKzAwM0EgQ09MT05cbiAgICAgIC8vIGNoYXJhY3RlciAoOiksIGFuZCBsZXQgdmFsdWUgYmUgdGhhdCBzdHJpbmcuXG4gICAgICAvLyBJZiB2YWx1ZSBzdGFydHMgd2l0aCBhIFUrMDAyMCBTUEFDRSBjaGFyYWN0ZXIsIHJlbW92ZSBpdCBmcm9tIHZhbHVlLlxuICAgICAgbGV0IHZhbHVlU3RhcnQgPSBjb2xvblBvc2l0aW9uICsgMVxuICAgICAgaWYgKGxpbmVbdmFsdWVTdGFydF0gPT09IFNQQUNFKSB7XG4gICAgICAgICsrdmFsdWVTdGFydFxuICAgICAgfVxuICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgaWYgdGhlcmUgaXMgYSBtb3JlIHBlcmZvcm1hbnQgd2F5IHRvIGV4dHJhY3QgdGhlXG4gICAgICAvLyB2YWx1ZVxuICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjYzMFxuICAgICAgdmFsdWUgPSBsaW5lLnN1YmFycmF5KHZhbHVlU3RhcnQpLnRvU3RyaW5nKCd1dGY4JylcblxuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgc3RyaW5nIGlzIG5vdCBlbXB0eSBidXQgZG9lcyBub3QgY29udGFpbiBhIFUrMDAzQSBDT0xPTlxuICAgICAgLy8gY2hhcmFjdGVyICg6KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcm9jZXNzIHRoZSBmaWVsZCB1c2luZyB0aGUgc3RlcHMgZGVzY3JpYmVkIGJlbG93LCB1c2luZyB0aGUgd2hvbGVcbiAgICAgIC8vIGxpbmUgYXMgdGhlIGZpZWxkIG5hbWUsIGFuZCB0aGUgZW1wdHkgc3RyaW5nIGFzIHRoZSBmaWVsZCB2YWx1ZS5cbiAgICAgIGZpZWxkID0gbGluZS50b1N0cmluZygndXRmOCcpXG4gICAgICB2YWx1ZSA9ICcnXG4gICAgfVxuXG4gICAgLy8gTW9kaWZ5IHRoZSBldmVudCB3aXRoIHRoZSBmaWVsZCBuYW1lIGFuZCB2YWx1ZS4gVGhlIHZhbHVlIGlzIGFsc29cbiAgICAvLyBkZWNvZGVkIGFzIFVURi04XG4gICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgIGlmIChldmVudFtmaWVsZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50W2ZpZWxkXSA9IHZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdICs9IGBcXG4ke3ZhbHVlfWBcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAncmV0cnknOlxuICAgICAgICBpZiAoaXNBU0NJSU51bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICBldmVudFtmaWVsZF0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdpZCc6XG4gICAgICAgIGlmIChpc1ZhbGlkTGFzdEV2ZW50SWQodmFsdWUpKSB7XG4gICAgICAgICAgZXZlbnRbZmllbGRdID0gdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnZXZlbnQnOlxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGV2ZW50W2ZpZWxkXSA9IHZhbHVlXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFNvdXJjZVN0cmVhbUV2ZW50fSBldmVudFxuICAgKi9cbiAgcHJvY2Vzc0V2ZW50IChldmVudCkge1xuICAgIGlmIChldmVudC5yZXRyeSAmJiBpc0FTQ0lJTnVtYmVyKGV2ZW50LnJldHJ5KSkge1xuICAgICAgdGhpcy5zdGF0ZS5yZWNvbm5lY3Rpb25UaW1lID0gcGFyc2VJbnQoZXZlbnQucmV0cnksIDEwKVxuICAgIH1cblxuICAgIGlmIChldmVudC5pZCAmJiBpc1ZhbGlkTGFzdEV2ZW50SWQoZXZlbnQuaWQpKSB7XG4gICAgICB0aGlzLnN0YXRlLmxhc3RFdmVudElkID0gZXZlbnQuaWRcbiAgICB9XG5cbiAgICAvLyBvbmx5IGRpc3BhdGNoIGV2ZW50LCB3aGVuIGRhdGEgaXMgcHJvdmlkZWRcbiAgICBpZiAoZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnB1c2goe1xuICAgICAgICB0eXBlOiBldmVudC5ldmVudCB8fCAnbWVzc2FnZScsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBkYXRhOiBldmVudC5kYXRhLFxuICAgICAgICAgIGxhc3RFdmVudElkOiB0aGlzLnN0YXRlLmxhc3RFdmVudElkLFxuICAgICAgICAgIG9yaWdpbjogdGhpcy5zdGF0ZS5vcmlnaW5cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjbGVhckV2ZW50ICgpIHtcbiAgICB0aGlzLmV2ZW50ID0ge1xuICAgICAgZGF0YTogdW5kZWZpbmVkLFxuICAgICAgZXZlbnQ6IHVuZGVmaW5lZCxcbiAgICAgIGlkOiB1bmRlZmluZWQsXG4gICAgICByZXRyeTogdW5kZWZpbmVkXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFdmVudFNvdXJjZVN0cmVhbVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/eventsource/eventsource.js":
/*!****************************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/eventsource.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { pipeline } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { fetching } = __webpack_require__(/*! ../fetch */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { EventSourceStream } = __webpack_require__(/*! ./eventsource-stream */ \"(rsc)/./node_modules/undici/lib/web/eventsource/eventsource-stream.js\")\nconst { parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { createFastMessageEvent } = __webpack_require__(/*! ../websocket/events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { isNetworkError } = __webpack_require__(/*! ../fetch/response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { delay } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/eventsource/util.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\n\nlet experimentalWarned = false\n\n/**\n * A reconnection time, in milliseconds. This must initially be an implementation-defined value,\n * probably in the region of a few seconds.\n *\n * In Comparison:\n * - Chrome uses 3000ms.\n * - Deno uses 5000ms.\n *\n * @type {3000}\n */\nconst defaultReconnectionTime = 3000\n\n/**\n * The readyState attribute represents the state of the connection.\n * @enum\n * @readonly\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#dom-eventsource-readystate-dev\n */\n\n/**\n * The connection has not yet been established, or it was closed and the user\n * agent is reconnecting.\n * @type {0}\n */\nconst CONNECTING = 0\n\n/**\n * The user agent has an open connection and is dispatching events as it\n * receives them.\n * @type {1}\n */\nconst OPEN = 1\n\n/**\n * The connection is not open, and the user agent is not trying to reconnect.\n * @type {2}\n */\nconst CLOSED = 2\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"same-origin\".\n * @type {'anonymous'}\n */\nconst ANONYMOUS = 'anonymous'\n\n/**\n * Requests for the element will have their mode set to \"cors\" and their credentials mode set to \"include\".\n * @type {'use-credentials'}\n */\nconst USE_CREDENTIALS = 'use-credentials'\n\n/**\n * The EventSource interface is used to receive server-sent events. It\n * connects to a server over HTTP and receives events in text/event-stream\n * format without closing the connection.\n * @extends {EventTarget}\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#server-sent-events\n * @api public\n */\nclass EventSource extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    message: null\n  }\n\n  #url = null\n  #withCredentials = false\n\n  #readyState = CONNECTING\n\n  #request = null\n  #controller = null\n\n  #dispatcher\n\n  /**\n   * @type {import('./eventsource-stream').eventSourceSettings}\n   */\n  #state\n\n  /**\n   * Creates a new EventSource object.\n   * @param {string} url\n   * @param {EventSourceInit} [eventSourceInitDict]\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#the-eventsource-interface\n   */\n  constructor (url, eventSourceInitDict = {}) {\n    // 1. Let ev be a new EventSource object.\n    super()\n\n    webidl.util.markAsUncloneable(this)\n\n    const prefix = 'EventSource constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('EventSource is experimental, expect them to change at any time.', {\n        code: 'UNDICI-ES'\n      })\n    }\n\n    url = webidl.converters.USVString(url, prefix, 'url')\n    eventSourceInitDict = webidl.converters.EventSourceInitDict(eventSourceInitDict, prefix, 'eventSourceInitDict')\n\n    this.#dispatcher = eventSourceInitDict.dispatcher\n    this.#state = {\n      lastEventId: '',\n      reconnectionTime: defaultReconnectionTime\n    }\n\n    // 2. Let settings be ev's relevant settings object.\n    // https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object\n    const settings = environmentSettingsObject\n\n    let urlRecord\n\n    try {\n      // 3. Let urlRecord be the result of encoding-parsing a URL given url, relative to settings.\n      urlRecord = new URL(url, settings.settingsObject.baseUrl)\n      this.#state.origin = urlRecord.origin\n    } catch (e) {\n      // 4. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 5. Set ev's url to urlRecord.\n    this.#url = urlRecord.href\n\n    // 6. Let corsAttributeState be Anonymous.\n    let corsAttributeState = ANONYMOUS\n\n    // 7. If the value of eventSourceInitDict's withCredentials member is true,\n    // then set corsAttributeState to Use Credentials and set ev's\n    // withCredentials attribute to true.\n    if (eventSourceInitDict.withCredentials) {\n      corsAttributeState = USE_CREDENTIALS\n      this.#withCredentials = true\n    }\n\n    // 8. Let request be the result of creating a potential-CORS request given\n    // urlRecord, the empty string, and corsAttributeState.\n    const initRequest = {\n      redirect: 'follow',\n      keepalive: true,\n      // @see https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes\n      mode: 'cors',\n      credentials: corsAttributeState === 'anonymous'\n        ? 'same-origin'\n        : 'omit',\n      referrer: 'no-referrer'\n    }\n\n    // 9. Set request's client to settings.\n    initRequest.client = environmentSettingsObject.settingsObject\n\n    // 10. User agents may set (`Accept`, `text/event-stream`) in request's header list.\n    initRequest.headersList = [['accept', { name: 'accept', value: 'text/event-stream' }]]\n\n    // 11. Set request's cache mode to \"no-store\".\n    initRequest.cache = 'no-store'\n\n    // 12. Set request's initiator type to \"other\".\n    initRequest.initiator = 'other'\n\n    initRequest.urlList = [new URL(this.#url)]\n\n    // 13. Set ev's request to request.\n    this.#request = makeRequest(initRequest)\n\n    this.#connect()\n  }\n\n  /**\n   * Returns the state of this EventSource object's connection. It can have the\n   * values described below.\n   * @returns {0|1|2}\n   * @readonly\n   */\n  get readyState () {\n    return this.#readyState\n  }\n\n  /**\n   * Returns the URL providing the event stream.\n   * @readonly\n   * @returns {string}\n   */\n  get url () {\n    return this.#url\n  }\n\n  /**\n   * Returns a boolean indicating whether the EventSource object was\n   * instantiated with CORS credentials set (true), or not (false, the default).\n   */\n  get withCredentials () {\n    return this.#withCredentials\n  }\n\n  #connect () {\n    if (this.#readyState === CLOSED) return\n\n    this.#readyState = CONNECTING\n\n    const fetchParams = {\n      request: this.#request,\n      dispatcher: this.#dispatcher\n    }\n\n    // 14. Let processEventSourceEndOfBody given response res be the following step: if res is not a network error, then reestablish the connection.\n    const processEventSourceEndOfBody = (response) => {\n      if (isNetworkError(response)) {\n        this.dispatchEvent(new Event('error'))\n        this.close()\n      }\n\n      this.#reconnect()\n    }\n\n    // 15. Fetch request, with processResponseEndOfBody set to processEventSourceEndOfBody...\n    fetchParams.processResponseEndOfBody = processEventSourceEndOfBody\n\n    // and processResponse set to the following steps given response res:\n    fetchParams.processResponse = (response) => {\n      // 1. If res is an aborted network error, then fail the connection.\n\n      if (isNetworkError(response)) {\n        // 1. When a user agent is to fail the connection, the user agent\n        // must queue a task which, if the readyState attribute is set to a\n        // value other than CLOSED, sets the readyState attribute to CLOSED\n        // and fires an event named error at the EventSource object. Once the\n        // user agent has failed the connection, it does not attempt to\n        // reconnect.\n        if (response.aborted) {\n          this.close()\n          this.dispatchEvent(new Event('error'))\n          return\n          // 2. Otherwise, if res is a network error, then reestablish the\n          // connection, unless the user agent knows that to be futile, in\n          // which case the user agent may fail the connection.\n        } else {\n          this.#reconnect()\n          return\n        }\n      }\n\n      // 3. Otherwise, if res's status is not 200, or if res's `Content-Type`\n      // is not `text/event-stream`, then fail the connection.\n      const contentType = response.headersList.get('content-type', true)\n      const mimeType = contentType !== null ? parseMIMEType(contentType) : 'failure'\n      const contentTypeValid = mimeType !== 'failure' && mimeType.essence === 'text/event-stream'\n      if (\n        response.status !== 200 ||\n        contentTypeValid === false\n      ) {\n        this.close()\n        this.dispatchEvent(new Event('error'))\n        return\n      }\n\n      // 4. Otherwise, announce the connection and interpret res's body\n      // line by line.\n\n      // When a user agent is to announce the connection, the user agent\n      // must queue a task which, if the readyState attribute is set to a\n      // value other than CLOSED, sets the readyState attribute to OPEN\n      // and fires an event named open at the EventSource object.\n      // @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n      this.#readyState = OPEN\n      this.dispatchEvent(new Event('open'))\n\n      // If redirected to a different origin, set the origin to the new origin.\n      this.#state.origin = response.urlList[response.urlList.length - 1].origin\n\n      const eventSourceStream = new EventSourceStream({\n        eventSourceSettings: this.#state,\n        push: (event) => {\n          this.dispatchEvent(createFastMessageEvent(\n            event.type,\n            event.options\n          ))\n        }\n      })\n\n      pipeline(response.body.stream,\n        eventSourceStream,\n        (error) => {\n          if (\n            error?.aborted === false\n          ) {\n            this.close()\n            this.dispatchEvent(new Event('error'))\n          }\n        })\n    }\n\n    this.#controller = fetching(fetchParams)\n  }\n\n  /**\n   * @see https://html.spec.whatwg.org/multipage/server-sent-events.html#sse-processing-model\n   * @returns {Promise<void>}\n   */\n  async #reconnect () {\n    // When a user agent is to reestablish the connection, the user agent must\n    // run the following steps. These steps are run in parallel, not as part of\n    // a task. (The tasks that it queues, of course, are run like normal tasks\n    // and not themselves in parallel.)\n\n    // 1. Queue a task to run the following steps:\n\n    //   1. If the readyState attribute is set to CLOSED, abort the task.\n    if (this.#readyState === CLOSED) return\n\n    //   2. Set the readyState attribute to CONNECTING.\n    this.#readyState = CONNECTING\n\n    //   3. Fire an event named error at the EventSource object.\n    this.dispatchEvent(new Event('error'))\n\n    // 2. Wait a delay equal to the reconnection time of the event source.\n    await delay(this.#state.reconnectionTime)\n\n    // 5. Queue a task to run the following steps:\n\n    //   1. If the EventSource object's readyState attribute is not set to\n    //      CONNECTING, then return.\n    if (this.#readyState !== CONNECTING) return\n\n    //   2. Let request be the EventSource object's request.\n    //   3. If the EventSource object's last event ID string is not the empty\n    //      string, then:\n    //      1. Let lastEventIDValue be the EventSource object's last event ID\n    //         string, encoded as UTF-8.\n    //      2. Set (`Last-Event-ID`, lastEventIDValue) in request's header\n    //         list.\n    if (this.#state.lastEventId.length) {\n      this.#request.headersList.set('last-event-id', this.#state.lastEventId, true)\n    }\n\n    //   4. Fetch request and process the response obtained in this fashion, if any, as described earlier in this section.\n    this.#connect()\n  }\n\n  /**\n   * Closes the connection, if any, and sets the readyState attribute to\n   * CLOSED.\n   */\n  close () {\n    webidl.brandCheck(this, EventSource)\n\n    if (this.#readyState === CLOSED) return\n    this.#readyState = CLOSED\n    this.#controller.abort()\n    this.#request = null\n  }\n\n  get onopen () {\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onmessage () {\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get onerror () {\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n}\n\nconst constantsPropertyDescriptors = {\n  CONNECTING: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CONNECTING,\n    writable: false\n  },\n  OPEN: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: OPEN,\n    writable: false\n  },\n  CLOSED: {\n    __proto__: null,\n    configurable: false,\n    enumerable: true,\n    value: CLOSED,\n    writable: false\n  }\n}\n\nObject.defineProperties(EventSource, constantsPropertyDescriptors)\nObject.defineProperties(EventSource.prototype, constantsPropertyDescriptors)\n\nObject.defineProperties(EventSource.prototype, {\n  close: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  url: kEnumerableProperty,\n  withCredentials: kEnumerableProperty\n})\n\nwebidl.converters.EventSourceInitDict = webidl.dictionaryConverter([\n  {\n    key: 'withCredentials',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'dispatcher', // undici only\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  EventSource,\n  defaultReconnectionTime\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvZXZlbnRzb3VyY2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMxQyxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG9FQUFVO0FBQ3ZDLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsOEVBQWtCO0FBQ2xELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsNEVBQWlCO0FBQzVDLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyxtR0FBc0I7QUFDNUQsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLGdGQUFtQjtBQUNyRCxRQUFRLHlCQUF5QixFQUFFLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ2hFLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDdEQsUUFBUSxRQUFRLEVBQUUsbUJBQU8sQ0FBQyx1RUFBUTtBQUNsQyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pELFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBZTs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsNENBQTRDOztBQUV4RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZXZlbnRzb3VyY2VcXGV2ZW50c291cmNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHBpcGVsaW5lIH0gPSByZXF1aXJlKCdub2RlOnN0cmVhbScpXG5jb25zdCB7IGZldGNoaW5nIH0gPSByZXF1aXJlKCcuLi9mZXRjaCcpXG5jb25zdCB7IG1ha2VSZXF1ZXN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC9yZXF1ZXN0JylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBFdmVudFNvdXJjZVN0cmVhbSB9ID0gcmVxdWlyZSgnLi9ldmVudHNvdXJjZS1zdHJlYW0nKVxuY29uc3QgeyBwYXJzZU1JTUVUeXBlIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhLXVybCcpXG5jb25zdCB7IGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQgfSA9IHJlcXVpcmUoJy4uL3dlYnNvY2tldC9ldmVudHMnKVxuY29uc3QgeyBpc05ldHdvcmtFcnJvciB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvcmVzcG9uc2UnKVxuY29uc3QgeyBkZWxheSB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvdXRpbCcpXG5cbmxldCBleHBlcmltZW50YWxXYXJuZWQgPSBmYWxzZVxuXG4vKipcbiAqIEEgcmVjb25uZWN0aW9uIHRpbWUsIGluIG1pbGxpc2Vjb25kcy4gVGhpcyBtdXN0IGluaXRpYWxseSBiZSBhbiBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHZhbHVlLFxuICogcHJvYmFibHkgaW4gdGhlIHJlZ2lvbiBvZiBhIGZldyBzZWNvbmRzLlxuICpcbiAqIEluIENvbXBhcmlzb246XG4gKiAtIENocm9tZSB1c2VzIDMwMDBtcy5cbiAqIC0gRGVubyB1c2VzIDUwMDBtcy5cbiAqXG4gKiBAdHlwZSB7MzAwMH1cbiAqL1xuY29uc3QgZGVmYXVsdFJlY29ubmVjdGlvblRpbWUgPSAzMDAwXG5cbi8qKlxuICogVGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uLlxuICogQGVudW1cbiAqIEByZWFkb25seVxuICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCNkb20tZXZlbnRzb3VyY2UtcmVhZHlzdGF0ZS1kZXZcbiAqL1xuXG4vKipcbiAqIFRoZSBjb25uZWN0aW9uIGhhcyBub3QgeWV0IGJlZW4gZXN0YWJsaXNoZWQsIG9yIGl0IHdhcyBjbG9zZWQgYW5kIHRoZSB1c2VyXG4gKiBhZ2VudCBpcyByZWNvbm5lY3RpbmcuXG4gKiBAdHlwZSB7MH1cbiAqL1xuY29uc3QgQ09OTkVDVElORyA9IDBcblxuLyoqXG4gKiBUaGUgdXNlciBhZ2VudCBoYXMgYW4gb3BlbiBjb25uZWN0aW9uIGFuZCBpcyBkaXNwYXRjaGluZyBldmVudHMgYXMgaXRcbiAqIHJlY2VpdmVzIHRoZW0uXG4gKiBAdHlwZSB7MX1cbiAqL1xuY29uc3QgT1BFTiA9IDFcblxuLyoqXG4gKiBUaGUgY29ubmVjdGlvbiBpcyBub3Qgb3BlbiwgYW5kIHRoZSB1c2VyIGFnZW50IGlzIG5vdCB0cnlpbmcgdG8gcmVjb25uZWN0LlxuICogQHR5cGUgezJ9XG4gKi9cbmNvbnN0IENMT1NFRCA9IDJcblxuLyoqXG4gKiBSZXF1ZXN0cyBmb3IgdGhlIGVsZW1lbnQgd2lsbCBoYXZlIHRoZWlyIG1vZGUgc2V0IHRvIFwiY29yc1wiIGFuZCB0aGVpciBjcmVkZW50aWFscyBtb2RlIHNldCB0byBcInNhbWUtb3JpZ2luXCIuXG4gKiBAdHlwZSB7J2Fub255bW91cyd9XG4gKi9cbmNvbnN0IEFOT05ZTU9VUyA9ICdhbm9ueW1vdXMnXG5cbi8qKlxuICogUmVxdWVzdHMgZm9yIHRoZSBlbGVtZW50IHdpbGwgaGF2ZSB0aGVpciBtb2RlIHNldCB0byBcImNvcnNcIiBhbmQgdGhlaXIgY3JlZGVudGlhbHMgbW9kZSBzZXQgdG8gXCJpbmNsdWRlXCIuXG4gKiBAdHlwZSB7J3VzZS1jcmVkZW50aWFscyd9XG4gKi9cbmNvbnN0IFVTRV9DUkVERU5USUFMUyA9ICd1c2UtY3JlZGVudGlhbHMnXG5cbi8qKlxuICogVGhlIEV2ZW50U291cmNlIGludGVyZmFjZSBpcyB1c2VkIHRvIHJlY2VpdmUgc2VydmVyLXNlbnQgZXZlbnRzLiBJdFxuICogY29ubmVjdHMgdG8gYSBzZXJ2ZXIgb3ZlciBIVFRQIGFuZCByZWNlaXZlcyBldmVudHMgaW4gdGV4dC9ldmVudC1zdHJlYW1cbiAqIGZvcm1hdCB3aXRob3V0IGNsb3NpbmcgdGhlIGNvbm5lY3Rpb24uXG4gKiBAZXh0ZW5kcyB7RXZlbnRUYXJnZXR9XG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sI3NlcnZlci1zZW50LWV2ZW50c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuY2xhc3MgRXZlbnRTb3VyY2UgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gICNldmVudHMgPSB7XG4gICAgb3BlbjogbnVsbCxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBtZXNzYWdlOiBudWxsXG4gIH1cblxuICAjdXJsID0gbnVsbFxuICAjd2l0aENyZWRlbnRpYWxzID0gZmFsc2VcblxuICAjcmVhZHlTdGF0ZSA9IENPTk5FQ1RJTkdcblxuICAjcmVxdWVzdCA9IG51bGxcbiAgI2NvbnRyb2xsZXIgPSBudWxsXG5cbiAgI2Rpc3BhdGNoZXJcblxuICAvKipcbiAgICogQHR5cGUge2ltcG9ydCgnLi9ldmVudHNvdXJjZS1zdHJlYW0nKS5ldmVudFNvdXJjZVNldHRpbmdzfVxuICAgKi9cbiAgI3N0YXRlXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgRXZlbnRTb3VyY2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEBwYXJhbSB7RXZlbnRTb3VyY2VJbml0fSBbZXZlbnRTb3VyY2VJbml0RGljdF1cbiAgICogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbCN0aGUtZXZlbnRzb3VyY2UtaW50ZXJmYWNlXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCBldmVudFNvdXJjZUluaXREaWN0ID0ge30pIHtcbiAgICAvLyAxLiBMZXQgZXYgYmUgYSBuZXcgRXZlbnRTb3VyY2Ugb2JqZWN0LlxuICAgIHN1cGVyKClcblxuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRXZlbnRTb3VyY2UgY29uc3RydWN0b3InXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBpZiAoIWV4cGVyaW1lbnRhbFdhcm5lZCkge1xuICAgICAgZXhwZXJpbWVudGFsV2FybmVkID0gdHJ1ZVxuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZygnRXZlbnRTb3VyY2UgaXMgZXhwZXJpbWVudGFsLCBleHBlY3QgdGhlbSB0byBjaGFuZ2UgYXQgYW55IHRpbWUuJywge1xuICAgICAgICBjb2RlOiAnVU5ESUNJLUVTJ1xuICAgICAgfSlcbiAgICB9XG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsLCBwcmVmaXgsICd1cmwnKVxuICAgIGV2ZW50U291cmNlSW5pdERpY3QgPSB3ZWJpZGwuY29udmVydGVycy5FdmVudFNvdXJjZUluaXREaWN0KGV2ZW50U291cmNlSW5pdERpY3QsIHByZWZpeCwgJ2V2ZW50U291cmNlSW5pdERpY3QnKVxuXG4gICAgdGhpcy4jZGlzcGF0Y2hlciA9IGV2ZW50U291cmNlSW5pdERpY3QuZGlzcGF0Y2hlclxuICAgIHRoaXMuI3N0YXRlID0ge1xuICAgICAgbGFzdEV2ZW50SWQ6ICcnLFxuICAgICAgcmVjb25uZWN0aW9uVGltZTogZGVmYXVsdFJlY29ubmVjdGlvblRpbWVcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgc2V0dGluZ3MgYmUgZXYncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2ViYXBwYXBpcy5odG1sI2Vudmlyb25tZW50LXNldHRpbmdzLW9iamVjdFxuICAgIGNvbnN0IHNldHRpbmdzID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdFxuXG4gICAgbGV0IHVybFJlY29yZFxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIDMuIExldCB1cmxSZWNvcmQgYmUgdGhlIHJlc3VsdCBvZiBlbmNvZGluZy1wYXJzaW5nIGEgVVJMIGdpdmVuIHVybCwgcmVsYXRpdmUgdG8gc2V0dGluZ3MuXG4gICAgICB1cmxSZWNvcmQgPSBuZXcgVVJMKHVybCwgc2V0dGluZ3Muc2V0dGluZ3NPYmplY3QuYmFzZVVybClcbiAgICAgIHRoaXMuI3N0YXRlLm9yaWdpbiA9IHVybFJlY29yZC5vcmlnaW5cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyA0LiBJZiB1cmxSZWNvcmQgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKGUsICdTeW50YXhFcnJvcicpXG4gICAgfVxuXG4gICAgLy8gNS4gU2V0IGV2J3MgdXJsIHRvIHVybFJlY29yZC5cbiAgICB0aGlzLiN1cmwgPSB1cmxSZWNvcmQuaHJlZlxuXG4gICAgLy8gNi4gTGV0IGNvcnNBdHRyaWJ1dGVTdGF0ZSBiZSBBbm9ueW1vdXMuXG4gICAgbGV0IGNvcnNBdHRyaWJ1dGVTdGF0ZSA9IEFOT05ZTU9VU1xuXG4gICAgLy8gNy4gSWYgdGhlIHZhbHVlIG9mIGV2ZW50U291cmNlSW5pdERpY3QncyB3aXRoQ3JlZGVudGlhbHMgbWVtYmVyIGlzIHRydWUsXG4gICAgLy8gdGhlbiBzZXQgY29yc0F0dHJpYnV0ZVN0YXRlIHRvIFVzZSBDcmVkZW50aWFscyBhbmQgc2V0IGV2J3NcbiAgICAvLyB3aXRoQ3JlZGVudGlhbHMgYXR0cmlidXRlIHRvIHRydWUuXG4gICAgaWYgKGV2ZW50U291cmNlSW5pdERpY3Qud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICBjb3JzQXR0cmlidXRlU3RhdGUgPSBVU0VfQ1JFREVOVElBTFNcbiAgICAgIHRoaXMuI3dpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyA4LiBMZXQgcmVxdWVzdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgcG90ZW50aWFsLUNPUlMgcmVxdWVzdCBnaXZlblxuICAgIC8vIHVybFJlY29yZCwgdGhlIGVtcHR5IHN0cmluZywgYW5kIGNvcnNBdHRyaWJ1dGVTdGF0ZS5cbiAgICBjb25zdCBpbml0UmVxdWVzdCA9IHtcbiAgICAgIHJlZGlyZWN0OiAnZm9sbG93JyxcbiAgICAgIGtlZXBhbGl2ZTogdHJ1ZSxcbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvdXJscy1hbmQtZmV0Y2hpbmcuaHRtbCNjb3JzLXNldHRpbmdzLWF0dHJpYnV0ZXNcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICAgIGNyZWRlbnRpYWxzOiBjb3JzQXR0cmlidXRlU3RhdGUgPT09ICdhbm9ueW1vdXMnXG4gICAgICAgID8gJ3NhbWUtb3JpZ2luJ1xuICAgICAgICA6ICdvbWl0JyxcbiAgICAgIHJlZmVycmVyOiAnbm8tcmVmZXJyZXInXG4gICAgfVxuXG4gICAgLy8gOS4gU2V0IHJlcXVlc3QncyBjbGllbnQgdG8gc2V0dGluZ3MuXG4gICAgaW5pdFJlcXVlc3QuY2xpZW50ID0gZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdC5zZXR0aW5nc09iamVjdFxuXG4gICAgLy8gMTAuIFVzZXIgYWdlbnRzIG1heSBzZXQgKGBBY2NlcHRgLCBgdGV4dC9ldmVudC1zdHJlYW1gKSBpbiByZXF1ZXN0J3MgaGVhZGVyIGxpc3QuXG4gICAgaW5pdFJlcXVlc3QuaGVhZGVyc0xpc3QgPSBbWydhY2NlcHQnLCB7IG5hbWU6ICdhY2NlcHQnLCB2YWx1ZTogJ3RleHQvZXZlbnQtc3RyZWFtJyB9XV1cblxuICAgIC8vIDExLiBTZXQgcmVxdWVzdCdzIGNhY2hlIG1vZGUgdG8gXCJuby1zdG9yZVwiLlxuICAgIGluaXRSZXF1ZXN0LmNhY2hlID0gJ25vLXN0b3JlJ1xuXG4gICAgLy8gMTIuIFNldCByZXF1ZXN0J3MgaW5pdGlhdG9yIHR5cGUgdG8gXCJvdGhlclwiLlxuICAgIGluaXRSZXF1ZXN0LmluaXRpYXRvciA9ICdvdGhlcidcblxuICAgIGluaXRSZXF1ZXN0LnVybExpc3QgPSBbbmV3IFVSTCh0aGlzLiN1cmwpXVxuXG4gICAgLy8gMTMuIFNldCBldidzIHJlcXVlc3QgdG8gcmVxdWVzdC5cbiAgICB0aGlzLiNyZXF1ZXN0ID0gbWFrZVJlcXVlc3QoaW5pdFJlcXVlc3QpXG5cbiAgICB0aGlzLiNjb25uZWN0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSBvZiB0aGlzIEV2ZW50U291cmNlIG9iamVjdCdzIGNvbm5lY3Rpb24uIEl0IGNhbiBoYXZlIHRoZVxuICAgKiB2YWx1ZXMgZGVzY3JpYmVkIGJlbG93LlxuICAgKiBAcmV0dXJucyB7MHwxfDJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUgKCkge1xuICAgIHJldHVybiB0aGlzLiNyZWFkeVN0YXRlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVVJMIHByb3ZpZGluZyB0aGUgZXZlbnQgc3RyZWFtLlxuICAgKiBAcmVhZG9ubHlcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldCB1cmwgKCkge1xuICAgIHJldHVybiB0aGlzLiN1cmxcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIEV2ZW50U291cmNlIG9iamVjdCB3YXNcbiAgICogaW5zdGFudGlhdGVkIHdpdGggQ09SUyBjcmVkZW50aWFscyBzZXQgKHRydWUpLCBvciBub3QgKGZhbHNlLCB0aGUgZGVmYXVsdCkuXG4gICAqL1xuICBnZXQgd2l0aENyZWRlbnRpYWxzICgpIHtcbiAgICByZXR1cm4gdGhpcy4jd2l0aENyZWRlbnRpYWxzXG4gIH1cblxuICAjY29ubmVjdCAoKSB7XG4gICAgaWYgKHRoaXMuI3JlYWR5U3RhdGUgPT09IENMT1NFRCkgcmV0dXJuXG5cbiAgICB0aGlzLiNyZWFkeVN0YXRlID0gQ09OTkVDVElOR1xuXG4gICAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgICByZXF1ZXN0OiB0aGlzLiNyZXF1ZXN0LFxuICAgICAgZGlzcGF0Y2hlcjogdGhpcy4jZGlzcGF0Y2hlclxuICAgIH1cblxuICAgIC8vIDE0LiBMZXQgcHJvY2Vzc0V2ZW50U291cmNlRW5kT2ZCb2R5IGdpdmVuIHJlc3BvbnNlIHJlcyBiZSB0aGUgZm9sbG93aW5nIHN0ZXA6IGlmIHJlcyBpcyBub3QgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlZXN0YWJsaXNoIHRoZSBjb25uZWN0aW9uLlxuICAgIGNvbnN0IHByb2Nlc3NFdmVudFNvdXJjZUVuZE9mQm9keSA9IChyZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKGlzTmV0d29ya0Vycm9yKHJlc3BvbnNlKSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgIH1cblxuICAgICAgdGhpcy4jcmVjb25uZWN0KClcbiAgICB9XG5cbiAgICAvLyAxNS4gRmV0Y2ggcmVxdWVzdCwgd2l0aCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgc2V0IHRvIHByb2Nlc3NFdmVudFNvdXJjZUVuZE9mQm9keS4uLlxuICAgIGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSA9IHByb2Nlc3NFdmVudFNvdXJjZUVuZE9mQm9keVxuXG4gICAgLy8gYW5kIHByb2Nlc3NSZXNwb25zZSBzZXQgdG8gdGhlIGZvbGxvd2luZyBzdGVwcyBnaXZlbiByZXNwb25zZSByZXM6XG4gICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlID0gKHJlc3BvbnNlKSA9PiB7XG4gICAgICAvLyAxLiBJZiByZXMgaXMgYW4gYWJvcnRlZCBuZXR3b3JrIGVycm9yLCB0aGVuIGZhaWwgdGhlIGNvbm5lY3Rpb24uXG5cbiAgICAgIGlmIChpc05ldHdvcmtFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgLy8gMS4gV2hlbiBhIHVzZXIgYWdlbnQgaXMgdG8gZmFpbCB0aGUgY29ubmVjdGlvbiwgdGhlIHVzZXIgYWdlbnRcbiAgICAgICAgLy8gbXVzdCBxdWV1ZSBhIHRhc2sgd2hpY2gsIGlmIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gYVxuICAgICAgICAvLyB2YWx1ZSBvdGhlciB0aGFuIENMT1NFRCwgc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gQ0xPU0VEXG4gICAgICAgIC8vIGFuZCBmaXJlcyBhbiBldmVudCBuYW1lZCBlcnJvciBhdCB0aGUgRXZlbnRTb3VyY2Ugb2JqZWN0LiBPbmNlIHRoZVxuICAgICAgICAvLyB1c2VyIGFnZW50IGhhcyBmYWlsZWQgdGhlIGNvbm5lY3Rpb24sIGl0IGRvZXMgbm90IGF0dGVtcHQgdG9cbiAgICAgICAgLy8gcmVjb25uZWN0LlxuICAgICAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiByZXMgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlZXN0YWJsaXNoIHRoZVxuICAgICAgICAgIC8vIGNvbm5lY3Rpb24sIHVubGVzcyB0aGUgdXNlciBhZ2VudCBrbm93cyB0aGF0IHRvIGJlIGZ1dGlsZSwgaW5cbiAgICAgICAgICAvLyB3aGljaCBjYXNlIHRoZSB1c2VyIGFnZW50IG1heSBmYWlsIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuI3JlY29ubmVjdCgpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiByZXMncyBzdGF0dXMgaXMgbm90IDIwMCwgb3IgaWYgcmVzJ3MgYENvbnRlbnQtVHlwZWBcbiAgICAgIC8vIGlzIG5vdCBgdGV4dC9ldmVudC1zdHJlYW1gLCB0aGVuIGZhaWwgdGhlIGNvbm5lY3Rpb24uXG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9IHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnY29udGVudC10eXBlJywgdHJ1ZSlcbiAgICAgIGNvbnN0IG1pbWVUeXBlID0gY29udGVudFR5cGUgIT09IG51bGwgPyBwYXJzZU1JTUVUeXBlKGNvbnRlbnRUeXBlKSA6ICdmYWlsdXJlJ1xuICAgICAgY29uc3QgY29udGVudFR5cGVWYWxpZCA9IG1pbWVUeXBlICE9PSAnZmFpbHVyZScgJiYgbWltZVR5cGUuZXNzZW5jZSA9PT0gJ3RleHQvZXZlbnQtc3RyZWFtJ1xuICAgICAgaWYgKFxuICAgICAgICByZXNwb25zZS5zdGF0dXMgIT09IDIwMCB8fFxuICAgICAgICBjb250ZW50VHlwZVZhbGlkID09PSBmYWxzZVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNC4gT3RoZXJ3aXNlLCBhbm5vdW5jZSB0aGUgY29ubmVjdGlvbiBhbmQgaW50ZXJwcmV0IHJlcydzIGJvZHlcbiAgICAgIC8vIGxpbmUgYnkgbGluZS5cblxuICAgICAgLy8gV2hlbiBhIHVzZXIgYWdlbnQgaXMgdG8gYW5ub3VuY2UgdGhlIGNvbm5lY3Rpb24sIHRoZSB1c2VyIGFnZW50XG4gICAgICAvLyBtdXN0IHF1ZXVlIGEgdGFzayB3aGljaCwgaWYgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIGlzIHNldCB0byBhXG4gICAgICAvLyB2YWx1ZSBvdGhlciB0aGFuIENMT1NFRCwgc2V0cyB0aGUgcmVhZHlTdGF0ZSBhdHRyaWJ1dGUgdG8gT1BFTlxuICAgICAgLy8gYW5kIGZpcmVzIGFuIGV2ZW50IG5hbWVkIG9wZW4gYXQgdGhlIEV2ZW50U291cmNlIG9iamVjdC5cbiAgICAgIC8vIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VydmVyLXNlbnQtZXZlbnRzLmh0bWwjc3NlLXByb2Nlc3NpbmctbW9kZWxcbiAgICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBPUEVOXG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpXG5cbiAgICAgIC8vIElmIHJlZGlyZWN0ZWQgdG8gYSBkaWZmZXJlbnQgb3JpZ2luLCBzZXQgdGhlIG9yaWdpbiB0byB0aGUgbmV3IG9yaWdpbi5cbiAgICAgIHRoaXMuI3N0YXRlLm9yaWdpbiA9IHJlc3BvbnNlLnVybExpc3RbcmVzcG9uc2UudXJsTGlzdC5sZW5ndGggLSAxXS5vcmlnaW5cblxuICAgICAgY29uc3QgZXZlbnRTb3VyY2VTdHJlYW0gPSBuZXcgRXZlbnRTb3VyY2VTdHJlYW0oe1xuICAgICAgICBldmVudFNvdXJjZVNldHRpbmdzOiB0aGlzLiNzdGF0ZSxcbiAgICAgICAgcHVzaDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQoXG4gICAgICAgICAgICBldmVudC50eXBlLFxuICAgICAgICAgICAgZXZlbnQub3B0aW9uc1xuICAgICAgICAgICkpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHBpcGVsaW5lKHJlc3BvbnNlLmJvZHkuc3RyZWFtLFxuICAgICAgICBldmVudFNvdXJjZVN0cmVhbSxcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZXJyb3I/LmFib3J0ZWQgPT09IGZhbHNlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMuI2NvbnRyb2xsZXIgPSBmZXRjaGluZyhmZXRjaFBhcmFtcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sI3NzZS1wcm9jZXNzaW5nLW1vZGVsXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgYXN5bmMgI3JlY29ubmVjdCAoKSB7XG4gICAgLy8gV2hlbiBhIHVzZXIgYWdlbnQgaXMgdG8gcmVlc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24sIHRoZSB1c2VyIGFnZW50IG11c3RcbiAgICAvLyBydW4gdGhlIGZvbGxvd2luZyBzdGVwcy4gVGhlc2Ugc3RlcHMgYXJlIHJ1biBpbiBwYXJhbGxlbCwgbm90IGFzIHBhcnQgb2ZcbiAgICAvLyBhIHRhc2suIChUaGUgdGFza3MgdGhhdCBpdCBxdWV1ZXMsIG9mIGNvdXJzZSwgYXJlIHJ1biBsaWtlIG5vcm1hbCB0YXNrc1xuICAgIC8vIGFuZCBub3QgdGhlbXNlbHZlcyBpbiBwYXJhbGxlbC4pXG5cbiAgICAvLyAxLiBRdWV1ZSBhIHRhc2sgdG8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG5cbiAgICAvLyAgIDEuIElmIHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBzZXQgdG8gQ0xPU0VELCBhYm9ydCB0aGUgdGFzay5cbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSA9PT0gQ0xPU0VEKSByZXR1cm5cblxuICAgIC8vICAgMi4gU2V0IHRoZSByZWFkeVN0YXRlIGF0dHJpYnV0ZSB0byBDT05ORUNUSU5HLlxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBDT05ORUNUSU5HXG5cbiAgICAvLyAgIDMuIEZpcmUgYW4gZXZlbnQgbmFtZWQgZXJyb3IgYXQgdGhlIEV2ZW50U291cmNlIG9iamVjdC5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKVxuXG4gICAgLy8gMi4gV2FpdCBhIGRlbGF5IGVxdWFsIHRvIHRoZSByZWNvbm5lY3Rpb24gdGltZSBvZiB0aGUgZXZlbnQgc291cmNlLlxuICAgIGF3YWl0IGRlbGF5KHRoaXMuI3N0YXRlLnJlY29ubmVjdGlvblRpbWUpXG5cbiAgICAvLyA1LiBRdWV1ZSBhIHRhc2sgdG8gcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG5cbiAgICAvLyAgIDEuIElmIHRoZSBFdmVudFNvdXJjZSBvYmplY3QncyByZWFkeVN0YXRlIGF0dHJpYnV0ZSBpcyBub3Qgc2V0IHRvXG4gICAgLy8gICAgICBDT05ORUNUSU5HLCB0aGVuIHJldHVybi5cbiAgICBpZiAodGhpcy4jcmVhZHlTdGF0ZSAhPT0gQ09OTkVDVElORykgcmV0dXJuXG5cbiAgICAvLyAgIDIuIExldCByZXF1ZXN0IGJlIHRoZSBFdmVudFNvdXJjZSBvYmplY3QncyByZXF1ZXN0LlxuICAgIC8vICAgMy4gSWYgdGhlIEV2ZW50U291cmNlIG9iamVjdCdzIGxhc3QgZXZlbnQgSUQgc3RyaW5nIGlzIG5vdCB0aGUgZW1wdHlcbiAgICAvLyAgICAgIHN0cmluZywgdGhlbjpcbiAgICAvLyAgICAgIDEuIExldCBsYXN0RXZlbnRJRFZhbHVlIGJlIHRoZSBFdmVudFNvdXJjZSBvYmplY3QncyBsYXN0IGV2ZW50IElEXG4gICAgLy8gICAgICAgICBzdHJpbmcsIGVuY29kZWQgYXMgVVRGLTguXG4gICAgLy8gICAgICAyLiBTZXQgKGBMYXN0LUV2ZW50LUlEYCwgbGFzdEV2ZW50SURWYWx1ZSkgaW4gcmVxdWVzdCdzIGhlYWRlclxuICAgIC8vICAgICAgICAgbGlzdC5cbiAgICBpZiAodGhpcy4jc3RhdGUubGFzdEV2ZW50SWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLiNyZXF1ZXN0LmhlYWRlcnNMaXN0LnNldCgnbGFzdC1ldmVudC1pZCcsIHRoaXMuI3N0YXRlLmxhc3RFdmVudElkLCB0cnVlKVxuICAgIH1cblxuICAgIC8vICAgNC4gRmV0Y2ggcmVxdWVzdCBhbmQgcHJvY2VzcyB0aGUgcmVzcG9uc2Ugb2J0YWluZWQgaW4gdGhpcyBmYXNoaW9uLCBpZiBhbnksIGFzIGRlc2NyaWJlZCBlYXJsaWVyIGluIHRoaXMgc2VjdGlvbi5cbiAgICB0aGlzLiNjb25uZWN0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24sIGlmIGFueSwgYW5kIHNldHMgdGhlIHJlYWR5U3RhdGUgYXR0cmlidXRlIHRvXG4gICAqIENMT1NFRC5cbiAgICovXG4gIGNsb3NlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFdmVudFNvdXJjZSlcblxuICAgIGlmICh0aGlzLiNyZWFkeVN0YXRlID09PSBDTE9TRUQpIHJldHVyblxuICAgIHRoaXMuI3JlYWR5U3RhdGUgPSBDTE9TRURcbiAgICB0aGlzLiNjb250cm9sbGVyLmFib3J0KClcbiAgICB0aGlzLiNyZXF1ZXN0ID0gbnVsbFxuICB9XG5cbiAgZ2V0IG9ub3BlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5vcGVuXG4gIH1cblxuICBzZXQgb25vcGVuIChmbikge1xuICAgIGlmICh0aGlzLiNldmVudHMub3Blbikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy4jZXZlbnRzLm9wZW4pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLm9wZW4gPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5vcGVuID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbm1lc3NhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLiNldmVudHMubWVzc2FnZVxuICB9XG5cbiAgc2V0IG9ubWVzc2FnZSAoZm4pIHtcbiAgICBpZiAodGhpcy4jZXZlbnRzLm1lc3NhZ2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuI2V2ZW50cy5tZXNzYWdlKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5tZXNzYWdlID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25lcnJvciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50cy5lcnJvclxuICB9XG5cbiAgc2V0IG9uZXJyb3IgKGZuKSB7XG4gICAgaWYgKHRoaXMuI2V2ZW50cy5lcnJvcikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuI2V2ZW50cy5lcnJvcilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNldmVudHMuZXJyb3IgPSBudWxsXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGNvbnN0YW50c1Byb3BlcnR5RGVzY3JpcHRvcnMgPSB7XG4gIENPTk5FQ1RJTkc6IHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBDT05ORUNUSU5HLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9LFxuICBPUEVOOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogT1BFTixcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSxcbiAgQ0xPU0VEOiB7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogQ0xPU0VELFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEV2ZW50U291cmNlLCBjb25zdGFudHNQcm9wZXJ0eURlc2NyaXB0b3JzKVxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRXZlbnRTb3VyY2UucHJvdG90eXBlLCBjb25zdGFudHNQcm9wZXJ0eURlc2NyaXB0b3JzKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFdmVudFNvdXJjZS5wcm90b3R5cGUsIHtcbiAgY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubWVzc2FnZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25vcGVuOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWFkeVN0YXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICB1cmw6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHdpdGhDcmVkZW50aWFsczoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuRXZlbnRTb3VyY2VJbml0RGljdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAge1xuICAgIGtleTogJ3dpdGhDcmVkZW50aWFscycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2Rpc3BhdGNoZXInLCAvLyB1bmRpY2kgb25seVxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFdmVudFNvdXJjZSxcbiAgZGVmYXVsdFJlY29ubmVjdGlvblRpbWVcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/eventsource/eventsource.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/eventsource/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/eventsource/util.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * Checks if the given value is a valid LastEventId.\n * @param {string} value\n * @returns {boolean}\n */\nfunction isValidLastEventId (value) {\n  // LastEventId should not contain U+0000 NULL\n  return value.indexOf('\\u0000') === -1\n}\n\n/**\n * Checks if the given value is a base 10 digit.\n * @param {string} value\n * @returns {boolean}\n */\nfunction isASCIINumber (value) {\n  if (value.length === 0) return false\n  for (let i = 0; i < value.length; i++) {\n    if (value.charCodeAt(i) < 0x30 || value.charCodeAt(i) > 0x39) return false\n  }\n  return true\n}\n\n// https://github.com/nodejs/undici/issues/2664\nfunction delay (ms) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms).unref()\n  })\n}\n\nmodule.exports = {\n  isValidLastEventId,\n  isASCIINumber,\n  delay\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZXZlbnRzb3VyY2UvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGV2ZW50c291cmNlXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBMYXN0RXZlbnRJZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRMYXN0RXZlbnRJZCAodmFsdWUpIHtcbiAgLy8gTGFzdEV2ZW50SWQgc2hvdWxkIG5vdCBjb250YWluIFUrMDAwMCBOVUxMXG4gIHJldHVybiB2YWx1ZS5pbmRleE9mKCdcXHUwMDAwJykgPT09IC0xXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIGJhc2UgMTAgZGlnaXQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0FTQ0lJTnVtYmVyICh2YWx1ZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2VcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh2YWx1ZS5jaGFyQ29kZUF0KGkpIDwgMHgzMCB8fCB2YWx1ZS5jaGFyQ29kZUF0KGkpID4gMHgzOSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvaXNzdWVzLzI2NjRcbmZ1bmN0aW9uIGRlbGF5IChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKS51bnJlZigpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1ZhbGlkTGFzdEV2ZW50SWQsXG4gIGlzQVNDSUlOdW1iZXIsXG4gIGRlbGF5XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/eventsource/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/body.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/body.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst util = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  ReadableStreamFrom,\n  isBlobLike,\n  isReadableStreamLike,\n  readableStreamClose,\n  createDeferredPromise,\n  fullyReadBody,\n  extractMimeType,\n  utf8DecodeBytes\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { Blob } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { isErrored, isDisturbed } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { isArrayBuffer } = __webpack_require__(/*! node:util/types */ \"node:util/types\")\nconst { serializeAMimeType } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { multipartFormDataParser } = __webpack_require__(/*! ./formdata-parser */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata-parser.js\")\nlet random\n\ntry {\n  const crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n  random = (max) => crypto.randomInt(0, max)\n} catch {\n  random = (max) => Math.floor(Math.random(max))\n}\n\nconst textEncoder = new TextEncoder()\nfunction noop () {}\n\nconst hasFinalizationRegistry = globalThis.FinalizationRegistry && process.version.indexOf('v18') !== 0\nlet streamRegistry\n\nif (hasFinalizationRegistry) {\n  streamRegistry = new FinalizationRegistry((weakRef) => {\n    const stream = weakRef.deref()\n    if (stream && !stream.locked && !isDisturbed(stream) && !isErrored(stream)) {\n      stream.cancel('Response object has been garbage collected').catch(noop)\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  // 1. Let stream be null.\n  let stream = null\n\n  // 2. If object is a ReadableStream object, then set stream to object.\n  if (object instanceof ReadableStream) {\n    stream = object\n  } else if (isBlobLike(object)) {\n    // 3. Otherwise, if object is a Blob object, set stream to the\n    //    result of running object’s get stream.\n    stream = object.stream()\n  } else {\n    // 4. Otherwise, set stream to a new ReadableStream object, and set\n    //    up stream with byte reading support.\n    stream = new ReadableStream({\n      async pull (controller) {\n        const buffer = typeof source === 'string' ? textEncoder.encode(source) : source\n\n        if (buffer.byteLength) {\n          controller.enqueue(buffer)\n        }\n\n        queueMicrotask(() => readableStreamClose(controller))\n      },\n      start () {},\n      type: 'bytes'\n    })\n  }\n\n  // 5. Assert: stream is a ReadableStream object.\n  assert(isReadableStreamLike(stream))\n\n  // 6. Let action be null.\n  let action = null\n\n  // 7. Let source be null.\n  let source = null\n\n  // 8. Let length be null.\n  let length = null\n\n  // 9. Let type be null.\n  let type = null\n\n  // 10. Switch on object:\n  if (typeof object === 'string') {\n    // Set source to the UTF-8 encoding of object.\n    // Note: setting source to a Uint8Array here breaks some mocking assumptions.\n    source = object\n\n    // Set type to `text/plain;charset=UTF-8`.\n    type = 'text/plain;charset=UTF-8'\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    type = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (isArrayBuffer(object)) {\n    // BufferSource/ArrayBuffer\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.slice())\n  } else if (ArrayBuffer.isView(object)) {\n    // BufferSource/ArrayBufferView\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength))\n  } else if (util.isFormDataLike(object)) {\n    const boundary = `----formdata-undici-0${`${random(1e11)}`.padStart(11, '0')}`\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    // - This ensures that the body is immutable and can't be changed afterwords\n    // - That the content-length is calculated in advance.\n    // - And that all parts are pre-encoded and ready to be sent.\n\n    const blobParts = []\n    const rn = new Uint8Array([13, 10]) // '\\r\\n'\n    length = 0\n    let hasUnknownSizeValue = false\n\n    for (const [name, value] of object) {\n      if (typeof value === 'string') {\n        const chunk = textEncoder.encode(prefix +\n          `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`)\n        blobParts.push(chunk)\n        length += chunk.byteLength\n      } else {\n        const chunk = textEncoder.encode(`${prefix}; name=\"${escape(normalizeLinefeeds(name))}\"` +\n          (value.name ? `; filename=\"${escape(value.name)}\"` : '') + '\\r\\n' +\n          `Content-Type: ${\n            value.type || 'application/octet-stream'\n          }\\r\\n\\r\\n`)\n        blobParts.push(chunk, value, rn)\n        if (typeof value.size === 'number') {\n          length += chunk.byteLength + value.size + rn.byteLength\n        } else {\n          hasUnknownSizeValue = true\n        }\n      }\n    }\n\n    // CRLF is appended to the body to function with legacy servers and match other implementations.\n    // https://github.com/curl/curl/blob/3434c6b46e682452973972e8313613dfa58cd690/lib/mime.c#L1029-L1030\n    // https://github.com/form-data/form-data/issues/63\n    const chunk = textEncoder.encode(`--${boundary}--\\r\\n`)\n    blobParts.push(chunk)\n    length += chunk.byteLength\n    if (hasUnknownSizeValue) {\n      length = null\n    }\n\n    // Set source to object.\n    source = object\n\n    action = async function * () {\n      for (const part of blobParts) {\n        if (part.stream) {\n          yield * part.stream()\n        } else {\n          yield part\n        }\n      }\n    }\n\n    // Set type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    type = `multipart/form-data; boundary=${boundary}`\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // type to its value.\n    if (object.type) {\n      type = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  }\n\n  // 11. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 12. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n            controller.byobRequest?.respond(0)\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            const buffer = new Uint8Array(value)\n            if (buffer.byteLength) {\n              controller.enqueue(buffer)\n            }\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      },\n      type: 'bytes'\n    })\n  }\n\n  // 13. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 14. Return (body, type).\n  return [body, type]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'The body has already been consumed.')\n    // istanbul ignore next\n    assert(!object.locked, 'The stream is locked.')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (instance, body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n\n  if (hasFinalizationRegistry) {\n    streamRegistry.register(instance, new WeakRef(out1))\n  }\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nfunction throwIfAborted (state) {\n  if (state.aborted) {\n    throw new DOMException('The operation was aborted.', 'AbortError')\n  }\n}\n\nfunction bodyMixinMethods (instance) {\n  const methods = {\n    blob () {\n      // The blob() method steps are to return the result of\n      // running consume body with this and the following step\n      // given a byte sequence bytes: return a Blob whose\n      // contents are bytes and whose type attribute is this’s\n      // MIME type.\n      return consumeBody(this, (bytes) => {\n        let mimeType = bodyMimeType(this)\n\n        if (mimeType === null) {\n          mimeType = ''\n        } else if (mimeType) {\n          mimeType = serializeAMimeType(mimeType)\n        }\n\n        // Return a Blob whose contents are bytes and type attribute\n        // is mimeType.\n        return new Blob([bytes], { type: mimeType })\n      }, instance)\n    },\n\n    arrayBuffer () {\n      // The arrayBuffer() method steps are to return the result\n      // of running consume body with this and the following step\n      // given a byte sequence bytes: return a new ArrayBuffer\n      // whose contents are bytes.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes).buffer\n      }, instance)\n    },\n\n    text () {\n      // The text() method steps are to return the result of running\n      // consume body with this and UTF-8 decode.\n      return consumeBody(this, utf8DecodeBytes, instance)\n    },\n\n    json () {\n      // The json() method steps are to return the result of running\n      // consume body with this and parse JSON from bytes.\n      return consumeBody(this, parseJSONFromBytes, instance)\n    },\n\n    formData () {\n      // The formData() method steps are to return the result of running\n      // consume body with this and the following step given a byte sequence bytes:\n      return consumeBody(this, (value) => {\n        // 1. Let mimeType be the result of get the MIME type with this.\n        const mimeType = bodyMimeType(this)\n\n        // 2. If mimeType is non-null, then switch on mimeType’s essence and run\n        //    the corresponding steps:\n        if (mimeType !== null) {\n          switch (mimeType.essence) {\n            case 'multipart/form-data': {\n              // 1. ... [long step]\n              const parsed = multipartFormDataParser(value, mimeType)\n\n              // 2. If that fails for some reason, then throw a TypeError.\n              if (parsed === 'failure') {\n                throw new TypeError('Failed to parse body as FormData.')\n              }\n\n              // 3. Return a new FormData object, appending each entry,\n              //    resulting from the parsing operation, to its entry list.\n              const fd = new FormData()\n              fd[kState] = parsed\n\n              return fd\n            }\n            case 'application/x-www-form-urlencoded': {\n              // 1. Let entries be the result of parsing bytes.\n              const entries = new URLSearchParams(value.toString())\n\n              // 2. If entries is failure, then throw a TypeError.\n\n              // 3. Return a new FormData object whose entry list is entries.\n              const fd = new FormData()\n\n              for (const [name, value] of entries) {\n                fd.append(name, value)\n              }\n\n              return fd\n            }\n          }\n        }\n\n        // 3. Throw a TypeError.\n        throw new TypeError(\n          'Content-Type was not one of \"multipart/form-data\" or \"application/x-www-form-urlencoded\".'\n        )\n      }, instance)\n    },\n\n    bytes () {\n      // The bytes() method steps are to return the result of running consume body\n      // with this and the following step given a byte sequence bytes: return the\n      // result of creating a Uint8Array from bytes in this’s relevant realm.\n      return consumeBody(this, (bytes) => {\n        return new Uint8Array(bytes)\n      }, instance)\n    }\n  }\n\n  return methods\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype.prototype, bodyMixinMethods(prototype))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-consume-body\n * @param {Response|Request} object\n * @param {(value: unknown) => unknown} convertBytesToJSValue\n * @param {Response|Request} instance\n */\nasync function consumeBody (object, convertBytesToJSValue, instance) {\n  webidl.brandCheck(object, instance)\n\n  // 1. If object is unusable, then return a promise rejected\n  //    with a TypeError.\n  if (bodyUnusable(object)) {\n    throw new TypeError('Body is unusable: Body has already been read')\n  }\n\n  throwIfAborted(object[kState])\n\n  // 2. Let promise be a new promise.\n  const promise = createDeferredPromise()\n\n  // 3. Let errorSteps given error be to reject promise with error.\n  const errorSteps = (error) => promise.reject(error)\n\n  // 4. Let successSteps given a byte sequence data be to resolve\n  //    promise with the result of running convertBytesToJSValue\n  //    with data. If that threw an exception, then run errorSteps\n  //    with that exception.\n  const successSteps = (data) => {\n    try {\n      promise.resolve(convertBytesToJSValue(data))\n    } catch (e) {\n      errorSteps(e)\n    }\n  }\n\n  // 5. If object’s body is null, then run successSteps with an\n  //    empty byte sequence.\n  if (object[kState].body == null) {\n    successSteps(Buffer.allocUnsafe(0))\n    return promise.promise\n  }\n\n  // 6. Otherwise, fully read object’s body given successSteps,\n  //    errorSteps, and object’s relevant global object.\n  await fullyReadBody(object[kState].body, successSteps, errorSteps)\n\n  // 7. Return promise.\n  return promise.promise\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction bodyUnusable (object) {\n  const body = object[kState].body\n\n  // An object including the Body interface mixin is\n  // said to be unusable if its body is non-null and\n  // its body’s stream is disturbed or locked.\n  return body != null && (body.stream.locked || util.isDisturbed(body.stream))\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#parse-json-bytes-to-a-javascript-value\n * @param {Uint8Array} bytes\n */\nfunction parseJSONFromBytes (bytes) {\n  return JSON.parse(utf8DecodeBytes(bytes))\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-body-mime-type\n * @param {import('./response').Response|import('./request').Request} requestOrResponse\n */\nfunction bodyMimeType (requestOrResponse) {\n  // 1. Let headers be null.\n  // 2. If requestOrResponse is a Request object, then set headers to requestOrResponse’s request’s header list.\n  // 3. Otherwise, set headers to requestOrResponse’s response’s header list.\n  /** @type {import('./headers').HeadersList} */\n  const headers = requestOrResponse[kState].headersList\n\n  // 4. Let mimeType be the result of extracting a MIME type from headers.\n  const mimeType = extractMimeType(headers)\n\n  // 5. If mimeType is failure, then return null.\n  if (mimeType === 'failure') {\n    return null\n  }\n\n  // 6. Return mimeType.\n  return mimeType\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody,\n  streamRegistry,\n  hasFinalizationRegistry,\n  bodyUnusable\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvYm9keS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3BCLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDekMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUN0QyxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHFFQUFVO0FBQ3JDLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEseUJBQXlCLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN4RCxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsd0NBQWlCO0FBQ25ELFFBQVEscUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUNuRCxRQUFRLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsdUZBQW1CO0FBQy9EOztBQUVBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsZ0NBQWE7QUFDdEM7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1AsaUJBQWlCO0FBQ2pCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNB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QUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyw2QkFBNkI7QUFDeEMsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLDJEQUEyRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQ0FBaUM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGJvZHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qge1xuICBSZWFkYWJsZVN0cmVhbUZyb20sXG4gIGlzQmxvYkxpa2UsXG4gIGlzUmVhZGFibGVTdHJlYW1MaWtlLFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIGZ1bGx5UmVhZEJvZHksXG4gIGV4dHJhY3RNaW1lVHlwZSxcbiAgdXRmOERlY29kZUJ5dGVzXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgRm9ybURhdGEgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEnKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBCbG9iIH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB7IGlzRXJyb3JlZCwgaXNEaXN0dXJiZWQgfSA9IHJlcXVpcmUoJ25vZGU6c3RyZWFtJylcbmNvbnN0IHsgaXNBcnJheUJ1ZmZlciB9ID0gcmVxdWlyZSgnbm9kZTp1dGlsL3R5cGVzJylcbmNvbnN0IHsgc2VyaWFsaXplQU1pbWVUeXBlIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsgbXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEtcGFyc2VyJylcbmxldCByYW5kb21cblxudHJ5IHtcbiAgY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKVxuICByYW5kb20gPSAobWF4KSA9PiBjcnlwdG8ucmFuZG9tSW50KDAsIG1heClcbn0gY2F0Y2gge1xuICByYW5kb20gPSAobWF4KSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKG1heCkpXG59XG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbmZ1bmN0aW9uIG5vb3AgKCkge31cblxuY29uc3QgaGFzRmluYWxpemF0aW9uUmVnaXN0cnkgPSBnbG9iYWxUaGlzLkZpbmFsaXphdGlvblJlZ2lzdHJ5ICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MTgnKSAhPT0gMFxubGV0IHN0cmVhbVJlZ2lzdHJ5XG5cbmlmIChoYXNGaW5hbGl6YXRpb25SZWdpc3RyeSkge1xuICBzdHJlYW1SZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgod2Vha1JlZikgPT4ge1xuICAgIGNvbnN0IHN0cmVhbSA9IHdlYWtSZWYuZGVyZWYoKVxuICAgIGlmIChzdHJlYW0gJiYgIXN0cmVhbS5sb2NrZWQgJiYgIWlzRGlzdHVyYmVkKHN0cmVhbSkgJiYgIWlzRXJyb3JlZChzdHJlYW0pKSB7XG4gICAgICBzdHJlYW0uY2FuY2VsKCdSZXNwb25zZSBvYmplY3QgaGFzIGJlZW4gZ2FyYmFnZSBjb2xsZWN0ZWQnKS5jYXRjaChub29wKVxuICAgIH1cbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuZnVuY3Rpb24gZXh0cmFjdEJvZHkgKG9iamVjdCwga2VlcGFsaXZlID0gZmFsc2UpIHtcbiAgLy8gMS4gTGV0IHN0cmVhbSBiZSBudWxsLlxuICBsZXQgc3RyZWFtID0gbnVsbFxuXG4gIC8vIDIuIElmIG9iamVjdCBpcyBhIFJlYWRhYmxlU3RyZWFtIG9iamVjdCwgdGhlbiBzZXQgc3RyZWFtIHRvIG9iamVjdC5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG4gICAgc3RyZWFtID0gb2JqZWN0XG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZShvYmplY3QpKSB7XG4gICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBvYmplY3QgaXMgYSBCbG9iIG9iamVjdCwgc2V0IHN0cmVhbSB0byB0aGVcbiAgICAvLyAgICByZXN1bHQgb2YgcnVubmluZyBvYmplY3TigJlzIGdldCBzdHJlYW0uXG4gICAgc3RyZWFtID0gb2JqZWN0LnN0cmVhbSgpXG4gIH0gZWxzZSB7XG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBzZXQgc3RyZWFtIHRvIGEgbmV3IFJlYWRhYmxlU3RyZWFtIG9iamVjdCwgYW5kIHNldFxuICAgIC8vICAgIHVwIHN0cmVhbSB3aXRoIGJ5dGUgcmVhZGluZyBzdXBwb3J0LlxuICAgIHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gdGV4dEVuY29kZXIuZW5jb2RlKHNvdXJjZSkgOiBzb3VyY2VcblxuICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYnVmZmVyKVxuICAgICAgICB9XG5cbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcmVhZGFibGVTdHJlYW1DbG9zZShjb250cm9sbGVyKSlcbiAgICAgIH0sXG4gICAgICBzdGFydCAoKSB7fSxcbiAgICAgIHR5cGU6ICdieXRlcydcbiAgICB9KVxuICB9XG5cbiAgLy8gNS4gQXNzZXJ0OiBzdHJlYW0gaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QuXG4gIGFzc2VydChpc1JlYWRhYmxlU3RyZWFtTGlrZShzdHJlYW0pKVxuXG4gIC8vIDYuIExldCBhY3Rpb24gYmUgbnVsbC5cbiAgbGV0IGFjdGlvbiA9IG51bGxcblxuICAvLyA3LiBMZXQgc291cmNlIGJlIG51bGwuXG4gIGxldCBzb3VyY2UgPSBudWxsXG5cbiAgLy8gOC4gTGV0IGxlbmd0aCBiZSBudWxsLlxuICBsZXQgbGVuZ3RoID0gbnVsbFxuXG4gIC8vIDkuIExldCB0eXBlIGJlIG51bGwuXG4gIGxldCB0eXBlID0gbnVsbFxuXG4gIC8vIDEwLiBTd2l0Y2ggb24gb2JqZWN0OlxuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBTZXQgc291cmNlIHRvIHRoZSBVVEYtOCBlbmNvZGluZyBvZiBvYmplY3QuXG4gICAgLy8gTm90ZTogc2V0dGluZyBzb3VyY2UgdG8gYSBVaW50OEFycmF5IGhlcmUgYnJlYWtzIHNvbWUgbW9ja2luZyBhc3N1bXB0aW9ucy5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCB0eXBlIHRvIGB0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04J1xuICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcykge1xuICAgIC8vIFVSTFNlYXJjaFBhcmFtc1xuXG4gICAgLy8gc3BlYyBzYXlzIHRvIHJ1biBhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQgb24gYm9keS5saXN0XG4gICAgLy8gdGhpcyBpcyBpbXBsZW1lbnRlZCBpbiBOb2RlLmpzIGFzIGFwYXJ0IG9mIGFuIFVSTFNlYXJjaFBhcmFtcyBpbnN0YW5jZSB0b1N0cmluZyBtZXRob2RcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMNDkwXG4gICAgLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL2U0NmM2ODBiZjJiMjExYmJkNTJjZjk1OWNhMTdlZTk4YzdmNjU3ZjUvbGliL2ludGVybmFsL3VybC5qcyNMMTEwMFxuXG4gICAgLy8gU2V0IHNvdXJjZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgdGhlIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBzZXJpYWxpemVyIHdpdGggb2JqZWN04oCZcyBsaXN0LlxuICAgIHNvdXJjZSA9IG9iamVjdC50b1N0cmluZygpXG5cbiAgICAvLyBTZXQgdHlwZSB0byBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLThgLlxuICAgIHR5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnXG4gIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihvYmplY3QpKSB7XG4gICAgLy8gQnVmZmVyU291cmNlL0FycmF5QnVmZmVyXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIGEgY29weSBvZiB0aGUgYnl0ZXMgaGVsZCBieSBvYmplY3QuXG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LnNsaWNlKCkpXG4gIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KG9iamVjdCkpIHtcbiAgICAvLyBCdWZmZXJTb3VyY2UvQXJyYXlCdWZmZXJWaWV3XG5cbiAgICAvLyBTZXQgc291cmNlIHRvIGEgY29weSBvZiB0aGUgYnl0ZXMgaGVsZCBieSBvYmplY3QuXG4gICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkob2JqZWN0LmJ1ZmZlci5zbGljZShvYmplY3QuYnl0ZU9mZnNldCwgb2JqZWN0LmJ5dGVPZmZzZXQgKyBvYmplY3QuYnl0ZUxlbmd0aCkpXG4gIH0gZWxzZSBpZiAodXRpbC5pc0Zvcm1EYXRhTGlrZShvYmplY3QpKSB7XG4gICAgY29uc3QgYm91bmRhcnkgPSBgLS0tLWZvcm1kYXRhLXVuZGljaS0wJHtgJHtyYW5kb20oMWUxMSl9YC5wYWRTdGFydCgxMSwgJzAnKX1gXG4gICAgY29uc3QgcHJlZml4ID0gYC0tJHtib3VuZGFyeX1cXHJcXG5Db250ZW50LURpc3Bvc2l0aW9uOiBmb3JtLWRhdGFgXG5cbiAgICAvKiEgZm9ybWRhdGEtcG9seWZpbGwuIE1JVCBMaWNlbnNlLiBKaW1teSBXw6RydGluZyA8aHR0cHM6Ly9qaW1teS53YXJ0aW5nLnNlL29wZW5zb3VyY2U+ICovXG4gICAgY29uc3QgZXNjYXBlID0gKHN0cikgPT5cbiAgICAgIHN0ci5yZXBsYWNlKC9cXG4vZywgJyUwQScpLnJlcGxhY2UoL1xcci9nLCAnJTBEJykucmVwbGFjZSgvXCIvZywgJyUyMicpXG4gICAgY29uc3Qgbm9ybWFsaXplTGluZWZlZWRzID0gKHZhbHVlKSA9PiB2YWx1ZS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCAnXFxyXFxuJylcblxuICAgIC8vIFNldCBhY3Rpb24gdG8gdGhpcyBzdGVwOiBydW4gdGhlIG11bHRpcGFydC9mb3JtLWRhdGFcbiAgICAvLyBlbmNvZGluZyBhbGdvcml0aG0sIHdpdGggb2JqZWN04oCZcyBlbnRyeSBsaXN0IGFuZCBVVEYtOC5cbiAgICAvLyAtIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBib2R5IGlzIGltbXV0YWJsZSBhbmQgY2FuJ3QgYmUgY2hhbmdlZCBhZnRlcndvcmRzXG4gICAgLy8gLSBUaGF0IHRoZSBjb250ZW50LWxlbmd0aCBpcyBjYWxjdWxhdGVkIGluIGFkdmFuY2UuXG4gICAgLy8gLSBBbmQgdGhhdCBhbGwgcGFydHMgYXJlIHByZS1lbmNvZGVkIGFuZCByZWFkeSB0byBiZSBzZW50LlxuXG4gICAgY29uc3QgYmxvYlBhcnRzID0gW11cbiAgICBjb25zdCBybiA9IG5ldyBVaW50OEFycmF5KFsxMywgMTBdKSAvLyAnXFxyXFxuJ1xuICAgIGxlbmd0aCA9IDBcbiAgICBsZXQgaGFzVW5rbm93blNpemVWYWx1ZSA9IGZhbHNlXG5cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2Ygb2JqZWN0KSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBjaHVuayA9IHRleHRFbmNvZGVyLmVuY29kZShwcmVmaXggK1xuICAgICAgICAgIGA7IG5hbWU9XCIke2VzY2FwZShub3JtYWxpemVMaW5lZmVlZHMobmFtZSkpfVwiYCArXG4gICAgICAgICAgYFxcclxcblxcclxcbiR7bm9ybWFsaXplTGluZWZlZWRzKHZhbHVlKX1cXHJcXG5gKVxuICAgICAgICBibG9iUGFydHMucHVzaChjaHVuaylcbiAgICAgICAgbGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGhcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGNodW5rID0gdGV4dEVuY29kZXIuZW5jb2RlKGAke3ByZWZpeH07IG5hbWU9XCIke2VzY2FwZShub3JtYWxpemVMaW5lZmVlZHMobmFtZSkpfVwiYCArXG4gICAgICAgICAgKHZhbHVlLm5hbWUgPyBgOyBmaWxlbmFtZT1cIiR7ZXNjYXBlKHZhbHVlLm5hbWUpfVwiYCA6ICcnKSArICdcXHJcXG4nICtcbiAgICAgICAgICBgQ29udGVudC1UeXBlOiAke1xuICAgICAgICAgICAgdmFsdWUudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgICAgICAgIH1cXHJcXG5cXHJcXG5gKVxuICAgICAgICBibG9iUGFydHMucHVzaChjaHVuaywgdmFsdWUsIHJuKVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlLnNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGggKyB2YWx1ZS5zaXplICsgcm4uYnl0ZUxlbmd0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhc1Vua25vd25TaXplVmFsdWUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDUkxGIGlzIGFwcGVuZGVkIHRvIHRoZSBib2R5IHRvIGZ1bmN0aW9uIHdpdGggbGVnYWN5IHNlcnZlcnMgYW5kIG1hdGNoIG90aGVyIGltcGxlbWVudGF0aW9ucy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY3VybC9jdXJsL2Jsb2IvMzQzNGM2YjQ2ZTY4MjQ1Mjk3Mzk3MmU4MzEzNjEzZGZhNThjZDY5MC9saWIvbWltZS5jI0wxMDI5LUwxMDMwXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zvcm0tZGF0YS9mb3JtLWRhdGEvaXNzdWVzLzYzXG4gICAgY29uc3QgY2h1bmsgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoYC0tJHtib3VuZGFyeX0tLVxcclxcbmApXG4gICAgYmxvYlBhcnRzLnB1c2goY2h1bmspXG4gICAgbGVuZ3RoICs9IGNodW5rLmJ5dGVMZW5ndGhcbiAgICBpZiAoaGFzVW5rbm93blNpemVWYWx1ZSkge1xuICAgICAgbGVuZ3RoID0gbnVsbFxuICAgIH1cblxuICAgIC8vIFNldCBzb3VyY2UgdG8gb2JqZWN0LlxuICAgIHNvdXJjZSA9IG9iamVjdFxuXG4gICAgYWN0aW9uID0gYXN5bmMgZnVuY3Rpb24gKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgYmxvYlBhcnRzKSB7XG4gICAgICAgIGlmIChwYXJ0LnN0cmVhbSkge1xuICAgICAgICAgIHlpZWxkICogcGFydC5zdHJlYW0oKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHlpZWxkIHBhcnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0eXBlIHRvIGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT1gLFxuICAgIC8vIGZvbGxvd2VkIGJ5IHRoZSBtdWx0aXBhcnQvZm9ybS1kYXRhIGJvdW5kYXJ5IHN0cmluZyBnZW5lcmF0ZWRcbiAgICAvLyBieSB0aGUgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBlbmNvZGluZyBhbGdvcml0aG0uXG4gICAgdHlwZSA9IGBtdWx0aXBhcnQvZm9ybS1kYXRhOyBib3VuZGFyeT0ke2JvdW5kYXJ5fWBcbiAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKG9iamVjdCkpIHtcbiAgICAvLyBCbG9iXG5cbiAgICAvLyBTZXQgc291cmNlIHRvIG9iamVjdC5cbiAgICBzb3VyY2UgPSBvYmplY3RcblxuICAgIC8vIFNldCBsZW5ndGggdG8gb2JqZWN04oCZcyBzaXplLlxuICAgIGxlbmd0aCA9IG9iamVjdC5zaXplXG5cbiAgICAvLyBJZiBvYmplY3TigJlzIHR5cGUgYXR0cmlidXRlIGlzIG5vdCB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgc2V0XG4gICAgLy8gdHlwZSB0byBpdHMgdmFsdWUuXG4gICAgaWYgKG9iamVjdC50eXBlKSB7XG4gICAgICB0eXBlID0gb2JqZWN0LnR5cGVcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG9iamVjdFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiBrZWVwYWxpdmUgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAoa2VlcGFsaXZlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZWVwYWxpdmUnKVxuICAgIH1cblxuICAgIC8vIElmIG9iamVjdCBpcyBkaXN0dXJiZWQgb3IgbG9ja2VkLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh1dGlsLmlzRGlzdHVyYmVkKG9iamVjdCkgfHwgb2JqZWN0LmxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1Jlc3BvbnNlIGJvZHkgb2JqZWN0IHNob3VsZCBub3QgYmUgZGlzdHVyYmVkIG9yIGxvY2tlZCdcbiAgICAgIClcbiAgICB9XG5cbiAgICBzdHJlYW0gPVxuICAgICAgb2JqZWN0IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gPyBvYmplY3QgOiBSZWFkYWJsZVN0cmVhbUZyb20ob2JqZWN0KVxuICB9XG5cbiAgLy8gMTEuIElmIHNvdXJjZSBpcyBhIGJ5dGUgc2VxdWVuY2UsIHRoZW4gc2V0IGFjdGlvbiB0byBhXG4gIC8vIHN0ZXAgdGhhdCByZXR1cm5zIHNvdXJjZSBhbmQgbGVuZ3RoIHRvIHNvdXJjZeKAmXMgbGVuZ3RoLlxuICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgfHwgdXRpbC5pc0J1ZmZlcihzb3VyY2UpKSB7XG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc291cmNlKVxuICB9XG5cbiAgLy8gMTIuIElmIGFjdGlvbiBpcyBub24tbnVsbCwgdGhlbiBydW4gdGhlc2Ugc3RlcHMgaW4gaW4gcGFyYWxsZWw6XG4gIGlmIChhY3Rpb24gIT0gbnVsbCkge1xuICAgIC8vIFJ1biBhY3Rpb24uXG4gICAgbGV0IGl0ZXJhdG9yXG4gICAgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIGFzeW5jIHN0YXJ0ICgpIHtcbiAgICAgICAgaXRlcmF0b3IgPSBhY3Rpb24ob2JqZWN0KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgfSxcbiAgICAgIGFzeW5jIHB1bGwgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgLy8gV2hlbiBydW5uaW5nIGFjdGlvbiBpcyBkb25lLCBjbG9zZSBzdHJlYW0uXG4gICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpXG4gICAgICAgICAgICBjb250cm9sbGVyLmJ5b2JSZXF1ZXN0Py5yZXNwb25kKDApXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXaGVuZXZlciBvbmUgb3IgbW9yZSBieXRlcyBhcmUgYXZhaWxhYmxlIGFuZCBzdHJlYW0gaXMgbm90IGVycm9yZWQsXG4gICAgICAgICAgLy8gZW5xdWV1ZSBhIFVpbnQ4QXJyYXkgd3JhcHBpbmcgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyB0aGUgYXZhaWxhYmxlXG4gICAgICAgICAgLy8gYnl0ZXMgaW50byBzdHJlYW0uXG4gICAgICAgICAgaWYgKCFpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpXG4gICAgICAgICAgICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJ1ZmZlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPiAwXG4gICAgICB9LFxuICAgICAgYXN5bmMgY2FuY2VsIChyZWFzb24pIHtcbiAgICAgICAgYXdhaXQgaXRlcmF0b3IucmV0dXJuKClcbiAgICAgIH0sXG4gICAgICB0eXBlOiAnYnl0ZXMnXG4gICAgfSlcbiAgfVxuXG4gIC8vIDEzLiBMZXQgYm9keSBiZSBhIGJvZHkgd2hvc2Ugc3RyZWFtIGlzIHN0cmVhbSwgc291cmNlIGlzIHNvdXJjZSxcbiAgLy8gYW5kIGxlbmd0aCBpcyBsZW5ndGguXG4gIGNvbnN0IGJvZHkgPSB7IHN0cmVhbSwgc291cmNlLCBsZW5ndGggfVxuXG4gIC8vIDE0LiBSZXR1cm4gKGJvZHksIHR5cGUpLlxuICByZXR1cm4gW2JvZHksIHR5cGVdXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5aW5pdC1zYWZlbHktZXh0cmFjdFxuZnVuY3Rpb24gc2FmZWx5RXh0cmFjdEJvZHkgKG9iamVjdCwga2VlcGFsaXZlID0gZmFsc2UpIHtcbiAgLy8gVG8gc2FmZWx5IGV4dHJhY3QgYSBib2R5IGFuZCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb21cbiAgLy8gYSBieXRlIHNlcXVlbmNlIG9yIEJvZHlJbml0IG9iamVjdCBvYmplY3QsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiBvYmplY3QgaXMgYSBSZWFkYWJsZVN0cmVhbSBvYmplY3QsIHRoZW46XG4gIGlmIChvYmplY3QgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIC8vIEFzc2VydDogb2JqZWN0IGlzIG5laXRoZXIgZGlzdHVyYmVkIG5vciBsb2NrZWQuXG4gICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICBhc3NlcnQoIXV0aWwuaXNEaXN0dXJiZWQob2JqZWN0KSwgJ1RoZSBib2R5IGhhcyBhbHJlYWR5IGJlZW4gY29uc3VtZWQuJylcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGFzc2VydCghb2JqZWN0LmxvY2tlZCwgJ1RoZSBzdHJlYW0gaXMgbG9ja2VkLicpXG4gIH1cblxuICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgZXh0cmFjdGluZyBvYmplY3QuXG4gIHJldHVybiBleHRyYWN0Qm9keShvYmplY3QsIGtlZXBhbGl2ZSlcbn1cblxuZnVuY3Rpb24gY2xvbmVCb2R5IChpbnN0YW5jZSwgYm9keSkge1xuICAvLyBUbyBjbG9uZSBhIGJvZHkgYm9keSwgcnVuIHRoZXNlIHN0ZXBzOlxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY2xvbmVcblxuICAvLyAxLiBMZXQgwqsgb3V0MSwgb3V0MiDCuyBiZSB0aGUgcmVzdWx0IG9mIHRlZWluZyBib2R54oCZcyBzdHJlYW0uXG4gIGNvbnN0IFtvdXQxLCBvdXQyXSA9IGJvZHkuc3RyZWFtLnRlZSgpXG5cbiAgaWYgKGhhc0ZpbmFsaXphdGlvblJlZ2lzdHJ5KSB7XG4gICAgc3RyZWFtUmVnaXN0cnkucmVnaXN0ZXIoaW5zdGFuY2UsIG5ldyBXZWFrUmVmKG91dDEpKVxuICB9XG5cbiAgLy8gMi4gU2V0IGJvZHnigJlzIHN0cmVhbSB0byBvdXQxLlxuICBib2R5LnN0cmVhbSA9IG91dDFcblxuICAvLyAzLiBSZXR1cm4gYSBib2R5IHdob3NlIHN0cmVhbSBpcyBvdXQyIGFuZCBvdGhlciBtZW1iZXJzIGFyZSBjb3BpZWQgZnJvbSBib2R5LlxuICByZXR1cm4ge1xuICAgIHN0cmVhbTogb3V0MixcbiAgICBsZW5ndGg6IGJvZHkubGVuZ3RoLFxuICAgIHNvdXJjZTogYm9keS5zb3VyY2VcbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0lmQWJvcnRlZCAoc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmFib3J0ZWQpIHtcbiAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicsICdBYm9ydEVycm9yJylcbiAgfVxufVxuXG5mdW5jdGlvbiBib2R5TWl4aW5NZXRob2RzIChpbnN0YW5jZSkge1xuICBjb25zdCBtZXRob2RzID0ge1xuICAgIGJsb2IgKCkge1xuICAgICAgLy8gVGhlIGJsb2IoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mXG4gICAgICAvLyBydW5uaW5nIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIHRoZSBmb2xsb3dpbmcgc3RlcFxuICAgICAgLy8gZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOiByZXR1cm4gYSBCbG9iIHdob3NlXG4gICAgICAvLyBjb250ZW50cyBhcmUgYnl0ZXMgYW5kIHdob3NlIHR5cGUgYXR0cmlidXRlIGlzIHRoaXPigJlzXG4gICAgICAvLyBNSU1FIHR5cGUuXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgKGJ5dGVzKSA9PiB7XG4gICAgICAgIGxldCBtaW1lVHlwZSA9IGJvZHlNaW1lVHlwZSh0aGlzKVxuXG4gICAgICAgIGlmIChtaW1lVHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG1pbWVUeXBlID0gJydcbiAgICAgICAgfSBlbHNlIGlmIChtaW1lVHlwZSkge1xuICAgICAgICAgIG1pbWVUeXBlID0gc2VyaWFsaXplQU1pbWVUeXBlKG1pbWVUeXBlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV0dXJuIGEgQmxvYiB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMgYW5kIHR5cGUgYXR0cmlidXRlXG4gICAgICAgIC8vIGlzIG1pbWVUeXBlLlxuICAgICAgICByZXR1cm4gbmV3IEJsb2IoW2J5dGVzXSwgeyB0eXBlOiBtaW1lVHlwZSB9KVxuICAgICAgfSwgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIGFycmF5QnVmZmVyICgpIHtcbiAgICAgIC8vIFRoZSBhcnJheUJ1ZmZlcigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHRcbiAgICAgIC8vIG9mIHJ1bm5pbmcgY29uc3VtZSBib2R5IHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwXG4gICAgICAvLyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgYnl0ZXM6IHJldHVybiBhIG5ldyBBcnJheUJ1ZmZlclxuICAgICAgLy8gd2hvc2UgY29udGVudHMgYXJlIGJ5dGVzLlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsIChieXRlcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpLmJ1ZmZlclxuICAgICAgfSwgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIHRleHQgKCkge1xuICAgICAgLy8gVGhlIHRleHQoKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmdcbiAgICAgIC8vIGNvbnN1bWUgYm9keSB3aXRoIHRoaXMgYW5kIFVURi04IGRlY29kZS5cbiAgICAgIHJldHVybiBjb25zdW1lQm9keSh0aGlzLCB1dGY4RGVjb2RlQnl0ZXMsIGluc3RhbmNlKVxuICAgIH0sXG5cbiAgICBqc29uICgpIHtcbiAgICAgIC8vIFRoZSBqc29uKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICAvLyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCBwYXJzZSBKU09OIGZyb20gYnl0ZXMuXG4gICAgICByZXR1cm4gY29uc3VtZUJvZHkodGhpcywgcGFyc2VKU09ORnJvbUJ5dGVzLCBpbnN0YW5jZSlcbiAgICB9LFxuXG4gICAgZm9ybURhdGEgKCkge1xuICAgICAgLy8gVGhlIGZvcm1EYXRhKCkgbWV0aG9kIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nXG4gICAgICAvLyBjb25zdW1lIGJvZHkgd2l0aCB0aGlzIGFuZCB0aGUgZm9sbG93aW5nIHN0ZXAgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzOlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsICh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyAxLiBMZXQgbWltZVR5cGUgYmUgdGhlIHJlc3VsdCBvZiBnZXQgdGhlIE1JTUUgdHlwZSB3aXRoIHRoaXMuXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gYm9keU1pbWVUeXBlKHRoaXMpXG5cbiAgICAgICAgLy8gMi4gSWYgbWltZVR5cGUgaXMgbm9uLW51bGwsIHRoZW4gc3dpdGNoIG9uIG1pbWVUeXBl4oCZcyBlc3NlbmNlIGFuZCBydW5cbiAgICAgICAgLy8gICAgdGhlIGNvcnJlc3BvbmRpbmcgc3RlcHM6XG4gICAgICAgIGlmIChtaW1lVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAobWltZVR5cGUuZXNzZW5jZSkge1xuICAgICAgICAgICAgY2FzZSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSc6IHtcbiAgICAgICAgICAgICAgLy8gMS4gLi4uIFtsb25nIHN0ZXBdXG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IG11bHRpcGFydEZvcm1EYXRhUGFyc2VyKHZhbHVlLCBtaW1lVHlwZSlcblxuICAgICAgICAgICAgICAvLyAyLiBJZiB0aGF0IGZhaWxzIGZvciBzb21lIHJlYXNvbiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlZCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmFpbGVkIHRvIHBhcnNlIGJvZHkgYXMgRm9ybURhdGEuJylcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIDMuIFJldHVybiBhIG5ldyBGb3JtRGF0YSBvYmplY3QsIGFwcGVuZGluZyBlYWNoIGVudHJ5LFxuICAgICAgICAgICAgICAvLyAgICByZXN1bHRpbmcgZnJvbSB0aGUgcGFyc2luZyBvcGVyYXRpb24sIHRvIGl0cyBlbnRyeSBsaXN0LlxuICAgICAgICAgICAgICBjb25zdCBmZCA9IG5ldyBGb3JtRGF0YSgpXG4gICAgICAgICAgICAgIGZkW2tTdGF0ZV0gPSBwYXJzZWRcblxuICAgICAgICAgICAgICByZXR1cm4gZmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6IHtcbiAgICAgICAgICAgICAgLy8gMS4gTGV0IGVudHJpZXMgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGJ5dGVzLlxuICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh2YWx1ZS50b1N0cmluZygpKVxuXG4gICAgICAgICAgICAgIC8vIDIuIElmIGVudHJpZXMgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cblxuICAgICAgICAgICAgICAvLyAzLiBSZXR1cm4gYSBuZXcgRm9ybURhdGEgb2JqZWN0IHdob3NlIGVudHJ5IGxpc3QgaXMgZW50cmllcy5cbiAgICAgICAgICAgICAgY29uc3QgZmQgPSBuZXcgRm9ybURhdGEoKVxuXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgZmQuYXBwZW5kKG5hbWUsIHZhbHVlKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy4gVGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSB3YXMgbm90IG9uZSBvZiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiBvciBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLidcbiAgICAgICAgKVxuICAgICAgfSwgaW5zdGFuY2UpXG4gICAgfSxcblxuICAgIGJ5dGVzICgpIHtcbiAgICAgIC8vIFRoZSBieXRlcygpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBjb25zdW1lIGJvZHlcbiAgICAgIC8vIHdpdGggdGhpcyBhbmQgdGhlIGZvbGxvd2luZyBzdGVwIGdpdmVuIGEgYnl0ZSBzZXF1ZW5jZSBieXRlczogcmV0dXJuIHRoZVxuICAgICAgLy8gcmVzdWx0IG9mIGNyZWF0aW5nIGEgVWludDhBcnJheSBmcm9tIGJ5dGVzIGluIHRoaXPigJlzIHJlbGV2YW50IHJlYWxtLlxuICAgICAgcmV0dXJuIGNvbnN1bWVCb2R5KHRoaXMsIChieXRlcykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpXG4gICAgICB9LCBpbnN0YW5jZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWV0aG9kc1xufVxuXG5mdW5jdGlvbiBtaXhpbkJvZHkgKHByb3RvdHlwZSkge1xuICBPYmplY3QuYXNzaWduKHByb3RvdHlwZS5wcm90b3R5cGUsIGJvZHlNaXhpbk1ldGhvZHMocHJvdG90eXBlKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWJvZHktY29uc3VtZS1ib2R5XG4gKiBAcGFyYW0ge1Jlc3BvbnNlfFJlcXVlc3R9IG9iamVjdFxuICogQHBhcmFtIHsodmFsdWU6IHVua25vd24pID0+IHVua25vd259IGNvbnZlcnRCeXRlc1RvSlNWYWx1ZVxuICogQHBhcmFtIHtSZXNwb25zZXxSZXF1ZXN0fSBpbnN0YW5jZVxuICovXG5hc3luYyBmdW5jdGlvbiBjb25zdW1lQm9keSAob2JqZWN0LCBjb252ZXJ0Qnl0ZXNUb0pTVmFsdWUsIGluc3RhbmNlKSB7XG4gIHdlYmlkbC5icmFuZENoZWNrKG9iamVjdCwgaW5zdGFuY2UpXG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIHVudXNhYmxlLCB0aGVuIHJldHVybiBhIHByb21pc2UgcmVqZWN0ZWRcbiAgLy8gICAgd2l0aCBhIFR5cGVFcnJvci5cbiAgaWYgKGJvZHlVbnVzYWJsZShvYmplY3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBpcyB1bnVzYWJsZTogQm9keSBoYXMgYWxyZWFkeSBiZWVuIHJlYWQnKVxuICB9XG5cbiAgdGhyb3dJZkFib3J0ZWQob2JqZWN0W2tTdGF0ZV0pXG5cbiAgLy8gMi4gTGV0IHByb21pc2UgYmUgYSBuZXcgcHJvbWlzZS5cbiAgY29uc3QgcHJvbWlzZSA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZSgpXG5cbiAgLy8gMy4gTGV0IGVycm9yU3RlcHMgZ2l2ZW4gZXJyb3IgYmUgdG8gcmVqZWN0IHByb21pc2Ugd2l0aCBlcnJvci5cbiAgY29uc3QgZXJyb3JTdGVwcyA9IChlcnJvcikgPT4gcHJvbWlzZS5yZWplY3QoZXJyb3IpXG5cbiAgLy8gNC4gTGV0IHN1Y2Nlc3NTdGVwcyBnaXZlbiBhIGJ5dGUgc2VxdWVuY2UgZGF0YSBiZSB0byByZXNvbHZlXG4gIC8vICAgIHByb21pc2Ugd2l0aCB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgY29udmVydEJ5dGVzVG9KU1ZhbHVlXG4gIC8vICAgIHdpdGggZGF0YS4gSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIHRoZW4gcnVuIGVycm9yU3RlcHNcbiAgLy8gICAgd2l0aCB0aGF0IGV4Y2VwdGlvbi5cbiAgY29uc3Qgc3VjY2Vzc1N0ZXBzID0gKGRhdGEpID0+IHtcbiAgICB0cnkge1xuICAgICAgcHJvbWlzZS5yZXNvbHZlKGNvbnZlcnRCeXRlc1RvSlNWYWx1ZShkYXRhKSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvclN0ZXBzKGUpXG4gICAgfVxuICB9XG5cbiAgLy8gNS4gSWYgb2JqZWN04oCZcyBib2R5IGlzIG51bGwsIHRoZW4gcnVuIHN1Y2Nlc3NTdGVwcyB3aXRoIGFuXG4gIC8vICAgIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIGlmIChvYmplY3Rba1N0YXRlXS5ib2R5ID09IG51bGwpIHtcbiAgICBzdWNjZXNzU3RlcHMoQnVmZmVyLmFsbG9jVW5zYWZlKDApKVxuICAgIHJldHVybiBwcm9taXNlLnByb21pc2VcbiAgfVxuXG4gIC8vIDYuIE90aGVyd2lzZSwgZnVsbHkgcmVhZCBvYmplY3TigJlzIGJvZHkgZ2l2ZW4gc3VjY2Vzc1N0ZXBzLFxuICAvLyAgICBlcnJvclN0ZXBzLCBhbmQgb2JqZWN04oCZcyByZWxldmFudCBnbG9iYWwgb2JqZWN0LlxuICBhd2FpdCBmdWxseVJlYWRCb2R5KG9iamVjdFtrU3RhdGVdLmJvZHksIHN1Y2Nlc3NTdGVwcywgZXJyb3JTdGVwcylcblxuICAvLyA3LiBSZXR1cm4gcHJvbWlzZS5cbiAgcmV0dXJuIHByb21pc2UucHJvbWlzZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keS11bnVzYWJsZVxuZnVuY3Rpb24gYm9keVVudXNhYmxlIChvYmplY3QpIHtcbiAgY29uc3QgYm9keSA9IG9iamVjdFtrU3RhdGVdLmJvZHlcblxuICAvLyBBbiBvYmplY3QgaW5jbHVkaW5nIHRoZSBCb2R5IGludGVyZmFjZSBtaXhpbiBpc1xuICAvLyBzYWlkIHRvIGJlIHVudXNhYmxlIGlmIGl0cyBib2R5IGlzIG5vbi1udWxsIGFuZFxuICAvLyBpdHMgYm9keeKAmXMgc3RyZWFtIGlzIGRpc3R1cmJlZCBvciBsb2NrZWQuXG4gIHJldHVybiBib2R5ICE9IG51bGwgJiYgKGJvZHkuc3RyZWFtLmxvY2tlZCB8fCB1dGlsLmlzRGlzdHVyYmVkKGJvZHkuc3RyZWFtKSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNwYXJzZS1qc29uLWJ5dGVzLXRvLWEtamF2YXNjcmlwdC12YWx1ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICovXG5mdW5jdGlvbiBwYXJzZUpTT05Gcm9tQnl0ZXMgKGJ5dGVzKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHV0ZjhEZWNvZGVCeXRlcyhieXRlcykpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LW1pbWUtdHlwZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vcmVzcG9uc2UnKS5SZXNwb25zZXxpbXBvcnQoJy4vcmVxdWVzdCcpLlJlcXVlc3R9IHJlcXVlc3RPclJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGJvZHlNaW1lVHlwZSAocmVxdWVzdE9yUmVzcG9uc2UpIHtcbiAgLy8gMS4gTGV0IGhlYWRlcnMgYmUgbnVsbC5cbiAgLy8gMi4gSWYgcmVxdWVzdE9yUmVzcG9uc2UgaXMgYSBSZXF1ZXN0IG9iamVjdCwgdGhlbiBzZXQgaGVhZGVycyB0byByZXF1ZXN0T3JSZXNwb25zZeKAmXMgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIC8vIDMuIE90aGVyd2lzZSwgc2V0IGhlYWRlcnMgdG8gcmVxdWVzdE9yUmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vaGVhZGVycycpLkhlYWRlcnNMaXN0fSAqL1xuICBjb25zdCBoZWFkZXJzID0gcmVxdWVzdE9yUmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdFxuXG4gIC8vIDQuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYSBNSU1FIHR5cGUgZnJvbSBoZWFkZXJzLlxuICBjb25zdCBtaW1lVHlwZSA9IGV4dHJhY3RNaW1lVHlwZShoZWFkZXJzKVxuXG4gIC8vIDUuIElmIG1pbWVUeXBlIGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIG51bGwuXG4gIGlmIChtaW1lVHlwZSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDYuIFJldHVybiBtaW1lVHlwZS5cbiAgcmV0dXJuIG1pbWVUeXBlXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBleHRyYWN0Qm9keSxcbiAgc2FmZWx5RXh0cmFjdEJvZHksXG4gIGNsb25lQm9keSxcbiAgbWl4aW5Cb2R5LFxuICBzdHJlYW1SZWdpc3RyeSxcbiAgaGFzRmluYWxpemF0aW9uUmVnaXN0cnksXG4gIGJvZHlVbnVzYWJsZVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/body.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/constants.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/constants.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst corsSafeListedMethods = /** @type {const} */ (['GET', 'HEAD', 'POST'])\nconst corsSafeListedMethodsSet = new Set(corsSafeListedMethods)\n\nconst nullBodyStatus = /** @type {const} */ ([101, 204, 205, 304])\n\nconst redirectStatus = /** @type {const} */ ([301, 302, 303, 307, 308])\nconst redirectStatusSet = new Set(redirectStatus)\n\n/**\n * @see https://fetch.spec.whatwg.org/#block-bad-port\n */\nconst badPorts = /** @type {const} */ ([\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '4190', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6679',\n  '6697', '10080'\n])\nconst badPortsSet = new Set(badPorts)\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#referrer-policies\n */\nconst referrerPolicy = /** @type {const} */ ([\n  '',\n  'no-referrer',\n  'no-referrer-when-downgrade',\n  'same-origin',\n  'origin',\n  'strict-origin',\n  'origin-when-cross-origin',\n  'strict-origin-when-cross-origin',\n  'unsafe-url'\n])\nconst referrerPolicySet = new Set(referrerPolicy)\n\nconst requestRedirect = /** @type {const} */ (['follow', 'manual', 'error'])\n\nconst safeMethods = /** @type {const} */ (['GET', 'HEAD', 'OPTIONS', 'TRACE'])\nconst safeMethodsSet = new Set(safeMethods)\n\nconst requestMode = /** @type {const} */ (['navigate', 'same-origin', 'no-cors', 'cors'])\n\nconst requestCredentials = /** @type {const} */ (['omit', 'same-origin', 'include'])\n\nconst requestCache = /** @type {const} */ ([\n  'default',\n  'no-store',\n  'reload',\n  'no-cache',\n  'force-cache',\n  'only-if-cached'\n])\n\n/**\n * @see https://fetch.spec.whatwg.org/#request-body-header-name\n */\nconst requestBodyHeader = /** @type {const} */ ([\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type',\n  // See https://github.com/nodejs/undici/issues/2021\n  // 'Content-Length' is a forbidden header name, which is typically\n  // removed in the Headers implementation. However, undici doesn't\n  // filter out headers, so we add it here.\n  'content-length'\n])\n\n/**\n * @see https://fetch.spec.whatwg.org/#enumdef-requestduplex\n */\nconst requestDuplex = /** @type {const} */ ([\n  'half'\n])\n\n/**\n * @see http://fetch.spec.whatwg.org/#forbidden-method\n */\nconst forbiddenMethods = /** @type {const} */ (['CONNECT', 'TRACE', 'TRACK'])\nconst forbiddenMethodsSet = new Set(forbiddenMethods)\n\nconst subresource = /** @type {const} */ ([\n  'audio',\n  'audioworklet',\n  'font',\n  'image',\n  'manifest',\n  'paintworklet',\n  'script',\n  'style',\n  'track',\n  'video',\n  'xslt',\n  ''\n])\nconst subresourceSet = new Set(subresource)\n\nmodule.exports = {\n  subresource,\n  forbiddenMethods,\n  requestBodyHeader,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  redirectStatus,\n  corsSafeListedMethods,\n  nullBodyStatus,\n  safeMethods,\n  badPorts,\n  requestDuplex,\n  subresourceSet,\n  badPortsSet,\n  redirectStatusSet,\n  corsSafeListedMethodsSet,\n  safeMethodsSet,\n  forbiddenMethodsSet,\n  referrerPolicySet\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLHlDQUF5QyxPQUFPO0FBQ2hEOztBQUVBLGtDQUFrQyxPQUFPOztBQUV6QyxrQ0FBa0MsT0FBTztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLE9BQU87O0FBRTFDLCtCQUErQixPQUFPO0FBQ3RDOztBQUVBLCtCQUErQixPQUFPOztBQUV0QyxzQ0FBc0MsT0FBTzs7QUFFN0MsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQzs7QUFFQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBjb3JzU2FmZUxpc3RlZE1ldGhvZHMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydHRVQnLCAnSEVBRCcsICdQT1NUJ10pXG5jb25zdCBjb3JzU2FmZUxpc3RlZE1ldGhvZHNTZXQgPSBuZXcgU2V0KGNvcnNTYWZlTGlzdGVkTWV0aG9kcylcblxuY29uc3QgbnVsbEJvZHlTdGF0dXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWzEwMSwgMjA0LCAyMDUsIDMwNF0pXG5cbmNvbnN0IHJlZGlyZWN0U3RhdHVzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF0pXG5jb25zdCByZWRpcmVjdFN0YXR1c1NldCA9IG5ldyBTZXQocmVkaXJlY3RTdGF0dXMpXG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYmxvY2stYmFkLXBvcnRcbiAqL1xuY29uc3QgYmFkUG9ydHMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnMScsICc3JywgJzknLCAnMTEnLCAnMTMnLCAnMTUnLCAnMTcnLCAnMTknLCAnMjAnLCAnMjEnLCAnMjInLCAnMjMnLCAnMjUnLCAnMzcnLCAnNDInLCAnNDMnLCAnNTMnLCAnNjknLCAnNzcnLCAnNzknLFxuICAnODcnLCAnOTUnLCAnMTAxJywgJzEwMicsICcxMDMnLCAnMTA0JywgJzEwOScsICcxMTAnLCAnMTExJywgJzExMycsICcxMTUnLCAnMTE3JywgJzExOScsICcxMjMnLCAnMTM1JywgJzEzNycsXG4gICcxMzknLCAnMTQzJywgJzE2MScsICcxNzknLCAnMzg5JywgJzQyNycsICc0NjUnLCAnNTEyJywgJzUxMycsICc1MTQnLCAnNTE1JywgJzUyNicsICc1MzAnLCAnNTMxJywgJzUzMicsXG4gICc1NDAnLCAnNTQ4JywgJzU1NCcsICc1NTYnLCAnNTYzJywgJzU4NycsICc2MDEnLCAnNjM2JywgJzk4OScsICc5OTAnLCAnOTkzJywgJzk5NScsICcxNzE5JywgJzE3MjAnLCAnMTcyMycsXG4gICcyMDQ5JywgJzM2NTknLCAnNDA0NScsICc0MTkwJywgJzUwNjAnLCAnNTA2MScsICc2MDAwJywgJzY1NjYnLCAnNjY2NScsICc2NjY2JywgJzY2NjcnLCAnNjY2OCcsICc2NjY5JywgJzY2NzknLFxuICAnNjY5NycsICcxMDA4MCdcbl0pXG5jb25zdCBiYWRQb3J0c1NldCA9IG5ldyBTZXQoYmFkUG9ydHMpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jcmVmZXJyZXItcG9saWNpZXNcbiAqL1xuY29uc3QgcmVmZXJyZXJQb2xpY3kgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnJyxcbiAgJ25vLXJlZmVycmVyJyxcbiAgJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJyxcbiAgJ3NhbWUtb3JpZ2luJyxcbiAgJ29yaWdpbicsXG4gICdzdHJpY3Qtb3JpZ2luJyxcbiAgJ29yaWdpbi13aGVuLWNyb3NzLW9yaWdpbicsXG4gICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJyxcbiAgJ3Vuc2FmZS11cmwnXG5dKVxuY29uc3QgcmVmZXJyZXJQb2xpY3lTZXQgPSBuZXcgU2V0KHJlZmVycmVyUG9saWN5KVxuXG5jb25zdCByZXF1ZXN0UmVkaXJlY3QgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydmb2xsb3cnLCAnbWFudWFsJywgJ2Vycm9yJ10pXG5cbmNvbnN0IHNhZmVNZXRob2RzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdUUkFDRSddKVxuY29uc3Qgc2FmZU1ldGhvZHNTZXQgPSBuZXcgU2V0KHNhZmVNZXRob2RzKVxuXG5jb25zdCByZXF1ZXN0TW9kZSA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ25hdmlnYXRlJywgJ3NhbWUtb3JpZ2luJywgJ25vLWNvcnMnLCAnY29ycyddKVxuXG5jb25zdCByZXF1ZXN0Q3JlZGVudGlhbHMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydvbWl0JywgJ3NhbWUtb3JpZ2luJywgJ2luY2x1ZGUnXSlcblxuY29uc3QgcmVxdWVzdENhY2hlID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcbiAgJ2RlZmF1bHQnLFxuICAnbm8tc3RvcmUnLFxuICAncmVsb2FkJyxcbiAgJ25vLWNhY2hlJyxcbiAgJ2ZvcmNlLWNhY2hlJyxcbiAgJ29ubHktaWYtY2FjaGVkJ1xuXSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWJvZHktaGVhZGVyLW5hbWVcbiAqL1xuY29uc3QgcmVxdWVzdEJvZHlIZWFkZXIgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnY29udGVudC1lbmNvZGluZycsXG4gICdjb250ZW50LWxhbmd1YWdlJyxcbiAgJ2NvbnRlbnQtbG9jYXRpb24nLFxuICAnY29udGVudC10eXBlJyxcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8yMDIxXG4gIC8vICdDb250ZW50LUxlbmd0aCcgaXMgYSBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHdoaWNoIGlzIHR5cGljYWxseVxuICAvLyByZW1vdmVkIGluIHRoZSBIZWFkZXJzIGltcGxlbWVudGF0aW9uLiBIb3dldmVyLCB1bmRpY2kgZG9lc24ndFxuICAvLyBmaWx0ZXIgb3V0IGhlYWRlcnMsIHNvIHdlIGFkZCBpdCBoZXJlLlxuICAnY29udGVudC1sZW5ndGgnXG5dKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2VudW1kZWYtcmVxdWVzdGR1cGxleFxuICovXG5jb25zdCByZXF1ZXN0RHVwbGV4ID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcbiAgJ2hhbGYnXG5dKVxuXG4vKipcbiAqIEBzZWUgaHR0cDovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZm9yYmlkZGVuLW1ldGhvZFxuICovXG5jb25zdCBmb3JiaWRkZW5NZXRob2RzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsnQ09OTkVDVCcsICdUUkFDRScsICdUUkFDSyddKVxuY29uc3QgZm9yYmlkZGVuTWV0aG9kc1NldCA9IG5ldyBTZXQoZm9yYmlkZGVuTWV0aG9kcylcblxuY29uc3Qgc3VicmVzb3VyY2UgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoW1xuICAnYXVkaW8nLFxuICAnYXVkaW93b3JrbGV0JyxcbiAgJ2ZvbnQnLFxuICAnaW1hZ2UnLFxuICAnbWFuaWZlc3QnLFxuICAncGFpbnR3b3JrbGV0JyxcbiAgJ3NjcmlwdCcsXG4gICdzdHlsZScsXG4gICd0cmFjaycsXG4gICd2aWRlbycsXG4gICd4c2x0JyxcbiAgJydcbl0pXG5jb25zdCBzdWJyZXNvdXJjZVNldCA9IG5ldyBTZXQoc3VicmVzb3VyY2UpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdWJyZXNvdXJjZSxcbiAgZm9yYmlkZGVuTWV0aG9kcyxcbiAgcmVxdWVzdEJvZHlIZWFkZXIsXG4gIHJlZmVycmVyUG9saWN5LFxuICByZXF1ZXN0UmVkaXJlY3QsXG4gIHJlcXVlc3RNb2RlLFxuICByZXF1ZXN0Q3JlZGVudGlhbHMsXG4gIHJlcXVlc3RDYWNoZSxcbiAgcmVkaXJlY3RTdGF0dXMsXG4gIGNvcnNTYWZlTGlzdGVkTWV0aG9kcyxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIHNhZmVNZXRob2RzLFxuICBiYWRQb3J0cyxcbiAgcmVxdWVzdER1cGxleCxcbiAgc3VicmVzb3VyY2VTZXQsXG4gIGJhZFBvcnRzU2V0LFxuICByZWRpcmVjdFN0YXR1c1NldCxcbiAgY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0LFxuICBzYWZlTWV0aG9kc1NldCxcbiAgZm9yYmlkZGVuTWV0aG9kc1NldCxcbiAgcmVmZXJyZXJQb2xpY3lTZXRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/data-url.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/data-url.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\n\nconst encoder = new TextEncoder()\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-token-code-point\n */\nconst HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+\\-.^_|~A-Za-z0-9]+$/\nconst HTTP_WHITESPACE_REGEX = /[\\u000A\\u000D\\u0009\\u0020]/ // eslint-disable-line\nconst ASCII_WHITESPACE_REPLACE_REGEX = /[\\u0009\\u000A\\u000C\\u000D\\u0020]/g // eslint-disable-line\n/**\n * @see https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n */\nconst HTTP_QUOTED_STRING_TOKENS = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/ // eslint-disable-line\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePointsFast(\n    ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = removeASCIIWhitespace(mimeType, true, true)\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = isomorphicDecode(body)\n\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  if (!excludeFragment) {\n    return url.href\n  }\n\n  const href = url.href\n  const hashLength = url.hash.length\n\n  const serialized = hashLength === 0 ? href : href.substring(0, href.length - hashLength)\n\n  if (!hashLength && href.endsWith('#')) {\n    return serialized.slice(0, -1)\n  }\n\n  return serialized\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n/**\n * A faster collectASequenceOfCodePoints that only works when comparing a single character.\n * @param {string} char\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePointsFast (char, input, position) {\n  const idx = input.indexOf(char, position.position)\n  const start = position.position\n\n  if (idx === -1) {\n    position.position = input.length\n    return input.slice(start)\n  }\n\n  position.position = idx\n  return input.slice(start, position.position)\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n/**\n * @param {number} byte\n */\nfunction isHexCharByte (byte) {\n  // 0-9 A-F a-f\n  return (byte >= 0x30 && byte <= 0x39) || (byte >= 0x41 && byte <= 0x46) || (byte >= 0x61 && byte <= 0x66)\n}\n\n/**\n * @param {number} byte\n */\nfunction hexByteToNumber (byte) {\n  return (\n    // 0-9\n    byte >= 0x30 && byte <= 0x39\n      ? (byte - 48)\n    // Convert to uppercase\n    // ((byte & 0xDF) - 65) + 10\n      : ((byte & 0xDF) - 55)\n  )\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  const length = input.length\n  // 1. Let output be an empty byte sequence.\n  /** @type {Uint8Array} */\n  const output = new Uint8Array(length)\n  let j = 0\n  // 2. For each byte byte in input:\n  for (let i = 0; i < length; ++i) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output[j++] = byte\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    } else if (\n      byte === 0x25 &&\n      !(isHexCharByte(input[i + 1]) && isHexCharByte(input[i + 2]))\n    ) {\n      output[j++] = 0x25\n\n    // 3. Otherwise:\n    } else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      // 2. Append a byte whose value is bytePoint to output.\n      output[j++] = (hexByteToNumber(input[i + 1]) << 4) | hexByteToNumber(input[i + 2])\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return length === j ? output : output.subarray(0, j)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = removeHTTPWhitespace(input, true, true)\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePointsFast(\n    '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePointsFast(\n    ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = removeHTTPWhitespace(subtype, false, true)\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {\n    return 'failure'\n  }\n\n  const typeLowercase = type.toLowerCase()\n  const subtypeLowercase = subtype.toLowerCase()\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: typeLowercase,\n    subtype: subtypeLowercase,\n    /** @type {Map<string, string>} */\n    parameters: new Map(),\n    // https://mimesniff.spec.whatwg.org/#mime-type-essence\n    essence: `${typeLowercase}/${subtypeLowercase}`\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      char => HTTP_WHITESPACE_REGEX.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      parameterValue = collectAnHTTPQuotedString(input, position, true)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n    // 9. Otherwise:\n    } else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePointsFast(\n        ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = removeHTTPWhitespace(parameterValue, false, true)\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      HTTP_TOKEN_CODEPOINTS.test(parameterName) &&\n      (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(ASCII_WHITESPACE_REPLACE_REGEX, '')  // eslint-disable-line\n\n  let dataLength = data.length\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (dataLength % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    if (data.charCodeAt(dataLength - 1) === 0x003D) {\n      --dataLength\n      if (data.charCodeAt(dataLength - 1) === 0x003D) {\n        --dataLength\n      }\n    }\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (dataLength % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data.length === dataLength ? data : data.substring(0, dataLength))) {\n    return 'failure'\n  }\n\n  const buffer = Buffer.from(data, 'base64')\n  return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n\n    // 6. Otherwise:\n    } else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#serialize-a-mime-type\n */\nfunction serializeAMimeType (mimeType) {\n  assert(mimeType !== 'failure')\n  const { parameters, essence } = mimeType\n\n  // 1. Let serialization be the concatenation of mimeType’s\n  //    type, U+002F (/), and mimeType’s subtype.\n  let serialization = essence\n\n  // 2. For each name → value of mimeType’s parameters:\n  for (let [name, value] of parameters.entries()) {\n    // 1. Append U+003B (;) to serialization.\n    serialization += ';'\n\n    // 2. Append name to serialization.\n    serialization += name\n\n    // 3. Append U+003D (=) to serialization.\n    serialization += '='\n\n    // 4. If value does not solely contain HTTP token code\n    //    points or value is the empty string, then:\n    if (!HTTP_TOKEN_CODEPOINTS.test(value)) {\n      // 1. Precede each occurrence of U+0022 (\") or\n      //    U+005C (\\) in value with U+005C (\\).\n      value = value.replace(/(\\\\|\")/g, '\\\\$1')\n\n      // 2. Prepend U+0022 (\") to value.\n      value = '\"' + value\n\n      // 3. Append U+0022 (\") to value.\n      value += '\"'\n    }\n\n    // 5. Append value to serialization.\n    serialization += value\n  }\n\n  // 3. Return serialization.\n  return serialization\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {number} char\n */\nfunction isHTTPWhiteSpace (char) {\n  // \"\\r\\n\\t \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeHTTPWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isHTTPWhiteSpace)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#ascii-whitespace\n * @param {number} char\n */\nfunction isASCIIWhitespace (char) {\n  // \"\\r\\n\\t\\f \"\n  return char === 0x00d || char === 0x00a || char === 0x009 || char === 0x00c || char === 0x020\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#strip-leading-and-trailing-ascii-whitespace\n * @param {string} str\n * @param {boolean} [leading=true]\n * @param {boolean} [trailing=true]\n */\nfunction removeASCIIWhitespace (str, leading = true, trailing = true) {\n  return removeChars(str, leading, trailing, isASCIIWhitespace)\n}\n\n/**\n * @param {string} str\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns\n */\nfunction removeChars (str, leading, trailing, predicate) {\n  let lead = 0\n  let trail = str.length - 1\n\n  if (leading) {\n    while (lead < str.length && predicate(str.charCodeAt(lead))) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(str.charCodeAt(trail))) trail--\n  }\n\n  return lead === 0 && trail === str.length - 1 ? str : str.slice(lead, trail + 1)\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {Uint8Array} input\n * @returns {string}\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n  const length = input.length\n  if ((2 << 15) - 1 > length) {\n    return String.fromCharCode.apply(null, input)\n  }\n  let result = ''; let i = 0\n  let addition = (2 << 15) - 1\n  while (i < length) {\n    if (i + addition > length) {\n      addition = length - i\n    }\n    result += String.fromCharCode.apply(null, input.subarray(i, i += addition))\n  }\n  return result\n}\n\n/**\n * @see https://mimesniff.spec.whatwg.org/#minimize-a-supported-mime-type\n * @param {Exclude<ReturnType<typeof parseMIMEType>, 'failure'>} mimeType\n */\nfunction minimizeSupportedMimeType (mimeType) {\n  switch (mimeType.essence) {\n    case 'application/ecmascript':\n    case 'application/javascript':\n    case 'application/x-ecmascript':\n    case 'application/x-javascript':\n    case 'text/ecmascript':\n    case 'text/javascript':\n    case 'text/javascript1.0':\n    case 'text/javascript1.1':\n    case 'text/javascript1.2':\n    case 'text/javascript1.3':\n    case 'text/javascript1.4':\n    case 'text/javascript1.5':\n    case 'text/jscript':\n    case 'text/livescript':\n    case 'text/x-ecmascript':\n    case 'text/x-javascript':\n      // 1. If mimeType is a JavaScript MIME type, then return \"text/javascript\".\n      return 'text/javascript'\n    case 'application/json':\n    case 'text/json':\n      // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n      return 'application/json'\n    case 'image/svg+xml':\n      // 3. If mimeType’s essence is \"image/svg+xml\", then return \"image/svg+xml\".\n      return 'image/svg+xml'\n    case 'text/xml':\n    case 'application/xml':\n      // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n      return 'application/xml'\n  }\n\n  // 2. If mimeType is a JSON MIME type, then return \"application/json\".\n  if (mimeType.subtype.endsWith('+json')) {\n    return 'application/json'\n  }\n\n  // 4. If mimeType is an XML MIME type, then return \"application/xml\".\n  if (mimeType.subtype.endsWith('+xml')) {\n    return 'application/xml'\n  }\n\n  // 5. If mimeType is supported by the user agent, then return mimeType’s essence.\n  // Technically, node doesn't support any mimetypes.\n\n  // 6. Return the empty string.\n  return ''\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  collectASequenceOfCodePointsFast,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString,\n  serializeAMimeType,\n  removeChars,\n  removeHTTPWhitespace,\n  minimizeSupportedMimeType,\n  HTTP_TOKEN_CODEPOINTS,\n  isomorphicDecode\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGF0YS11cmwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLGdDQUFhOztBQUVwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxRQUFRLFNBQVMsR0FBRztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQSwwQ0FBMEM7QUFDMUM7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVywyQkFBMkI7QUFDdEMsV0FBVyxRQUFRO0FBQ25CLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxzREFBc0Q7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxkYXRhLXVybC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jaHR0cC10b2tlbi1jb2RlLXBvaW50XG4gKi9cbmNvbnN0IEhUVFBfVE9LRU5fQ09ERVBPSU5UUyA9IC9eWyEjJCUmJyorXFwtLl5ffH5BLVphLXowLTldKyQvXG5jb25zdCBIVFRQX1dISVRFU1BBQ0VfUkVHRVggPSAvW1xcdTAwMEFcXHUwMDBEXFx1MDAwOVxcdTAwMjBdLyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5jb25zdCBBU0NJSV9XSElURVNQQUNFX1JFUExBQ0VfUkVHRVggPSAvW1xcdTAwMDlcXHUwMDBBXFx1MDAwQ1xcdTAwMERcXHUwMDIwXS9nIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtcXVvdGVkLXN0cmluZy10b2tlbi1jb2RlLXBvaW50XG4gKi9cbmNvbnN0IEhUVFBfUVVPVEVEX1NUUklOR19UT0tFTlMgPSAvXltcXHUwMDA5XFx1MDAyMC1cXHUwMDdFXFx1MDA4MC1cXHUwMEZGXSskLyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkYXRhLXVybC1wcm9jZXNzb3Jcbi8qKiBAcGFyYW0ge1VSTH0gZGF0YVVSTCAqL1xuZnVuY3Rpb24gZGF0YVVSTFByb2Nlc3NvciAoZGF0YVVSTCkge1xuICAvLyAxLiBBc3NlcnQ6IGRhdGFVUkzigJlzIHNjaGVtZSBpcyBcImRhdGFcIi5cbiAgYXNzZXJ0KGRhdGFVUkwucHJvdG9jb2wgPT09ICdkYXRhOicpXG5cbiAgLy8gMi4gTGV0IGlucHV0IGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGUgVVJMXG4gIC8vIHNlcmlhbGl6ZXIgb24gZGF0YVVSTCB3aXRoIGV4Y2x1ZGUgZnJhZ21lbnRcbiAgLy8gc2V0IHRvIHRydWUuXG4gIGxldCBpbnB1dCA9IFVSTFNlcmlhbGl6ZXIoZGF0YVVSTCwgdHJ1ZSlcblxuICAvLyAzLiBSZW1vdmUgdGhlIGxlYWRpbmcgXCJkYXRhOlwiIHN0cmluZyBmcm9tIGlucHV0LlxuICBpbnB1dCA9IGlucHV0LnNsaWNlKDUpXG5cbiAgLy8gNC4gTGV0IHBvc2l0aW9uIHBvaW50IGF0IHRoZSBzdGFydCBvZiBpbnB1dC5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyA1LiBMZXQgbWltZVR5cGUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGFcbiAgLy8gc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IGVxdWFsXG4gIC8vIHRvIFUrMDAyQyAoLCksIGdpdmVuIHBvc2l0aW9uLlxuICBsZXQgbWltZVR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAnLCcsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDYuIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIEFTQ0lJIHdoaXRlc3BhY2VcbiAgLy8gZnJvbSBtaW1lVHlwZS5cbiAgLy8gVW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IHdlIG5lZWQgdG8gc3RvcmUgdGhlXG4gIC8vIGxlbmd0aCBiZWNhdXNlIGlmIHRoZSBtaW1ldHlwZSBoYXMgc3BhY2VzIHJlbW92ZWQsXG4gIC8vIHRoZSB3cm9uZyBhbW91bnQgd2lsbCBiZSBzbGljZWQgZnJvbSB0aGUgaW5wdXQgaW5cbiAgLy8gc3RlcCAjOVxuICBjb25zdCBtaW1lVHlwZUxlbmd0aCA9IG1pbWVUeXBlLmxlbmd0aFxuICBtaW1lVHlwZSA9IHJlbW92ZUFTQ0lJV2hpdGVzcGFjZShtaW1lVHlwZSwgdHJ1ZSwgdHJ1ZSlcblxuICAvLyA3LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW5cbiAgLy8gcmV0dXJuIGZhaWx1cmVcbiAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDguIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDkuIExldCBlbmNvZGVkQm9keSBiZSB0aGUgcmVtYWluZGVyIG9mIGlucHV0LlxuICBjb25zdCBlbmNvZGVkQm9keSA9IGlucHV0LnNsaWNlKG1pbWVUeXBlTGVuZ3RoICsgMSlcblxuICAvLyAxMC4gTGV0IGJvZHkgYmUgdGhlIHBlcmNlbnQtZGVjb2Rpbmcgb2YgZW5jb2RlZEJvZHkuXG4gIGxldCBib2R5ID0gc3RyaW5nUGVyY2VudERlY29kZShlbmNvZGVkQm9keSlcblxuICAvLyAxMS4gSWYgbWltZVR5cGUgZW5kcyB3aXRoIFUrMDAzQiAoOyksIGZvbGxvd2VkIGJ5XG4gIC8vIHplcm8gb3IgbW9yZSBVKzAwMjAgU1BBQ0UsIGZvbGxvd2VkIGJ5IGFuIEFTQ0lJXG4gIC8vIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIFwiYmFzZTY0XCIsIHRoZW46XG4gIGlmICgvOyhcXHUwMDIwKXswLH1iYXNlNjQkL2kudGVzdChtaW1lVHlwZSkpIHtcbiAgICAvLyAxLiBMZXQgc3RyaW5nQm9keSBiZSB0aGUgaXNvbW9ycGhpYyBkZWNvZGUgb2YgYm9keS5cbiAgICBjb25zdCBzdHJpbmdCb2R5ID0gaXNvbW9ycGhpY0RlY29kZShib2R5KVxuXG4gICAgLy8gMi4gU2V0IGJvZHkgdG8gdGhlIGZvcmdpdmluZy1iYXNlNjQgZGVjb2RlIG9mXG4gICAgLy8gc3RyaW5nQm9keS5cbiAgICBib2R5ID0gZm9yZ2l2aW5nQmFzZTY0KHN0cmluZ0JvZHkpXG5cbiAgICAvLyAzLiBJZiBib2R5IGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gICAgaWYgKGJvZHkgPT09ICdmYWlsdXJlJykge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH1cblxuICAgIC8vIDQuIFJlbW92ZSB0aGUgbGFzdCA2IGNvZGUgcG9pbnRzIGZyb20gbWltZVR5cGUuXG4gICAgbWltZVR5cGUgPSBtaW1lVHlwZS5zbGljZSgwLCAtNilcblxuICAgIC8vIDUuIFJlbW92ZSB0cmFpbGluZyBVKzAwMjAgU1BBQ0UgY29kZSBwb2ludHMgZnJvbSBtaW1lVHlwZSxcbiAgICAvLyBpZiBhbnkuXG4gICAgbWltZVR5cGUgPSBtaW1lVHlwZS5yZXBsYWNlKC8oXFx1MDAyMCkrJC8sICcnKVxuXG4gICAgLy8gNi4gUmVtb3ZlIHRoZSBsYXN0IFUrMDAzQiAoOykgY29kZSBwb2ludCBmcm9tIG1pbWVUeXBlLlxuICAgIG1pbWVUeXBlID0gbWltZVR5cGUuc2xpY2UoMCwgLTEpXG4gIH1cblxuICAvLyAxMi4gSWYgbWltZVR5cGUgc3RhcnRzIHdpdGggVSswMDNCICg7KSwgdGhlbiBwcmVwZW5kXG4gIC8vIFwidGV4dC9wbGFpblwiIHRvIG1pbWVUeXBlLlxuICBpZiAobWltZVR5cGUuc3RhcnRzV2l0aCgnOycpKSB7XG4gICAgbWltZVR5cGUgPSAndGV4dC9wbGFpbicgKyBtaW1lVHlwZVxuICB9XG5cbiAgLy8gMTMuIExldCBtaW1lVHlwZVJlY29yZCBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmdcbiAgLy8gbWltZVR5cGUuXG4gIGxldCBtaW1lVHlwZVJlY29yZCA9IHBhcnNlTUlNRVR5cGUobWltZVR5cGUpXG5cbiAgLy8gMTQuIElmIG1pbWVUeXBlUmVjb3JkIGlzIGZhaWx1cmUsIHRoZW4gc2V0XG4gIC8vIG1pbWVUeXBlUmVjb3JkIHRvIHRleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSS5cbiAgaWYgKG1pbWVUeXBlUmVjb3JkID09PSAnZmFpbHVyZScpIHtcbiAgICBtaW1lVHlwZVJlY29yZCA9IHBhcnNlTUlNRVR5cGUoJ3RleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSScpXG4gIH1cblxuICAvLyAxNS4gUmV0dXJuIGEgbmV3IGRhdGE6IFVSTCBzdHJ1Y3Qgd2hvc2UgTUlNRVxuICAvLyB0eXBlIGlzIG1pbWVUeXBlUmVjb3JkIGFuZCBib2R5IGlzIGJvZHkuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkYXRhLXVybC1zdHJ1Y3RcbiAgcmV0dXJuIHsgbWltZVR5cGU6IG1pbWVUeXBlUmVjb3JkLCBib2R5IH1cbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXVybC1zZXJpYWxpemVyXG4vKipcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXhjbHVkZUZyYWdtZW50XG4gKi9cbmZ1bmN0aW9uIFVSTFNlcmlhbGl6ZXIgKHVybCwgZXhjbHVkZUZyYWdtZW50ID0gZmFsc2UpIHtcbiAgaWYgKCFleGNsdWRlRnJhZ21lbnQpIHtcbiAgICByZXR1cm4gdXJsLmhyZWZcbiAgfVxuXG4gIGNvbnN0IGhyZWYgPSB1cmwuaHJlZlxuICBjb25zdCBoYXNoTGVuZ3RoID0gdXJsLmhhc2gubGVuZ3RoXG5cbiAgY29uc3Qgc2VyaWFsaXplZCA9IGhhc2hMZW5ndGggPT09IDAgPyBocmVmIDogaHJlZi5zdWJzdHJpbmcoMCwgaHJlZi5sZW5ndGggLSBoYXNoTGVuZ3RoKVxuXG4gIGlmICghaGFzaExlbmd0aCAmJiBocmVmLmVuZHNXaXRoKCcjJykpIHtcbiAgICByZXR1cm4gc2VyaWFsaXplZC5zbGljZSgwLCAtMSlcbiAgfVxuXG4gIHJldHVybiBzZXJpYWxpemVkXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNjb2xsZWN0LWEtc2VxdWVuY2Utb2YtY29kZS1wb2ludHNcbi8qKlxuICogQHBhcmFtIHsoY2hhcjogc3RyaW5nKSA9PiBib29sZWFufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyAoY29uZGl0aW9uLCBpbnB1dCwgcG9zaXRpb24pIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBsZXQgcmVzdWx0ID0gJydcblxuICAvLyAyLiBXaGlsZSBwb3NpdGlvbiBkb2VzbuKAmXQgcG9pbnQgcGFzdCB0aGUgZW5kIG9mIGlucHV0IGFuZCB0aGVcbiAgLy8gY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgbWVldHMgdGhlIGNvbmRpdGlvbiBjb25kaXRpb246XG4gIHdoaWxlIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCAmJiBjb25kaXRpb24oaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dKSkge1xuICAgIC8vIDEuIEFwcGVuZCB0aGF0IGNvZGUgcG9pbnQgdG8gdGhlIGVuZCBvZiByZXN1bHQuXG4gICAgcmVzdWx0ICs9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgLy8gMi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcbiAgfVxuXG4gIC8vIDMuIFJldHVybiByZXN1bHQuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBBIGZhc3RlciBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzIHRoYXQgb25seSB3b3JrcyB3aGVuIGNvbXBhcmluZyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhclxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdCAoY2hhciwgaW5wdXQsIHBvc2l0aW9uKSB7XG4gIGNvbnN0IGlkeCA9IGlucHV0LmluZGV4T2YoY2hhciwgcG9zaXRpb24ucG9zaXRpb24pXG4gIGNvbnN0IHN0YXJ0ID0gcG9zaXRpb24ucG9zaXRpb25cblxuICBpZiAoaWR4ID09PSAtMSkge1xuICAgIHBvc2l0aW9uLnBvc2l0aW9uID0gaW5wdXQubGVuZ3RoXG4gICAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0KVxuICB9XG5cbiAgcG9zaXRpb24ucG9zaXRpb24gPSBpZHhcbiAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0LCBwb3NpdGlvbi5wb3NpdGlvbilcbn1cblxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNzdHJpbmctcGVyY2VudC1kZWNvZGVcbi8qKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgKi9cbmZ1bmN0aW9uIHN0cmluZ1BlcmNlbnREZWNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIExldCBieXRlcyBiZSB0aGUgVVRGLTggZW5jb2Rpbmcgb2YgaW5wdXQuXG4gIGNvbnN0IGJ5dGVzID0gZW5jb2Rlci5lbmNvZGUoaW5wdXQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBwZXJjZW50LWRlY29kaW5nIG9mIGJ5dGVzLlxuICByZXR1cm4gcGVyY2VudERlY29kZShieXRlcylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYnl0ZVxuICovXG5mdW5jdGlvbiBpc0hleENoYXJCeXRlIChieXRlKSB7XG4gIC8vIDAtOSBBLUYgYS1mXG4gIHJldHVybiAoYnl0ZSA+PSAweDMwICYmIGJ5dGUgPD0gMHgzOSkgfHwgKGJ5dGUgPj0gMHg0MSAmJiBieXRlIDw9IDB4NDYpIHx8IChieXRlID49IDB4NjEgJiYgYnl0ZSA8PSAweDY2KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlXG4gKi9cbmZ1bmN0aW9uIGhleEJ5dGVUb051bWJlciAoYnl0ZSkge1xuICByZXR1cm4gKFxuICAgIC8vIDAtOVxuICAgIGJ5dGUgPj0gMHgzMCAmJiBieXRlIDw9IDB4MzlcbiAgICAgID8gKGJ5dGUgLSA0OClcbiAgICAvLyBDb252ZXJ0IHRvIHVwcGVyY2FzZVxuICAgIC8vICgoYnl0ZSAmIDB4REYpIC0gNjUpICsgMTBcbiAgICAgIDogKChieXRlICYgMHhERikgLSA1NSlcbiAgKVxufVxuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3BlcmNlbnQtZGVjb2RlXG4vKiogQHBhcmFtIHtVaW50OEFycmF5fSBpbnB1dCAqL1xuZnVuY3Rpb24gcGVyY2VudERlY29kZSAoaW5wdXQpIHtcbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoXG4gIC8vIDEuIExldCBvdXRwdXQgYmUgYW4gZW1wdHkgYnl0ZSBzZXF1ZW5jZS5cbiAgLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqL1xuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBqID0gMFxuICAvLyAyLiBGb3IgZWFjaCBieXRlIGJ5dGUgaW4gaW5wdXQ6XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBieXRlID0gaW5wdXRbaV1cblxuICAgIC8vIDEuIElmIGJ5dGUgaXMgbm90IDB4MjUgKCUpLCB0aGVuIGFwcGVuZCBieXRlIHRvIG91dHB1dC5cbiAgICBpZiAoYnl0ZSAhPT0gMHgyNSkge1xuICAgICAgb3V0cHV0W2orK10gPSBieXRlXG5cbiAgICAvLyAyLiBPdGhlcndpc2UsIGlmIGJ5dGUgaXMgMHgyNSAoJSkgYW5kIHRoZSBuZXh0IHR3byBieXRlc1xuICAgIC8vIGFmdGVyIGJ5dGUgaW4gaW5wdXQgYXJlIG5vdCBpbiB0aGUgcmFuZ2VzXG4gICAgLy8gMHgzMCAoMCkgdG8gMHgzOSAoOSksIDB4NDEgKEEpIHRvIDB4NDYgKEYpLFxuICAgIC8vIGFuZCAweDYxIChhKSB0byAweDY2IChmKSwgYWxsIGluY2x1c2l2ZSwgYXBwZW5kIGJ5dGVcbiAgICAvLyB0byBvdXRwdXQuXG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGJ5dGUgPT09IDB4MjUgJiZcbiAgICAgICEoaXNIZXhDaGFyQnl0ZShpbnB1dFtpICsgMV0pICYmIGlzSGV4Q2hhckJ5dGUoaW5wdXRbaSArIDJdKSlcbiAgICApIHtcbiAgICAgIG91dHB1dFtqKytdID0gMHgyNVxuXG4gICAgLy8gMy4gT3RoZXJ3aXNlOlxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAxLiBMZXQgYnl0ZVBvaW50IGJlIHRoZSB0d28gYnl0ZXMgYWZ0ZXIgYnl0ZSBpbiBpbnB1dCxcbiAgICAgIC8vIGRlY29kZWQsIGFuZCB0aGVuIGludGVycHJldGVkIGFzIGhleGFkZWNpbWFsIG51bWJlci5cbiAgICAgIC8vIDIuIEFwcGVuZCBhIGJ5dGUgd2hvc2UgdmFsdWUgaXMgYnl0ZVBvaW50IHRvIG91dHB1dC5cbiAgICAgIG91dHB1dFtqKytdID0gKGhleEJ5dGVUb051bWJlcihpbnB1dFtpICsgMV0pIDw8IDQpIHwgaGV4Qnl0ZVRvTnVtYmVyKGlucHV0W2kgKyAyXSlcblxuICAgICAgLy8gMy4gU2tpcCB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gaW5wdXQuXG4gICAgICBpICs9IDJcbiAgICB9XG4gIH1cblxuICAvLyAzLiBSZXR1cm4gb3V0cHV0LlxuICByZXR1cm4gbGVuZ3RoID09PSBqID8gb3V0cHV0IDogb3V0cHV0LnN1YmFycmF5KDAsIGopXG59XG5cbi8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jcGFyc2UtYS1taW1lLXR5cGVcbi8qKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgKi9cbmZ1bmN0aW9uIHBhcnNlTUlNRVR5cGUgKGlucHV0KSB7XG4gIC8vIDEuIFJlbW92ZSBhbnkgbGVhZGluZyBhbmQgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlXG4gIC8vIGZyb20gaW5wdXQuXG4gIGlucHV0ID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2UoaW5wdXQsIHRydWUsIHRydWUpXG5cbiAgLy8gMi4gTGV0IHBvc2l0aW9uIGJlIGEgcG9zaXRpb24gdmFyaWFibGUgZm9yIGlucHV0LFxuICAvLyBpbml0aWFsbHkgcG9pbnRpbmcgYXQgdGhlIHN0YXJ0IG9mIGlucHV0LlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIDMuIExldCB0eXBlIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlXG4gIC8vIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwMkYgKC8pIGZyb21cbiAgLy8gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICBjb25zdCB0eXBlID0gY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgJy8nLFxuICAgIGlucHV0LFxuICAgIHBvc2l0aW9uXG4gIClcblxuICAvLyA0LiBJZiB0eXBlIGlzIHRoZSBlbXB0eSBzdHJpbmcgb3IgZG9lcyBub3Qgc29sZWx5XG4gIC8vIGNvbnRhaW4gSFRUUCB0b2tlbiBjb2RlIHBvaW50cywgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgLy8gaHR0cHM6Ly9taW1lc25pZmYuc3BlYy53aGF0d2cub3JnLyNodHRwLXRva2VuLWNvZGUtcG9pbnRcbiAgaWYgKHR5cGUubGVuZ3RoID09PSAwIHx8ICFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdCh0eXBlKSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDUuIElmIHBvc2l0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiBpbnB1dCwgdGhlbiByZXR1cm5cbiAgLy8gZmFpbHVyZVxuICBpZiAocG9zaXRpb24ucG9zaXRpb24gPiBpbnB1dC5sZW5ndGgpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA2LiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuIChUaGlzIHNraXBzIHBhc3QgVSswMDJGICgvKS4pXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyA3LiBMZXQgc3VidHlwZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZlxuICAvLyBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDNCICg7KSBmcm9tIGlucHV0LCBnaXZlblxuICAvLyBwb3NpdGlvbi5cbiAgbGV0IHN1YnR5cGUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAnOycsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDguIFJlbW92ZSBhbnkgdHJhaWxpbmcgSFRUUCB3aGl0ZXNwYWNlIGZyb20gc3VidHlwZS5cbiAgc3VidHlwZSA9IHJlbW92ZUhUVFBXaGl0ZXNwYWNlKHN1YnR5cGUsIGZhbHNlLCB0cnVlKVxuXG4gIC8vIDkuIElmIHN1YnR5cGUgaXMgdGhlIGVtcHR5IHN0cmluZyBvciBkb2VzIG5vdCBzb2xlbHlcbiAgLy8gY29udGFpbiBIVFRQIHRva2VuIGNvZGUgcG9pbnRzLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoc3VidHlwZS5sZW5ndGggPT09IDAgfHwgIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHN1YnR5cGUpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgY29uc3QgdHlwZUxvd2VyY2FzZSA9IHR5cGUudG9Mb3dlckNhc2UoKVxuICBjb25zdCBzdWJ0eXBlTG93ZXJjYXNlID0gc3VidHlwZS50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gMTAuIExldCBtaW1lVHlwZSBiZSBhIG5ldyBNSU1FIHR5cGUgcmVjb3JkIHdob3NlIHR5cGVcbiAgLy8gaXMgdHlwZSwgaW4gQVNDSUkgbG93ZXJjYXNlLCBhbmQgc3VidHlwZSBpcyBzdWJ0eXBlLFxuICAvLyBpbiBBU0NJSSBsb3dlcmNhc2UuXG4gIC8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jbWltZS10eXBlXG4gIGNvbnN0IG1pbWVUeXBlID0ge1xuICAgIHR5cGU6IHR5cGVMb3dlcmNhc2UsXG4gICAgc3VidHlwZTogc3VidHlwZUxvd2VyY2FzZSxcbiAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIHN0cmluZz59ICovXG4gICAgcGFyYW1ldGVyczogbmV3IE1hcCgpLFxuICAgIC8vIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jbWltZS10eXBlLWVzc2VuY2VcbiAgICBlc3NlbmNlOiBgJHt0eXBlTG93ZXJjYXNlfS8ke3N1YnR5cGVMb3dlcmNhc2V9YFxuICB9XG5cbiAgLy8gMTEuIFdoaWxlIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQ6XG4gIHdoaWxlIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgIC8vIDEuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwM0IgKDspLilcbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyAyLiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUFxuICAgIC8vIHdoaXRlc3BhY2UgZnJvbSBpbnB1dCBnaXZlbiBwb3NpdGlvbi5cbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtd2hpdGVzcGFjZVxuICAgICAgY2hhciA9PiBIVFRQX1dISVRFU1BBQ0VfUkVHRVgudGVzdChjaGFyKSxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyAzLiBMZXQgcGFyYW1ldGVyTmFtZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYVxuICAgIC8vIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzIHRoYXQgYXJlIG5vdCBVKzAwM0IgKDspXG4gICAgLy8gb3IgVSswMDNEICg9KSBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbi5cbiAgICBsZXQgcGFyYW1ldGVyTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gJzsnICYmIGNoYXIgIT09ICc9JyxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyA0LiBTZXQgcGFyYW1ldGVyTmFtZSB0byBwYXJhbWV0ZXJOYW1lLCBpbiBBU0NJSVxuICAgIC8vIGxvd2VyY2FzZS5cbiAgICBwYXJhbWV0ZXJOYW1lID0gcGFyYW1ldGVyTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyA1LiBJZiBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuOlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgLy8gMS4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0IGlzXG4gICAgICAvLyBVKzAwM0IgKDspLCB0aGVuIGNvbnRpbnVlLlxuICAgICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gJzsnKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS4gKFRoaXMgc2tpcHMgcGFzdCBVKzAwM0QgKD0pLilcbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcbiAgICB9XG5cbiAgICAvLyA2LiBJZiBwb3NpdGlvbiBpcyBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gYnJlYWsuXG4gICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIC8vIDcuIExldCBwYXJhbWV0ZXJWYWx1ZSBiZSBudWxsLlxuICAgIGxldCBwYXJhbWV0ZXJWYWx1ZSA9IG51bGxcblxuICAgIC8vIDguIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpc1xuICAgIC8vIFUrMDAyMiAoXCIpLCB0aGVuOlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gPT09ICdcIicpIHtcbiAgICAgIC8vIDEuIFNldCBwYXJhbWV0ZXJWYWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmdcbiAgICAgIC8vIGFuIEhUVFAgcXVvdGVkIHN0cmluZyBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvblxuICAgICAgLy8gYW5kIHRoZSBleHRyYWN0LXZhbHVlIGZsYWcuXG4gICAgICBwYXJhbWV0ZXJWYWx1ZSA9IGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcoaW5wdXQsIHBvc2l0aW9uLCB0cnVlKVxuXG4gICAgICAvLyAyLiBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90XG4gICAgICAvLyBVKzAwM0IgKDspIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50c0Zhc3QoXG4gICAgICAgICc7JyxcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHBvc2l0aW9uXG4gICAgICApXG5cbiAgICAvLyA5LiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIFNldCBwYXJhbWV0ZXJWYWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmdcbiAgICAgIC8vIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgbm90IFUrMDAzQiAoOylcbiAgICAgIC8vIGZyb20gaW5wdXQsIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgcGFyYW1ldGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzRmFzdChcbiAgICAgICAgJzsnLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgcG9zaXRpb25cbiAgICAgIClcblxuICAgICAgLy8gMi4gUmVtb3ZlIGFueSB0cmFpbGluZyBIVFRQIHdoaXRlc3BhY2UgZnJvbSBwYXJhbWV0ZXJWYWx1ZS5cbiAgICAgIHBhcmFtZXRlclZhbHVlID0gcmVtb3ZlSFRUUFdoaXRlc3BhY2UocGFyYW1ldGVyVmFsdWUsIGZhbHNlLCB0cnVlKVxuXG4gICAgICAvLyAzLiBJZiBwYXJhbWV0ZXJWYWx1ZSBpcyB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIGNvbnRpbnVlLlxuICAgICAgaWYgKHBhcmFtZXRlclZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEwLiBJZiBhbGwgb2YgdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZVxuICAgIC8vIC0gcGFyYW1ldGVyTmFtZSBpcyBub3QgdGhlIGVtcHR5IHN0cmluZ1xuICAgIC8vIC0gcGFyYW1ldGVyTmFtZSBzb2xlbHkgY29udGFpbnMgSFRUUCB0b2tlbiBjb2RlIHBvaW50c1xuICAgIC8vIC0gcGFyYW1ldGVyVmFsdWUgc29sZWx5IGNvbnRhaW5zIEhUVFAgcXVvdGVkLXN0cmluZyB0b2tlbiBjb2RlIHBvaW50c1xuICAgIC8vIC0gbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbcGFyYW1ldGVyTmFtZV0gZG9lcyBub3QgZXhpc3RcbiAgICAvLyB0aGVuIHNldCBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXSB0byBwYXJhbWV0ZXJWYWx1ZS5cbiAgICBpZiAoXG4gICAgICBwYXJhbWV0ZXJOYW1lLmxlbmd0aCAhPT0gMCAmJlxuICAgICAgSFRUUF9UT0tFTl9DT0RFUE9JTlRTLnRlc3QocGFyYW1ldGVyTmFtZSkgJiZcbiAgICAgIChwYXJhbWV0ZXJWYWx1ZS5sZW5ndGggPT09IDAgfHwgSFRUUF9RVU9URURfU1RSSU5HX1RPS0VOUy50ZXN0KHBhcmFtZXRlclZhbHVlKSkgJiZcbiAgICAgICFtaW1lVHlwZS5wYXJhbWV0ZXJzLmhhcyhwYXJhbWV0ZXJOYW1lKVxuICAgICkge1xuICAgICAgbWltZVR5cGUucGFyYW1ldGVycy5zZXQocGFyYW1ldGVyTmFtZSwgcGFyYW1ldGVyVmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIFJldHVybiBtaW1lVHlwZS5cbiAgcmV0dXJuIG1pbWVUeXBlXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNmb3JnaXZpbmctYmFzZTY0LWRlY29kZVxuLyoqIEBwYXJhbSB7c3RyaW5nfSBkYXRhICovXG5mdW5jdGlvbiBmb3JnaXZpbmdCYXNlNjQgKGRhdGEpIHtcbiAgLy8gMS4gUmVtb3ZlIGFsbCBBU0NJSSB3aGl0ZXNwYWNlIGZyb20gZGF0YS5cbiAgZGF0YSA9IGRhdGEucmVwbGFjZShBU0NJSV9XSElURVNQQUNFX1JFUExBQ0VfUkVHRVgsICcnKSAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGxldCBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGhcbiAgLy8gMi4gSWYgZGF0YeKAmXMgY29kZSBwb2ludCBsZW5ndGggZGl2aWRlcyBieSA0IGxlYXZpbmdcbiAgLy8gbm8gcmVtYWluZGVyLCB0aGVuOlxuICBpZiAoZGF0YUxlbmd0aCAlIDQgPT09IDApIHtcbiAgICAvLyAxLiBJZiBkYXRhIGVuZHMgd2l0aCBvbmUgb3IgdHdvIFUrMDAzRCAoPSkgY29kZSBwb2ludHMsXG4gICAgLy8gdGhlbiByZW1vdmUgdGhlbSBmcm9tIGRhdGEuXG4gICAgaWYgKGRhdGEuY2hhckNvZGVBdChkYXRhTGVuZ3RoIC0gMSkgPT09IDB4MDAzRCkge1xuICAgICAgLS1kYXRhTGVuZ3RoXG4gICAgICBpZiAoZGF0YS5jaGFyQ29kZUF0KGRhdGFMZW5ndGggLSAxKSA9PT0gMHgwMDNEKSB7XG4gICAgICAgIC0tZGF0YUxlbmd0aFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIElmIGRhdGHigJlzIGNvZGUgcG9pbnQgbGVuZ3RoIGRpdmlkZXMgYnkgNCBsZWF2aW5nXG4gIC8vIGEgcmVtYWluZGVyIG9mIDEsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChkYXRhTGVuZ3RoICUgNCA9PT0gMSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDQuIElmIGRhdGEgY29udGFpbnMgYSBjb2RlIHBvaW50IHRoYXQgaXMgbm90IG9uZSBvZlxuICAvLyAgVSswMDJCICgrKVxuICAvLyAgVSswMDJGICgvKVxuICAvLyAgQVNDSUkgYWxwaGFudW1lcmljXG4gIC8vIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmICgvW14rLzAtOUEtWmEtel0vLnRlc3QoZGF0YS5sZW5ndGggPT09IGRhdGFMZW5ndGggPyBkYXRhIDogZGF0YS5zdWJzdHJpbmcoMCwgZGF0YUxlbmd0aCkpKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oZGF0YSwgJ2Jhc2U2NCcpXG4gIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb2xsZWN0LWFuLWh0dHAtcXVvdGVkLXN0cmluZ1xuLy8gdGVzdHM6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNleGFtcGxlLWh0dHAtcXVvdGVkLXN0cmluZ1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBleHRyYWN0VmFsdWVcbiAqL1xuZnVuY3Rpb24gY29sbGVjdEFuSFRUUFF1b3RlZFN0cmluZyAoaW5wdXQsIHBvc2l0aW9uLCBleHRyYWN0VmFsdWUpIHtcbiAgLy8gMS4gTGV0IHBvc2l0aW9uU3RhcnQgYmUgcG9zaXRpb24uXG4gIGNvbnN0IHBvc2l0aW9uU3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvblxuXG4gIC8vIDIuIExldCB2YWx1ZSBiZSB0aGUgZW1wdHkgc3RyaW5nLlxuICBsZXQgdmFsdWUgPSAnJ1xuXG4gIC8vIDMuIEFzc2VydDogdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGlucHV0XG4gIC8vIGlzIFUrMDAyMiAoXCIpLlxuICBhc3NlcnQoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dID09PSAnXCInKVxuXG4gIC8vIDQuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgcG9zaXRpb24ucG9zaXRpb24rK1xuXG4gIC8vIDUuIFdoaWxlIHRydWU6XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gMS4gQXBwZW5kIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGNvZGUgcG9pbnRzXG4gICAgLy8gdGhhdCBhcmUgbm90IFUrMDAyMiAoXCIpIG9yIFUrMDA1QyAoXFwpIGZyb20gaW5wdXQsIGdpdmVuXG4gICAgLy8gcG9zaXRpb24sIHRvIHZhbHVlLlxuICAgIHZhbHVlICs9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gJ1wiJyAmJiBjaGFyICE9PSAnXFxcXCcsXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gMi4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGJyZWFrLlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA+PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IHF1b3RlT3JCYWNrc2xhc2ggYmUgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluXG4gICAgLy8gaW5wdXQuXG4gICAgY29uc3QgcXVvdGVPckJhY2tzbGFzaCA9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgLy8gNC4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICAgIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAgIC8vIDUuIElmIHF1b3RlT3JCYWNrc2xhc2ggaXMgVSswMDVDIChcXCksIHRoZW46XG4gICAgaWYgKHF1b3RlT3JCYWNrc2xhc2ggPT09ICdcXFxcJykge1xuICAgICAgLy8gMS4gSWYgcG9zaXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuIGFwcGVuZFxuICAgICAgLy8gVSswMDVDIChcXCkgdG8gdmFsdWUgYW5kIGJyZWFrLlxuICAgICAgaWYgKHBvc2l0aW9uLnBvc2l0aW9uID49IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSArPSAnXFxcXCdcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gQXBwZW5kIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCB0byB2YWx1ZS5cbiAgICAgIHZhbHVlICs9IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXVxuXG4gICAgICAvLyAzLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyA2LiBPdGhlcndpc2U6XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDEuIEFzc2VydDogcXVvdGVPckJhY2tzbGFzaCBpcyBVKzAwMjIgKFwiKS5cbiAgICAgIGFzc2VydChxdW90ZU9yQmFja3NsYXNoID09PSAnXCInKVxuXG4gICAgICAvLyAyLiBCcmVhay5cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgLy8gNi4gSWYgdGhlIGV4dHJhY3QtdmFsdWUgZmxhZyBpcyBzZXQsIHRoZW4gcmV0dXJuIHZhbHVlLlxuICBpZiAoZXh0cmFjdFZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyA3LiBSZXR1cm4gdGhlIGNvZGUgcG9pbnRzIGZyb20gcG9zaXRpb25TdGFydCB0byBwb3NpdGlvbixcbiAgLy8gaW5jbHVzaXZlLCB3aXRoaW4gaW5wdXQuXG4gIHJldHVybiBpbnB1dC5zbGljZShwb3NpdGlvblN0YXJ0LCBwb3NpdGlvbi5wb3NpdGlvbilcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vbWltZXNuaWZmLnNwZWMud2hhdHdnLm9yZy8jc2VyaWFsaXplLWEtbWltZS10eXBlXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUFNaW1lVHlwZSAobWltZVR5cGUpIHtcbiAgYXNzZXJ0KG1pbWVUeXBlICE9PSAnZmFpbHVyZScpXG4gIGNvbnN0IHsgcGFyYW1ldGVycywgZXNzZW5jZSB9ID0gbWltZVR5cGVcblxuICAvLyAxLiBMZXQgc2VyaWFsaXphdGlvbiBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBtaW1lVHlwZeKAmXNcbiAgLy8gICAgdHlwZSwgVSswMDJGICgvKSwgYW5kIG1pbWVUeXBl4oCZcyBzdWJ0eXBlLlxuICBsZXQgc2VyaWFsaXphdGlvbiA9IGVzc2VuY2VcblxuICAvLyAyLiBGb3IgZWFjaCBuYW1lIOKGkiB2YWx1ZSBvZiBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyczpcbiAgZm9yIChsZXQgW25hbWUsIHZhbHVlXSBvZiBwYXJhbWV0ZXJzLmVudHJpZXMoKSkge1xuICAgIC8vIDEuIEFwcGVuZCBVKzAwM0IgKDspIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSAnOydcblxuICAgIC8vIDIuIEFwcGVuZCBuYW1lIHRvIHNlcmlhbGl6YXRpb24uXG4gICAgc2VyaWFsaXphdGlvbiArPSBuYW1lXG5cbiAgICAvLyAzLiBBcHBlbmQgVSswMDNEICg9KSB0byBzZXJpYWxpemF0aW9uLlxuICAgIHNlcmlhbGl6YXRpb24gKz0gJz0nXG5cbiAgICAvLyA0LiBJZiB2YWx1ZSBkb2VzIG5vdCBzb2xlbHkgY29udGFpbiBIVFRQIHRva2VuIGNvZGVcbiAgICAvLyAgICBwb2ludHMgb3IgdmFsdWUgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbjpcbiAgICBpZiAoIUhUVFBfVE9LRU5fQ09ERVBPSU5UUy50ZXN0KHZhbHVlKSkge1xuICAgICAgLy8gMS4gUHJlY2VkZSBlYWNoIG9jY3VycmVuY2Ugb2YgVSswMDIyIChcIikgb3JcbiAgICAgIC8vICAgIFUrMDA1QyAoXFwpIGluIHZhbHVlIHdpdGggVSswMDVDIChcXCkuXG4gICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXFxcfFwiKS9nLCAnXFxcXCQxJylcblxuICAgICAgLy8gMi4gUHJlcGVuZCBVKzAwMjIgKFwiKSB0byB2YWx1ZS5cbiAgICAgIHZhbHVlID0gJ1wiJyArIHZhbHVlXG5cbiAgICAgIC8vIDMuIEFwcGVuZCBVKzAwMjIgKFwiKSB0byB2YWx1ZS5cbiAgICAgIHZhbHVlICs9ICdcIidcbiAgICB9XG5cbiAgICAvLyA1LiBBcHBlbmQgdmFsdWUgdG8gc2VyaWFsaXphdGlvbi5cbiAgICBzZXJpYWxpemF0aW9uICs9IHZhbHVlXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gc2VyaWFsaXphdGlvbi5cbiAgcmV0dXJuIHNlcmlhbGl6YXRpb25cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzSFRUUFdoaXRlU3BhY2UgKGNoYXIpIHtcbiAgLy8gXCJcXHJcXG5cXHQgXCJcbiAgcmV0dXJuIGNoYXIgPT09IDB4MDBkIHx8IGNoYXIgPT09IDB4MDBhIHx8IGNoYXIgPT09IDB4MDA5IHx8IGNoYXIgPT09IDB4MDIwXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC13aGl0ZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtsZWFkaW5nPXRydWVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0cmFpbGluZz10cnVlXVxuICovXG5mdW5jdGlvbiByZW1vdmVIVFRQV2hpdGVzcGFjZSAoc3RyLCBsZWFkaW5nID0gdHJ1ZSwgdHJhaWxpbmcgPSB0cnVlKSB7XG4gIHJldHVybiByZW1vdmVDaGFycyhzdHIsIGxlYWRpbmcsIHRyYWlsaW5nLCBpc0hUVFBXaGl0ZVNwYWNlKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI2FzY2lpLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFyXG4gKi9cbmZ1bmN0aW9uIGlzQVNDSUlXaGl0ZXNwYWNlIChjaGFyKSB7XG4gIC8vIFwiXFxyXFxuXFx0XFxmIFwiXG4gIHJldHVybiBjaGFyID09PSAweDAwZCB8fCBjaGFyID09PSAweDAwYSB8fCBjaGFyID09PSAweDAwOSB8fCBjaGFyID09PSAweDAwYyB8fCBjaGFyID09PSAweDAyMFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWxlYWRpbmctYW5kLXRyYWlsaW5nLWFzY2lpLXdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2xlYWRpbmc9dHJ1ZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3RyYWlsaW5nPXRydWVdXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUFTQ0lJV2hpdGVzcGFjZSAoc3RyLCBsZWFkaW5nID0gdHJ1ZSwgdHJhaWxpbmcgPSB0cnVlKSB7XG4gIHJldHVybiByZW1vdmVDaGFycyhzdHIsIGxlYWRpbmcsIHRyYWlsaW5nLCBpc0FTQ0lJV2hpdGVzcGFjZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxlYWRpbmdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJhaWxpbmdcbiAqIEBwYXJhbSB7KGNoYXJDb2RlOiBudW1iZXIpID0+IGJvb2xlYW59IHByZWRpY2F0ZVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2hhcnMgKHN0ciwgbGVhZGluZywgdHJhaWxpbmcsIHByZWRpY2F0ZSkge1xuICBsZXQgbGVhZCA9IDBcbiAgbGV0IHRyYWlsID0gc3RyLmxlbmd0aCAtIDFcblxuICBpZiAobGVhZGluZykge1xuICAgIHdoaWxlIChsZWFkIDwgc3RyLmxlbmd0aCAmJiBwcmVkaWNhdGUoc3RyLmNoYXJDb2RlQXQobGVhZCkpKSBsZWFkKytcbiAgfVxuXG4gIGlmICh0cmFpbGluZykge1xuICAgIHdoaWxlICh0cmFpbCA+IDAgJiYgcHJlZGljYXRlKHN0ci5jaGFyQ29kZUF0KHRyYWlsKSkpIHRyYWlsLS1cbiAgfVxuXG4gIHJldHVybiBsZWFkID09PSAwICYmIHRyYWlsID09PSBzdHIubGVuZ3RoIC0gMSA/IHN0ciA6IHN0ci5zbGljZShsZWFkLCB0cmFpbCArIDEpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jaXNvbW9ycGhpYy1kZWNvZGVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGlzb21vcnBoaWNEZWNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIFRvIGlzb21vcnBoaWMgZGVjb2RlIGEgYnl0ZSBzZXF1ZW5jZSBpbnB1dCwgcmV0dXJuIGEgc3RyaW5nIHdob3NlIGNvZGUgcG9pbnRcbiAgLy8gICAgbGVuZ3RoIGlzIGVxdWFsIHRvIGlucHV04oCZcyBsZW5ndGggYW5kIHdob3NlIGNvZGUgcG9pbnRzIGhhdmUgdGhlIHNhbWUgdmFsdWVzXG4gIC8vICAgIGFzIHRoZSB2YWx1ZXMgb2YgaW5wdXTigJlzIGJ5dGVzLCBpbiB0aGUgc2FtZSBvcmRlci5cbiAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoXG4gIGlmICgoMiA8PCAxNSkgLSAxID4gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaW5wdXQpXG4gIH1cbiAgbGV0IHJlc3VsdCA9ICcnOyBsZXQgaSA9IDBcbiAgbGV0IGFkZGl0aW9uID0gKDIgPDwgMTUpIC0gMVxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgIGlmIChpICsgYWRkaXRpb24gPiBsZW5ndGgpIHtcbiAgICAgIGFkZGl0aW9uID0gbGVuZ3RoIC0gaVxuICAgIH1cbiAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBpbnB1dC5zdWJhcnJheShpLCBpICs9IGFkZGl0aW9uKSlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL21pbWVzbmlmZi5zcGVjLndoYXR3Zy5vcmcvI21pbmltaXplLWEtc3VwcG9ydGVkLW1pbWUtdHlwZVxuICogQHBhcmFtIHtFeGNsdWRlPFJldHVyblR5cGU8dHlwZW9mIHBhcnNlTUlNRVR5cGU+LCAnZmFpbHVyZSc+fSBtaW1lVHlwZVxuICovXG5mdW5jdGlvbiBtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlIChtaW1lVHlwZSkge1xuICBzd2l0Y2ggKG1pbWVUeXBlLmVzc2VuY2UpIHtcbiAgICBjYXNlICdhcHBsaWNhdGlvbi9lY21hc2NyaXB0JzpcbiAgICBjYXNlICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JzpcbiAgICBjYXNlICdhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHQnOlxuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC9lY21hc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQnOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuMCc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS4xJzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjInOlxuICAgIGNhc2UgJ3RleHQvamF2YXNjcmlwdDEuMyc6XG4gICAgY2FzZSAndGV4dC9qYXZhc2NyaXB0MS40JzpcbiAgICBjYXNlICd0ZXh0L2phdmFzY3JpcHQxLjUnOlxuICAgIGNhc2UgJ3RleHQvanNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC9saXZlc2NyaXB0JzpcbiAgICBjYXNlICd0ZXh0L3gtZWNtYXNjcmlwdCc6XG4gICAgY2FzZSAndGV4dC94LWphdmFzY3JpcHQnOlxuICAgICAgLy8gMS4gSWYgbWltZVR5cGUgaXMgYSBKYXZhU2NyaXB0IE1JTUUgdHlwZSwgdGhlbiByZXR1cm4gXCJ0ZXh0L2phdmFzY3JpcHRcIi5cbiAgICAgIHJldHVybiAndGV4dC9qYXZhc2NyaXB0J1xuICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2pzb24nOlxuICAgIGNhc2UgJ3RleHQvanNvbic6XG4gICAgICAvLyAyLiBJZiBtaW1lVHlwZSBpcyBhIEpTT04gTUlNRSB0eXBlLCB0aGVuIHJldHVybiBcImFwcGxpY2F0aW9uL2pzb25cIi5cbiAgICAgIHJldHVybiAnYXBwbGljYXRpb24vanNvbidcbiAgICBjYXNlICdpbWFnZS9zdmcreG1sJzpcbiAgICAgIC8vIDMuIElmIG1pbWVUeXBl4oCZcyBlc3NlbmNlIGlzIFwiaW1hZ2Uvc3ZnK3htbFwiLCB0aGVuIHJldHVybiBcImltYWdlL3N2Zyt4bWxcIi5cbiAgICAgIHJldHVybiAnaW1hZ2Uvc3ZnK3htbCdcbiAgICBjYXNlICd0ZXh0L3htbCc6XG4gICAgY2FzZSAnYXBwbGljYXRpb24veG1sJzpcbiAgICAgIC8vIDQuIElmIG1pbWVUeXBlIGlzIGFuIFhNTCBNSU1FIHR5cGUsIHRoZW4gcmV0dXJuIFwiYXBwbGljYXRpb24veG1sXCIuXG4gICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3htbCdcbiAgfVxuXG4gIC8vIDIuIElmIG1pbWVUeXBlIGlzIGEgSlNPTiBNSU1FIHR5cGUsIHRoZW4gcmV0dXJuIFwiYXBwbGljYXRpb24vanNvblwiLlxuICBpZiAobWltZVR5cGUuc3VidHlwZS5lbmRzV2l0aCgnK2pzb24nKSkge1xuICAgIHJldHVybiAnYXBwbGljYXRpb24vanNvbidcbiAgfVxuXG4gIC8vIDQuIElmIG1pbWVUeXBlIGlzIGFuIFhNTCBNSU1FIHR5cGUsIHRoZW4gcmV0dXJuIFwiYXBwbGljYXRpb24veG1sXCIuXG4gIGlmIChtaW1lVHlwZS5zdWJ0eXBlLmVuZHNXaXRoKCcreG1sJykpIHtcbiAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3htbCdcbiAgfVxuXG4gIC8vIDUuIElmIG1pbWVUeXBlIGlzIHN1cHBvcnRlZCBieSB0aGUgdXNlciBhZ2VudCwgdGhlbiByZXR1cm4gbWltZVR5cGXigJlzIGVzc2VuY2UuXG4gIC8vIFRlY2huaWNhbGx5LCBub2RlIGRvZXNuJ3Qgc3VwcG9ydCBhbnkgbWltZXR5cGVzLlxuXG4gIC8vIDYuIFJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICByZXR1cm4gJydcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRhdGFVUkxQcm9jZXNzb3IsXG4gIFVSTFNlcmlhbGl6ZXIsXG4gIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMsXG4gIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0LFxuICBzdHJpbmdQZXJjZW50RGVjb2RlLFxuICBwYXJzZU1JTUVUeXBlLFxuICBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nLFxuICBzZXJpYWxpemVBTWltZVR5cGUsXG4gIHJlbW92ZUNoYXJzLFxuICByZW1vdmVIVFRQV2hpdGVzcGFjZSxcbiAgbWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZSxcbiAgSFRUUF9UT0tFTl9DT0RFUE9JTlRTLFxuICBpc29tb3JwaGljRGVjb2RlXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js":
/*!*****************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/dispatcher-weakref.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kConnected, kSize } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\n\nclass CompatWeakRef {\n  constructor (value) {\n    this.value = value\n  }\n\n  deref () {\n    return this.value[kConnected] === 0 && this.value[kSize] === 0\n      ? undefined\n      : this.value\n  }\n}\n\nclass CompatFinalizer {\n  constructor (finalizer) {\n    this.finalizer = finalizer\n  }\n\n  register (dispatcher, key) {\n    if (dispatcher.on) {\n      dispatcher.on('disconnect', () => {\n        if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n          this.finalizer(key)\n        }\n      })\n    }\n  }\n\n  unregister (key) {}\n}\n\nmodule.exports = function () {\n  // FIXME: remove workaround when the Node bug is backported to v18\n  // https://github.com/nodejs/node/issues/49344#issuecomment-1741776308\n  if (process.env.NODE_V8_COVERAGE && process.version.startsWith('v18')) {\n    process._rawDebug('Using compatibility WeakRef and FinalizationRegistry')\n    return {\n      WeakRef: CompatWeakRef,\n      FinalizationRegistry: CompatFinalizer\n    }\n  }\n  return { WeakRef, FinalizationRegistry }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZGlzcGF0Y2hlci13ZWFrcmVmLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQywyRUFBb0I7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGRpc3BhdGNoZXItd2Vha3JlZi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ29ubmVjdGVkLCBrU2l6ZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcblxuY2xhc3MgQ29tcGF0V2Vha1JlZiB7XG4gIGNvbnN0cnVjdG9yICh2YWx1ZSkge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgZGVyZWYgKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlW2tDb25uZWN0ZWRdID09PSAwICYmIHRoaXMudmFsdWVba1NpemVdID09PSAwXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiB0aGlzLnZhbHVlXG4gIH1cbn1cblxuY2xhc3MgQ29tcGF0RmluYWxpemVyIHtcbiAgY29uc3RydWN0b3IgKGZpbmFsaXplcikge1xuICAgIHRoaXMuZmluYWxpemVyID0gZmluYWxpemVyXG4gIH1cblxuICByZWdpc3RlciAoZGlzcGF0Y2hlciwga2V5KSB7XG4gICAgaWYgKGRpc3BhdGNoZXIub24pIHtcbiAgICAgIGRpc3BhdGNoZXIub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICAgIGlmIChkaXNwYXRjaGVyW2tDb25uZWN0ZWRdID09PSAwICYmIGRpc3BhdGNoZXJba1NpemVdID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5maW5hbGl6ZXIoa2V5KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHVucmVnaXN0ZXIgKGtleSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIEZJWE1FOiByZW1vdmUgd29ya2Fyb3VuZCB3aGVuIHRoZSBOb2RlIGJ1ZyBpcyBiYWNrcG9ydGVkIHRvIHYxOFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzQ5MzQ0I2lzc3VlY29tbWVudC0xNzQxNzc2MzA4XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX1Y4X0NPVkVSQUdFICYmIHByb2Nlc3MudmVyc2lvbi5zdGFydHNXaXRoKCd2MTgnKSkge1xuICAgIHByb2Nlc3MuX3Jhd0RlYnVnKCdVc2luZyBjb21wYXRpYmlsaXR5IFdlYWtSZWYgYW5kIEZpbmFsaXphdGlvblJlZ2lzdHJ5JylcbiAgICByZXR1cm4ge1xuICAgICAgV2Vha1JlZjogQ29tcGF0V2Vha1JlZixcbiAgICAgIEZpbmFsaXphdGlvblJlZ2lzdHJ5OiBDb21wYXRGaW5hbGl6ZXJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgV2Vha1JlZiwgRmluYWxpemF0aW9uUmVnaXN0cnkgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/file.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/file.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Blob, File } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\n\n// TODO(@KhafraDev): remove\nclass FileLike {\n  constructor (blobLike, fileName, options = {}) {\n    // TODO: argument idl type check\n\n    // The File constructor is invoked with two or three parameters, depending\n    // on whether the optional dictionary parameter is used. When the File()\n    // constructor is invoked, user agents must run the following steps:\n\n    // 1. Let bytes be the result of processing blob parts given fileBits and\n    // options.\n\n    // 2. Let n be the fileName argument to the constructor.\n    const n = fileName\n\n    // 3. Process FilePropertyBag dictionary argument by running the following\n    // substeps:\n\n    //    1. If the type member is provided and is not the empty string, let t\n    //    be set to the type dictionary member. If t contains any characters\n    //    outside the range U+0020 to U+007E, then set t to the empty string\n    //    and return from these substeps.\n    //    TODO\n    const t = options.type\n\n    //    2. Convert every character in t to ASCII lowercase.\n    //    TODO\n\n    //    3. If the lastModified member is provided, let d be set to the\n    //    lastModified dictionary member. If it is not provided, set d to the\n    //    current date and time represented as the number of milliseconds since\n    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n    const d = options.lastModified ?? Date.now()\n\n    // 4. Return a new File object F such that:\n    // F refers to the bytes byte sequence.\n    // F.size is set to the number of total bytes in bytes.\n    // F.name is set to n.\n    // F.type is set to t.\n    // F.lastModified is set to d.\n\n    this[kState] = {\n      blobLike,\n      name: n,\n      type: t,\n      lastModified: d\n    }\n  }\n\n  stream (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.stream(...args)\n  }\n\n  arrayBuffer (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.arrayBuffer(...args)\n  }\n\n  slice (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.slice(...args)\n  }\n\n  text (...args) {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.text(...args)\n  }\n\n  get size () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.size\n  }\n\n  get type () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].blobLike.type\n  }\n\n  get name () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].name\n  }\n\n  get lastModified () {\n    webidl.brandCheck(this, FileLike)\n\n    return this[kState].lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'File'\n  }\n}\n\nwebidl.converters.Blob = webidl.interfaceConverter(Blob)\n\n// If this function is moved to ./util.js, some tools (such as\n// rollup) will warn about circular dependencies. See:\n// https://github.com/nodejs/undici/issues/1629\nfunction isFileLike (object) {\n  return (\n    (object instanceof File) ||\n    (\n      object &&\n      (typeof object.stream === 'function' ||\n      typeof object.arrayBuffer === 'function') &&\n      object[Symbol.toStringTag] === 'File'\n    )\n  )\n}\n\nmodule.exports = { FileLike, isFileLike }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZmlsZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzVDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsdUVBQVc7QUFDdEMsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxRUFBVTs7QUFFckM7QUFDQTtBQUNBLCtDQUErQztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxmaWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJsb2IsIEZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcbmNvbnN0IHsga1N0YXRlIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcblxuLy8gVE9ETyhAS2hhZnJhRGV2KTogcmVtb3ZlXG5jbGFzcyBGaWxlTGlrZSB7XG4gIGNvbnN0cnVjdG9yIChibG9iTGlrZSwgZmlsZU5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIC8vIFRPRE86IGFyZ3VtZW50IGlkbCB0eXBlIGNoZWNrXG5cbiAgICAvLyBUaGUgRmlsZSBjb25zdHJ1Y3RvciBpcyBpbnZva2VkIHdpdGggdHdvIG9yIHRocmVlIHBhcmFtZXRlcnMsIGRlcGVuZGluZ1xuICAgIC8vIG9uIHdoZXRoZXIgdGhlIG9wdGlvbmFsIGRpY3Rpb25hcnkgcGFyYW1ldGVyIGlzIHVzZWQuIFdoZW4gdGhlIEZpbGUoKVxuICAgIC8vIGNvbnN0cnVjdG9yIGlzIGludm9rZWQsIHVzZXIgYWdlbnRzIG11c3QgcnVuIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG5cbiAgICAvLyAxLiBMZXQgYnl0ZXMgYmUgdGhlIHJlc3VsdCBvZiBwcm9jZXNzaW5nIGJsb2IgcGFydHMgZ2l2ZW4gZmlsZUJpdHMgYW5kXG4gICAgLy8gb3B0aW9ucy5cblxuICAgIC8vIDIuIExldCBuIGJlIHRoZSBmaWxlTmFtZSBhcmd1bWVudCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgY29uc3QgbiA9IGZpbGVOYW1lXG5cbiAgICAvLyAzLiBQcm9jZXNzIEZpbGVQcm9wZXJ0eUJhZyBkaWN0aW9uYXJ5IGFyZ3VtZW50IGJ5IHJ1bm5pbmcgdGhlIGZvbGxvd2luZ1xuICAgIC8vIHN1YnN0ZXBzOlxuXG4gICAgLy8gICAgMS4gSWYgdGhlIHR5cGUgbWVtYmVyIGlzIHByb3ZpZGVkIGFuZCBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IHRcbiAgICAvLyAgICBiZSBzZXQgdG8gdGhlIHR5cGUgZGljdGlvbmFyeSBtZW1iZXIuIElmIHQgY29udGFpbnMgYW55IGNoYXJhY3RlcnNcbiAgICAvLyAgICBvdXRzaWRlIHRoZSByYW5nZSBVKzAwMjAgdG8gVSswMDdFLCB0aGVuIHNldCB0IHRvIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAvLyAgICBhbmQgcmV0dXJuIGZyb20gdGhlc2Ugc3Vic3RlcHMuXG4gICAgLy8gICAgVE9ET1xuICAgIGNvbnN0IHQgPSBvcHRpb25zLnR5cGVcblxuICAgIC8vICAgIDIuIENvbnZlcnQgZXZlcnkgY2hhcmFjdGVyIGluIHQgdG8gQVNDSUkgbG93ZXJjYXNlLlxuICAgIC8vICAgIFRPRE9cblxuICAgIC8vICAgIDMuIElmIHRoZSBsYXN0TW9kaWZpZWQgbWVtYmVyIGlzIHByb3ZpZGVkLCBsZXQgZCBiZSBzZXQgdG8gdGhlXG4gICAgLy8gICAgbGFzdE1vZGlmaWVkIGRpY3Rpb25hcnkgbWVtYmVyLiBJZiBpdCBpcyBub3QgcHJvdmlkZWQsIHNldCBkIHRvIHRoZVxuICAgIC8vICAgIGN1cnJlbnQgZGF0ZSBhbmQgdGltZSByZXByZXNlbnRlZCBhcyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBzaW5jZVxuICAgIC8vICAgIHRoZSBVbml4IEVwb2NoICh3aGljaCBpcyB0aGUgZXF1aXZhbGVudCBvZiBEYXRlLm5vdygpIFtFQ01BLTI2Ml0pLlxuICAgIGNvbnN0IGQgPSBvcHRpb25zLmxhc3RNb2RpZmllZCA/PyBEYXRlLm5vdygpXG5cbiAgICAvLyA0LiBSZXR1cm4gYSBuZXcgRmlsZSBvYmplY3QgRiBzdWNoIHRoYXQ6XG4gICAgLy8gRiByZWZlcnMgdG8gdGhlIGJ5dGVzIGJ5dGUgc2VxdWVuY2UuXG4gICAgLy8gRi5zaXplIGlzIHNldCB0byB0aGUgbnVtYmVyIG9mIHRvdGFsIGJ5dGVzIGluIGJ5dGVzLlxuICAgIC8vIEYubmFtZSBpcyBzZXQgdG8gbi5cbiAgICAvLyBGLnR5cGUgaXMgc2V0IHRvIHQuXG4gICAgLy8gRi5sYXN0TW9kaWZpZWQgaXMgc2V0IHRvIGQuXG5cbiAgICB0aGlzW2tTdGF0ZV0gPSB7XG4gICAgICBibG9iTGlrZSxcbiAgICAgIG5hbWU6IG4sXG4gICAgICB0eXBlOiB0LFxuICAgICAgbGFzdE1vZGlmaWVkOiBkXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtICguLi5hcmdzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnN0cmVhbSguLi5hcmdzKVxuICB9XG5cbiAgYXJyYXlCdWZmZXIgKC4uLmFyZ3MpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2UuYXJyYXlCdWZmZXIoLi4uYXJncylcbiAgfVxuXG4gIHNsaWNlICguLi5hcmdzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnNsaWNlKC4uLmFyZ3MpXG4gIH1cblxuICB0ZXh0ICguLi5hcmdzKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmJsb2JMaWtlLnRleHQoLi4uYXJncylcbiAgfVxuXG4gIGdldCBzaXplICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlTGlrZSlcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYmxvYkxpa2Uuc2l6ZVxuICB9XG5cbiAgZ2V0IHR5cGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ibG9iTGlrZS50eXBlXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZUxpa2UpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLm5hbWVcbiAgfVxuXG4gIGdldCBsYXN0TW9kaWZpZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVMaWtlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5sYXN0TW9kaWZpZWRcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSAoKSB7XG4gICAgcmV0dXJuICdGaWxlJ1xuICB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLkJsb2IgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKEJsb2IpXG5cbi8vIElmIHRoaXMgZnVuY3Rpb24gaXMgbW92ZWQgdG8gLi91dGlsLmpzLCBzb21lIHRvb2xzIChzdWNoIGFzXG4vLyByb2xsdXApIHdpbGwgd2FybiBhYm91dCBjaXJjdWxhciBkZXBlbmRlbmNpZXMuIFNlZTpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNjI5XG5mdW5jdGlvbiBpc0ZpbGVMaWtlIChvYmplY3QpIHtcbiAgcmV0dXJuIChcbiAgICAob2JqZWN0IGluc3RhbmNlb2YgRmlsZSkgfHxcbiAgICAoXG4gICAgICBvYmplY3QgJiZcbiAgICAgICh0eXBlb2Ygb2JqZWN0LnN0cmVhbSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgdHlwZW9mIG9iamVjdC5hcnJheUJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykgJiZcbiAgICAgIG9iamVjdFtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnRmlsZSdcbiAgICApXG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEZpbGVMaWtlLCBpc0ZpbGVMaWtlIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/formdata-parser.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata-parser.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isUSVString, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { utf8DecodeBytes } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { HTTP_TOKEN_CODEPOINTS, isomorphicDecode } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { isFileLike } = __webpack_require__(/*! ./file */ \"(rsc)/./node_modules/undici/lib/web/fetch/file.js\")\nconst { makeEntry } = __webpack_require__(/*! ./formdata */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { File: NodeFile } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\nconst File = globalThis.File ?? NodeFile\n\nconst formDataNameBuffer = Buffer.from('form-data; name=\"')\nconst filenameBuffer = Buffer.from('; filename')\nconst dd = Buffer.from('--')\nconst ddcrlf = Buffer.from('--\\r\\n')\n\n/**\n * @param {string} chars\n */\nfunction isAsciiString (chars) {\n  for (let i = 0; i < chars.length; ++i) {\n    if ((chars.charCodeAt(i) & ~0x7F) !== 0) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-boundary\n * @param {string} boundary\n */\nfunction validateBoundary (boundary) {\n  const length = boundary.length\n\n  // - its length is greater or equal to 27 and lesser or equal to 70, and\n  if (length < 27 || length > 70) {\n    return false\n  }\n\n  // - it is composed by bytes in the ranges 0x30 to 0x39, 0x41 to 0x5A, or\n  //   0x61 to 0x7A, inclusive (ASCII alphanumeric), or which are 0x27 ('),\n  //   0x2D (-) or 0x5F (_).\n  for (let i = 0; i < length; ++i) {\n    const cp = boundary.charCodeAt(i)\n\n    if (!(\n      (cp >= 0x30 && cp <= 0x39) ||\n      (cp >= 0x41 && cp <= 0x5a) ||\n      (cp >= 0x61 && cp <= 0x7a) ||\n      cp === 0x27 ||\n      cp === 0x2d ||\n      cp === 0x5f\n    )) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#multipart-form-data-parser\n * @param {Buffer} input\n * @param {ReturnType<import('./data-url')['parseMIMEType']>} mimeType\n */\nfunction multipartFormDataParser (input, mimeType) {\n  // 1. Assert: mimeType’s essence is \"multipart/form-data\".\n  assert(mimeType !== 'failure' && mimeType.essence === 'multipart/form-data')\n\n  const boundaryString = mimeType.parameters.get('boundary')\n\n  // 2. If mimeType’s parameters[\"boundary\"] does not exist, return failure.\n  //    Otherwise, let boundary be the result of UTF-8 decoding mimeType’s\n  //    parameters[\"boundary\"].\n  if (boundaryString === undefined) {\n    return 'failure'\n  }\n\n  const boundary = Buffer.from(`--${boundaryString}`, 'utf8')\n\n  // 3. Let entry list be an empty entry list.\n  const entryList = []\n\n  // 4. Let position be a pointer to a byte in input, initially pointing at\n  //    the first byte.\n  const position = { position: 0 }\n\n  // Note: undici addition, allows leading and trailing CRLFs.\n  while (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n    position.position += 2\n  }\n\n  let trailing = input.length\n\n  while (input[trailing - 1] === 0x0a && input[trailing - 2] === 0x0d) {\n    trailing -= 2\n  }\n\n  if (trailing !== input.length) {\n    input = input.subarray(0, trailing)\n  }\n\n  // 5. While true:\n  while (true) {\n    // 5.1. If position points to a sequence of bytes starting with 0x2D 0x2D\n    //      (`--`) followed by boundary, advance position by 2 + the length of\n    //      boundary. Otherwise, return failure.\n    // Note: boundary is padded with 2 dashes already, no need to add 2.\n    if (input.subarray(position.position, position.position + boundary.length).equals(boundary)) {\n      position.position += boundary.length\n    } else {\n      return 'failure'\n    }\n\n    // 5.2. If position points to the sequence of bytes 0x2D 0x2D 0x0D 0x0A\n    //      (`--` followed by CR LF) followed by the end of input, return entry list.\n    // Note: a body does NOT need to end with CRLF. It can end with --.\n    if (\n      (position.position === input.length - 2 && bufferStartsWith(input, dd, position)) ||\n      (position.position === input.length - 4 && bufferStartsWith(input, ddcrlf, position))\n    ) {\n      return entryList\n    }\n\n    // 5.3. If position does not point to a sequence of bytes starting with 0x0D\n    //      0x0A (CR LF), return failure.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    }\n\n    // 5.4. Advance position by 2. (This skips past the newline.)\n    position.position += 2\n\n    // 5.5. Let name, filename and contentType be the result of parsing\n    //      multipart/form-data headers on input and position, if the result\n    //      is not failure. Otherwise, return failure.\n    const result = parseMultipartFormDataHeaders(input, position)\n\n    if (result === 'failure') {\n      return 'failure'\n    }\n\n    let { name, filename, contentType, encoding } = result\n\n    // 5.6. Advance position by 2. (This skips past the empty line that marks\n    //      the end of the headers.)\n    position.position += 2\n\n    // 5.7. Let body be the empty byte sequence.\n    let body\n\n    // 5.8. Body loop: While position is not past the end of input:\n    // TODO: the steps here are completely wrong\n    {\n      const boundaryIndex = input.indexOf(boundary.subarray(2), position.position)\n\n      if (boundaryIndex === -1) {\n        return 'failure'\n      }\n\n      body = input.subarray(position.position, boundaryIndex - 4)\n\n      position.position += body.length\n\n      // Note: position must be advanced by the body's length before being\n      // decoded, otherwise the parsing will fail.\n      if (encoding === 'base64') {\n        body = Buffer.from(body.toString(), 'base64')\n      }\n    }\n\n    // 5.9. If position does not point to a sequence of bytes starting with\n    //      0x0D 0x0A (CR LF), return failure. Otherwise, advance position by 2.\n    if (input[position.position] !== 0x0d || input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    } else {\n      position.position += 2\n    }\n\n    // 5.10. If filename is not null:\n    let value\n\n    if (filename !== null) {\n      // 5.10.1. If contentType is null, set contentType to \"text/plain\".\n      contentType ??= 'text/plain'\n\n      // 5.10.2. If contentType is not an ASCII string, set contentType to the empty string.\n\n      // Note: `buffer.isAscii` can be used at zero-cost, but converting a string to a buffer is a high overhead.\n      // Content-Type is a relatively small string, so it is faster to use `String#charCodeAt`.\n      if (!isAsciiString(contentType)) {\n        contentType = ''\n      }\n\n      // 5.10.3. Let value be a new File object with name filename, type contentType, and body body.\n      value = new File([body], filename, { type: contentType })\n    } else {\n      // 5.11. Otherwise:\n\n      // 5.11.1. Let value be the UTF-8 decoding without BOM of body.\n      value = utf8DecodeBytes(Buffer.from(body))\n    }\n\n    // 5.12. Assert: name is a scalar value string and value is either a scalar value string or a File object.\n    assert(isUSVString(name))\n    assert((typeof value === 'string' && isUSVString(value)) || isFileLike(value))\n\n    // 5.13. Create an entry with name and value, and append it to entry list.\n    entryList.push(makeEntry(name, value, filename))\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-multipart-form-data-headers\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataHeaders (input, position) {\n  // 1. Let name, filename and contentType be null.\n  let name = null\n  let filename = null\n  let contentType = null\n  let encoding = null\n\n  // 2. While true:\n  while (true) {\n    // 2.1. If position points to a sequence of bytes starting with 0x0D 0x0A (CR LF):\n    if (input[position.position] === 0x0d && input[position.position + 1] === 0x0a) {\n      // 2.1.1. If name is null, return failure.\n      if (name === null) {\n        return 'failure'\n      }\n\n      // 2.1.2. Return name, filename and contentType.\n      return { name, filename, contentType, encoding }\n    }\n\n    // 2.2. Let header name be the result of collecting a sequence of bytes that are\n    //      not 0x0A (LF), 0x0D (CR) or 0x3A (:), given position.\n    let headerName = collectASequenceOfBytes(\n      (char) => char !== 0x0a && char !== 0x0d && char !== 0x3a,\n      input,\n      position\n    )\n\n    // 2.3. Remove any HTTP tab or space bytes from the start or end of header name.\n    headerName = removeChars(headerName, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 2.4. If header name does not match the field-name token production, return failure.\n    if (!HTTP_TOKEN_CODEPOINTS.test(headerName.toString())) {\n      return 'failure'\n    }\n\n    // 2.5. If the byte at position is not 0x3A (:), return failure.\n    if (input[position.position] !== 0x3a) {\n      return 'failure'\n    }\n\n    // 2.6. Advance position by 1.\n    position.position++\n\n    // 2.7. Collect a sequence of bytes that are HTTP tab or space bytes given position.\n    //      (Do nothing with those bytes.)\n    collectASequenceOfBytes(\n      (char) => char === 0x20 || char === 0x09,\n      input,\n      position\n    )\n\n    // 2.8. Byte-lowercase header name and switch on the result:\n    switch (bufferToLowerCasedHeaderName(headerName)) {\n      case 'content-disposition': {\n        // 1. Set name and filename to null.\n        name = filename = null\n\n        // 2. If position does not point to a sequence of bytes starting with\n        //    `form-data; name=\"`, return failure.\n        if (!bufferStartsWith(input, formDataNameBuffer, position)) {\n          return 'failure'\n        }\n\n        // 3. Advance position so it points at the byte after the next 0x22 (\")\n        //    byte (the one in the sequence of bytes matched above).\n        position.position += 17\n\n        // 4. Set name to the result of parsing a multipart/form-data name given\n        //    input and position, if the result is not failure. Otherwise, return\n        //    failure.\n        name = parseMultipartFormDataName(input, position)\n\n        if (name === null) {\n          return 'failure'\n        }\n\n        // 5. If position points to a sequence of bytes starting with `; filename=\"`:\n        if (bufferStartsWith(input, filenameBuffer, position)) {\n          // Note: undici also handles filename*\n          let check = position.position + filenameBuffer.length\n\n          if (input[check] === 0x2a) {\n            position.position += 1\n            check += 1\n          }\n\n          if (input[check] !== 0x3d || input[check + 1] !== 0x22) { // =\"\n            return 'failure'\n          }\n\n          // 1. Advance position so it points at the byte after the next 0x22 (\") byte\n          //    (the one in the sequence of bytes matched above).\n          position.position += 12\n\n          // 2. Set filename to the result of parsing a multipart/form-data name given\n          //    input and position, if the result is not failure. Otherwise, return failure.\n          filename = parseMultipartFormDataName(input, position)\n\n          if (filename === null) {\n            return 'failure'\n          }\n        }\n\n        break\n      }\n      case 'content-type': {\n        // 1. Let header value be the result of collecting a sequence of bytes that are\n        //    not 0x0A (LF) or 0x0D (CR), given position.\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        // 2. Remove any HTTP tab or space bytes from the end of header value.\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        // 3. Set contentType to the isomorphic decoding of header value.\n        contentType = isomorphicDecode(headerValue)\n\n        break\n      }\n      case 'content-transfer-encoding': {\n        let headerValue = collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n\n        headerValue = removeChars(headerValue, false, true, (char) => char === 0x9 || char === 0x20)\n\n        encoding = isomorphicDecode(headerValue)\n\n        break\n      }\n      default: {\n        // Collect a sequence of bytes that are not 0x0A (LF) or 0x0D (CR), given position.\n        // (Do nothing with those bytes.)\n        collectASequenceOfBytes(\n          (char) => char !== 0x0a && char !== 0x0d,\n          input,\n          position\n        )\n      }\n    }\n\n    // 2.9. If position does not point to a sequence of bytes starting with 0x0D 0x0A\n    //      (CR LF), return failure. Otherwise, advance position by 2 (past the newline).\n    if (input[position.position] !== 0x0d && input[position.position + 1] !== 0x0a) {\n      return 'failure'\n    } else {\n      position.position += 2\n    }\n  }\n}\n\n/**\n * @see https://andreubotella.github.io/multipart-form-data/#parse-a-multipart-form-data-name\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction parseMultipartFormDataName (input, position) {\n  // 1. Assert: The byte at (position - 1) is 0x22 (\").\n  assert(input[position.position - 1] === 0x22)\n\n  // 2. Let name be the result of collecting a sequence of bytes that are not 0x0A (LF), 0x0D (CR) or 0x22 (\"), given position.\n  /** @type {string | Buffer} */\n  let name = collectASequenceOfBytes(\n    (char) => char !== 0x0a && char !== 0x0d && char !== 0x22,\n    input,\n    position\n  )\n\n  // 3. If the byte at position is not 0x22 (\"), return failure. Otherwise, advance position by 1.\n  if (input[position.position] !== 0x22) {\n    return null // name could be 'failure'\n  } else {\n    position.position++\n  }\n\n  // 4. Replace any occurrence of the following subsequences in name with the given byte:\n  // - `%0A`: 0x0A (LF)\n  // - `%0D`: 0x0D (CR)\n  // - `%22`: 0x22 (\")\n  name = new TextDecoder().decode(name)\n    .replace(/%0A/ig, '\\n')\n    .replace(/%0D/ig, '\\r')\n    .replace(/%22/g, '\"')\n\n  // 5. Return the UTF-8 decoding without BOM of name.\n  return name\n}\n\n/**\n * @param {(char: number) => boolean} condition\n * @param {Buffer} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfBytes (condition, input, position) {\n  let start = position.position\n\n  while (start < input.length && condition(input[start])) {\n    ++start\n  }\n\n  return input.subarray(position.position, (position.position = start))\n}\n\n/**\n * @param {Buffer} buf\n * @param {boolean} leading\n * @param {boolean} trailing\n * @param {(charCode: number) => boolean} predicate\n * @returns {Buffer}\n */\nfunction removeChars (buf, leading, trailing, predicate) {\n  let lead = 0\n  let trail = buf.length - 1\n\n  if (leading) {\n    while (lead < buf.length && predicate(buf[lead])) lead++\n  }\n\n  if (trailing) {\n    while (trail > 0 && predicate(buf[trail])) trail--\n  }\n\n  return lead === 0 && trail === buf.length - 1 ? buf : buf.subarray(lead, trail + 1)\n}\n\n/**\n * Checks if {@param buffer} starts with {@param start}\n * @param {Buffer} buffer\n * @param {Buffer} start\n * @param {{ position: number }} position\n */\nfunction bufferStartsWith (buffer, start, position) {\n  if (buffer.length < start.length) {\n    return false\n  }\n\n  for (let i = 0; i < start.length; i++) {\n    if (start[i] !== buffer[position.position + i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nmodule.exports = {\n  multipartFormDataParser,\n  validateBoundary\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEtcGFyc2VyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsNENBQTRDLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDL0UsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQzVDLFFBQVEsMENBQTBDLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUN4RSxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3ZDLFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTs7QUFFaEQ7O0FBRUEsbURBQW1EO0FBQ25ELHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLG1EQUFtRDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLGVBQWU7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxmb3JtZGF0YS1wYXJzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaXNVU1ZTdHJpbmcsIGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IHV0ZjhEZWNvZGVCeXRlcyB9ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgSFRUUF9UT0tFTl9DT0RFUE9JTlRTLCBpc29tb3JwaGljRGVjb2RlIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsgaXNGaWxlTGlrZSB9ID0gcmVxdWlyZSgnLi9maWxlJylcbmNvbnN0IHsgbWFrZUVudHJ5IH0gPSByZXF1aXJlKCcuL2Zvcm1kYXRhJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgRmlsZTogTm9kZUZpbGUgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxuY29uc3QgRmlsZSA9IGdsb2JhbFRoaXMuRmlsZSA/PyBOb2RlRmlsZVxuXG5jb25zdCBmb3JtRGF0YU5hbWVCdWZmZXIgPSBCdWZmZXIuZnJvbSgnZm9ybS1kYXRhOyBuYW1lPVwiJylcbmNvbnN0IGZpbGVuYW1lQnVmZmVyID0gQnVmZmVyLmZyb20oJzsgZmlsZW5hbWUnKVxuY29uc3QgZGQgPSBCdWZmZXIuZnJvbSgnLS0nKVxuY29uc3QgZGRjcmxmID0gQnVmZmVyLmZyb20oJy0tXFxyXFxuJylcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhcnNcbiAqL1xuZnVuY3Rpb24gaXNBc2NpaVN0cmluZyAoY2hhcnMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7ICsraSkge1xuICAgIGlmICgoY2hhcnMuY2hhckNvZGVBdChpKSAmIH4weDdGKSAhPT0gMCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2FuZHJldWJvdGVsbGEuZ2l0aHViLmlvL211bHRpcGFydC1mb3JtLWRhdGEvI211bHRpcGFydC1mb3JtLWRhdGEtYm91bmRhcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUJvdW5kYXJ5IChib3VuZGFyeSkge1xuICBjb25zdCBsZW5ndGggPSBib3VuZGFyeS5sZW5ndGhcblxuICAvLyAtIGl0cyBsZW5ndGggaXMgZ3JlYXRlciBvciBlcXVhbCB0byAyNyBhbmQgbGVzc2VyIG9yIGVxdWFsIHRvIDcwLCBhbmRcbiAgaWYgKGxlbmd0aCA8IDI3IHx8IGxlbmd0aCA+IDcwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyAtIGl0IGlzIGNvbXBvc2VkIGJ5IGJ5dGVzIGluIHRoZSByYW5nZXMgMHgzMCB0byAweDM5LCAweDQxIHRvIDB4NUEsIG9yXG4gIC8vICAgMHg2MSB0byAweDdBLCBpbmNsdXNpdmUgKEFTQ0lJIGFscGhhbnVtZXJpYyksIG9yIHdoaWNoIGFyZSAweDI3ICgnKSxcbiAgLy8gICAweDJEICgtKSBvciAweDVGIChfKS5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGNwID0gYm91bmRhcnkuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKCEoXG4gICAgICAoY3AgPj0gMHgzMCAmJiBjcCA8PSAweDM5KSB8fFxuICAgICAgKGNwID49IDB4NDEgJiYgY3AgPD0gMHg1YSkgfHxcbiAgICAgIChjcCA+PSAweDYxICYmIGNwIDw9IDB4N2EpIHx8XG4gICAgICBjcCA9PT0gMHgyNyB8fFxuICAgICAgY3AgPT09IDB4MmQgfHxcbiAgICAgIGNwID09PSAweDVmXG4gICAgKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vYW5kcmV1Ym90ZWxsYS5naXRodWIuaW8vbXVsdGlwYXJ0LWZvcm0tZGF0YS8jbXVsdGlwYXJ0LWZvcm0tZGF0YS1wYXJzZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBpbnB1dFxuICogQHBhcmFtIHtSZXR1cm5UeXBlPGltcG9ydCgnLi9kYXRhLXVybCcpWydwYXJzZU1JTUVUeXBlJ10+fSBtaW1lVHlwZVxuICovXG5mdW5jdGlvbiBtdWx0aXBhcnRGb3JtRGF0YVBhcnNlciAoaW5wdXQsIG1pbWVUeXBlKSB7XG4gIC8vIDEuIEFzc2VydDogbWltZVR5cGXigJlzIGVzc2VuY2UgaXMgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIuXG4gIGFzc2VydChtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnICYmIG1pbWVUeXBlLmVzc2VuY2UgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJylcblxuICBjb25zdCBib3VuZGFyeVN0cmluZyA9IG1pbWVUeXBlLnBhcmFtZXRlcnMuZ2V0KCdib3VuZGFyeScpXG5cbiAgLy8gMi4gSWYgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJib3VuZGFyeVwiXSBkb2VzIG5vdCBleGlzdCwgcmV0dXJuIGZhaWx1cmUuXG4gIC8vICAgIE90aGVyd2lzZSwgbGV0IGJvdW5kYXJ5IGJlIHRoZSByZXN1bHQgb2YgVVRGLTggZGVjb2RpbmcgbWltZVR5cGXigJlzXG4gIC8vICAgIHBhcmFtZXRlcnNbXCJib3VuZGFyeVwiXS5cbiAgaWYgKGJvdW5kYXJ5U3RyaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICBjb25zdCBib3VuZGFyeSA9IEJ1ZmZlci5mcm9tKGAtLSR7Ym91bmRhcnlTdHJpbmd9YCwgJ3V0ZjgnKVxuXG4gIC8vIDMuIExldCBlbnRyeSBsaXN0IGJlIGFuIGVtcHR5IGVudHJ5IGxpc3QuXG4gIGNvbnN0IGVudHJ5TGlzdCA9IFtdXG5cbiAgLy8gNC4gTGV0IHBvc2l0aW9uIGJlIGEgcG9pbnRlciB0byBhIGJ5dGUgaW4gaW5wdXQsIGluaXRpYWxseSBwb2ludGluZyBhdFxuICAvLyAgICB0aGUgZmlyc3QgYnl0ZS5cbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cblxuICAvLyBOb3RlOiB1bmRpY2kgYWRkaXRpb24sIGFsbG93cyBsZWFkaW5nIGFuZCB0cmFpbGluZyBDUkxGcy5cbiAgd2hpbGUgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gMHgwZCAmJiBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiArIDFdID09PSAweDBhKSB7XG4gICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMlxuICB9XG5cbiAgbGV0IHRyYWlsaW5nID0gaW5wdXQubGVuZ3RoXG5cbiAgd2hpbGUgKGlucHV0W3RyYWlsaW5nIC0gMV0gPT09IDB4MGEgJiYgaW5wdXRbdHJhaWxpbmcgLSAyXSA9PT0gMHgwZCkge1xuICAgIHRyYWlsaW5nIC09IDJcbiAgfVxuXG4gIGlmICh0cmFpbGluZyAhPT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgaW5wdXQgPSBpbnB1dC5zdWJhcnJheSgwLCB0cmFpbGluZylcbiAgfVxuXG4gIC8vIDUuIFdoaWxlIHRydWU6XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gNS4xLiBJZiBwb3NpdGlvbiBwb2ludHMgdG8gYSBzZXF1ZW5jZSBvZiBieXRlcyBzdGFydGluZyB3aXRoIDB4MkQgMHgyRFxuICAgIC8vICAgICAgKGAtLWApIGZvbGxvd2VkIGJ5IGJvdW5kYXJ5LCBhZHZhbmNlIHBvc2l0aW9uIGJ5IDIgKyB0aGUgbGVuZ3RoIG9mXG4gICAgLy8gICAgICBib3VuZGFyeS4gT3RoZXJ3aXNlLCByZXR1cm4gZmFpbHVyZS5cbiAgICAvLyBOb3RlOiBib3VuZGFyeSBpcyBwYWRkZWQgd2l0aCAyIGRhc2hlcyBhbHJlYWR5LCBubyBuZWVkIHRvIGFkZCAyLlxuICAgIGlmIChpbnB1dC5zdWJhcnJheShwb3NpdGlvbi5wb3NpdGlvbiwgcG9zaXRpb24ucG9zaXRpb24gKyBib3VuZGFyeS5sZW5ndGgpLmVxdWFscyhib3VuZGFyeSkpIHtcbiAgICAgIHBvc2l0aW9uLnBvc2l0aW9uICs9IGJvdW5kYXJ5Lmxlbmd0aFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfVxuXG4gICAgLy8gNS4yLiBJZiBwb3NpdGlvbiBwb2ludHMgdG8gdGhlIHNlcXVlbmNlIG9mIGJ5dGVzIDB4MkQgMHgyRCAweDBEIDB4MEFcbiAgICAvLyAgICAgIChgLS1gIGZvbGxvd2VkIGJ5IENSIExGKSBmb2xsb3dlZCBieSB0aGUgZW5kIG9mIGlucHV0LCByZXR1cm4gZW50cnkgbGlzdC5cbiAgICAvLyBOb3RlOiBhIGJvZHkgZG9lcyBOT1QgbmVlZCB0byBlbmQgd2l0aCBDUkxGLiBJdCBjYW4gZW5kIHdpdGggLS0uXG4gICAgaWYgKFxuICAgICAgKHBvc2l0aW9uLnBvc2l0aW9uID09PSBpbnB1dC5sZW5ndGggLSAyICYmIGJ1ZmZlclN0YXJ0c1dpdGgoaW5wdXQsIGRkLCBwb3NpdGlvbikpIHx8XG4gICAgICAocG9zaXRpb24ucG9zaXRpb24gPT09IGlucHV0Lmxlbmd0aCAtIDQgJiYgYnVmZmVyU3RhcnRzV2l0aChpbnB1dCwgZGRjcmxmLCBwb3NpdGlvbikpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZW50cnlMaXN0XG4gICAgfVxuXG4gICAgLy8gNS4zLiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgwRFxuICAgIC8vICAgICAgMHgwQSAoQ1IgTEYpLCByZXR1cm4gZmFpbHVyZS5cbiAgICBpZiAoaW5wdXRbcG9zaXRpb24ucG9zaXRpb25dICE9PSAweDBkIHx8IGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uICsgMV0gIT09IDB4MGEpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyA1LjQuIEFkdmFuY2UgcG9zaXRpb24gYnkgMi4gKFRoaXMgc2tpcHMgcGFzdCB0aGUgbmV3bGluZS4pXG4gICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMlxuXG4gICAgLy8gNS41LiBMZXQgbmFtZSwgZmlsZW5hbWUgYW5kIGNvbnRlbnRUeXBlIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZ1xuICAgIC8vICAgICAgbXVsdGlwYXJ0L2Zvcm0tZGF0YSBoZWFkZXJzIG9uIGlucHV0IGFuZCBwb3NpdGlvbiwgaWYgdGhlIHJlc3VsdFxuICAgIC8vICAgICAgaXMgbm90IGZhaWx1cmUuIE90aGVyd2lzZSwgcmV0dXJuIGZhaWx1cmUuXG4gICAgY29uc3QgcmVzdWx0ID0gcGFyc2VNdWx0aXBhcnRGb3JtRGF0YUhlYWRlcnMoaW5wdXQsIHBvc2l0aW9uKVxuXG4gICAgaWYgKHJlc3VsdCA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfVxuXG4gICAgbGV0IHsgbmFtZSwgZmlsZW5hbWUsIGNvbnRlbnRUeXBlLCBlbmNvZGluZyB9ID0gcmVzdWx0XG5cbiAgICAvLyA1LjYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMi4gKFRoaXMgc2tpcHMgcGFzdCB0aGUgZW1wdHkgbGluZSB0aGF0IG1hcmtzXG4gICAgLy8gICAgICB0aGUgZW5kIG9mIHRoZSBoZWFkZXJzLilcbiAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAyXG5cbiAgICAvLyA1LjcuIExldCBib2R5IGJlIHRoZSBlbXB0eSBieXRlIHNlcXVlbmNlLlxuICAgIGxldCBib2R5XG5cbiAgICAvLyA1LjguIEJvZHkgbG9vcDogV2hpbGUgcG9zaXRpb24gaXMgbm90IHBhc3QgdGhlIGVuZCBvZiBpbnB1dDpcbiAgICAvLyBUT0RPOiB0aGUgc3RlcHMgaGVyZSBhcmUgY29tcGxldGVseSB3cm9uZ1xuICAgIHtcbiAgICAgIGNvbnN0IGJvdW5kYXJ5SW5kZXggPSBpbnB1dC5pbmRleE9mKGJvdW5kYXJ5LnN1YmFycmF5KDIpLCBwb3NpdGlvbi5wb3NpdGlvbilcblxuICAgICAgaWYgKGJvdW5kYXJ5SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICAgIH1cblxuICAgICAgYm9keSA9IGlucHV0LnN1YmFycmF5KHBvc2l0aW9uLnBvc2l0aW9uLCBib3VuZGFyeUluZGV4IC0gNClcblxuICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gYm9keS5sZW5ndGhcblxuICAgICAgLy8gTm90ZTogcG9zaXRpb24gbXVzdCBiZSBhZHZhbmNlZCBieSB0aGUgYm9keSdzIGxlbmd0aCBiZWZvcmUgYmVpbmdcbiAgICAgIC8vIGRlY29kZWQsIG90aGVyd2lzZSB0aGUgcGFyc2luZyB3aWxsIGZhaWwuXG4gICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XG4gICAgICAgIGJvZHkgPSBCdWZmZXIuZnJvbShib2R5LnRvU3RyaW5nKCksICdiYXNlNjQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuOS4gSWYgcG9zaXRpb24gZG9lcyBub3QgcG9pbnQgdG8gYSBzZXF1ZW5jZSBvZiBieXRlcyBzdGFydGluZyB3aXRoXG4gICAgLy8gICAgICAweDBEIDB4MEEgKENSIExGKSwgcmV0dXJuIGZhaWx1cmUuIE90aGVyd2lzZSwgYWR2YW5jZSBwb3NpdGlvbiBieSAyLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4MGQgfHwgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSAhPT0gMHgwYSkge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAyXG4gICAgfVxuXG4gICAgLy8gNS4xMC4gSWYgZmlsZW5hbWUgaXMgbm90IG51bGw6XG4gICAgbGV0IHZhbHVlXG5cbiAgICBpZiAoZmlsZW5hbWUgIT09IG51bGwpIHtcbiAgICAgIC8vIDUuMTAuMS4gSWYgY29udGVudFR5cGUgaXMgbnVsbCwgc2V0IGNvbnRlbnRUeXBlIHRvIFwidGV4dC9wbGFpblwiLlxuICAgICAgY29udGVudFR5cGUgPz89ICd0ZXh0L3BsYWluJ1xuXG4gICAgICAvLyA1LjEwLjIuIElmIGNvbnRlbnRUeXBlIGlzIG5vdCBhbiBBU0NJSSBzdHJpbmcsIHNldCBjb250ZW50VHlwZSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgICAvLyBOb3RlOiBgYnVmZmVyLmlzQXNjaWlgIGNhbiBiZSB1c2VkIGF0IHplcm8tY29zdCwgYnV0IGNvbnZlcnRpbmcgYSBzdHJpbmcgdG8gYSBidWZmZXIgaXMgYSBoaWdoIG92ZXJoZWFkLlxuICAgICAgLy8gQ29udGVudC1UeXBlIGlzIGEgcmVsYXRpdmVseSBzbWFsbCBzdHJpbmcsIHNvIGl0IGlzIGZhc3RlciB0byB1c2UgYFN0cmluZyNjaGFyQ29kZUF0YC5cbiAgICAgIGlmICghaXNBc2NpaVN0cmluZyhjb250ZW50VHlwZSkpIHtcbiAgICAgICAgY29udGVudFR5cGUgPSAnJ1xuICAgICAgfVxuXG4gICAgICAvLyA1LjEwLjMuIExldCB2YWx1ZSBiZSBhIG5ldyBGaWxlIG9iamVjdCB3aXRoIG5hbWUgZmlsZW5hbWUsIHR5cGUgY29udGVudFR5cGUsIGFuZCBib2R5IGJvZHkuXG4gICAgICB2YWx1ZSA9IG5ldyBGaWxlKFtib2R5XSwgZmlsZW5hbWUsIHsgdHlwZTogY29udGVudFR5cGUgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gNS4xMS4gT3RoZXJ3aXNlOlxuXG4gICAgICAvLyA1LjExLjEuIExldCB2YWx1ZSBiZSB0aGUgVVRGLTggZGVjb2Rpbmcgd2l0aG91dCBCT00gb2YgYm9keS5cbiAgICAgIHZhbHVlID0gdXRmOERlY29kZUJ5dGVzKEJ1ZmZlci5mcm9tKGJvZHkpKVxuICAgIH1cblxuICAgIC8vIDUuMTIuIEFzc2VydDogbmFtZSBpcyBhIHNjYWxhciB2YWx1ZSBzdHJpbmcgYW5kIHZhbHVlIGlzIGVpdGhlciBhIHNjYWxhciB2YWx1ZSBzdHJpbmcgb3IgYSBGaWxlIG9iamVjdC5cbiAgICBhc3NlcnQoaXNVU1ZTdHJpbmcobmFtZSkpXG4gICAgYXNzZXJ0KCh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIGlzVVNWU3RyaW5nKHZhbHVlKSkgfHwgaXNGaWxlTGlrZSh2YWx1ZSkpXG5cbiAgICAvLyA1LjEzLiBDcmVhdGUgYW4gZW50cnkgd2l0aCBuYW1lIGFuZCB2YWx1ZSwgYW5kIGFwcGVuZCBpdCB0byBlbnRyeSBsaXN0LlxuICAgIGVudHJ5TGlzdC5wdXNoKG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2FuZHJldWJvdGVsbGEuZ2l0aHViLmlvL211bHRpcGFydC1mb3JtLWRhdGEvI3BhcnNlLW11bHRpcGFydC1mb3JtLWRhdGEtaGVhZGVyc1xuICogQHBhcmFtIHtCdWZmZXJ9IGlucHV0XG4gKiBAcGFyYW0ge3sgcG9zaXRpb246IG51bWJlciB9fSBwb3NpdGlvblxuICovXG5mdW5jdGlvbiBwYXJzZU11bHRpcGFydEZvcm1EYXRhSGVhZGVycyAoaW5wdXQsIHBvc2l0aW9uKSB7XG4gIC8vIDEuIExldCBuYW1lLCBmaWxlbmFtZSBhbmQgY29udGVudFR5cGUgYmUgbnVsbC5cbiAgbGV0IG5hbWUgPSBudWxsXG4gIGxldCBmaWxlbmFtZSA9IG51bGxcbiAgbGV0IGNvbnRlbnRUeXBlID0gbnVsbFxuICBsZXQgZW5jb2RpbmcgPSBudWxsXG5cbiAgLy8gMi4gV2hpbGUgdHJ1ZTpcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyAyLjEuIElmIHBvc2l0aW9uIHBvaW50cyB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgwRCAweDBBIChDUiBMRik6XG4gICAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSA9PT0gMHgwZCAmJiBpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiArIDFdID09PSAweDBhKSB7XG4gICAgICAvLyAyLjEuMS4gSWYgbmFtZSBpcyBudWxsLCByZXR1cm4gZmFpbHVyZS5cbiAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICAgIH1cblxuICAgICAgLy8gMi4xLjIuIFJldHVybiBuYW1lLCBmaWxlbmFtZSBhbmQgY29udGVudFR5cGUuXG4gICAgICByZXR1cm4geyBuYW1lLCBmaWxlbmFtZSwgY29udGVudFR5cGUsIGVuY29kaW5nIH1cbiAgICB9XG5cbiAgICAvLyAyLjIuIExldCBoZWFkZXIgbmFtZSBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZVxuICAgIC8vICAgICAgbm90IDB4MEEgKExGKSwgMHgwRCAoQ1IpIG9yIDB4M0EgKDopLCBnaXZlbiBwb3NpdGlvbi5cbiAgICBsZXQgaGVhZGVyTmFtZSA9IGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgIT09IDB4MGEgJiYgY2hhciAhPT0gMHgwZCAmJiBjaGFyICE9PSAweDNhLFxuICAgICAgaW5wdXQsXG4gICAgICBwb3NpdGlvblxuICAgIClcblxuICAgIC8vIDIuMy4gUmVtb3ZlIGFueSBIVFRQIHRhYiBvciBzcGFjZSBieXRlcyBmcm9tIHRoZSBzdGFydCBvciBlbmQgb2YgaGVhZGVyIG5hbWUuXG4gICAgaGVhZGVyTmFtZSA9IHJlbW92ZUNoYXJzKGhlYWRlck5hbWUsIHRydWUsIHRydWUsIChjaGFyKSA9PiBjaGFyID09PSAweDkgfHwgY2hhciA9PT0gMHgyMClcblxuICAgIC8vIDIuNC4gSWYgaGVhZGVyIG5hbWUgZG9lcyBub3QgbWF0Y2ggdGhlIGZpZWxkLW5hbWUgdG9rZW4gcHJvZHVjdGlvbiwgcmV0dXJuIGZhaWx1cmUuXG4gICAgaWYgKCFIVFRQX1RPS0VOX0NPREVQT0lOVFMudGVzdChoZWFkZXJOYW1lLnRvU3RyaW5nKCkpKSB7XG4gICAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gICAgfVxuXG4gICAgLy8gMi41LiBJZiB0aGUgYnl0ZSBhdCBwb3NpdGlvbiBpcyBub3QgMHgzQSAoOiksIHJldHVybiBmYWlsdXJlLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4M2EpIHtcbiAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICB9XG5cbiAgICAvLyAyLjYuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgICAvLyAyLjcuIENvbGxlY3QgYSBzZXF1ZW5jZSBvZiBieXRlcyB0aGF0IGFyZSBIVFRQIHRhYiBvciBzcGFjZSBieXRlcyBnaXZlbiBwb3NpdGlvbi5cbiAgICAvLyAgICAgIChEbyBub3RoaW5nIHdpdGggdGhvc2UgYnl0ZXMuKVxuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09IDB4MjAgfHwgY2hhciA9PT0gMHgwOSxcbiAgICAgIGlucHV0LFxuICAgICAgcG9zaXRpb25cbiAgICApXG5cbiAgICAvLyAyLjguIEJ5dGUtbG93ZXJjYXNlIGhlYWRlciBuYW1lIGFuZCBzd2l0Y2ggb24gdGhlIHJlc3VsdDpcbiAgICBzd2l0Y2ggKGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUoaGVhZGVyTmFtZSkpIHtcbiAgICAgIGNhc2UgJ2NvbnRlbnQtZGlzcG9zaXRpb24nOiB7XG4gICAgICAgIC8vIDEuIFNldCBuYW1lIGFuZCBmaWxlbmFtZSB0byBudWxsLlxuICAgICAgICBuYW1lID0gZmlsZW5hbWUgPSBudWxsXG5cbiAgICAgICAgLy8gMi4gSWYgcG9zaXRpb24gZG9lcyBub3QgcG9pbnQgdG8gYSBzZXF1ZW5jZSBvZiBieXRlcyBzdGFydGluZyB3aXRoXG4gICAgICAgIC8vICAgIGBmb3JtLWRhdGE7IG5hbWU9XCJgLCByZXR1cm4gZmFpbHVyZS5cbiAgICAgICAgaWYgKCFidWZmZXJTdGFydHNXaXRoKGlucHV0LCBmb3JtRGF0YU5hbWVCdWZmZXIsIHBvc2l0aW9uKSkge1xuICAgICAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIEFkdmFuY2UgcG9zaXRpb24gc28gaXQgcG9pbnRzIGF0IHRoZSBieXRlIGFmdGVyIHRoZSBuZXh0IDB4MjIgKFwiKVxuICAgICAgICAvLyAgICBieXRlICh0aGUgb25lIGluIHRoZSBzZXF1ZW5jZSBvZiBieXRlcyBtYXRjaGVkIGFib3ZlKS5cbiAgICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMTdcblxuICAgICAgICAvLyA0LiBTZXQgbmFtZSB0byB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYSBtdWx0aXBhcnQvZm9ybS1kYXRhIG5hbWUgZ2l2ZW5cbiAgICAgICAgLy8gICAgaW5wdXQgYW5kIHBvc2l0aW9uLCBpZiB0aGUgcmVzdWx0IGlzIG5vdCBmYWlsdXJlLiBPdGhlcndpc2UsIHJldHVyblxuICAgICAgICAvLyAgICBmYWlsdXJlLlxuICAgICAgICBuYW1lID0gcGFyc2VNdWx0aXBhcnRGb3JtRGF0YU5hbWUoaW5wdXQsIHBvc2l0aW9uKVxuXG4gICAgICAgIGlmIChuYW1lID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS4gSWYgcG9zaXRpb24gcG9pbnRzIHRvIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgc3RhcnRpbmcgd2l0aCBgOyBmaWxlbmFtZT1cImA6XG4gICAgICAgIGlmIChidWZmZXJTdGFydHNXaXRoKGlucHV0LCBmaWxlbmFtZUJ1ZmZlciwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgLy8gTm90ZTogdW5kaWNpIGFsc28gaGFuZGxlcyBmaWxlbmFtZSpcbiAgICAgICAgICBsZXQgY2hlY2sgPSBwb3NpdGlvbi5wb3NpdGlvbiArIGZpbGVuYW1lQnVmZmVyLmxlbmd0aFxuXG4gICAgICAgICAgaWYgKGlucHV0W2NoZWNrXSA9PT0gMHgyYSkge1xuICAgICAgICAgICAgcG9zaXRpb24ucG9zaXRpb24gKz0gMVxuICAgICAgICAgICAgY2hlY2sgKz0gMVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnB1dFtjaGVja10gIT09IDB4M2QgfHwgaW5wdXRbY2hlY2sgKyAxXSAhPT0gMHgyMikgeyAvLyA9XCJcbiAgICAgICAgICAgIHJldHVybiAnZmFpbHVyZSdcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAxLiBBZHZhbmNlIHBvc2l0aW9uIHNvIGl0IHBvaW50cyBhdCB0aGUgYnl0ZSBhZnRlciB0aGUgbmV4dCAweDIyIChcIikgYnl0ZVxuICAgICAgICAgIC8vICAgICh0aGUgb25lIGluIHRoZSBzZXF1ZW5jZSBvZiBieXRlcyBtYXRjaGVkIGFib3ZlKS5cbiAgICAgICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAxMlxuXG4gICAgICAgICAgLy8gMi4gU2V0IGZpbGVuYW1lIHRvIHRoZSByZXN1bHQgb2YgcGFyc2luZyBhIG11bHRpcGFydC9mb3JtLWRhdGEgbmFtZSBnaXZlblxuICAgICAgICAgIC8vICAgIGlucHV0IGFuZCBwb3NpdGlvbiwgaWYgdGhlIHJlc3VsdCBpcyBub3QgZmFpbHVyZS4gT3RoZXJ3aXNlLCByZXR1cm4gZmFpbHVyZS5cbiAgICAgICAgICBmaWxlbmFtZSA9IHBhcnNlTXVsdGlwYXJ0Rm9ybURhdGFOYW1lKGlucHV0LCBwb3NpdGlvbilcblxuICAgICAgICAgIGlmIChmaWxlbmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdjb250ZW50LXR5cGUnOiB7XG4gICAgICAgIC8vIDEuIExldCBoZWFkZXIgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgdGhhdCBhcmVcbiAgICAgICAgLy8gICAgbm90IDB4MEEgKExGKSBvciAweDBEIChDUiksIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICBsZXQgaGVhZGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcblxuICAgICAgICAvLyAyLiBSZW1vdmUgYW55IEhUVFAgdGFiIG9yIHNwYWNlIGJ5dGVzIGZyb20gdGhlIGVuZCBvZiBoZWFkZXIgdmFsdWUuXG4gICAgICAgIGhlYWRlclZhbHVlID0gcmVtb3ZlQ2hhcnMoaGVhZGVyVmFsdWUsIGZhbHNlLCB0cnVlLCAoY2hhcikgPT4gY2hhciA9PT0gMHg5IHx8IGNoYXIgPT09IDB4MjApXG5cbiAgICAgICAgLy8gMy4gU2V0IGNvbnRlbnRUeXBlIHRvIHRoZSBpc29tb3JwaGljIGRlY29kaW5nIG9mIGhlYWRlciB2YWx1ZS5cbiAgICAgICAgY29udGVudFR5cGUgPSBpc29tb3JwaGljRGVjb2RlKGhlYWRlclZhbHVlKVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjYXNlICdjb250ZW50LXRyYW5zZmVyLWVuY29kaW5nJzoge1xuICAgICAgICBsZXQgaGVhZGVyVmFsdWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAgICAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkLFxuICAgICAgICAgIGlucHV0LFxuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIClcblxuICAgICAgICBoZWFkZXJWYWx1ZSA9IHJlbW92ZUNoYXJzKGhlYWRlclZhbHVlLCBmYWxzZSwgdHJ1ZSwgKGNoYXIpID0+IGNoYXIgPT09IDB4OSB8fCBjaGFyID09PSAweDIwKVxuXG4gICAgICAgIGVuY29kaW5nID0gaXNvbW9ycGhpY0RlY29kZShoZWFkZXJWYWx1ZSlcblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICAvLyBDb2xsZWN0IGEgc2VxdWVuY2Ugb2YgYnl0ZXMgdGhhdCBhcmUgbm90IDB4MEEgKExGKSBvciAweDBEIChDUiksIGdpdmVuIHBvc2l0aW9uLlxuICAgICAgICAvLyAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgICAgICAgY29sbGVjdEFTZXF1ZW5jZU9mQnl0ZXMoXG4gICAgICAgICAgKGNoYXIpID0+IGNoYXIgIT09IDB4MGEgJiYgY2hhciAhPT0gMHgwZCxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBwb3NpdGlvblxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMi45LiBJZiBwb3NpdGlvbiBkb2VzIG5vdCBwb2ludCB0byBhIHNlcXVlbmNlIG9mIGJ5dGVzIHN0YXJ0aW5nIHdpdGggMHgwRCAweDBBXG4gICAgLy8gICAgICAoQ1IgTEYpLCByZXR1cm4gZmFpbHVyZS4gT3RoZXJ3aXNlLCBhZHZhbmNlIHBvc2l0aW9uIGJ5IDIgKHBhc3QgdGhlIG5ld2xpbmUpLlxuICAgIGlmIChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbl0gIT09IDB4MGQgJiYgaW5wdXRbcG9zaXRpb24ucG9zaXRpb24gKyAxXSAhPT0gMHgwYSkge1xuICAgICAgcmV0dXJuICdmYWlsdXJlJ1xuICAgIH0gZWxzZSB7XG4gICAgICBwb3NpdGlvbi5wb3NpdGlvbiArPSAyXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2FuZHJldWJvdGVsbGEuZ2l0aHViLmlvL211bHRpcGFydC1mb3JtLWRhdGEvI3BhcnNlLWEtbXVsdGlwYXJ0LWZvcm0tZGF0YS1uYW1lXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTXVsdGlwYXJ0Rm9ybURhdGFOYW1lIChpbnB1dCwgcG9zaXRpb24pIHtcbiAgLy8gMS4gQXNzZXJ0OiBUaGUgYnl0ZSBhdCAocG9zaXRpb24gLSAxKSBpcyAweDIyIChcIikuXG4gIGFzc2VydChpbnB1dFtwb3NpdGlvbi5wb3NpdGlvbiAtIDFdID09PSAweDIyKVxuXG4gIC8vIDIuIExldCBuYW1lIGJlIHRoZSByZXN1bHQgb2YgY29sbGVjdGluZyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHRoYXQgYXJlIG5vdCAweDBBIChMRiksIDB4MEQgKENSKSBvciAweDIyIChcIiksIGdpdmVuIHBvc2l0aW9uLlxuICAvKiogQHR5cGUge3N0cmluZyB8IEJ1ZmZlcn0gKi9cbiAgbGV0IG5hbWUgPSBjb2xsZWN0QVNlcXVlbmNlT2ZCeXRlcyhcbiAgICAoY2hhcikgPT4gY2hhciAhPT0gMHgwYSAmJiBjaGFyICE9PSAweDBkICYmIGNoYXIgIT09IDB4MjIsXG4gICAgaW5wdXQsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDMuIElmIHRoZSBieXRlIGF0IHBvc2l0aW9uIGlzIG5vdCAweDIyIChcIiksIHJldHVybiBmYWlsdXJlLiBPdGhlcndpc2UsIGFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgaWYgKGlucHV0W3Bvc2l0aW9uLnBvc2l0aW9uXSAhPT0gMHgyMikge1xuICAgIHJldHVybiBudWxsIC8vIG5hbWUgY291bGQgYmUgJ2ZhaWx1cmUnXG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICB9XG5cbiAgLy8gNC4gUmVwbGFjZSBhbnkgb2NjdXJyZW5jZSBvZiB0aGUgZm9sbG93aW5nIHN1YnNlcXVlbmNlcyBpbiBuYW1lIHdpdGggdGhlIGdpdmVuIGJ5dGU6XG4gIC8vIC0gYCUwQWA6IDB4MEEgKExGKVxuICAvLyAtIGAlMERgOiAweDBEIChDUilcbiAgLy8gLSBgJTIyYDogMHgyMiAoXCIpXG4gIG5hbWUgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobmFtZSlcbiAgICAucmVwbGFjZSgvJTBBL2lnLCAnXFxuJylcbiAgICAucmVwbGFjZSgvJTBEL2lnLCAnXFxyJylcbiAgICAucmVwbGFjZSgvJTIyL2csICdcIicpXG5cbiAgLy8gNS4gUmV0dXJuIHRoZSBVVEYtOCBkZWNvZGluZyB3aXRob3V0IEJPTSBvZiBuYW1lLlxuICByZXR1cm4gbmFtZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGNoYXI6IG51bWJlcikgPT4gYm9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gaW5wdXRcbiAqIEBwYXJhbSB7eyBwb3NpdGlvbjogbnVtYmVyIH19IHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RBU2VxdWVuY2VPZkJ5dGVzIChjb25kaXRpb24sIGlucHV0LCBwb3NpdGlvbikge1xuICBsZXQgc3RhcnQgPSBwb3NpdGlvbi5wb3NpdGlvblxuXG4gIHdoaWxlIChzdGFydCA8IGlucHV0Lmxlbmd0aCAmJiBjb25kaXRpb24oaW5wdXRbc3RhcnRdKSkge1xuICAgICsrc3RhcnRcbiAgfVxuXG4gIHJldHVybiBpbnB1dC5zdWJhcnJheShwb3NpdGlvbi5wb3NpdGlvbiwgKHBvc2l0aW9uLnBvc2l0aW9uID0gc3RhcnQpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbGVhZGluZ1xuICogQHBhcmFtIHtib29sZWFufSB0cmFpbGluZ1xuICogQHBhcmFtIHsoY2hhckNvZGU6IG51bWJlcikgPT4gYm9vbGVhbn0gcHJlZGljYXRlXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiByZW1vdmVDaGFycyAoYnVmLCBsZWFkaW5nLCB0cmFpbGluZywgcHJlZGljYXRlKSB7XG4gIGxldCBsZWFkID0gMFxuICBsZXQgdHJhaWwgPSBidWYubGVuZ3RoIC0gMVxuXG4gIGlmIChsZWFkaW5nKSB7XG4gICAgd2hpbGUgKGxlYWQgPCBidWYubGVuZ3RoICYmIHByZWRpY2F0ZShidWZbbGVhZF0pKSBsZWFkKytcbiAgfVxuXG4gIGlmICh0cmFpbGluZykge1xuICAgIHdoaWxlICh0cmFpbCA+IDAgJiYgcHJlZGljYXRlKGJ1Zlt0cmFpbF0pKSB0cmFpbC0tXG4gIH1cblxuICByZXR1cm4gbGVhZCA9PT0gMCAmJiB0cmFpbCA9PT0gYnVmLmxlbmd0aCAtIDEgPyBidWYgOiBidWYuc3ViYXJyYXkobGVhZCwgdHJhaWwgKyAxKVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB7QHBhcmFtIGJ1ZmZlcn0gc3RhcnRzIHdpdGgge0BwYXJhbSBzdGFydH1cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzdGFydFxuICogQHBhcmFtIHt7IHBvc2l0aW9uOiBudW1iZXIgfX0gcG9zaXRpb25cbiAqL1xuZnVuY3Rpb24gYnVmZmVyU3RhcnRzV2l0aCAoYnVmZmVyLCBzdGFydCwgcG9zaXRpb24pIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPCBzdGFydC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhcnQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RhcnRbaV0gIT09IGJ1ZmZlcltwb3NpdGlvbi5wb3NpdGlvbiArIGldKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbXVsdGlwYXJ0Rm9ybURhdGFQYXJzZXIsXG4gIHZhbGlkYXRlQm91bmRhcnlcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/formdata-parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/formdata.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/formdata.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isBlobLike, iteratorMixin } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { kState } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { FileLike, isFileLike } = __webpack_require__(/*! ./file */ \"(rsc)/./node_modules/undici/lib/web/fetch/file.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { File: NativeFile } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\n\n/** @type {globalThis['File']} */\nconst File = globalThis.File ?? NativeFile\n\n// https://xhr.spec.whatwg.org/#formdata\nclass FormData {\n  constructor (form) {\n    webidl.util.markAsUncloneable(this)\n\n    if (form !== undefined) {\n      throw webidl.errors.conversionFailed({\n        prefix: 'FormData constructor',\n        argument: 'Argument 1',\n        types: ['undefined']\n      })\n    }\n\n    this[kState] = []\n  }\n\n  append (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.append'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    if (arguments.length === 3 && !isBlobLike(value)) {\n      throw new TypeError(\n        \"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n    value = isBlobLike(value)\n      ? webidl.converters.Blob(value, prefix, 'value', { strict: false })\n      : webidl.converters.USVString(value, prefix, 'value')\n    filename = arguments.length === 3\n      ? webidl.converters.USVString(filename, prefix, 'filename')\n      : undefined\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. Append entry to this’s entry list.\n    this[kState].push(entry)\n  }\n\n  delete (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.delete'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from this’s entry list.\n    this[kState] = this[kState].filter(entry => entry.name !== name)\n  }\n\n  get (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.get'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return null.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx === -1) {\n      return null\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // this’s entry list.\n    return this[kState][idx].value\n  }\n\n  getAll (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.getAll'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from this’s entry list.\n    return this[kState]\n      .filter((entry) => entry.name === name)\n      .map((entry) => entry.value)\n  }\n\n  has (name) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.has'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in this’s entry list; otherwise false.\n    return this[kState].findIndex((entry) => entry.name === name) !== -1\n  }\n\n  set (name, value, filename = undefined) {\n    webidl.brandCheck(this, FormData)\n\n    const prefix = 'FormData.set'\n    webidl.argumentLengthCheck(arguments, 2, prefix)\n\n    if (arguments.length === 3 && !isBlobLike(value)) {\n      throw new TypeError(\n        \"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n\n    name = webidl.converters.USVString(name, prefix, 'name')\n    value = isBlobLike(value)\n      ? webidl.converters.Blob(value, prefix, 'name', { strict: false })\n      : webidl.converters.USVString(value, prefix, 'name')\n    filename = arguments.length === 3\n      ? webidl.converters.USVString(filename, prefix, 'name')\n      : undefined\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. If there are entries in this’s entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx !== -1) {\n      this[kState] = [\n        ...this[kState].slice(0, idx),\n        entry,\n        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)\n      ]\n    } else {\n      // 4. Otherwise, append entry to this’s entry list.\n      this[kState].push(entry)\n    }\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    const state = this[kState].reduce((a, b) => {\n      if (a[b.name]) {\n        if (Array.isArray(a[b.name])) {\n          a[b.name].push(b.value)\n        } else {\n          a[b.name] = [a[b.name], b.value]\n        }\n      } else {\n        a[b.name] = b.value\n      }\n\n      return a\n    }, { __proto__: null })\n\n    options.depth ??= depth\n    options.colors ??= true\n\n    const output = nodeUtil.formatWithOptions(options, state)\n\n    // remove [Object null prototype]\n    return `FormData ${output.slice(output.indexOf(']') + 2)}`\n  }\n}\n\niteratorMixin('FormData', FormData, kState, 'name', 'value')\n\nObject.defineProperties(FormData.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  getAll: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'FormData',\n    configurable: true\n  }\n})\n\n/**\n * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry\n * @param {string} name\n * @param {string|Blob} value\n * @param {?string} filename\n * @returns\n */\nfunction makeEntry (name, value, filename) {\n  // 1. Set name to the result of converting name into a scalar value string.\n  // Note: This operation was done by the webidl converter USVString.\n\n  // 2. If value is a string, then set value to the result of converting\n  //    value into a scalar value string.\n  if (typeof value === 'string') {\n    // Note: This operation was done by the webidl converter USVString.\n  } else {\n    // 3. Otherwise:\n\n    // 1. If value is not a File object, then set value to a new File object,\n    //    representing the same bytes, whose name attribute value is \"blob\"\n    if (!isFileLike(value)) {\n      value = value instanceof Blob\n        ? new File([value], 'blob', { type: value.type })\n        : new FileLike(value, 'blob', { type: value.type })\n    }\n\n    // 2. If filename is given, then set value to a new File object,\n    //    representing the same bytes, whose name attribute is filename.\n    if (filename !== undefined) {\n      /** @type {FilePropertyBag} */\n      const options = {\n        type: value.type,\n        lastModified: value.lastModified\n      }\n\n      value = value instanceof NativeFile\n        ? new File([value], filename, options)\n        : new FileLike(value, filename, options)\n    }\n  }\n\n  // 4. Return an entry whose name is name and whose value is value.\n  return { name, value }\n}\n\nmodule.exports = { FormData, makeEntry }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZm9ybWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3RELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsdUVBQVc7QUFDdEMsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN6RCxRQUFRLHVCQUF1QixFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDakQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxRUFBVTtBQUNyQyxRQUFRLG1CQUFtQixFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsNEJBQVc7O0FBRXBDLFdBQVcsb0JBQW9CO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQSx5REFBeUQsZUFBZTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBO0FBQ0Esd0RBQXdELGVBQWU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSSxpQkFBaUI7O0FBRTFCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msa0JBQWtCO0FBQ3hELHdDQUF3QyxrQkFBa0I7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxmb3JtZGF0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBpc0Jsb2JMaWtlLCBpdGVyYXRvck1peGluIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBrU3RhdGUgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHkgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IEZpbGVMaWtlLCBpc0ZpbGVMaWtlIH0gPSByZXF1aXJlKCcuL2ZpbGUnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgRmlsZTogTmF0aXZlRmlsZSB9ID0gcmVxdWlyZSgnbm9kZTpidWZmZXInKVxuY29uc3Qgbm9kZVV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuXG4vKiogQHR5cGUge2dsb2JhbFRoaXNbJ0ZpbGUnXX0gKi9cbmNvbnN0IEZpbGUgPSBnbG9iYWxUaGlzLkZpbGUgPz8gTmF0aXZlRmlsZVxuXG4vLyBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI2Zvcm1kYXRhXG5jbGFzcyBGb3JtRGF0YSB7XG4gIGNvbnN0cnVjdG9yIChmb3JtKSB7XG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcblxuICAgIGlmIChmb3JtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICAgIHByZWZpeDogJ0Zvcm1EYXRhIGNvbnN0cnVjdG9yJyxcbiAgICAgICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICAgICAgdHlwZXM6IFsndW5kZWZpbmVkJ11cbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpc1trU3RhdGVdID0gW11cbiAgfVxuXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUsIGZpbGVuYW1lID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRm9ybURhdGEpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnRm9ybURhdGEuYXBwZW5kJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMiwgcHJlZml4KVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgIWlzQmxvYkxpa2UodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkZhaWxlZCB0byBleGVjdXRlICdhcHBlbmQnIG9uICdGb3JtRGF0YSc6IHBhcmFtZXRlciAyIGlzIG5vdCBvZiB0eXBlICdCbG9iJ1wiXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IHZhbHVlIGJlIHZhbHVlIGlmIGdpdmVuOyBvdGhlcndpc2UgYmxvYlZhbHVlLlxuXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcbiAgICB2YWx1ZSA9IGlzQmxvYkxpa2UodmFsdWUpXG4gICAgICA/IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IodmFsdWUsIHByZWZpeCwgJ3ZhbHVlJywgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgICA6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSwgcHJlZml4LCAndmFsdWUnKVxuICAgIGZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gM1xuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoZmlsZW5hbWUsIHByZWZpeCwgJ2ZpbGVuYW1lJylcbiAgICAgIDogdW5kZWZpbmVkXG5cbiAgICAvLyAyLiBMZXQgZW50cnkgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBlbnRyeSB3aXRoXG4gICAgLy8gbmFtZSwgdmFsdWUsIGFuZCBmaWxlbmFtZSBpZiBnaXZlbi5cbiAgICBjb25zdCBlbnRyeSA9IG1ha2VFbnRyeShuYW1lLCB2YWx1ZSwgZmlsZW5hbWUpXG5cbiAgICAvLyAzLiBBcHBlbmQgZW50cnkgdG8gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICB0aGlzW2tTdGF0ZV0ucHVzaChlbnRyeSlcbiAgfVxuXG4gIGRlbGV0ZSAobmFtZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZvcm1EYXRhKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0Zvcm1EYXRhLmRlbGV0ZSdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG5cbiAgICAvLyBUaGUgZGVsZXRlKG5hbWUpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmVtb3ZlIGFsbCBlbnRyaWVzIHdob3NlIG5hbWVcbiAgICAvLyBpcyBuYW1lIGZyb20gdGhpc+KAmXMgZW50cnkgbGlzdC5cbiAgICB0aGlzW2tTdGF0ZV0gPSB0aGlzW2tTdGF0ZV0uZmlsdGVyKGVudHJ5ID0+IGVudHJ5Lm5hbWUgIT09IG5hbWUpXG4gIH1cblxuICBnZXQgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5nZXQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gbnVsbC5cbiAgICBjb25zdCBpZHggPSB0aGlzW2tTdGF0ZV0uZmluZEluZGV4KChlbnRyeSkgPT4gZW50cnkubmFtZSA9PT0gbmFtZSlcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICAvLyAyLiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbnRyeSB3aG9zZSBuYW1lIGlzIG5hbWUgZnJvbVxuICAgIC8vIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXVtpZHhdLnZhbHVlXG4gIH1cblxuICBnZXRBbGwgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5nZXRBbGwnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gMS4gSWYgdGhlcmUgaXMgbm8gZW50cnkgd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3QsXG4gICAgLy8gdGhlbiByZXR1cm4gdGhlIGVtcHR5IGxpc3QuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGVudHJpZXMgd2hvc2UgbmFtZSBpcyBuYW1lLCBpbiBvcmRlcixcbiAgICAvLyBmcm9tIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXVxuICAgICAgLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpXG4gICAgICAubWFwKChlbnRyeSkgPT4gZW50cnkudmFsdWUpXG4gIH1cblxuICBoYXMgKG5hbWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5oYXMnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCBwcmVmaXgpXG5cbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuXG4gICAgLy8gVGhlIGhhcyhuYW1lKSBtZXRob2Qgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGFuIGVudHJ5XG4gICAgLy8gd2hvc2UgbmFtZSBpcyBuYW1lIGluIHRoaXPigJlzIGVudHJ5IGxpc3Q7IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmZpbmRJbmRleCgoZW50cnkpID0+IGVudHJ5Lm5hbWUgPT09IG5hbWUpICE9PSAtMVxuICB9XG5cbiAgc2V0IChuYW1lLCB2YWx1ZSwgZmlsZW5hbWUgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGb3JtRGF0YSlcblxuICAgIGNvbnN0IHByZWZpeCA9ICdGb3JtRGF0YS5zZXQnXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCBwcmVmaXgpXG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMyAmJiAhaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ3NldCcgb24gJ0Zvcm1EYXRhJzogcGFyYW1ldGVyIDIgaXMgbm90IG9mIHR5cGUgJ0Jsb2InXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBUaGUgc2V0KG5hbWUsIHZhbHVlKSBhbmQgc2V0KG5hbWUsIGJsb2JWYWx1ZSwgZmlsZW5hbWUpIG1ldGhvZCBzdGVwc1xuICAgIC8vIGFyZTpcblxuICAgIC8vIDEuIExldCB2YWx1ZSBiZSB2YWx1ZSBpZiBnaXZlbjsgb3RoZXJ3aXNlIGJsb2JWYWx1ZS5cblxuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG4gICAgdmFsdWUgPSBpc0Jsb2JMaWtlKHZhbHVlKVxuICAgICAgPyB3ZWJpZGwuY29udmVydGVycy5CbG9iKHZhbHVlLCBwcmVmaXgsICduYW1lJywgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgICA6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh2YWx1ZSwgcHJlZml4LCAnbmFtZScpXG4gICAgZmlsZW5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAzXG4gICAgICA/IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhmaWxlbmFtZSwgcHJlZml4LCAnbmFtZScpXG4gICAgICA6IHVuZGVmaW5lZFxuXG4gICAgLy8gMi4gTGV0IGVudHJ5IGJlIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW4gZW50cnkgd2l0aCBuYW1lLCB2YWx1ZSwgYW5kXG4gICAgLy8gZmlsZW5hbWUgaWYgZ2l2ZW4uXG4gICAgY29uc3QgZW50cnkgPSBtYWtlRW50cnkobmFtZSwgdmFsdWUsIGZpbGVuYW1lKVxuXG4gICAgLy8gMy4gSWYgdGhlcmUgYXJlIGVudHJpZXMgaW4gdGhpc+KAmXMgZW50cnkgbGlzdCB3aG9zZSBuYW1lIGlzIG5hbWUsIHRoZW5cbiAgICAvLyByZXBsYWNlIHRoZSBmaXJzdCBzdWNoIGVudHJ5IHdpdGggZW50cnkgYW5kIHJlbW92ZSB0aGUgb3RoZXJzLlxuICAgIGNvbnN0IGlkeCA9IHRoaXNba1N0YXRlXS5maW5kSW5kZXgoKGVudHJ5KSA9PiBlbnRyeS5uYW1lID09PSBuYW1lKVxuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICB0aGlzW2tTdGF0ZV0gPSBbXG4gICAgICAgIC4uLnRoaXNba1N0YXRlXS5zbGljZSgwLCBpZHgpLFxuICAgICAgICBlbnRyeSxcbiAgICAgICAgLi4udGhpc1trU3RhdGVdLnNsaWNlKGlkeCArIDEpLmZpbHRlcigoZW50cnkpID0+IGVudHJ5Lm5hbWUgIT09IG5hbWUpXG4gICAgICBdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDQuIE90aGVyd2lzZSwgYXBwZW5kIGVudHJ5IHRvIHRoaXPigJlzIGVudHJ5IGxpc3QuXG4gICAgICB0aGlzW2tTdGF0ZV0ucHVzaChlbnRyeSlcbiAgICB9XG4gIH1cblxuICBbbm9kZVV0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpc1trU3RhdGVdLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgICAgaWYgKGFbYi5uYW1lXSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhW2IubmFtZV0pKSB7XG4gICAgICAgICAgYVtiLm5hbWVdLnB1c2goYi52YWx1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhW2IubmFtZV0gPSBbYVtiLm5hbWVdLCBiLnZhbHVlXVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhW2IubmFtZV0gPSBiLnZhbHVlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhXG4gICAgfSwgeyBfX3Byb3RvX186IG51bGwgfSlcblxuICAgIG9wdGlvbnMuZGVwdGggPz89IGRlcHRoXG4gICAgb3B0aW9ucy5jb2xvcnMgPz89IHRydWVcblxuICAgIGNvbnN0IG91dHB1dCA9IG5vZGVVdGlsLmZvcm1hdFdpdGhPcHRpb25zKG9wdGlvbnMsIHN0YXRlKVxuXG4gICAgLy8gcmVtb3ZlIFtPYmplY3QgbnVsbCBwcm90b3R5cGVdXG4gICAgcmV0dXJuIGBGb3JtRGF0YSAke291dHB1dC5zbGljZShvdXRwdXQuaW5kZXhPZignXScpICsgMil9YFxuICB9XG59XG5cbml0ZXJhdG9yTWl4aW4oJ0Zvcm1EYXRhJywgRm9ybURhdGEsIGtTdGF0ZSwgJ25hbWUnLCAndmFsdWUnKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGb3JtRGF0YS5wcm90b3R5cGUsIHtcbiAgYXBwZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZ2V0QWxsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoYXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Zvcm1EYXRhJyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI2NyZWF0ZS1hbi1lbnRyeVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfEJsb2J9IHZhbHVlXG4gKiBAcGFyYW0gez9zdHJpbmd9IGZpbGVuYW1lXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBtYWtlRW50cnkgKG5hbWUsIHZhbHVlLCBmaWxlbmFtZSkge1xuICAvLyAxLiBTZXQgbmFtZSB0byB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgbmFtZSBpbnRvIGEgc2NhbGFyIHZhbHVlIHN0cmluZy5cbiAgLy8gTm90ZTogVGhpcyBvcGVyYXRpb24gd2FzIGRvbmUgYnkgdGhlIHdlYmlkbCBjb252ZXJ0ZXIgVVNWU3RyaW5nLlxuXG4gIC8vIDIuIElmIHZhbHVlIGlzIGEgc3RyaW5nLCB0aGVuIHNldCB2YWx1ZSB0byB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmdcbiAgLy8gICAgdmFsdWUgaW50byBhIHNjYWxhciB2YWx1ZSBzdHJpbmcuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgLy8gTm90ZTogVGhpcyBvcGVyYXRpb24gd2FzIGRvbmUgYnkgdGhlIHdlYmlkbCBjb252ZXJ0ZXIgVVNWU3RyaW5nLlxuICB9IGVsc2Uge1xuICAgIC8vIDMuIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIElmIHZhbHVlIGlzIG5vdCBhIEZpbGUgb2JqZWN0LCB0aGVuIHNldCB2YWx1ZSB0byBhIG5ldyBGaWxlIG9iamVjdCxcbiAgICAvLyAgICByZXByZXNlbnRpbmcgdGhlIHNhbWUgYnl0ZXMsIHdob3NlIG5hbWUgYXR0cmlidXRlIHZhbHVlIGlzIFwiYmxvYlwiXG4gICAgaWYgKCFpc0ZpbGVMaWtlKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZSBpbnN0YW5jZW9mIEJsb2JcbiAgICAgICAgPyBuZXcgRmlsZShbdmFsdWVdLCAnYmxvYicsIHsgdHlwZTogdmFsdWUudHlwZSB9KVxuICAgICAgICA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgJ2Jsb2InLCB7IHR5cGU6IHZhbHVlLnR5cGUgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBJZiBmaWxlbmFtZSBpcyBnaXZlbiwgdGhlbiBzZXQgdmFsdWUgdG8gYSBuZXcgRmlsZSBvYmplY3QsXG4gICAgLy8gICAgcmVwcmVzZW50aW5nIHRoZSBzYW1lIGJ5dGVzLCB3aG9zZSBuYW1lIGF0dHJpYnV0ZSBpcyBmaWxlbmFtZS5cbiAgICBpZiAoZmlsZW5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLyoqIEB0eXBlIHtGaWxlUHJvcGVydHlCYWd9ICovXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICB0eXBlOiB2YWx1ZS50eXBlLFxuICAgICAgICBsYXN0TW9kaWZpZWQ6IHZhbHVlLmxhc3RNb2RpZmllZFxuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHZhbHVlIGluc3RhbmNlb2YgTmF0aXZlRmlsZVxuICAgICAgICA/IG5ldyBGaWxlKFt2YWx1ZV0sIGZpbGVuYW1lLCBvcHRpb25zKVxuICAgICAgICA6IG5ldyBGaWxlTGlrZSh2YWx1ZSwgZmlsZW5hbWUsIG9wdGlvbnMpXG4gICAgfVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIGFuIGVudHJ5IHdob3NlIG5hbWUgaXMgbmFtZSBhbmQgd2hvc2UgdmFsdWUgaXMgdmFsdWUuXG4gIHJldHVybiB7IG5hbWUsIHZhbHVlIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IEZvcm1EYXRhLCBtYWtlRW50cnkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/global.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/global.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// In case of breaking changes, increase the version\n// number to avoid conflicts.\nconst globalOrigin = Symbol.for('undici.globalOrigin.1')\n\nfunction getGlobalOrigin () {\n  return globalThis[globalOrigin]\n}\n\nfunction setGlobalOrigin (newOrigin) {\n  if (newOrigin === undefined) {\n    Object.defineProperty(globalThis, globalOrigin, {\n      value: undefined,\n      writable: true,\n      enumerable: false,\n      configurable: false\n    })\n\n    return\n  }\n\n  const parsedURL = new URL(newOrigin)\n\n  if (parsedURL.protocol !== 'http:' && parsedURL.protocol !== 'https:') {\n    throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`)\n  }\n\n  Object.defineProperty(globalThis, globalOrigin, {\n    value: parsedURL,\n    writable: true,\n    enumerable: false,\n    configurable: false\n  })\n}\n\nmodule.exports = {\n  getGlobalOrigin,\n  setGlobalOrigin\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvZ2xvYmFsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx3RUFBd0UsbUJBQW1CO0FBQzNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcZ2xvYmFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBJbiBjYXNlIG9mIGJyZWFraW5nIGNoYW5nZXMsIGluY3JlYXNlIHRoZSB2ZXJzaW9uXG4vLyBudW1iZXIgdG8gYXZvaWQgY29uZmxpY3RzLlxuY29uc3QgZ2xvYmFsT3JpZ2luID0gU3ltYm9sLmZvcigndW5kaWNpLmdsb2JhbE9yaWdpbi4xJylcblxuZnVuY3Rpb24gZ2V0R2xvYmFsT3JpZ2luICgpIHtcbiAgcmV0dXJuIGdsb2JhbFRoaXNbZ2xvYmFsT3JpZ2luXVxufVxuXG5mdW5jdGlvbiBzZXRHbG9iYWxPcmlnaW4gKG5ld09yaWdpbikge1xuICBpZiAobmV3T3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgZ2xvYmFsT3JpZ2luLCB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgICB9KVxuXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCBwYXJzZWRVUkwgPSBuZXcgVVJMKG5ld09yaWdpbilcblxuICBpZiAocGFyc2VkVVJMLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVSTC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBPbmx5IGh0dHAgJiBodHRwcyB1cmxzIGFyZSBhbGxvd2VkLCByZWNlaXZlZCAke3BhcnNlZFVSTC5wcm90b2NvbH1gKVxuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdsb2JhbFRoaXMsIGdsb2JhbE9yaWdpbiwge1xuICAgIHZhbHVlOiBwYXJzZWRVUkwsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0R2xvYmFsT3JpZ2luLFxuICBzZXRHbG9iYWxPcmlnaW5cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/global.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/headers.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/headers.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst {\n  iteratorMixin,\n  isValidHeaderName,\n  isValidHeaderValue\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst util = __webpack_require__(/*! node:util */ \"node:util\")\n\nconst kHeadersMap = Symbol('headers map')\nconst kHeadersSortedMap = Symbol('headers map sorted')\n\n/**\n * @param {number} code\n */\nfunction isHTTPWhiteSpaceCharCode (code) {\n  return code === 0x00a || code === 0x00d || code === 0x009 || code === 0x020\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize\n * @param {string} potentialValue\n */\nfunction headerValueNormalize (potentialValue) {\n  //  To normalize a byte sequence potentialValue, remove\n  //  any leading and trailing HTTP whitespace bytes from\n  //  potentialValue.\n  let i = 0; let j = potentialValue.length\n\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j\n  while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i\n\n  return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j)\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  // 1. If object is a sequence, then for each header in object:\n  // Note: webidl conversion to array has already been done.\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; ++i) {\n      const header = object[i]\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (header.length !== 2) {\n        throw webidl.errors.exception({\n          header: 'Headers constructor',\n          message: `expected name/value pair to be length 2, found ${header.length}.`\n        })\n      }\n\n      // 2. Append (header’s first item, header’s second item) to headers.\n      appendHeader(headers, header[0], header[1])\n    }\n  } else if (typeof object === 'object' && object !== null) {\n    // Note: null should throw\n\n    // 2. Otherwise, object is a record, then for each key → value in object,\n    //    append (key, value) to headers\n    const keys = Object.keys(object)\n    for (let i = 0; i < keys.length; ++i) {\n      appendHeader(headers, keys[i], object[keys[i]])\n    }\n  } else {\n    throw webidl.errors.conversionFailed({\n      prefix: 'Headers constructor',\n      argument: 'Argument 1',\n      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n    })\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-headers-append\n */\nfunction appendHeader (headers, name, value) {\n  // 1. Normalize value.\n  value = headerValueNormalize(value)\n\n  // 2. If name is not a header name or value is not a\n  //    header value, then throw a TypeError.\n  if (!isValidHeaderName(name)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value: name,\n      type: 'header name'\n    })\n  } else if (!isValidHeaderValue(value)) {\n    throw webidl.errors.invalidArgument({\n      prefix: 'Headers.append',\n      value,\n      type: 'header value'\n    })\n  }\n\n  // 3. If headers’s guard is \"immutable\", then throw a TypeError.\n  // 4. Otherwise, if headers’s guard is \"request\" and name is a\n  //    forbidden header name, return.\n  // 5. Otherwise, if headers’s guard is \"request-no-cors\":\n  //    TODO\n  // Note: undici does not implement forbidden header names\n  if (getHeadersGuard(headers) === 'immutable') {\n    throw new TypeError('immutable')\n  }\n\n  // 6. Otherwise, if headers’s guard is \"response\" and name is a\n  //    forbidden response-header name, return.\n\n  // 7. Append (name, value) to headers’s header list.\n  return getHeadersList(headers).append(name, value, false)\n\n  // 8. If headers’s guard is \"request-no-cors\", then remove\n  //    privileged no-CORS request headers from headers\n}\n\nfunction compareHeaderName (a, b) {\n  return a[0] < b[0] ? -1 : 1\n}\n\nclass HeadersList {\n  /** @type {[string, string][]|null} */\n  cookies = null\n\n  constructor (init) {\n    if (init instanceof HeadersList) {\n      this[kHeadersMap] = new Map(init[kHeadersMap])\n      this[kHeadersSortedMap] = init[kHeadersSortedMap]\n      this.cookies = init.cookies === null ? null : [...init.cookies]\n    } else {\n      this[kHeadersMap] = new Map(init)\n      this[kHeadersSortedMap] = null\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#header-list-contains\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  contains (name, isLowerCase) {\n    // A header list list contains a header name name if list\n    // contains a header whose name is a byte-case-insensitive\n    // match for name.\n\n    return this[kHeadersMap].has(isLowerCase ? name : name.toLowerCase())\n  }\n\n  clear () {\n    this[kHeadersMap].clear()\n    this[kHeadersSortedMap] = null\n    this.cookies = null\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-append\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  append (name, value, isLowerCase) {\n    this[kHeadersSortedMap] = null\n\n    // 1. If list contains name, then set name to the first such\n    //    header’s name.\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n    const exists = this[kHeadersMap].get(lowercaseName)\n\n    // 2. Append (name, value) to list.\n    if (exists) {\n      const delimiter = lowercaseName === 'cookie' ? '; ' : ', '\n      this[kHeadersMap].set(lowercaseName, {\n        name: exists.name,\n        value: `${exists.value}${delimiter}${value}`\n      })\n    } else {\n      this[kHeadersMap].set(lowercaseName, { name, value })\n    }\n\n    if (lowercaseName === 'set-cookie') {\n      (this.cookies ??= []).push(value)\n    }\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-set\n   * @param {string} name\n   * @param {string} value\n   * @param {boolean} isLowerCase\n   */\n  set (name, value, isLowerCase) {\n    this[kHeadersSortedMap] = null\n    const lowercaseName = isLowerCase ? name : name.toLowerCase()\n\n    if (lowercaseName === 'set-cookie') {\n      this.cookies = [value]\n    }\n\n    // 1. If list contains name, then set the value of\n    //    the first such header to value and remove the\n    //    others.\n    // 2. Otherwise, append header (name, value) to list.\n    this[kHeadersMap].set(lowercaseName, { name, value })\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-delete\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   */\n  delete (name, isLowerCase) {\n    this[kHeadersSortedMap] = null\n    if (!isLowerCase) name = name.toLowerCase()\n\n    if (name === 'set-cookie') {\n      this.cookies = null\n    }\n\n    this[kHeadersMap].delete(name)\n  }\n\n  /**\n   * @see https://fetch.spec.whatwg.org/#concept-header-list-get\n   * @param {string} name\n   * @param {boolean} isLowerCase\n   * @returns {string | null}\n   */\n  get (name, isLowerCase) {\n    // 1. If list does not contain name, then return null.\n    // 2. Return the values of all headers in list whose name\n    //    is a byte-case-insensitive match for name,\n    //    separated from each other by 0x2C 0x20, in order.\n    return this[kHeadersMap].get(isLowerCase ? name : name.toLowerCase())?.value ?? null\n  }\n\n  * [Symbol.iterator] () {\n    // use the lowercased name\n    for (const { 0: name, 1: { value } } of this[kHeadersMap]) {\n      yield [name, value]\n    }\n  }\n\n  get entries () {\n    const headers = {}\n\n    if (this[kHeadersMap].size !== 0) {\n      for (const { name, value } of this[kHeadersMap].values()) {\n        headers[name] = value\n      }\n    }\n\n    return headers\n  }\n\n  rawValues () {\n    return this[kHeadersMap].values()\n  }\n\n  get entriesList () {\n    const headers = []\n\n    if (this[kHeadersMap].size !== 0) {\n      for (const { 0: lowerName, 1: { name, value } } of this[kHeadersMap]) {\n        if (lowerName === 'set-cookie') {\n          for (const cookie of this.cookies) {\n            headers.push([name, cookie])\n          }\n        } else {\n          headers.push([name, value])\n        }\n      }\n    }\n\n    return headers\n  }\n\n  // https://fetch.spec.whatwg.org/#convert-header-names-to-a-sorted-lowercase-set\n  toSortedArray () {\n    const size = this[kHeadersMap].size\n    const array = new Array(size)\n    // In most cases, you will use the fast-path.\n    // fast-path: Use binary insertion sort for small arrays.\n    if (size <= 32) {\n      if (size === 0) {\n        // If empty, it is an empty array. To avoid the first index assignment.\n        return array\n      }\n      // Improve performance by unrolling loop and avoiding double-loop.\n      // Double-loop-less version of the binary insertion sort.\n      const iterator = this[kHeadersMap][Symbol.iterator]()\n      const firstValue = iterator.next().value\n      // set [name, value] to first index.\n      array[0] = [firstValue[0], firstValue[1].value]\n      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n      // 3.2.2. Assert: value is non-null.\n      assert(firstValue[1].value !== null)\n      for (\n        let i = 1, j = 0, right = 0, left = 0, pivot = 0, x, value;\n        i < size;\n        ++i\n      ) {\n        // get next value\n        value = iterator.next().value\n        // set [name, value] to current index.\n        x = array[i] = [value[0], value[1].value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(x[1] !== null)\n        left = 0\n        right = i\n        // binary search\n        while (left < right) {\n          // middle index\n          pivot = left + ((right - left) >> 1)\n          // compare header name\n          if (array[pivot][0] <= x[0]) {\n            left = pivot + 1\n          } else {\n            right = pivot\n          }\n        }\n        if (i !== pivot) {\n          j = i\n          while (j > left) {\n            array[j] = array[--j]\n          }\n          array[left] = x\n        }\n      }\n      /* c8 ignore next 4 */\n      if (!iterator.next().done) {\n        // This is for debugging and will never be called.\n        throw new TypeError('Unreachable')\n      }\n      return array\n    } else {\n      // This case would be a rare occurrence.\n      // slow-path: fallback\n      let i = 0\n      for (const { 0: name, 1: { value } } of this[kHeadersMap]) {\n        array[i++] = [name, value]\n        // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n        // 3.2.2. Assert: value is non-null.\n        assert(value !== null)\n      }\n      return array.sort(compareHeaderName)\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#headers-class\nclass Headers {\n  #guard\n  #headersList\n\n  constructor (init = undefined) {\n    webidl.util.markAsUncloneable(this)\n\n    if (init === kConstruct) {\n      return\n    }\n\n    this.#headersList = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this.#guard = 'none'\n\n    // 2. If init is given, then fill this with init.\n    if (init !== undefined) {\n      init = webidl.converters.HeadersInit(init, 'Headers contructor', 'init')\n      fill(this, init)\n    }\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-append\n  append (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.append')\n\n    const prefix = 'Headers.append'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    return appendHeader(this, name, value)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-delete\n  delete (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.delete')\n\n    const prefix = 'Headers.delete'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix: 'Headers.delete',\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. If this’s guard is \"immutable\", then throw a TypeError.\n    // 3. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 4. Otherwise, if this’s guard is \"request-no-cors\", name\n    //    is not a no-CORS-safelisted request-header name, and\n    //    name is not a privileged no-CORS request-header name,\n    //    return.\n    // 5. Otherwise, if this’s guard is \"response\" and name is\n    //    a forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 6. If this’s header list does not contain name, then\n    //    return.\n    if (!this.#headersList.contains(name, false)) {\n      return\n    }\n\n    // 7. Delete name from this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this.\n    this.#headersList.delete(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-get\n  get (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.get')\n\n    const prefix = 'Headers.get'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return the result of getting name from this’s header\n    //    list.\n    return this.#headersList.get(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-has\n  has (name) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 1, 'Headers.has')\n\n    const prefix = 'Headers.has'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n\n    // 1. If name is not a header name, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    }\n\n    // 2. Return true if this’s header list contains name;\n    //    otherwise false.\n    return this.#headersList.contains(name, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-set\n  set (name, value) {\n    webidl.brandCheck(this, Headers)\n\n    webidl.argumentLengthCheck(arguments, 2, 'Headers.set')\n\n    const prefix = 'Headers.set'\n    name = webidl.converters.ByteString(name, prefix, 'name')\n    value = webidl.converters.ByteString(value, prefix, 'value')\n\n    // 1. Normalize value.\n    value = headerValueNormalize(value)\n\n    // 2. If name is not a header name or value is not a\n    //    header value, then throw a TypeError.\n    if (!isValidHeaderName(name)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value: name,\n        type: 'header name'\n      })\n    } else if (!isValidHeaderValue(value)) {\n      throw webidl.errors.invalidArgument({\n        prefix,\n        value,\n        type: 'header value'\n      })\n    }\n\n    // 3. If this’s guard is \"immutable\", then throw a TypeError.\n    // 4. Otherwise, if this’s guard is \"request\" and name is a\n    //    forbidden header name, return.\n    // 5. Otherwise, if this’s guard is \"request-no-cors\" and\n    //    name/value is not a no-CORS-safelisted request-header,\n    //    return.\n    // 6. Otherwise, if this’s guard is \"response\" and name is a\n    //    forbidden response-header name, return.\n    // Note: undici does not implement forbidden header names\n    if (this.#guard === 'immutable') {\n      throw new TypeError('immutable')\n    }\n\n    // 7. Set (name, value) in this’s header list.\n    // 8. If this’s guard is \"request-no-cors\", then remove\n    //    privileged no-CORS request headers from this\n    this.#headersList.set(name, value, false)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie\n  getSetCookie () {\n    webidl.brandCheck(this, Headers)\n\n    // 1. If this’s header list does not contain `Set-Cookie`, then return « ».\n    // 2. Return the values of all headers in this’s header list whose name is\n    //    a byte-case-insensitive match for `Set-Cookie`, in order.\n\n    const list = this.#headersList.cookies\n\n    if (list) {\n      return [...list]\n    }\n\n    return []\n  }\n\n  // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine\n  get [kHeadersSortedMap] () {\n    if (this.#headersList[kHeadersSortedMap]) {\n      return this.#headersList[kHeadersSortedMap]\n    }\n\n    // 1. Let headers be an empty list of headers with the key being the name\n    //    and value the value.\n    const headers = []\n\n    // 2. Let names be the result of convert header names to a sorted-lowercase\n    //    set with all the names of the headers in list.\n    const names = this.#headersList.toSortedArray()\n\n    const cookies = this.#headersList.cookies\n\n    // fast-path\n    if (cookies === null || cookies.length === 1) {\n      // Note: The non-null assertion of value has already been done by `HeadersList#toSortedArray`\n      return (this.#headersList[kHeadersSortedMap] = names)\n    }\n\n    // 3. For each name of names:\n    for (let i = 0; i < names.length; ++i) {\n      const { 0: name, 1: value } = names[i]\n      // 1. If name is `set-cookie`, then:\n      if (name === 'set-cookie') {\n        // 1. Let values be a list of all values of headers in list whose name\n        //    is a byte-case-insensitive match for name, in order.\n\n        // 2. For each value of values:\n        // 1. Append (name, value) to headers.\n        for (let j = 0; j < cookies.length; ++j) {\n          headers.push([name, cookies[j]])\n        }\n      } else {\n        // 2. Otherwise:\n\n        // 1. Let value be the result of getting name from list.\n\n        // 2. Assert: value is non-null.\n        // Note: This operation was done by `HeadersList#toSortedArray`.\n\n        // 3. Append (name, value) to headers.\n        headers.push([name, value])\n      }\n    }\n\n    // 4. Return headers.\n    return (this.#headersList[kHeadersSortedMap] = headers)\n  }\n\n  [util.inspect.custom] (depth, options) {\n    options.depth ??= depth\n\n    return `Headers ${util.formatWithOptions(options, this.#headersList.entries)}`\n  }\n\n  static getHeadersGuard (o) {\n    return o.#guard\n  }\n\n  static setHeadersGuard (o, guard) {\n    o.#guard = guard\n  }\n\n  static getHeadersList (o) {\n    return o.#headersList\n  }\n\n  static setHeadersList (o, list) {\n    o.#headersList = list\n  }\n}\n\nconst { getHeadersGuard, setHeadersGuard, getHeadersList, setHeadersList } = Headers\nReflect.deleteProperty(Headers, 'getHeadersGuard')\nReflect.deleteProperty(Headers, 'setHeadersGuard')\nReflect.deleteProperty(Headers, 'getHeadersList')\nReflect.deleteProperty(Headers, 'setHeadersList')\n\niteratorMixin('Headers', Headers, kHeadersSortedMap, 0, 1)\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  getSetCookie: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Headers',\n    configurable: true\n  },\n  [util.inspect.custom]: {\n    enumerable: false\n  }\n})\n\nwebidl.converters.HeadersInit = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === 'Object') {\n    const iterator = Reflect.get(V, Symbol.iterator)\n\n    // A work-around to ensure we send the properly-cased Headers when V is a Headers object.\n    // Read https://github.com/nodejs/undici/pull/3159#issuecomment-2075537226 before touching, please.\n    if (!util.types.isProxy(V) && iterator === Headers.prototype.entries) { // Headers object\n      try {\n        return getHeadersList(V).entriesList\n      } catch {\n        // fall-through\n      }\n    }\n\n    if (typeof iterator === 'function') {\n      return webidl.converters['sequence<sequence<ByteString>>'](V, prefix, argument, iterator.bind(V))\n    }\n\n    return webidl.converters['record<ByteString, ByteString>'](V, prefix, argument)\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix: 'Headers constructor',\n    argument: 'Argument 1',\n    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']\n  })\n}\n\nmodule.exports = {\n  fill,\n  // for test.\n  compareHeaderName,\n  Headers,\n  HeadersList,\n  getHeadersGuard,\n  setHeadersGuard,\n  setHeadersList,\n  getHeadersList\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaGVhZGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNuRCxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDcEIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxRUFBVTtBQUNyQyxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLDRCQUFXOztBQUVoQztBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGNBQWM7QUFDbkYsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxFQUFFLFVBQVUsRUFBRSxNQUFNO0FBQ25ELE9BQU87QUFDUCxNQUFNO0FBQ04sNkNBQTZDLGFBQWE7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsY0FBYyxVQUFVO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsbUJBQW1CLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYyxVQUFVO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQiwyREFBMkQ7QUFDakY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxtRUFBbUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXGhlYWRlcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL0V0aGFuLUFycm93b29kL3VuZGljaS1mZXRjaFxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBrQ29uc3RydWN0IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3N5bWJvbHMnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qge1xuICBpdGVyYXRvck1peGluLFxuICBpc1ZhbGlkSGVhZGVyTmFtZSxcbiAgaXNWYWxpZEhlYWRlclZhbHVlXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuL3dlYmlkbCcpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdub2RlOmFzc2VydCcpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcblxuY29uc3Qga0hlYWRlcnNNYXAgPSBTeW1ib2woJ2hlYWRlcnMgbWFwJylcbmNvbnN0IGtIZWFkZXJzU29ydGVkTWFwID0gU3ltYm9sKCdoZWFkZXJzIG1hcCBzb3J0ZWQnKVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlXG4gKi9cbmZ1bmN0aW9uIGlzSFRUUFdoaXRlU3BhY2VDaGFyQ29kZSAoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMHgwMGEgfHwgY29kZSA9PT0gMHgwMGQgfHwgY29kZSA9PT0gMHgwMDkgfHwgY29kZSA9PT0gMHgwMjBcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci12YWx1ZS1ub3JtYWxpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwb3RlbnRpYWxWYWx1ZVxuICovXG5mdW5jdGlvbiBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSAocG90ZW50aWFsVmFsdWUpIHtcbiAgLy8gIFRvIG5vcm1hbGl6ZSBhIGJ5dGUgc2VxdWVuY2UgcG90ZW50aWFsVmFsdWUsIHJlbW92ZVxuICAvLyAgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEhUVFAgd2hpdGVzcGFjZSBieXRlcyBmcm9tXG4gIC8vICBwb3RlbnRpYWxWYWx1ZS5cbiAgbGV0IGkgPSAwOyBsZXQgaiA9IHBvdGVudGlhbFZhbHVlLmxlbmd0aFxuXG4gIHdoaWxlIChqID4gaSAmJiBpc0hUVFBXaGl0ZVNwYWNlQ2hhckNvZGUocG90ZW50aWFsVmFsdWUuY2hhckNvZGVBdChqIC0gMSkpKSAtLWpcbiAgd2hpbGUgKGogPiBpICYmIGlzSFRUUFdoaXRlU3BhY2VDaGFyQ29kZShwb3RlbnRpYWxWYWx1ZS5jaGFyQ29kZUF0KGkpKSkgKytpXG5cbiAgcmV0dXJuIGkgPT09IDAgJiYgaiA9PT0gcG90ZW50aWFsVmFsdWUubGVuZ3RoID8gcG90ZW50aWFsVmFsdWUgOiBwb3RlbnRpYWxWYWx1ZS5zdWJzdHJpbmcoaSwgailcbn1cblxuZnVuY3Rpb24gZmlsbCAoaGVhZGVycywgb2JqZWN0KSB7XG4gIC8vIFRvIGZpbGwgYSBIZWFkZXJzIG9iamVjdCBoZWFkZXJzIHdpdGggYSBnaXZlbiBvYmplY3Qgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gSWYgb2JqZWN0IGlzIGEgc2VxdWVuY2UsIHRoZW4gZm9yIGVhY2ggaGVhZGVyIGluIG9iamVjdDpcbiAgLy8gTm90ZTogd2ViaWRsIGNvbnZlcnNpb24gdG8gYXJyYXkgaGFzIGFscmVhZHkgYmVlbiBkb25lLlxuICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGhlYWRlciA9IG9iamVjdFtpXVxuICAgICAgLy8gMS4gSWYgaGVhZGVyIGRvZXMgbm90IGNvbnRhaW4gZXhhY3RseSB0d28gaXRlbXMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgaGVhZGVyOiAnSGVhZGVycyBjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgbWVzc2FnZTogYGV4cGVjdGVkIG5hbWUvdmFsdWUgcGFpciB0byBiZSBsZW5ndGggMiwgZm91bmQgJHtoZWFkZXIubGVuZ3RofS5gXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEFwcGVuZCAoaGVhZGVy4oCZcyBmaXJzdCBpdGVtLCBoZWFkZXLigJlzIHNlY29uZCBpdGVtKSB0byBoZWFkZXJzLlxuICAgICAgYXBwZW5kSGVhZGVyKGhlYWRlcnMsIGhlYWRlclswXSwgaGVhZGVyWzFdKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICAvLyBOb3RlOiBudWxsIHNob3VsZCB0aHJvd1xuXG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBvYmplY3QgaXMgYSByZWNvcmQsIHRoZW4gZm9yIGVhY2gga2V5IOKGkiB2YWx1ZSBpbiBvYmplY3QsXG4gICAgLy8gICAgYXBwZW5kIChrZXksIHZhbHVlKSB0byBoZWFkZXJzXG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFwcGVuZEhlYWRlcihoZWFkZXJzLCBrZXlzW2ldLCBvYmplY3Rba2V5c1tpXV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgICBwcmVmaXg6ICdIZWFkZXJzIGNvbnN0cnVjdG9yJyxcbiAgICAgIGFyZ3VtZW50OiAnQXJndW1lbnQgMScsXG4gICAgICB0eXBlczogWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nLCAncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J11cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXJzLWFwcGVuZFxuICovXG5mdW5jdGlvbiBhcHBlbmRIZWFkZXIgKGhlYWRlcnMsIG5hbWUsIHZhbHVlKSB7XG4gIC8vIDEuIE5vcm1hbGl6ZSB2YWx1ZS5cbiAgdmFsdWUgPSBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSh2YWx1ZSlcblxuICAvLyAyLiBJZiBuYW1lIGlzIG5vdCBhIGhlYWRlciBuYW1lIG9yIHZhbHVlIGlzIG5vdCBhXG4gIC8vICAgIGhlYWRlciB2YWx1ZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgIHByZWZpeDogJ0hlYWRlcnMuYXBwZW5kJyxcbiAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgdHlwZTogJ2hlYWRlciBuYW1lJ1xuICAgIH0pXG4gIH0gZWxzZSBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmludmFsaWRBcmd1bWVudCh7XG4gICAgICBwcmVmaXg6ICdIZWFkZXJzLmFwcGVuZCcsXG4gICAgICB2YWx1ZSxcbiAgICAgIHR5cGU6ICdoZWFkZXIgdmFsdWUnXG4gICAgfSlcbiAgfVxuXG4gIC8vIDMuIElmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwiaW1tdXRhYmxlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIC8vIDQuIE90aGVyd2lzZSwgaWYgaGVhZGVyc+KAmXMgZ3VhcmQgaXMgXCJyZXF1ZXN0XCIgYW5kIG5hbWUgaXMgYVxuICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgLy8gNS4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiOlxuICAvLyAgICBUT0RPXG4gIC8vIE5vdGU6IHVuZGljaSBkb2VzIG5vdCBpbXBsZW1lbnQgZm9yYmlkZGVuIGhlYWRlciBuYW1lc1xuICBpZiAoZ2V0SGVhZGVyc0d1YXJkKGhlYWRlcnMpID09PSAnaW1tdXRhYmxlJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ltbXV0YWJsZScpXG4gIH1cblxuICAvLyA2LiBPdGhlcndpc2UsIGlmIGhlYWRlcnPigJlzIGd1YXJkIGlzIFwicmVzcG9uc2VcIiBhbmQgbmFtZSBpcyBhXG4gIC8vICAgIGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZSwgcmV0dXJuLlxuXG4gIC8vIDcuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGhlYWRlcnPigJlzIGhlYWRlciBsaXN0LlxuICByZXR1cm4gZ2V0SGVhZGVyc0xpc3QoaGVhZGVycykuYXBwZW5kKG5hbWUsIHZhbHVlLCBmYWxzZSlcblxuICAvLyA4LiBJZiBoZWFkZXJz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAvLyAgICBwcml2aWxlZ2VkIG5vLUNPUlMgcmVxdWVzdCBoZWFkZXJzIGZyb20gaGVhZGVyc1xufVxuXG5mdW5jdGlvbiBjb21wYXJlSGVhZGVyTmFtZSAoYSwgYikge1xuICByZXR1cm4gYVswXSA8IGJbMF0gPyAtMSA6IDFcbn1cblxuY2xhc3MgSGVhZGVyc0xpc3Qge1xuICAvKiogQHR5cGUge1tzdHJpbmcsIHN0cmluZ11bXXxudWxsfSAqL1xuICBjb29raWVzID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yIChpbml0KSB7XG4gICAgaWYgKGluaXQgaW5zdGFuY2VvZiBIZWFkZXJzTGlzdCkge1xuICAgICAgdGhpc1trSGVhZGVyc01hcF0gPSBuZXcgTWFwKGluaXRba0hlYWRlcnNNYXBdKVxuICAgICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBpbml0W2tIZWFkZXJzU29ydGVkTWFwXVxuICAgICAgdGhpcy5jb29raWVzID0gaW5pdC5jb29raWVzID09PSBudWxsID8gbnVsbCA6IFsuLi5pbml0LmNvb2tpZXNdXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdID0gbmV3IE1hcChpbml0KVxuICAgICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci1saXN0LWNvbnRhaW5zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICovXG4gIGNvbnRhaW5zIChuYW1lLCBpc0xvd2VyQ2FzZSkge1xuICAgIC8vIEEgaGVhZGVyIGxpc3QgbGlzdCBjb250YWlucyBhIGhlYWRlciBuYW1lIG5hbWUgaWYgbGlzdFxuICAgIC8vIGNvbnRhaW5zIGEgaGVhZGVyIHdob3NlIG5hbWUgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmVcbiAgICAvLyBtYXRjaCBmb3IgbmFtZS5cblxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS5oYXMoaXNMb3dlckNhc2UgPyBuYW1lIDogbmFtZS50b0xvd2VyQ2FzZSgpKVxuICB9XG5cbiAgY2xlYXIgKCkge1xuICAgIHRoaXNba0hlYWRlcnNNYXBdLmNsZWFyKClcbiAgICB0aGlzW2tIZWFkZXJzU29ydGVkTWFwXSA9IG51bGxcbiAgICB0aGlzLmNvb2tpZXMgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1hcHBlbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb3dlckNhc2VcbiAgICovXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUsIGlzTG93ZXJDYXNlKSB7XG4gICAgdGhpc1trSGVhZGVyc1NvcnRlZE1hcF0gPSBudWxsXG5cbiAgICAvLyAxLiBJZiBsaXN0IGNvbnRhaW5zIG5hbWUsIHRoZW4gc2V0IG5hbWUgdG8gdGhlIGZpcnN0IHN1Y2hcbiAgICAvLyAgICBoZWFkZXLigJlzIG5hbWUuXG4gICAgY29uc3QgbG93ZXJjYXNlTmFtZSA9IGlzTG93ZXJDYXNlID8gbmFtZSA6IG5hbWUudG9Mb3dlckNhc2UoKVxuICAgIGNvbnN0IGV4aXN0cyA9IHRoaXNba0hlYWRlcnNNYXBdLmdldChsb3dlcmNhc2VOYW1lKVxuXG4gICAgLy8gMi4gQXBwZW5kIChuYW1lLCB2YWx1ZSkgdG8gbGlzdC5cbiAgICBpZiAoZXhpc3RzKSB7XG4gICAgICBjb25zdCBkZWxpbWl0ZXIgPSBsb3dlcmNhc2VOYW1lID09PSAnY29va2llJyA/ICc7ICcgOiAnLCAnXG4gICAgICB0aGlzW2tIZWFkZXJzTWFwXS5zZXQobG93ZXJjYXNlTmFtZSwge1xuICAgICAgICBuYW1lOiBleGlzdHMubmFtZSxcbiAgICAgICAgdmFsdWU6IGAke2V4aXN0cy52YWx1ZX0ke2RlbGltaXRlcn0ke3ZhbHVlfWBcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0hlYWRlcnNNYXBdLnNldChsb3dlcmNhc2VOYW1lLCB7IG5hbWUsIHZhbHVlIH0pXG4gICAgfVxuXG4gICAgaWYgKGxvd2VyY2FzZU5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgKHRoaXMuY29va2llcyA/Pz0gW10pLnB1c2godmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqL1xuICBzZXQgKG5hbWUsIHZhbHVlLCBpc0xvd2VyQ2FzZSkge1xuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIGNvbnN0IGxvd2VyY2FzZU5hbWUgPSBpc0xvd2VyQ2FzZSA/IG5hbWUgOiBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGlmIChsb3dlcmNhc2VOYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHRoaXMuY29va2llcyA9IFt2YWx1ZV1cbiAgICB9XG5cbiAgICAvLyAxLiBJZiBsaXN0IGNvbnRhaW5zIG5hbWUsIHRoZW4gc2V0IHRoZSB2YWx1ZSBvZlxuICAgIC8vICAgIHRoZSBmaXJzdCBzdWNoIGhlYWRlciB0byB2YWx1ZSBhbmQgcmVtb3ZlIHRoZVxuICAgIC8vICAgIG90aGVycy5cbiAgICAvLyAyLiBPdGhlcndpc2UsIGFwcGVuZCBoZWFkZXIgKG5hbWUsIHZhbHVlKSB0byBsaXN0LlxuICAgIHRoaXNba0hlYWRlcnNNYXBdLnNldChsb3dlcmNhc2VOYW1lLCB7IG5hbWUsIHZhbHVlIH0pXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1kZWxldGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBpc0xvd2VyQ2FzZVxuICAgKi9cbiAgZGVsZXRlIChuYW1lLCBpc0xvd2VyQ2FzZSkge1xuICAgIHRoaXNba0hlYWRlcnNTb3J0ZWRNYXBdID0gbnVsbFxuICAgIGlmICghaXNMb3dlckNhc2UpIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKClcblxuICAgIGlmIChuYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgIHRoaXMuY29va2llcyA9IG51bGxcbiAgICB9XG5cbiAgICB0aGlzW2tIZWFkZXJzTWFwXS5kZWxldGUobmFtZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1saXN0LWdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTG93ZXJDYXNlXG4gICAqIEByZXR1cm5zIHtzdHJpbmcgfCBudWxsfVxuICAgKi9cbiAgZ2V0IChuYW1lLCBpc0xvd2VyQ2FzZSkge1xuICAgIC8vIDEuIElmIGxpc3QgZG9lcyBub3QgY29udGFpbiBuYW1lLCB0aGVuIHJldHVybiBudWxsLlxuICAgIC8vIDIuIFJldHVybiB0aGUgdmFsdWVzIG9mIGFsbCBoZWFkZXJzIGluIGxpc3Qgd2hvc2UgbmFtZVxuICAgIC8vICAgIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBuYW1lLFxuICAgIC8vICAgIHNlcGFyYXRlZCBmcm9tIGVhY2ggb3RoZXIgYnkgMHgyQyAweDIwLCBpbiBvcmRlci5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc01hcF0uZ2V0KGlzTG93ZXJDYXNlID8gbmFtZSA6IG5hbWUudG9Mb3dlckNhc2UoKSk/LnZhbHVlID8/IG51bGxcbiAgfVxuXG4gICogW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIC8vIHVzZSB0aGUgbG93ZXJjYXNlZCBuYW1lXG4gICAgZm9yIChjb25zdCB7IDA6IG5hbWUsIDE6IHsgdmFsdWUgfSB9IG9mIHRoaXNba0hlYWRlcnNNYXBdKSB7XG4gICAgICB5aWVsZCBbbmFtZSwgdmFsdWVdXG4gICAgfVxuICB9XG5cbiAgZ2V0IGVudHJpZXMgKCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fVxuXG4gICAgaWYgKHRoaXNba0hlYWRlcnNNYXBdLnNpemUgIT09IDApIHtcbiAgICAgIGZvciAoY29uc3QgeyBuYW1lLCB2YWx1ZSB9IG9mIHRoaXNba0hlYWRlcnNNYXBdLnZhbHVlcygpKSB7XG4gICAgICAgIGhlYWRlcnNbbmFtZV0gPSB2YWx1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICByYXdWYWx1ZXMgKCkge1xuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzTWFwXS52YWx1ZXMoKVxuICB9XG5cbiAgZ2V0IGVudHJpZXNMaXN0ICgpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gW11cblxuICAgIGlmICh0aGlzW2tIZWFkZXJzTWFwXS5zaXplICE9PSAwKSB7XG4gICAgICBmb3IgKGNvbnN0IHsgMDogbG93ZXJOYW1lLCAxOiB7IG5hbWUsIHZhbHVlIH0gfSBvZiB0aGlzW2tIZWFkZXJzTWFwXSkge1xuICAgICAgICBpZiAobG93ZXJOYW1lID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGNvb2tpZSBvZiB0aGlzLmNvb2tpZXMpIHtcbiAgICAgICAgICAgIGhlYWRlcnMucHVzaChbbmFtZSwgY29va2llXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZGVycy5wdXNoKFtuYW1lLCB2YWx1ZV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbnZlcnQtaGVhZGVyLW5hbWVzLXRvLWEtc29ydGVkLWxvd2VyY2FzZS1zZXRcbiAgdG9Tb3J0ZWRBcnJheSAoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXNba0hlYWRlcnNNYXBdLnNpemVcbiAgICBjb25zdCBhcnJheSA9IG5ldyBBcnJheShzaXplKVxuICAgIC8vIEluIG1vc3QgY2FzZXMsIHlvdSB3aWxsIHVzZSB0aGUgZmFzdC1wYXRoLlxuICAgIC8vIGZhc3QtcGF0aDogVXNlIGJpbmFyeSBpbnNlcnRpb24gc29ydCBmb3Igc21hbGwgYXJyYXlzLlxuICAgIGlmIChzaXplIDw9IDMyKSB7XG4gICAgICBpZiAoc2l6ZSA9PT0gMCkge1xuICAgICAgICAvLyBJZiBlbXB0eSwgaXQgaXMgYW4gZW1wdHkgYXJyYXkuIFRvIGF2b2lkIHRoZSBmaXJzdCBpbmRleCBhc3NpZ25tZW50LlxuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICAgIH1cbiAgICAgIC8vIEltcHJvdmUgcGVyZm9ybWFuY2UgYnkgdW5yb2xsaW5nIGxvb3AgYW5kIGF2b2lkaW5nIGRvdWJsZS1sb29wLlxuICAgICAgLy8gRG91YmxlLWxvb3AtbGVzcyB2ZXJzaW9uIG9mIHRoZSBiaW5hcnkgaW5zZXJ0aW9uIHNvcnQuXG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXNba0hlYWRlcnNNYXBdW1N5bWJvbC5pdGVyYXRvcl0oKVxuICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZVxuICAgICAgLy8gc2V0IFtuYW1lLCB2YWx1ZV0gdG8gZmlyc3QgaW5kZXguXG4gICAgICBhcnJheVswXSA9IFtmaXJzdFZhbHVlWzBdLCBmaXJzdFZhbHVlWzFdLnZhbHVlXVxuICAgICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3Qtc29ydC1hbmQtY29tYmluZVxuICAgICAgLy8gMy4yLjIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICBhc3NlcnQoZmlyc3RWYWx1ZVsxXS52YWx1ZSAhPT0gbnVsbClcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBpID0gMSwgaiA9IDAsIHJpZ2h0ID0gMCwgbGVmdCA9IDAsIHBpdm90ID0gMCwgeCwgdmFsdWU7XG4gICAgICAgIGkgPCBzaXplO1xuICAgICAgICArK2lcbiAgICAgICkge1xuICAgICAgICAvLyBnZXQgbmV4dCB2YWx1ZVxuICAgICAgICB2YWx1ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZVxuICAgICAgICAvLyBzZXQgW25hbWUsIHZhbHVlXSB0byBjdXJyZW50IGluZGV4LlxuICAgICAgICB4ID0gYXJyYXlbaV0gPSBbdmFsdWVbMF0sIHZhbHVlWzFdLnZhbHVlXVxuICAgICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gICAgICAgIC8vIDMuMi4yLiBBc3NlcnQ6IHZhbHVlIGlzIG5vbi1udWxsLlxuICAgICAgICBhc3NlcnQoeFsxXSAhPT0gbnVsbClcbiAgICAgICAgbGVmdCA9IDBcbiAgICAgICAgcmlnaHQgPSBpXG4gICAgICAgIC8vIGJpbmFyeSBzZWFyY2hcbiAgICAgICAgd2hpbGUgKGxlZnQgPCByaWdodCkge1xuICAgICAgICAgIC8vIG1pZGRsZSBpbmRleFxuICAgICAgICAgIHBpdm90ID0gbGVmdCArICgocmlnaHQgLSBsZWZ0KSA+PiAxKVxuICAgICAgICAgIC8vIGNvbXBhcmUgaGVhZGVyIG5hbWVcbiAgICAgICAgICBpZiAoYXJyYXlbcGl2b3RdWzBdIDw9IHhbMF0pIHtcbiAgICAgICAgICAgIGxlZnQgPSBwaXZvdCArIDFcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmlnaHQgPSBwaXZvdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSAhPT0gcGl2b3QpIHtcbiAgICAgICAgICBqID0gaVxuICAgICAgICAgIHdoaWxlIChqID4gbGVmdCkge1xuICAgICAgICAgICAgYXJyYXlbal0gPSBhcnJheVstLWpdXG4gICAgICAgICAgfVxuICAgICAgICAgIGFycmF5W2xlZnRdID0geFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBjOCBpZ25vcmUgbmV4dCA0ICovXG4gICAgICBpZiAoIWl0ZXJhdG9yLm5leHQoKS5kb25lKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgZm9yIGRlYnVnZ2luZyBhbmQgd2lsbCBuZXZlciBiZSBjYWxsZWQuXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VucmVhY2hhYmxlJylcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGNhc2Ugd291bGQgYmUgYSByYXJlIG9jY3VycmVuY2UuXG4gICAgICAvLyBzbG93LXBhdGg6IGZhbGxiYWNrXG4gICAgICBsZXQgaSA9IDBcbiAgICAgIGZvciAoY29uc3QgeyAwOiBuYW1lLCAxOiB7IHZhbHVlIH0gfSBvZiB0aGlzW2tIZWFkZXJzTWFwXSkge1xuICAgICAgICBhcnJheVtpKytdID0gW25hbWUsIHZhbHVlXVxuICAgICAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gICAgICAgIC8vIDMuMi4yLiBBc3NlcnQ6IHZhbHVlIGlzIG5vbi1udWxsLlxuICAgICAgICBhc3NlcnQodmFsdWUgIT09IG51bGwpXG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXkuc29ydChjb21wYXJlSGVhZGVyTmFtZSlcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlcnMtY2xhc3NcbmNsYXNzIEhlYWRlcnMge1xuICAjZ3VhcmRcbiAgI2hlYWRlcnNMaXN0XG5cbiAgY29uc3RydWN0b3IgKGluaXQgPSB1bmRlZmluZWQpIHtcbiAgICB3ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSh0aGlzKVxuXG4gICAgaWYgKGluaXQgPT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuI2hlYWRlcnNMaXN0ID0gbmV3IEhlYWRlcnNMaXN0KClcblxuICAgIC8vIFRoZSBuZXcgSGVhZGVycyhpbml0KSBjb25zdHJ1Y3RvciBzdGVwcyBhcmU6XG5cbiAgICAvLyAxLiBTZXQgdGhpc+KAmXMgZ3VhcmQgdG8gXCJub25lXCIuXG4gICAgdGhpcy4jZ3VhcmQgPSAnbm9uZSdcblxuICAgIC8vIDIuIElmIGluaXQgaXMgZ2l2ZW4sIHRoZW4gZmlsbCB0aGlzIHdpdGggaW5pdC5cbiAgICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbml0ID0gd2ViaWRsLmNvbnZlcnRlcnMuSGVhZGVyc0luaXQoaW5pdCwgJ0hlYWRlcnMgY29udHJ1Y3RvcicsICdpbml0JylcbiAgICAgIGZpbGwodGhpcywgaW5pdClcbiAgICB9XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLWhlYWRlcnMtYXBwZW5kXG4gIGFwcGVuZCAobmFtZSwgdmFsdWUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBIZWFkZXJzKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAyLCAnSGVhZGVycy5hcHBlbmQnKVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ0hlYWRlcnMuYXBwZW5kJ1xuICAgIG5hbWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKG5hbWUsIHByZWZpeCwgJ25hbWUnKVxuICAgIHZhbHVlID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyh2YWx1ZSwgcHJlZml4LCAndmFsdWUnKVxuXG4gICAgcmV0dXJuIGFwcGVuZEhlYWRlcih0aGlzLCBuYW1lLCB2YWx1ZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1kZWxldGVcbiAgZGVsZXRlIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0hlYWRlcnMuZGVsZXRlJylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdIZWFkZXJzLmRlbGV0ZSdcbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcblxuICAgIC8vIDEuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXg6ICdIZWFkZXJzLmRlbGV0ZScsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIElmIHRoaXPigJlzIGd1YXJkIGlzIFwiaW1tdXRhYmxlXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3RcIiBhbmQgbmFtZSBpcyBhXG4gICAgLy8gICAgZm9yYmlkZGVuIGhlYWRlciBuYW1lLCByZXR1cm4uXG4gICAgLy8gNC4gT3RoZXJ3aXNlLCBpZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCBuYW1lXG4gICAgLy8gICAgaXMgbm90IGEgbm8tQ09SUy1zYWZlbGlzdGVkIHJlcXVlc3QtaGVhZGVyIG5hbWUsIGFuZFxuICAgIC8vICAgIG5hbWUgaXMgbm90IGEgcHJpdmlsZWdlZCBuby1DT1JTIHJlcXVlc3QtaGVhZGVyIG5hbWUsXG4gICAgLy8gICAgcmV0dXJuLlxuICAgIC8vIDUuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXNwb25zZVwiIGFuZCBuYW1lIGlzXG4gICAgLy8gICAgYSBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiBoZWFkZXIgbmFtZXNcbiAgICBpZiAodGhpcy4jZ3VhcmQgPT09ICdpbW11dGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbW11dGFibGUnKVxuICAgIH1cblxuICAgIC8vIDYuIElmIHRoaXPigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gbmFtZSwgdGhlblxuICAgIC8vICAgIHJldHVybi5cbiAgICBpZiAoIXRoaXMuI2hlYWRlcnNMaXN0LmNvbnRhaW5zKG5hbWUsIGZhbHNlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gNy4gRGVsZXRlIG5hbWUgZnJvbSB0aGlz4oCZcyBoZWFkZXIgbGlzdC5cbiAgICAvLyA4LiBJZiB0aGlz4oCZcyBndWFyZCBpcyBcInJlcXVlc3Qtbm8tY29yc1wiLCB0aGVuIHJlbW92ZVxuICAgIC8vICAgIHByaXZpbGVnZWQgbm8tQ09SUyByZXF1ZXN0IGhlYWRlcnMgZnJvbSB0aGlzLlxuICAgIHRoaXMuI2hlYWRlcnNMaXN0LmRlbGV0ZShuYW1lLCBmYWxzZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1nZXRcbiAgZ2V0IChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0hlYWRlcnMuZ2V0JylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdIZWFkZXJzLmdldCdcbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcblxuICAgIC8vIDEuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIGdldHRpbmcgbmFtZSBmcm9tIHRoaXPigJlzIGhlYWRlclxuICAgIC8vICAgIGxpc3QuXG4gICAgcmV0dXJuIHRoaXMuI2hlYWRlcnNMaXN0LmdldChuYW1lLCBmYWxzZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1oYXNcbiAgaGFzIChuYW1lKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgSGVhZGVycylcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0hlYWRlcnMuaGFzJylcblxuICAgIGNvbnN0IHByZWZpeCA9ICdIZWFkZXJzLmhhcydcbiAgICBuYW1lID0gd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyhuYW1lLCBwcmVmaXgsICduYW1lJylcblxuICAgIC8vIDEuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFJldHVybiB0cnVlIGlmIHRoaXPigJlzIGhlYWRlciBsaXN0IGNvbnRhaW5zIG5hbWU7XG4gICAgLy8gICAgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzLiNoZWFkZXJzTGlzdC5jb250YWlucyhuYW1lLCBmYWxzZSlcbiAgfVxuXG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20taGVhZGVycy1zZXRcbiAgc2V0IChuYW1lLCB2YWx1ZSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDIsICdIZWFkZXJzLnNldCcpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnSGVhZGVycy5zZXQnXG4gICAgbmFtZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJ5dGVTdHJpbmcobmFtZSwgcHJlZml4LCAnbmFtZScpXG4gICAgdmFsdWUgPSB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nKHZhbHVlLCBwcmVmaXgsICd2YWx1ZScpXG5cbiAgICAvLyAxLiBOb3JtYWxpemUgdmFsdWUuXG4gICAgdmFsdWUgPSBoZWFkZXJWYWx1ZU5vcm1hbGl6ZSh2YWx1ZSlcblxuICAgIC8vIDIuIElmIG5hbWUgaXMgbm90IGEgaGVhZGVyIG5hbWUgb3IgdmFsdWUgaXMgbm90IGFcbiAgICAvLyAgICBoZWFkZXIgdmFsdWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKCFpc1ZhbGlkSGVhZGVyTmFtZShuYW1lKSkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5pbnZhbGlkQXJndW1lbnQoe1xuICAgICAgICBwcmVmaXgsXG4gICAgICAgIHZhbHVlOiBuYW1lLFxuICAgICAgICB0eXBlOiAnaGVhZGVyIG5hbWUnXG4gICAgICB9KVxuICAgIH0gZWxzZSBpZiAoIWlzVmFsaWRIZWFkZXJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50KHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogJ2hlYWRlciB2YWx1ZSdcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJpbW11dGFibGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyA0LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdFwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyA1LiBPdGhlcndpc2UsIGlmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIgYW5kXG4gICAgLy8gICAgbmFtZS92YWx1ZSBpcyBub3QgYSBuby1DT1JTLXNhZmVsaXN0ZWQgcmVxdWVzdC1oZWFkZXIsXG4gICAgLy8gICAgcmV0dXJuLlxuICAgIC8vIDYuIE90aGVyd2lzZSwgaWYgdGhpc+KAmXMgZ3VhcmQgaXMgXCJyZXNwb25zZVwiIGFuZCBuYW1lIGlzIGFcbiAgICAvLyAgICBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUsIHJldHVybi5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiBoZWFkZXIgbmFtZXNcbiAgICBpZiAodGhpcy4jZ3VhcmQgPT09ICdpbW11dGFibGUnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbW11dGFibGUnKVxuICAgIH1cblxuICAgIC8vIDcuIFNldCAobmFtZSwgdmFsdWUpIGluIHRoaXPigJlzIGhlYWRlciBsaXN0LlxuICAgIC8vIDguIElmIHRoaXPigJlzIGd1YXJkIGlzIFwicmVxdWVzdC1uby1jb3JzXCIsIHRoZW4gcmVtb3ZlXG4gICAgLy8gICAgcHJpdmlsZWdlZCBuby1DT1JTIHJlcXVlc3QgaGVhZGVycyBmcm9tIHRoaXNcbiAgICB0aGlzLiNoZWFkZXJzTGlzdC5zZXQobmFtZSwgdmFsdWUsIGZhbHNlKVxuICB9XG5cbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1oZWFkZXJzLWdldHNldGNvb2tpZVxuICBnZXRTZXRDb29raWUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEhlYWRlcnMpXG5cbiAgICAvLyAxLiBJZiB0aGlz4oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBTZXQtQ29va2llYCwgdGhlbiByZXR1cm4gwqsgwrsuXG4gICAgLy8gMi4gUmV0dXJuIHRoZSB2YWx1ZXMgb2YgYWxsIGhlYWRlcnMgaW4gdGhpc+KAmXMgaGVhZGVyIGxpc3Qgd2hvc2UgbmFtZSBpc1xuICAgIC8vICAgIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBgU2V0LUNvb2tpZWAsIGluIG9yZGVyLlxuXG4gICAgY29uc3QgbGlzdCA9IHRoaXMuI2hlYWRlcnNMaXN0LmNvb2tpZXNcblxuICAgIGlmIChsaXN0KSB7XG4gICAgICByZXR1cm4gWy4uLmxpc3RdXG4gICAgfVxuXG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1oZWFkZXItbGlzdC1zb3J0LWFuZC1jb21iaW5lXG4gIGdldCBba0hlYWRlcnNTb3J0ZWRNYXBdICgpIHtcbiAgICBpZiAodGhpcy4jaGVhZGVyc0xpc3Rba0hlYWRlcnNTb3J0ZWRNYXBdKSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGVhZGVyc0xpc3Rba0hlYWRlcnNTb3J0ZWRNYXBdXG4gICAgfVxuXG4gICAgLy8gMS4gTGV0IGhlYWRlcnMgYmUgYW4gZW1wdHkgbGlzdCBvZiBoZWFkZXJzIHdpdGggdGhlIGtleSBiZWluZyB0aGUgbmFtZVxuICAgIC8vICAgIGFuZCB2YWx1ZSB0aGUgdmFsdWUuXG4gICAgY29uc3QgaGVhZGVycyA9IFtdXG5cbiAgICAvLyAyLiBMZXQgbmFtZXMgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0IGhlYWRlciBuYW1lcyB0byBhIHNvcnRlZC1sb3dlcmNhc2VcbiAgICAvLyAgICBzZXQgd2l0aCBhbGwgdGhlIG5hbWVzIG9mIHRoZSBoZWFkZXJzIGluIGxpc3QuXG4gICAgY29uc3QgbmFtZXMgPSB0aGlzLiNoZWFkZXJzTGlzdC50b1NvcnRlZEFycmF5KClcblxuICAgIGNvbnN0IGNvb2tpZXMgPSB0aGlzLiNoZWFkZXJzTGlzdC5jb29raWVzXG5cbiAgICAvLyBmYXN0LXBhdGhcbiAgICBpZiAoY29va2llcyA9PT0gbnVsbCB8fCBjb29raWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gTm90ZTogVGhlIG5vbi1udWxsIGFzc2VydGlvbiBvZiB2YWx1ZSBoYXMgYWxyZWFkeSBiZWVuIGRvbmUgYnkgYEhlYWRlcnNMaXN0I3RvU29ydGVkQXJyYXlgXG4gICAgICByZXR1cm4gKHRoaXMuI2hlYWRlcnNMaXN0W2tIZWFkZXJzU29ydGVkTWFwXSA9IG5hbWVzKVxuICAgIH1cblxuICAgIC8vIDMuIEZvciBlYWNoIG5hbWUgb2YgbmFtZXM6XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgeyAwOiBuYW1lLCAxOiB2YWx1ZSB9ID0gbmFtZXNbaV1cbiAgICAgIC8vIDEuIElmIG5hbWUgaXMgYHNldC1jb29raWVgLCB0aGVuOlxuICAgICAgaWYgKG5hbWUgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICAvLyAxLiBMZXQgdmFsdWVzIGJlIGEgbGlzdCBvZiBhbGwgdmFsdWVzIG9mIGhlYWRlcnMgaW4gbGlzdCB3aG9zZSBuYW1lXG4gICAgICAgIC8vICAgIGlzIGEgYnl0ZS1jYXNlLWluc2Vuc2l0aXZlIG1hdGNoIGZvciBuYW1lLCBpbiBvcmRlci5cblxuICAgICAgICAvLyAyLiBGb3IgZWFjaCB2YWx1ZSBvZiB2YWx1ZXM6XG4gICAgICAgIC8vIDEuIEFwcGVuZCAobmFtZSwgdmFsdWUpIHRvIGhlYWRlcnMuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29va2llcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgIGhlYWRlcnMucHVzaChbbmFtZSwgY29va2llc1tqXV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDIuIE90aGVyd2lzZTpcblxuICAgICAgICAvLyAxLiBMZXQgdmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIG5hbWUgZnJvbSBsaXN0LlxuXG4gICAgICAgIC8vIDIuIEFzc2VydDogdmFsdWUgaXMgbm9uLW51bGwuXG4gICAgICAgIC8vIE5vdGU6IFRoaXMgb3BlcmF0aW9uIHdhcyBkb25lIGJ5IGBIZWFkZXJzTGlzdCN0b1NvcnRlZEFycmF5YC5cblxuICAgICAgICAvLyAzLiBBcHBlbmQgKG5hbWUsIHZhbHVlKSB0byBoZWFkZXJzLlxuICAgICAgICBoZWFkZXJzLnB1c2goW25hbWUsIHZhbHVlXSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4gaGVhZGVycy5cbiAgICByZXR1cm4gKHRoaXMuI2hlYWRlcnNMaXN0W2tIZWFkZXJzU29ydGVkTWFwXSA9IGhlYWRlcnMpXG4gIH1cblxuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0gKGRlcHRoLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5kZXB0aCA/Pz0gZGVwdGhcblxuICAgIHJldHVybiBgSGVhZGVycyAke3V0aWwuZm9ybWF0V2l0aE9wdGlvbnMob3B0aW9ucywgdGhpcy4jaGVhZGVyc0xpc3QuZW50cmllcyl9YFxuICB9XG5cbiAgc3RhdGljIGdldEhlYWRlcnNHdWFyZCAobykge1xuICAgIHJldHVybiBvLiNndWFyZFxuICB9XG5cbiAgc3RhdGljIHNldEhlYWRlcnNHdWFyZCAobywgZ3VhcmQpIHtcbiAgICBvLiNndWFyZCA9IGd1YXJkXG4gIH1cblxuICBzdGF0aWMgZ2V0SGVhZGVyc0xpc3QgKG8pIHtcbiAgICByZXR1cm4gby4jaGVhZGVyc0xpc3RcbiAgfVxuXG4gIHN0YXRpYyBzZXRIZWFkZXJzTGlzdCAobywgbGlzdCkge1xuICAgIG8uI2hlYWRlcnNMaXN0ID0gbGlzdFxuICB9XG59XG5cbmNvbnN0IHsgZ2V0SGVhZGVyc0d1YXJkLCBzZXRIZWFkZXJzR3VhcmQsIGdldEhlYWRlcnNMaXN0LCBzZXRIZWFkZXJzTGlzdCB9ID0gSGVhZGVyc1xuUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShIZWFkZXJzLCAnZ2V0SGVhZGVyc0d1YXJkJylcblJlZmxlY3QuZGVsZXRlUHJvcGVydHkoSGVhZGVycywgJ3NldEhlYWRlcnNHdWFyZCcpXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEhlYWRlcnMsICdnZXRIZWFkZXJzTGlzdCcpXG5SZWZsZWN0LmRlbGV0ZVByb3BlcnR5KEhlYWRlcnMsICdzZXRIZWFkZXJzTGlzdCcpXG5cbml0ZXJhdG9yTWl4aW4oJ0hlYWRlcnMnLCBIZWFkZXJzLCBrSGVhZGVyc1NvcnRlZE1hcCwgMCwgMSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSGVhZGVycy5wcm90b3R5cGUsIHtcbiAgYXBwZW5kOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZWxldGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaGFzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzZXQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGdldFNldENvb2tpZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0hlYWRlcnMnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICBbdXRpbC5pbnNwZWN0LmN1c3RvbV06IHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9XG59KVxuXG53ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdCA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSAnT2JqZWN0Jykge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gUmVmbGVjdC5nZXQoViwgU3ltYm9sLml0ZXJhdG9yKVxuXG4gICAgLy8gQSB3b3JrLWFyb3VuZCB0byBlbnN1cmUgd2Ugc2VuZCB0aGUgcHJvcGVybHktY2FzZWQgSGVhZGVycyB3aGVuIFYgaXMgYSBIZWFkZXJzIG9iamVjdC5cbiAgICAvLyBSZWFkIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL3B1bGwvMzE1OSNpc3N1ZWNvbW1lbnQtMjA3NTUzNzIyNiBiZWZvcmUgdG91Y2hpbmcsIHBsZWFzZS5cbiAgICBpZiAoIXV0aWwudHlwZXMuaXNQcm94eShWKSAmJiBpdGVyYXRvciA9PT0gSGVhZGVycy5wcm90b3R5cGUuZW50cmllcykgeyAvLyBIZWFkZXJzIG9iamVjdFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGdldEhlYWRlcnNMaXN0KFYpLmVudHJpZXNMaXN0XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gZmFsbC10aHJvdWdoXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nXShWLCBwcmVmaXgsIGFyZ3VtZW50LCBpdGVyYXRvci5iaW5kKFYpKVxuICAgIH1cblxuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVyc1sncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J10oViwgcHJlZml4LCBhcmd1bWVudClcbiAgfVxuXG4gIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgcHJlZml4OiAnSGVhZGVycyBjb25zdHJ1Y3RvcicsXG4gICAgYXJndW1lbnQ6ICdBcmd1bWVudCAxJyxcbiAgICB0eXBlczogWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nLCAncmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+J11cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGZpbGwsXG4gIC8vIGZvciB0ZXN0LlxuICBjb21wYXJlSGVhZGVyTmFtZSxcbiAgSGVhZGVycyxcbiAgSGVhZGVyc0xpc3QsXG4gIGdldEhlYWRlcnNHdWFyZCxcbiAgc2V0SGVhZGVyc0d1YXJkLFxuICBzZXRIZWFkZXJzTGlzdCxcbiAgZ2V0SGVhZGVyc0xpc3Rcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/headers.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/index.js":
/*!****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// https://github.com/Ethan-Arrowood/undici-fetch\n\n\n\nconst {\n  makeNetworkError,\n  makeAppropriateNetworkError,\n  filterResponse,\n  makeResponse,\n  fromInnerResponse\n} = __webpack_require__(/*! ./response */ \"(rsc)/./node_modules/undici/lib/web/fetch/response.js\")\nconst { HeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { Request, cloneRequest } = __webpack_require__(/*! ./request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst {\n  bytesMatch,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  sameOrigin,\n  isCancelled,\n  isAborted,\n  isErrorLike,\n  fullyReadBody,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlIsHttpHttpsScheme,\n  urlHasHttpsScheme,\n  clampAndCoarsenConnectionTimingInfo,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  createInflate,\n  extractMimeType\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { kState, kDispatcher } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { safelyExtractBody, extractBody } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\")\nconst {\n  redirectStatusSet,\n  nullBodyStatus,\n  safeMethodsSet,\n  requestBodyHeader,\n  subresourceSet\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst EE = __webpack_require__(/*! node:events */ \"node:events\")\nconst { Readable, pipeline, finished } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst { addAbortListener, isErrored, isReadable, bufferToLowerCasedHeaderName } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { dataURLProcessor, serializeAMimeType, minimizeSupportedMimeType } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(rsc)/./node_modules/undici/lib/global.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { STATUS_CODES } = __webpack_require__(/*! node:http */ \"node:http\")\nconst GET_OR_HEAD = ['GET', 'HEAD']\n\nconst defaultUserAgent = typeof __UNDICI_IS_NODE__ !== 'undefined' || typeof esbuildDetection !== 'undefined'\n  ? 'node'\n  : 'undici'\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.connection = null\n    this.dump = false\n    this.state = 'ongoing'\n  }\n\n  terminate (reason) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    this.state = 'terminated'\n    this.connection?.destroy(reason)\n    this.emit('terminated', reason)\n  }\n\n  // https://fetch.spec.whatwg.org/#fetch-controller-abort\n  abort (error) {\n    if (this.state !== 'ongoing') {\n      return\n    }\n\n    // 1. Set controller’s state to \"aborted\".\n    this.state = 'aborted'\n\n    // 2. Let fallbackError be an \"AbortError\" DOMException.\n    // 3. Set error to fallbackError if it is not given.\n    if (!error) {\n      error = new DOMException('The operation was aborted.', 'AbortError')\n    }\n\n    // 4. Let serializedError be StructuredSerialize(error).\n    //    If that threw an exception, catch it, and let\n    //    serializedError be StructuredSerialize(fallbackError).\n\n    // 5. Set controller’s serialized abort reason to serializedError.\n    this.serializedAbortReason = error\n\n    this.connection?.destroy(error)\n    this.emit('terminated', error)\n  }\n}\n\nfunction handleFetchDone (response) {\n  finalizeAndReportTiming(response, 'fetch')\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nfunction fetch (input, init = undefined) {\n  webidl.argumentLengthCheck(arguments, 1, 'globalThis.fetch')\n\n  // 1. Let p be a new promise.\n  let p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  let requestObject\n\n  try {\n    requestObject = new Request(input, init)\n  } catch (e) {\n    p.reject(e)\n    return p.promise\n  }\n\n  // 3. Let request be requestObject’s request.\n  const request = requestObject[kState]\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort the fetch() call with p, request, null, and\n    //    requestObject’s signal’s abort reason.\n    abortFetch(p, request, null, requestObject.signal.reason)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  const globalObject = request.client.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Let controller be null.\n  let controller = null\n\n  // 11. Add the following abort steps to requestObject’s signal:\n  addAbortListener(\n    requestObject.signal,\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Assert: controller is non-null.\n      assert(controller != null)\n\n      // 3. Abort controller with requestObject’s signal’s abort reason.\n      controller.abort(requestObject.signal.reason)\n\n      const realResponse = responseObject?.deref()\n\n      // 4. Abort the fetch() call with p, request, responseObject,\n      //    and requestObject’s signal’s abort reason.\n      abortFetch(p, request, realResponse, requestObject.signal.reason)\n    }\n  )\n\n  // 12. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  // see function handleFetchDone\n\n  // 13. Set controller to the result of calling fetch given request,\n  // with processResponseEndOfBody set to handleFetchDone, and processResponse\n  // given response being these substeps:\n\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If response’s aborted flag is set, then:\n    if (response.aborted) {\n      // 1. Let deserializedError be the result of deserialize a serialized\n      //    abort reason given controller’s serialized abort reason and\n      //    relevantRealm.\n\n      // 2. Abort the fetch() call with p, request, responseObject, and\n      //    deserializedError.\n\n      abortFetch(p, request, responseObject, controller.serializedAbortReason)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(new TypeError('fetch failed', { cause: response.error }))\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new WeakRef(fromInnerResponse(response, 'immutable'))\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject.deref())\n    p = null\n  }\n\n  controller = fetching({\n    request,\n    processResponseEndOfBody: handleFetchDone,\n    processResponse,\n    dispatcher: requestObject[kDispatcher] // undici\n  })\n\n  // 14. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!urlIsHttpHttpsScheme(originalURL)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!response.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL.href,\n    initiatorType,\n    globalThis,\n    cacheState\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nconst markResourceTiming = performance.markResourceTiming\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject, error) {\n  // 1. Reject promise with error.\n  if (p) {\n    // We might have already resolved the promise at this stage\n    p.reject(error)\n  }\n\n  // 2. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 3. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 4. Let response be responseObject’s response.\n  const response = responseObject[kState]\n\n  // 5. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n  dispatcher = getGlobalDispatcher() // undici\n}) {\n  // Ensure that the dispatcher is set accordingly\n  assert(dispatcher)\n\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currentTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currentTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    controller: new Fetch(dispatcher),\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If request’s body is a byte sequence, then set request’s body to\n  //    request’s body as a body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject?.constructor?.name === 'Window'\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    request.origin = request.client.origin\n  }\n\n  // 10. If all of the following conditions are true:\n  // TODO\n\n  // 11. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 12. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.contains('accept', true)) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value, true)\n  }\n\n  // 13. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.contains('accept-language', true)) {\n    request.headersList.append('accept-language', '*', true)\n  }\n\n  // 14. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 15. If request is a subresource request, then:\n  if (subresourceSet.has(request.destination)) {\n    // TODO\n  }\n\n  // 16. Run main fetch given fetchParams.\n  mainFetch(fetchParams)\n    .catch(err => {\n      fetchParams.controller.terminate(err)\n    })\n\n  // 17. Return fetchParam's controller\n  return fetchParams.controller\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n  if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request)\n\n      if (\n        // - request’s current URL’s origin is same origin with request’s origin,\n        //   and request’s response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // request’s current URL’s scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - request’s mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"')\n      }\n\n      // request’s mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        }\n\n        // 2. Set request’s response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch(fetchParams)\n      }\n\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n      }\n\n      // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch(fetchParams)\n    })()\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.contains('range', true)\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    fetchParams.controller.dump = true\n  }\n\n  // 20. If request’s integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale(fetchParams, makeNetworkError(reason))\n\n    // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!bytesMatch(bytes, request.integrity)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set response’s body to bytes as a body.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale(fetchParams, response)\n    }\n\n    // 4. Fully read response’s body given processBody and processBodyError.\n    await fullyReadBody(response.body, processBody, processBodyError)\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale(fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nfunction schemeFetch (fetchParams) {\n  // Note: since the connection is destroyed on redirect, which sets fetchParams to a\n  // cancelled state, we do not want this condition to trigger *unless* there have been\n  // no redirects. See https://github.com/nodejs/undici/issues/1776\n  // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n  if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {\n    return Promise.resolve(makeAppropriateNetworkError(fetchParams))\n  }\n\n  // 2. Let request be fetchParams’s request.\n  const { request } = fetchParams\n\n  const { protocol: scheme } = requestCurrentURL(request)\n\n  // 3. Switch on request’s current URL’s scheme and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If request’s current URL’s path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,\n      // and body is the empty byte sequence as a body.\n\n      // Otherwise, return a network error.\n      return Promise.resolve(makeNetworkError('about scheme is not supported'))\n    }\n    case 'blob:': {\n      if (!resolveObjectURL) {\n        resolveObjectURL = (__webpack_require__(/*! node:buffer */ \"node:buffer\").resolveObjectURL)\n      }\n\n      // 1. Let blobURLEntry be request’s current URL’s blob URL entry.\n      const blobURLEntry = requestCurrentURL(request)\n\n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (blobURLEntry.search.length !== 0) {\n        return Promise.resolve(makeNetworkError('NetworkError when attempting to fetch resource.'))\n      }\n\n      const blob = resolveObjectURL(blobURLEntry.toString())\n\n      // 2. If request’s method is not `GET`, blobURLEntry is null, or blobURLEntry’s\n      //    object is not a Blob object, then return a network error.\n      if (request.method !== 'GET' || !isBlobLike(blob)) {\n        return Promise.resolve(makeNetworkError('invalid method'))\n      }\n\n      // 3. Let blob be blobURLEntry’s object.\n      // Note: done above\n\n      // 4. Let response be a new response.\n      const response = makeResponse()\n\n      // 5. Let fullLength be blob’s size.\n      const fullLength = blob.size\n\n      // 6. Let serializedFullLength be fullLength, serialized and isomorphic encoded.\n      const serializedFullLength = isomorphicEncode(`${fullLength}`)\n\n      // 7. Let type be blob’s type.\n      const type = blob.type\n\n      // 8. If request’s header list does not contain `Range`:\n      // 9. Otherwise:\n      if (!request.headersList.contains('range', true)) {\n        // 1. Let bodyWithType be the result of safely extracting blob.\n        // Note: in the FileAPI a blob \"object\" is a Blob *or* a MediaSource.\n        // In node, this can only ever be a Blob. Therefore we can safely\n        // use extractBody directly.\n        const bodyWithType = extractBody(blob)\n\n        // 2. Set response’s status message to `OK`.\n        response.statusText = 'OK'\n\n        // 3. Set response’s body to bodyWithType’s body.\n        response.body = bodyWithType[0]\n\n        // 4. Set response’s header list to « (`Content-Length`, serializedFullLength), (`Content-Type`, type) ».\n        response.headersList.set('content-length', serializedFullLength, true)\n        response.headersList.set('content-type', type, true)\n      } else {\n        // 1. Set response’s range-requested flag.\n        response.rangeRequested = true\n\n        // 2. Let rangeHeader be the result of getting `Range` from request’s header list.\n        const rangeHeader = request.headersList.get('range', true)\n\n        // 3. Let rangeValue be the result of parsing a single range header value given rangeHeader and true.\n        const rangeValue = simpleRangeHeaderValue(rangeHeader, true)\n\n        // 4. If rangeValue is failure, then return a network error.\n        if (rangeValue === 'failure') {\n          return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n        }\n\n        // 5. Let (rangeStart, rangeEnd) be rangeValue.\n        let { rangeStartValue: rangeStart, rangeEndValue: rangeEnd } = rangeValue\n\n        // 6. If rangeStart is null:\n        // 7. Otherwise:\n        if (rangeStart === null) {\n          // 1. Set rangeStart to fullLength − rangeEnd.\n          rangeStart = fullLength - rangeEnd\n\n          // 2. Set rangeEnd to rangeStart + rangeEnd − 1.\n          rangeEnd = rangeStart + rangeEnd - 1\n        } else {\n          // 1. If rangeStart is greater than or equal to fullLength, then return a network error.\n          if (rangeStart >= fullLength) {\n            return Promise.resolve(makeNetworkError('Range start is greater than the blob\\'s size.'))\n          }\n\n          // 2. If rangeEnd is null or rangeEnd is greater than or equal to fullLength, then set\n          //    rangeEnd to fullLength − 1.\n          if (rangeEnd === null || rangeEnd >= fullLength) {\n            rangeEnd = fullLength - 1\n          }\n        }\n\n        // 8. Let slicedBlob be the result of invoking slice blob given blob, rangeStart,\n        //    rangeEnd + 1, and type.\n        const slicedBlob = blob.slice(rangeStart, rangeEnd, type)\n\n        // 9. Let slicedBodyWithType be the result of safely extracting slicedBlob.\n        // Note: same reason as mentioned above as to why we use extractBody\n        const slicedBodyWithType = extractBody(slicedBlob)\n\n        // 10. Set response’s body to slicedBodyWithType’s body.\n        response.body = slicedBodyWithType[0]\n\n        // 11. Let serializedSlicedLength be slicedBlob’s size, serialized and isomorphic encoded.\n        const serializedSlicedLength = isomorphicEncode(`${slicedBlob.size}`)\n\n        // 12. Let contentRange be the result of invoking build a content range given rangeStart,\n        //     rangeEnd, and fullLength.\n        const contentRange = buildContentRange(rangeStart, rangeEnd, fullLength)\n\n        // 13. Set response’s status to 206.\n        response.status = 206\n\n        // 14. Set response’s status message to `Partial Content`.\n        response.statusText = 'Partial Content'\n\n        // 15. Set response’s header list to « (`Content-Length`, serializedSlicedLength),\n        //     (`Content-Type`, type), (`Content-Range`, contentRange) ».\n        response.headersList.set('content-length', serializedSlicedLength, true)\n        response.headersList.set('content-type', type, true)\n        response.headersList.set('content-range', contentRange, true)\n      }\n\n      // 10. Return response.\n      return Promise.resolve(response)\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on request’s current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return Promise.resolve(makeNetworkError('failed to fetch the data URL'))\n      }\n\n      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n      const mimeType = serializeAMimeType(dataURLStruct.mimeType)\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is « (`Content-Type`, mimeType) »,\n      //    and body is dataURLStruct’s body as a body.\n      return Promise.resolve(makeResponse({\n        statusText: 'OK',\n        headersList: [\n          ['content-type', { name: 'Content-Type', value: mimeType }]\n        ],\n        body: safelyExtractBody(dataURLStruct.body)[0]\n      }))\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return Promise.resolve(makeNetworkError('not implemented... yet...'))\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return httpFetch(fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return Promise.resolve(makeNetworkError('unknown scheme'))\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    queueMicrotask(() => fetchParams.processResponseDone(response))\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  // 1. Let timingInfo be fetchParams’s timing info.\n  let timingInfo = fetchParams.timingInfo\n\n  // 2. If response is not a network error and fetchParams’s request’s client is a secure context,\n  //    then set timingInfo’s server-timing headers to the result of getting, decoding, and splitting\n  //    `Server-Timing` from response’s internal response’s header list.\n  // TODO\n\n  // 3. Let processResponseEndOfBody be the following steps:\n  const processResponseEndOfBody = () => {\n    // 1. Let unsafeEndTime be the unsafe shared current time.\n    const unsafeEndTime = Date.now() // ?\n\n    // 2. If fetchParams’s request’s destination is \"document\", then set fetchParams’s controller’s\n    //    full timing info to fetchParams’s timing info.\n    if (fetchParams.request.destination === 'document') {\n      fetchParams.controller.fullTimingInfo = timingInfo\n    }\n\n    // 3. Set fetchParams’s controller’s report timing steps to the following steps given a global object global:\n    fetchParams.controller.reportTimingSteps = () => {\n      // 1. If fetchParams’s request’s URL’s scheme is not an HTTP(S) scheme, then return.\n      if (fetchParams.request.url.protocol !== 'https:') {\n        return\n      }\n\n      // 2. Set timingInfo’s end time to the relative high resolution time given unsafeEndTime and global.\n      timingInfo.endTime = unsafeEndTime\n\n      // 3. Let cacheState be response’s cache state.\n      let cacheState = response.cacheState\n\n      // 4. Let bodyInfo be response’s body info.\n      const bodyInfo = response.bodyInfo\n\n      // 5. If response’s timing allow passed flag is not set, then set timingInfo to the result of creating an\n      //    opaque timing info for timingInfo and set cacheState to the empty string.\n      if (!response.timingAllowPassed) {\n        timingInfo = createOpaqueTimingInfo(timingInfo)\n\n        cacheState = ''\n      }\n\n      // 6. Let responseStatus be 0.\n      let responseStatus = 0\n\n      // 7. If fetchParams’s request’s mode is not \"navigate\" or response’s has-cross-origin-redirects is false:\n      if (fetchParams.request.mode !== 'navigator' || !response.hasCrossOriginRedirects) {\n        // 1. Set responseStatus to response’s status.\n        responseStatus = response.status\n\n        // 2. Let mimeType be the result of extracting a MIME type from response’s header list.\n        const mimeType = extractMimeType(response.headersList)\n\n        // 3. If mimeType is not failure, then set bodyInfo’s content type to the result of minimizing a supported MIME type given mimeType.\n        if (mimeType !== 'failure') {\n          bodyInfo.contentType = minimizeSupportedMimeType(mimeType)\n        }\n      }\n\n      // 8. If fetchParams’s request’s initiator type is non-null, then mark resource timing given timingInfo,\n      //    fetchParams’s request’s URL, fetchParams’s request’s initiator type, global, cacheState, bodyInfo,\n      //    and responseStatus.\n      if (fetchParams.request.initiatorType != null) {\n        // TODO: update markresourcetiming\n        markResourceTiming(timingInfo, fetchParams.request.url.href, fetchParams.request.initiatorType, globalThis, cacheState, bodyInfo, responseStatus)\n      }\n    }\n\n    // 4. Let processResponseEndOfBodyTask be the following steps:\n    const processResponseEndOfBodyTask = () => {\n      // 1. Set fetchParams’s request’s done flag.\n      fetchParams.request.done = true\n\n      // 2. If fetchParams’s process response end-of-body is non-null, then run fetchParams’s process\n      //    response end-of-body given response.\n      if (fetchParams.processResponseEndOfBody != null) {\n        queueMicrotask(() => fetchParams.processResponseEndOfBody(response))\n      }\n\n      // 3. If fetchParams’s request’s initiator type is non-null and fetchParams’s request’s client’s\n      //    global object is fetchParams’s task destination, then run fetchParams’s controller’s report\n      //    timing steps given fetchParams’s request’s client’s global object.\n      if (fetchParams.request.initiatorType != null) {\n        fetchParams.controller.reportTimingSteps()\n      }\n    }\n\n    // 5. Queue a fetch task to run processResponseEndOfBodyTask with fetchParams’s task destination\n    queueMicrotask(() => processResponseEndOfBodyTask())\n  }\n\n  // 4. If fetchParams’s process response is non-null, then queue a fetch task to run fetchParams’s\n  //    process response given response, with fetchParams’s task destination.\n  if (fetchParams.processResponse != null) {\n    queueMicrotask(() => {\n      fetchParams.processResponse(response)\n      fetchParams.processResponse = null\n    })\n  }\n\n  // 5. Let internalResponse be response, if response is a network error; otherwise response’s internal response.\n  const internalResponse = response.type === 'error' ? response : (response.internalResponse ?? response)\n\n  // 6. If internalResponse’s body is null, then run processResponseEndOfBody.\n  // 7. Otherwise:\n  if (internalResponse.body == null) {\n    processResponseEndOfBody()\n  } else {\n    // mcollina: all the following steps of the specs are skipped.\n    // The internal transform stream is not needed.\n    // See https://github.com/nodejs/undici/pull/3093#issuecomment-2050198541\n\n    // 1. Let transformStream be a new TransformStream.\n    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk, enqueues chunk in transformStream.\n    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm and flushAlgorithm\n    //    set to processResponseEndOfBody.\n    // 4. Set internalResponse’s body’s stream to the result of internalResponse’s body’s stream piped through transformStream.\n\n    finished(internalResponse.body.stream, () => {\n      processResponseEndOfBody()\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatusSet.has(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    if (request.redirect !== 'manual') {\n      fetchParams.controller.connection.destroy(undefined, false)\n    }\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError('unexpected redirect')\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch(fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nfunction httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return Promise.resolve(makeNetworkError(err))\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!urlIsHttpHttpsScheme(locationURL)) {\n    return Promise.resolve(makeNetworkError('URL scheme must be a HTTP(S) scheme'))\n  }\n\n  // 7. If request’s redirect count is 20, then return a network error.\n  if (request.redirectCount === 20) {\n    return Promise.resolve(makeNetworkError('redirect count exceeded'))\n  }\n\n  // 8. Increase request’s redirect count by 1.\n  request.redirectCount += 1\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return Promise.resolve(makeNetworkError('cross origin not allowed for request mode \"cors\"'))\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return Promise.resolve(makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    ))\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return Promise.resolve(makeNetworkError())\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !GET_OR_HEAD.includes(request.method))\n  ) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If request’s current URL’s origin is not same origin with locationURL’s\n  //     origin, then for each headerName of CORS non-wildcard request-header name,\n  //     delete headerName from request’s header list.\n  if (!sameOrigin(requestCurrentURL(request), locationURL)) {\n    // https://fetch.spec.whatwg.org/#cors-non-wildcard-request-header-name\n    request.headersList.delete('authorization', true)\n\n    // https://fetch.spec.whatwg.org/#authentication-entries\n    request.headersList.delete('proxy-authorization', true)\n\n    // \"Cookie\" and \"Host\" are forbidden request-headers, which undici doesn't implement.\n    request.headersList.delete('cookie', true)\n    request.headersList.delete('host', true)\n  }\n\n  // 14. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source != null)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 15. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 16. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 17. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 18. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL)\n\n  // 19. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 20. Return the result of running main fetch given fetchParams and true.\n  return mainFetch(fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = cloneRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    contentLengthHeaderValue = isomorphicEncode(`${contentLength}`)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue, true)\n  }\n\n  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,\n  //    contentLengthHeaderValue) to httpRequest’s header list.\n\n  //    10. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    11. If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (httpRequest.referrer instanceof URL) {\n    httpRequest.headersList.append('referer', isomorphicEncode(httpRequest.referrer.href), true)\n  }\n\n  //    12. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    14. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.contains('user-agent', true)) {\n    httpRequest.headersList.append('user-agent', defaultUserAgent)\n  }\n\n  //    15. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.contains('if-modified-since', true) ||\n      httpRequest.headersList.contains('if-none-match', true) ||\n      httpRequest.headersList.contains('if-unmodified-since', true) ||\n      httpRequest.headersList.contains('if-match', true) ||\n      httpRequest.headersList.contains('if-range', true))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.contains('cache-control', true)\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0', true)\n  }\n\n  //    17. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('pragma', true)) {\n      httpRequest.headersList.append('pragma', 'no-cache', true)\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.contains('cache-control', true)) {\n      httpRequest.headersList.append('cache-control', 'no-cache', true)\n    }\n  }\n\n  //    18. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.contains('range', true)) {\n    httpRequest.headersList.append('accept-encoding', 'identity', true)\n  }\n\n  //    19. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.contains('accept-encoding', true)) {\n    if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate', true)\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate', true)\n    }\n  }\n\n  httpRequest.headersList.delete('host', true)\n\n  //    20. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    21. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    22. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    23. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    24. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.cache !== 'no-store' && httpRequest.cache !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then return the appropriate network error for fetchParams.\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.cache === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch(\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethodsSet.has(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.contains('range', true)) {\n    response.rangeRequested = true\n  }\n\n  // 13. Set response’s request-includes-credentials to includeCredentials.\n  response.requestIncludesCredentials = includeCredentials\n\n  // 14. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 15. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 16. If all of the following are true\n  if (\n    // response’s status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.\n    if (isCancelled(fetchParams)) {\n      return makeAppropriateNetworkError(fetchParams)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    fetchParams.controller.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch(\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 17. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 18. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nasync function httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)\n\n  fetchParams.controller.connection = {\n    abort: null,\n    destroyed: false,\n    destroy (err, abort = true) {\n      if (!this.destroyed) {\n        this.destroyed = true\n        if (abort) {\n          this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))\n        }\n      }\n    }\n  }\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 4. Let httpCache be the result of determining the HTTP cache partition,\n  // given request.\n  // TODO: cache\n  const httpCache = null\n\n  // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n  if (httpCache == null) {\n    request.cache = 'no-store'\n  }\n\n  // 6. Let networkPartitionKey be the result of determining the network\n  // partition key given request.\n  // TODO\n\n  // 7. Let newConnection be \"yes\" if forceNewConnection is true; otherwise\n  // \"no\".\n  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars\n\n  // 8. Switch on request’s mode:\n  if (request.mode === 'websocket') {\n    // Let connection be the result of obtaining a WebSocket connection,\n    // given request’s current URL.\n    // TODO\n  } else {\n    // Let connection be the result of obtaining a connection, given\n    // networkPartitionKey, request’s current URL’s origin,\n    // includeCredentials, and forceNewConnection.\n    // TODO\n  }\n\n  // 9. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If connection is failure, then return a network error.\n\n  //    2. Set timingInfo’s final connection timing info to the result of\n  //    calling clamp and coarsen connection timing info with connection’s\n  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s\n  //    cross-origin isolated capability.\n\n  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,\n  //    and request’s body’s source is null, then append (`Transfer-Encoding`,\n  //    `chunked`) to request’s header list.\n\n  //    4. Set timingInfo’s final network-request start time to the coarsened\n  //    shared current time given fetchParams’s cross-origin isolated\n  //    capability.\n\n  //    5. Set response to the result of making an HTTP request over connection\n  //    using request with the following caveats:\n\n  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n  //        - If request’s body is non-null, and request’s body’s source is null,\n  //        then the user agent may have a buffer of up to 64 kibibytes and store\n  //        a part of request’s body in that buffer. If the user agent reads from\n  //        request’s body beyond that buffer’s size and the user agent needs to\n  //        resend request, then instead return a network error.\n\n  //        - Set timingInfo’s final network-response start time to the coarsened\n  //        shared current time given fetchParams’s cross-origin isolated capability,\n  //        immediately after the user agent’s HTTP parser receives the first byte\n  //        of the response (e.g., frame header bytes for HTTP/2 or response status\n  //        line for HTTP/1.x).\n\n  //        - Wait until all the headers are transmitted.\n\n  //        - Any responses whose status is in the range 100 to 199, inclusive,\n  //        and is not 101, are to be ignored, except for the purposes of setting\n  //        timingInfo’s final network-response start time above.\n\n  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and\n  //    response is transferred via HTTP/1.0 or older, then return a network\n  //    error.\n\n  //    - If the HTTP request results in a TLS client certificate dialog, then:\n\n  //        1. If request’s window is an environment settings object, make the\n  //        dialog available in request’s window.\n\n  //        2. Otherwise, return a network error.\n\n  // To transmit request’s body body, run these steps:\n  let requestBody = null\n  // 1. If body is null and fetchParams’s process request end-of-body is\n  // non-null, then queue a fetch task given fetchParams’s process request\n  // end-of-body and fetchParams’s task destination.\n  if (request.body == null && fetchParams.processRequestEndOfBody) {\n    queueMicrotask(() => fetchParams.processRequestEndOfBody())\n  } else if (request.body != null) {\n    // 2. Otherwise, if body is non-null:\n\n    //    1. Let processBodyChunk given bytes be these steps:\n    const processBodyChunk = async function * (bytes) {\n      // 1. If the ongoing fetch is terminated, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. Run this step in parallel: transmit bytes.\n      yield bytes\n\n      // 3. If fetchParams’s process request body is non-null, then run\n      // fetchParams’s process request body given bytes’s length.\n      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)\n    }\n\n    // 2. Let processEndOfBody be these steps:\n    const processEndOfBody = () => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If fetchParams’s process request end-of-body is non-null,\n      // then run fetchParams’s process request end-of-body.\n      if (fetchParams.processRequestEndOfBody) {\n        fetchParams.processRequestEndOfBody()\n      }\n    }\n\n    // 3. Let processBodyError given e be these steps:\n    const processBodyError = (e) => {\n      // 1. If fetchParams is canceled, then abort these steps.\n      if (isCancelled(fetchParams)) {\n        return\n      }\n\n      // 2. If e is an \"AbortError\" DOMException, then abort fetchParams’s controller.\n      if (e.name === 'AbortError') {\n        fetchParams.controller.abort()\n      } else {\n        fetchParams.controller.terminate(e)\n      }\n    }\n\n    // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,\n    // processBodyError, and fetchParams’s task destination.\n    requestBody = (async function * () {\n      try {\n        for await (const bytes of request.body.stream) {\n          yield * processBodyChunk(bytes)\n        }\n        processEndOfBody()\n      } catch (err) {\n        processBodyError(err)\n      }\n    })()\n  }\n\n  try {\n    // socket is only provided for websockets\n    const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody })\n\n    if (socket) {\n      response = makeResponse({ status, statusText, headersList, socket })\n    } else {\n      const iterator = body[Symbol.asyncIterator]()\n      fetchParams.controller.next = () => iterator.next()\n\n      response = makeResponse({ status, statusText, headersList })\n    }\n  } catch (err) {\n    // 10. If aborted, then:\n    if (err.name === 'AbortError') {\n      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      fetchParams.controller.connection.destroy()\n\n      // 2. Return the appropriate network error for fetchParams.\n      return makeAppropriateNetworkError(fetchParams, err)\n    }\n\n    return makeNetworkError(err)\n  }\n\n  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch\n  // if it is suspended.\n  const pullAlgorithm = async () => {\n    await fetchParams.controller.resume()\n  }\n\n  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s\n  // controller with reason, given reason.\n  const cancelAlgorithm = (reason) => {\n    // If the aborted fetch was already terminated, then we do not\n    // need to do anything.\n    if (!isCancelled(fetchParams)) {\n      fetchParams.controller.abort(reason)\n    }\n  }\n\n  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by\n  // the user agent.\n  // TODO\n\n  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object\n  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n  // TODO\n\n  // 15. Let stream be a new ReadableStream.\n  // 16. Set up stream with byte reading support with pullAlgorithm set to pullAlgorithm,\n  //     cancelAlgorithm set to cancelAlgorithm.\n  const stream = new ReadableStream(\n    {\n      async start (controller) {\n        fetchParams.controller.controller = controller\n      },\n      async pull (controller) {\n        await pullAlgorithm(controller)\n      },\n      async cancel (reason) {\n        await cancelAlgorithm(reason)\n      },\n      type: 'bytes'\n    }\n  )\n\n  // 17. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. Set response’s body to a new body whose stream is stream.\n  response.body = { stream, source: null, length: null }\n\n  //    2. If response is not a network error and request’s cache mode is\n  //    not \"no-store\", then update response in httpCache for request.\n  //    TODO\n\n  //    3. If includeCredentials is true and the user agent is not configured\n  //    to block cookies for request (see section 7 of [COOKIES]), then run the\n  //    \"set-cookie-string\" parsing algorithm (see section 5.2 of [COOKIES]) on\n  //    the value of each header whose name is a byte-case-insensitive match for\n  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.\n  //    TODO\n\n  // 18. If aborted, then:\n  // TODO\n\n  // 19. Run these steps in parallel:\n\n  //    1. Run these steps, but abort when fetchParams is canceled:\n  fetchParams.controller.onAborted = onAborted\n  fetchParams.controller.on('terminated', onAborted)\n  fetchParams.controller.resume = async () => {\n    // 1. While true\n    while (true) {\n      // 1-3. See onData...\n\n      // 4. Set bytes to the result of handling content codings given\n      // codings and bytes.\n      let bytes\n      let isFailure\n      try {\n        const { done, value } = await fetchParams.controller.next()\n\n        if (isAborted(fetchParams)) {\n          break\n        }\n\n        bytes = done ? undefined : value\n      } catch (err) {\n        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {\n          // zlib doesn't like empty streams.\n          bytes = undefined\n        } else {\n          bytes = err\n\n          // err may be propagated from the result of calling readablestream.cancel,\n          // which might not be an error. https://github.com/nodejs/undici/issues/2009\n          isFailure = true\n        }\n      }\n\n      if (bytes === undefined) {\n        // 2. Otherwise, if the bytes transmission for response’s message\n        // body is done normally and stream is readable, then close\n        // stream, finalize response for fetchParams and response, and\n        // abort these in-parallel steps.\n        readableStreamClose(fetchParams.controller.controller)\n\n        finalizeResponse(fetchParams, response)\n\n        return\n      }\n\n      // 5. Increase timingInfo’s decoded body size by bytes’s length.\n      timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n      // 6. If bytes is failure, then terminate fetchParams’s controller.\n      if (isFailure) {\n        fetchParams.controller.terminate(bytes)\n        return\n      }\n\n      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n      // into stream.\n      const buffer = new Uint8Array(bytes)\n      if (buffer.byteLength) {\n        fetchParams.controller.controller.enqueue(buffer)\n      }\n\n      // 8. If stream is errored, then terminate the ongoing fetch.\n      if (isErrored(stream)) {\n        fetchParams.controller.terminate()\n        return\n      }\n\n      // 9. If stream doesn’t need more data ask the user agent to suspend\n      // the ongoing fetch.\n      if (fetchParams.controller.controller.desiredSize <= 0) {\n        return\n      }\n    }\n  }\n\n  //    2. If aborted, then:\n  function onAborted (reason) {\n    // 2. If fetchParams is aborted, then:\n    if (isAborted(fetchParams)) {\n      // 1. Set response’s aborted flag.\n      response.aborted = true\n\n      // 2. If stream is readable, then error stream with the result of\n      //    deserialize a serialized abort reason given fetchParams’s\n      //    controller’s serialized abort reason and an\n      //    implementation-defined realm.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(\n          fetchParams.controller.serializedAbortReason\n        )\n      }\n    } else {\n      // 3. Otherwise, if stream is readable, error stream with a TypeError.\n      if (isReadable(stream)) {\n        fetchParams.controller.controller.error(new TypeError('terminated', {\n          cause: isErrorLike(reason) ? reason : undefined\n        }))\n      }\n    }\n\n    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n    fetchParams.controller.connection.destroy()\n  }\n\n  // 20. Return response.\n  return response\n\n  function dispatch ({ body }) {\n    const url = requestCurrentURL(request)\n    /** @type {import('../..').Agent} */\n    const agent = fetchParams.controller.dispatcher\n\n    return new Promise((resolve, reject) => agent.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: agent.isMockActive ? request.body && (request.body.source || request.body.stream) : body,\n        headers: request.headersList.entries,\n        maxRedirections: 0,\n        upgrade: request.mode === 'websocket' ? 'websocket' : undefined\n      },\n      {\n        body: null,\n        abort: null,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = fetchParams.controller\n\n          // Set timingInfo’s final connection timing info to the result of calling clamp and coarsen\n          // connection timing info with connection’s timing info, timingInfo’s post-redirect start\n          // time, and fetchParams’s cross-origin isolated capability.\n          // TODO: implement connection timing\n          timingInfo.finalConnectionTimingInfo = clampAndCoarsenConnectionTimingInfo(undefined, timingInfo.postRedirectStartTime, fetchParams.crossOriginIsolatedCapability)\n\n          if (connection.destroyed) {\n            abort(new DOMException('The operation was aborted.', 'AbortError'))\n          } else {\n            fetchParams.controller.on('terminated', abort)\n            this.abort = connection.abort = abort\n          }\n\n          // Set timingInfo’s final network-request start time to the coarsened shared current time given\n          // fetchParams’s cross-origin isolated capability.\n          timingInfo.finalNetworkRequestStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onResponseStarted () {\n          // Set timingInfo’s final network-response start time to the coarsened shared current\n          // time given fetchParams’s cross-origin isolated capability, immediately after the\n          // user agent’s HTTP parser receives the first byte of the response (e.g., frame header\n          // bytes for HTTP/2 or response status line for HTTP/1.x).\n          timingInfo.finalNetworkResponseStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n        },\n\n        onHeaders (status, rawHeaders, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          /** @type {string[]} */\n          let codings = []\n          let location = ''\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n          const contentEncoding = headersList.get('content-encoding', true)\n          if (contentEncoding) {\n            // https://www.rfc-editor.org/rfc/rfc7231#section-3.1.2.1\n            // \"All content-coding values are case-insensitive...\"\n            codings = contentEncoding.toLowerCase().split(',').map((x) => x.trim())\n          }\n          location = headersList.get('location', true)\n\n          this.body = new Readable({ read: resume })\n\n          const decoders = []\n\n          const willFollow = location && request.redirect === 'follow' &&\n            redirectStatusSet.has(status)\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          if (codings.length !== 0 && request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status) && !willFollow) {\n            for (let i = codings.length - 1; i >= 0; --i) {\n              const coding = codings[i]\n              // https://www.rfc-editor.org/rfc/rfc9112.html#section-7.2\n              if (coding === 'x-gzip' || coding === 'gzip') {\n                decoders.push(zlib.createGunzip({\n                  // Be less strict when decoding compressed responses, since sometimes\n                  // servers send slightly invalid responses that are still accepted\n                  // by common browsers.\n                  // Always using Z_SYNC_FLUSH is what cURL does.\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'deflate') {\n                decoders.push(createInflate({\n                  flush: zlib.constants.Z_SYNC_FLUSH,\n                  finishFlush: zlib.constants.Z_SYNC_FLUSH\n                }))\n              } else if (coding === 'br') {\n                decoders.push(zlib.createBrotliDecompress({\n                  flush: zlib.constants.BROTLI_OPERATION_FLUSH,\n                  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH\n                }))\n              } else {\n                decoders.length = 0\n                break\n              }\n            }\n          }\n\n          const onError = this.onError.bind(this)\n\n          resolve({\n            status,\n            statusText,\n            headersList,\n            body: decoders.length\n              ? pipeline(this.body, ...decoders, (err) => {\n                if (err) {\n                  this.onError(err)\n                }\n              }).on('error', onError)\n              : this.body.on('error', onError)\n          })\n\n          return true\n        },\n\n        onData (chunk) {\n          if (fetchParams.controller.dump) {\n            return\n          }\n\n          // 1. If one or more bytes have been transmitted from response’s\n          // message body, then:\n\n          //  1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          //  2. Let codings be the result of extracting header list values\n          //  given `Content-Encoding` and response’s header list.\n          //  See pullAlgorithm.\n\n          //  3. Increase timingInfo’s encoded body size by bytes’s length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          //  4. See pullAlgorithm...\n\n          return this.body.push(bytes)\n        },\n\n        onComplete () {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          if (fetchParams.controller.onAborted) {\n            fetchParams.controller.off('terminated', fetchParams.controller.onAborted)\n          }\n\n          fetchParams.controller.ended = true\n\n          this.body.push(null)\n        },\n\n        onError (error) {\n          if (this.abort) {\n            fetchParams.controller.off('terminated', this.abort)\n          }\n\n          this.body?.destroy(error)\n\n          fetchParams.controller.terminate(error)\n\n          reject(error)\n        },\n\n        onUpgrade (status, rawHeaders, socket) {\n          if (status !== 101) {\n            return\n          }\n\n          const headersList = new HeadersList()\n\n          for (let i = 0; i < rawHeaders.length; i += 2) {\n            headersList.append(bufferToLowerCasedHeaderName(rawHeaders[i]), rawHeaders[i + 1].toString('latin1'), true)\n          }\n\n          resolve({\n            status,\n            statusText: STATUS_CODES[status],\n            headersList,\n            socket\n          })\n\n          return true\n        }\n      }\n    ))\n  }\n}\n\nmodule.exports = {\n  fetch,\n  Fetch,\n  fetching,\n  finalizeAndReportTiming\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDeEIsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUMzQyxRQUFRLHdCQUF3QixFQUFFLG1CQUFPLENBQUMsdUVBQVc7QUFDckQsYUFBYSxtQkFBTyxDQUFDLDRCQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDcEIsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLGlDQUFpQyxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsMkVBQWE7QUFDekIsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDLFFBQVEsK0JBQStCLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUM5RCxRQUFRLHdFQUF3RSxFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQzNHLFFBQVEsa0VBQWtFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUNoRyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsK0RBQWM7QUFDdEQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxxRUFBVTtBQUNyQyxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLDRCQUFXO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1DQUFtQztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx1QkFBdUI7QUFDdEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBLHdDQUF3QyxVQUFVO0FBQ2xEO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsVUFBVTs7QUFFcEIsVUFBVSxtQkFBbUI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0VBQXVDO0FBQ2xFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVELFdBQVc7O0FBRWxFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1REFBdUQ7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELGdCQUFnQjs7QUFFM0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVDQUF1QztBQUNwRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtFQUFrRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0Es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QTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmZXRjaFxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL0V0aGFuLUFycm93b29kL3VuZGljaS1mZXRjaFxuXG4ndXNlIHN0cmljdCdcblxuY29uc3Qge1xuICBtYWtlTmV0d29ya0Vycm9yLFxuICBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IsXG4gIGZpbHRlclJlc3BvbnNlLFxuICBtYWtlUmVzcG9uc2UsXG4gIGZyb21Jbm5lclJlc3BvbnNlXG59ID0gcmVxdWlyZSgnLi9yZXNwb25zZScpXG5jb25zdCB7IEhlYWRlcnNMaXN0IH0gPSByZXF1aXJlKCcuL2hlYWRlcnMnKVxuY29uc3QgeyBSZXF1ZXN0LCBjbG9uZVJlcXVlc3QgfSA9IHJlcXVpcmUoJy4vcmVxdWVzdCcpXG5jb25zdCB6bGliID0gcmVxdWlyZSgnbm9kZTp6bGliJylcbmNvbnN0IHtcbiAgYnl0ZXNNYXRjaCxcbiAgbWFrZVBvbGljeUNvbnRhaW5lcixcbiAgY2xvbmVQb2xpY3lDb250YWluZXIsXG4gIHJlcXVlc3RCYWRQb3J0LFxuICBUQU9DaGVjayxcbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcixcbiAgcmVzcG9uc2VMb2NhdGlvblVSTCxcbiAgcmVxdWVzdEN1cnJlbnRVUkwsXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QsXG4gIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCxcbiAgY3JlYXRlT3BhcXVlVGltaW5nSW5mbyxcbiAgYXBwZW5kRmV0Y2hNZXRhZGF0YSxcbiAgY29yc0NoZWNrLFxuICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2ssXG4gIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsXG4gIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIGlzQmxvYkxpa2UsXG4gIHNhbWVPcmlnaW4sXG4gIGlzQ2FuY2VsbGVkLFxuICBpc0Fib3J0ZWQsXG4gIGlzRXJyb3JMaWtlLFxuICBmdWxseVJlYWRCb2R5LFxuICByZWFkYWJsZVN0cmVhbUNsb3NlLFxuICBpc29tb3JwaGljRW5jb2RlLFxuICB1cmxJc0xvY2FsLFxuICB1cmxJc0h0dHBIdHRwc1NjaGVtZSxcbiAgdXJsSGFzSHR0cHNTY2hlbWUsXG4gIGNsYW1wQW5kQ29hcnNlbkNvbm5lY3Rpb25UaW1pbmdJbmZvLFxuICBzaW1wbGVSYW5nZUhlYWRlclZhbHVlLFxuICBidWlsZENvbnRlbnRSYW5nZSxcbiAgY3JlYXRlSW5mbGF0ZSxcbiAgZXh0cmFjdE1pbWVUeXBlXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHsga1N0YXRlLCBrRGlzcGF0Y2hlciB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgc2FmZWx5RXh0cmFjdEJvZHksIGV4dHJhY3RCb2R5IH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3Qge1xuICByZWRpcmVjdFN0YXR1c1NldCxcbiAgbnVsbEJvZHlTdGF0dXMsXG4gIHNhZmVNZXRob2RzU2V0LFxuICByZXF1ZXN0Qm9keUhlYWRlcixcbiAgc3VicmVzb3VyY2VTZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCBFRSA9IHJlcXVpcmUoJ25vZGU6ZXZlbnRzJylcbmNvbnN0IHsgUmVhZGFibGUsIHBpcGVsaW5lLCBmaW5pc2hlZCB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgeyBhZGRBYm9ydExpc3RlbmVyLCBpc0Vycm9yZWQsIGlzUmVhZGFibGUsIGJ1ZmZlclRvTG93ZXJDYXNlZEhlYWRlck5hbWUgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGRhdGFVUkxQcm9jZXNzb3IsIHNlcmlhbGl6ZUFNaW1lVHlwZSwgbWluaW1pemVTdXBwb3J0ZWRNaW1lVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4uLy4uL2dsb2JhbCcpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBTVEFUVVNfQ09ERVMgfSA9IHJlcXVpcmUoJ25vZGU6aHR0cCcpXG5jb25zdCBHRVRfT1JfSEVBRCA9IFsnR0VUJywgJ0hFQUQnXVxuXG5jb25zdCBkZWZhdWx0VXNlckFnZW50ID0gdHlwZW9mIF9fVU5ESUNJX0lTX05PREVfXyAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGVzYnVpbGREZXRlY3Rpb24gIT09ICd1bmRlZmluZWQnXG4gID8gJ25vZGUnXG4gIDogJ3VuZGljaSdcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2J1ZmZlcicpLnJlc29sdmVPYmplY3RVUkx9ICovXG5sZXQgcmVzb2x2ZU9iamVjdFVSTFxuXG5jbGFzcyBGZXRjaCBleHRlbmRzIEVFIHtcbiAgY29uc3RydWN0b3IgKGRpc3BhdGNoZXIpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLmRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyXG4gICAgdGhpcy5jb25uZWN0aW9uID0gbnVsbFxuICAgIHRoaXMuZHVtcCA9IGZhbHNlXG4gICAgdGhpcy5zdGF0ZSA9ICdvbmdvaW5nJ1xuICB9XG5cbiAgdGVybWluYXRlIChyZWFzb24pIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29uZ29pbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0gJ3Rlcm1pbmF0ZWQnXG4gICAgdGhpcy5jb25uZWN0aW9uPy5kZXN0cm95KHJlYXNvbilcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLCByZWFzb24pXG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtY29udHJvbGxlci1hYm9ydFxuICBhYm9ydCAoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ29uZ29pbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAxLiBTZXQgY29udHJvbGxlcuKAmXMgc3RhdGUgdG8gXCJhYm9ydGVkXCIuXG4gICAgdGhpcy5zdGF0ZSA9ICdhYm9ydGVkJ1xuXG4gICAgLy8gMi4gTGV0IGZhbGxiYWNrRXJyb3IgYmUgYW4gXCJBYm9ydEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIC8vIDMuIFNldCBlcnJvciB0byBmYWxsYmFja0Vycm9yIGlmIGl0IGlzIG5vdCBnaXZlbi5cbiAgICBpZiAoIWVycm9yKSB7XG4gICAgICBlcnJvciA9IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDQuIExldCBzZXJpYWxpemVkRXJyb3IgYmUgU3RydWN0dXJlZFNlcmlhbGl6ZShlcnJvcikuXG4gICAgLy8gICAgSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIGNhdGNoIGl0LCBhbmQgbGV0XG4gICAgLy8gICAgc2VyaWFsaXplZEVycm9yIGJlIFN0cnVjdHVyZWRTZXJpYWxpemUoZmFsbGJhY2tFcnJvcikuXG5cbiAgICAvLyA1LiBTZXQgY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gdG8gc2VyaWFsaXplZEVycm9yLlxuICAgIHRoaXMuc2VyaWFsaXplZEFib3J0UmVhc29uID0gZXJyb3JcblxuICAgIHRoaXMuY29ubmVjdGlvbj8uZGVzdHJveShlcnJvcilcbiAgICB0aGlzLmVtaXQoJ3Rlcm1pbmF0ZWQnLCBlcnJvcilcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVGZXRjaERvbmUgKHJlc3BvbnNlKSB7XG4gIGZpbmFsaXplQW5kUmVwb3J0VGltaW5nKHJlc3BvbnNlLCAnZmV0Y2gnKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtbWV0aG9kXG5mdW5jdGlvbiBmZXRjaCAoaW5wdXQsIGluaXQgPSB1bmRlZmluZWQpIHtcbiAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnZ2xvYmFsVGhpcy5mZXRjaCcpXG5cbiAgLy8gMS4gTGV0IHAgYmUgYSBuZXcgcHJvbWlzZS5cbiAgbGV0IHAgPSBjcmVhdGVEZWZlcnJlZFByb21pc2UoKVxuXG4gIC8vIDIuIExldCByZXF1ZXN0T2JqZWN0IGJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgdGhlIGluaXRpYWwgdmFsdWUgb2ZcbiAgLy8gUmVxdWVzdCBhcyBjb25zdHJ1Y3RvciB3aXRoIGlucHV0IGFuZCBpbml0IGFzIGFyZ3VtZW50cy4gSWYgdGhpcyB0aHJvd3NcbiAgLy8gYW4gZXhjZXB0aW9uLCByZWplY3QgcCB3aXRoIGl0IGFuZCByZXR1cm4gcC5cbiAgbGV0IHJlcXVlc3RPYmplY3RcblxuICB0cnkge1xuICAgIHJlcXVlc3RPYmplY3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdClcbiAgfSBjYXRjaCAoZSkge1xuICAgIHAucmVqZWN0KGUpXG4gICAgcmV0dXJuIHAucHJvbWlzZVxuICB9XG5cbiAgLy8gMy4gTGV0IHJlcXVlc3QgYmUgcmVxdWVzdE9iamVjdOKAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IHJlcXVlc3RPYmplY3Rba1N0YXRlXVxuXG4gIC8vIDQuIElmIHJlcXVlc3RPYmplY3TigJlzIHNpZ25hbOKAmXMgYWJvcnRlZCBmbGFnIGlzIHNldCwgdGhlbjpcbiAgaWYgKHJlcXVlc3RPYmplY3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAvLyAxLiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgbnVsbCwgYW5kXG4gICAgLy8gICAgcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydCByZWFzb24uXG4gICAgYWJvcnRGZXRjaChwLCByZXF1ZXN0LCBudWxsLCByZXF1ZXN0T2JqZWN0LnNpZ25hbC5yZWFzb24pXG5cbiAgICAvLyAyLiBSZXR1cm4gcC5cbiAgICByZXR1cm4gcC5wcm9taXNlXG4gIH1cblxuICAvLyA1LiBMZXQgZ2xvYmFsT2JqZWN0IGJlIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdC5cbiAgY29uc3QgZ2xvYmFsT2JqZWN0ID0gcmVxdWVzdC5jbGllbnQuZ2xvYmFsT2JqZWN0XG5cbiAgLy8gNi4gSWYgZ2xvYmFsT2JqZWN0IGlzIGEgU2VydmljZVdvcmtlckdsb2JhbFNjb3BlIG9iamVjdCwgdGhlbiBzZXRcbiAgLy8gcmVxdWVzdOKAmXMgc2VydmljZS13b3JrZXJzIG1vZGUgdG8gXCJub25lXCIuXG4gIGlmIChnbG9iYWxPYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnU2VydmljZVdvcmtlckdsb2JhbFNjb3BlJykge1xuICAgIHJlcXVlc3Quc2VydmljZVdvcmtlcnMgPSAnbm9uZSdcbiAgfVxuXG4gIC8vIDcuIExldCByZXNwb25zZU9iamVjdCBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2VPYmplY3QgPSBudWxsXG5cbiAgLy8gOC4gTGV0IHJlbGV2YW50UmVhbG0gYmUgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG5cbiAgLy8gOS4gTGV0IGxvY2FsbHlBYm9ydGVkIGJlIGZhbHNlLlxuICBsZXQgbG9jYWxseUFib3J0ZWQgPSBmYWxzZVxuXG4gIC8vIDEwLiBMZXQgY29udHJvbGxlciBiZSBudWxsLlxuICBsZXQgY29udHJvbGxlciA9IG51bGxcblxuICAvLyAxMS4gQWRkIHRoZSBmb2xsb3dpbmcgYWJvcnQgc3RlcHMgdG8gcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFsOlxuICBhZGRBYm9ydExpc3RlbmVyKFxuICAgIHJlcXVlc3RPYmplY3Quc2lnbmFsLFxuICAgICgpID0+IHtcbiAgICAgIC8vIDEuIFNldCBsb2NhbGx5QWJvcnRlZCB0byB0cnVlLlxuICAgICAgbG9jYWxseUFib3J0ZWQgPSB0cnVlXG5cbiAgICAgIC8vIDIuIEFzc2VydDogY29udHJvbGxlciBpcyBub24tbnVsbC5cbiAgICAgIGFzc2VydChjb250cm9sbGVyICE9IG51bGwpXG5cbiAgICAgIC8vIDMuIEFib3J0IGNvbnRyb2xsZXIgd2l0aCByZXF1ZXN0T2JqZWN04oCZcyBzaWduYWzigJlzIGFib3J0IHJlYXNvbi5cbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQocmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuXG4gICAgICBjb25zdCByZWFsUmVzcG9uc2UgPSByZXNwb25zZU9iamVjdD8uZGVyZWYoKVxuXG4gICAgICAvLyA0LiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsXG4gICAgICAvLyAgICBhbmQgcmVxdWVzdE9iamVjdOKAmXMgc2lnbmFs4oCZcyBhYm9ydCByZWFzb24uXG4gICAgICBhYm9ydEZldGNoKHAsIHJlcXVlc3QsIHJlYWxSZXNwb25zZSwgcmVxdWVzdE9iamVjdC5zaWduYWwucmVhc29uKVxuICAgIH1cbiAgKVxuXG4gIC8vIDEyLiBMZXQgaGFuZGxlRmV0Y2hEb25lIGdpdmVuIHJlc3BvbnNlIHJlc3BvbnNlIGJlIHRvIGZpbmFsaXplIGFuZFxuICAvLyByZXBvcnQgdGltaW5nIHdpdGggcmVzcG9uc2UsIGdsb2JhbE9iamVjdCwgYW5kIFwiZmV0Y2hcIi5cbiAgLy8gc2VlIGZ1bmN0aW9uIGhhbmRsZUZldGNoRG9uZVxuXG4gIC8vIDEzLiBTZXQgY29udHJvbGxlciB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZmV0Y2ggZ2l2ZW4gcmVxdWVzdCxcbiAgLy8gd2l0aCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgc2V0IHRvIGhhbmRsZUZldGNoRG9uZSwgYW5kIHByb2Nlc3NSZXNwb25zZVxuICAvLyBnaXZlbiByZXNwb25zZSBiZWluZyB0aGVzZSBzdWJzdGVwczpcblxuICBjb25zdCBwcm9jZXNzUmVzcG9uc2UgPSAocmVzcG9uc2UpID0+IHtcbiAgICAvLyAxLiBJZiBsb2NhbGx5QWJvcnRlZCBpcyB0cnVlLCB0ZXJtaW5hdGUgdGhlc2Ugc3Vic3RlcHMuXG4gICAgaWYgKGxvY2FsbHlBYm9ydGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAyLiBJZiByZXNwb25zZeKAmXMgYWJvcnRlZCBmbGFnIGlzIHNldCwgdGhlbjpcbiAgICBpZiAocmVzcG9uc2UuYWJvcnRlZCkge1xuICAgICAgLy8gMS4gTGV0IGRlc2VyaWFsaXplZEVycm9yIGJlIHRoZSByZXN1bHQgb2YgZGVzZXJpYWxpemUgYSBzZXJpYWxpemVkXG4gICAgICAvLyAgICBhYm9ydCByZWFzb24gZ2l2ZW4gY29udHJvbGxlcuKAmXMgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gYW5kXG4gICAgICAvLyAgICByZWxldmFudFJlYWxtLlxuXG4gICAgICAvLyAyLiBBYm9ydCB0aGUgZmV0Y2goKSBjYWxsIHdpdGggcCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGFuZFxuICAgICAgLy8gICAgZGVzZXJpYWxpemVkRXJyb3IuXG5cbiAgICAgIGFib3J0RmV0Y2gocCwgcmVxdWVzdCwgcmVzcG9uc2VPYmplY3QsIGNvbnRyb2xsZXIuc2VyaWFsaXplZEFib3J0UmVhc29uKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yLCB0aGVuIHJlamVjdCBwIHdpdGggYSBUeXBlRXJyb3JcbiAgICAvLyBhbmQgdGVybWluYXRlIHRoZXNlIHN1YnN0ZXBzLlxuICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBwLnJlamVjdChuZXcgVHlwZUVycm9yKCdmZXRjaCBmYWlsZWQnLCB7IGNhdXNlOiByZXNwb25zZS5lcnJvciB9KSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIDQuIFNldCByZXNwb25zZU9iamVjdCB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LFxuICAgIC8vIGdpdmVuIHJlc3BvbnNlLCBcImltbXV0YWJsZVwiLCBhbmQgcmVsZXZhbnRSZWFsbS5cbiAgICByZXNwb25zZU9iamVjdCA9IG5ldyBXZWFrUmVmKGZyb21Jbm5lclJlc3BvbnNlKHJlc3BvbnNlLCAnaW1tdXRhYmxlJykpXG5cbiAgICAvLyA1LiBSZXNvbHZlIHAgd2l0aCByZXNwb25zZU9iamVjdC5cbiAgICBwLnJlc29sdmUocmVzcG9uc2VPYmplY3QuZGVyZWYoKSlcbiAgICBwID0gbnVsbFxuICB9XG5cbiAgY29udHJvbGxlciA9IGZldGNoaW5nKHtcbiAgICByZXF1ZXN0LFxuICAgIHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keTogaGFuZGxlRmV0Y2hEb25lLFxuICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICBkaXNwYXRjaGVyOiByZXF1ZXN0T2JqZWN0W2tEaXNwYXRjaGVyXSAvLyB1bmRpY2lcbiAgfSlcblxuICAvLyAxNC4gUmV0dXJuIHAuXG4gIHJldHVybiBwLnByb21pc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZpbmFsaXplLWFuZC1yZXBvcnQtdGltaW5nXG5mdW5jdGlvbiBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZyAocmVzcG9uc2UsIGluaXRpYXRvclR5cGUgPSAnb3RoZXInKSB7XG4gIC8vIDEuIElmIHJlc3BvbnNlIGlzIGFuIGFib3J0ZWQgbmV0d29yayBlcnJvciwgdGhlbiByZXR1cm4uXG4gIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InICYmIHJlc3BvbnNlLmFib3J0ZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIElmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBudWxsIG9yIGVtcHR5LCB0aGVuIHJldHVybi5cbiAgaWYgKCFyZXNwb25zZS51cmxMaXN0Py5sZW5ndGgpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDMuIExldCBvcmlnaW5hbFVSTCBiZSByZXNwb25zZeKAmXMgVVJMIGxpc3RbMF0uXG4gIGNvbnN0IG9yaWdpbmFsVVJMID0gcmVzcG9uc2UudXJsTGlzdFswXVxuXG4gIC8vIDQuIExldCB0aW1pbmdJbmZvIGJlIHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mby5cbiAgbGV0IHRpbWluZ0luZm8gPSByZXNwb25zZS50aW1pbmdJbmZvXG5cbiAgLy8gNS4gTGV0IGNhY2hlU3RhdGUgYmUgcmVzcG9uc2XigJlzIGNhY2hlIHN0YXRlLlxuICBsZXQgY2FjaGVTdGF0ZSA9IHJlc3BvbnNlLmNhY2hlU3RhdGVcblxuICAvLyA2LiBJZiBvcmlnaW5hbFVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZSwgdGhlbiByZXR1cm4uXG4gIGlmICghdXJsSXNIdHRwSHR0cHNTY2hlbWUob3JpZ2luYWxVUkwpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyA3LiBJZiB0aW1pbmdJbmZvIGlzIG51bGwsIHRoZW4gcmV0dXJuLlxuICBpZiAodGltaW5nSW5mbyA9PT0gbnVsbCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gOC4gSWYgcmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZyBpcyBub3Qgc2V0LCB0aGVuOlxuICBpZiAoIXJlc3BvbnNlLnRpbWluZ0FsbG93UGFzc2VkKSB7XG4gICAgLy8gIDEuIFNldCB0aW1pbmdJbmZvIHRvIGEgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhbiBvcGFxdWUgdGltaW5nIGluZm8gZm9yIHRpbWluZ0luZm8uXG4gICAgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8oe1xuICAgICAgc3RhcnRUaW1lOiB0aW1pbmdJbmZvLnN0YXJ0VGltZVxuICAgIH0pXG5cbiAgICAvLyAgMi4gU2V0IGNhY2hlU3RhdGUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgICBjYWNoZVN0YXRlID0gJydcbiAgfVxuXG4gIC8vIDkuIFNldCB0aW1pbmdJbmZv4oCZcyBlbmQgdGltZSB0byB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWVcbiAgLy8gZ2l2ZW4gZ2xvYmFs4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZFxuICAvLyBjYXBhYmlsaXR5LlxuICAvLyBUT0RPOiBnaXZlbiBnbG9iYWzigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkXG4gIC8vIGNhcGFiaWxpdHk/XG4gIHRpbWluZ0luZm8uZW5kVGltZSA9IGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lKClcblxuICAvLyAxMC4gU2V0IHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mbyB0byB0aW1pbmdJbmZvLlxuICByZXNwb25zZS50aW1pbmdJbmZvID0gdGltaW5nSW5mb1xuXG4gIC8vIDExLiBNYXJrIHJlc291cmNlIHRpbWluZyBmb3IgdGltaW5nSW5mbywgb3JpZ2luYWxVUkwsIGluaXRpYXRvclR5cGUsXG4gIC8vIGdsb2JhbCwgYW5kIGNhY2hlU3RhdGUuXG4gIG1hcmtSZXNvdXJjZVRpbWluZyhcbiAgICB0aW1pbmdJbmZvLFxuICAgIG9yaWdpbmFsVVJMLmhyZWYsXG4gICAgaW5pdGlhdG9yVHlwZSxcbiAgICBnbG9iYWxUaGlzLFxuICAgIGNhY2hlU3RhdGVcbiAgKVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vcmVzb3VyY2UtdGltaW5nLyNkZm4tbWFyay1yZXNvdXJjZS10aW1pbmdcbmNvbnN0IG1hcmtSZXNvdXJjZVRpbWluZyA9IHBlcmZvcm1hbmNlLm1hcmtSZXNvdXJjZVRpbWluZ1xuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYWJvcnQtZmV0Y2hcbmZ1bmN0aW9uIGFib3J0RmV0Y2ggKHAsIHJlcXVlc3QsIHJlc3BvbnNlT2JqZWN0LCBlcnJvcikge1xuICAvLyAxLiBSZWplY3QgcHJvbWlzZSB3aXRoIGVycm9yLlxuICBpZiAocCkge1xuICAgIC8vIFdlIG1pZ2h0IGhhdmUgYWxyZWFkeSByZXNvbHZlZCB0aGUgcHJvbWlzZSBhdCB0aGlzIHN0YWdlXG4gICAgcC5yZWplY3QoZXJyb3IpXG4gIH1cblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vdCBudWxsIGFuZCBpcyByZWFkYWJsZSwgdGhlbiBjYW5jZWwgcmVxdWVzdOKAmXNcbiAgLy8gYm9keSB3aXRoIGVycm9yLlxuICBpZiAocmVxdWVzdC5ib2R5ICE9IG51bGwgJiYgaXNSZWFkYWJsZShyZXF1ZXN0LmJvZHk/LnN0cmVhbSkpIHtcbiAgICByZXF1ZXN0LmJvZHkuc3RyZWFtLmNhbmNlbChlcnJvcikuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRVJSX0lOVkFMSURfU1RBVEUnKSB7XG4gICAgICAgIC8vIE5vZGUgYnVnP1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH1cblxuICAvLyAzLiBJZiByZXNwb25zZU9iamVjdCBpcyBudWxsLCB0aGVuIHJldHVybi5cbiAgaWYgKHJlc3BvbnNlT2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDQuIExldCByZXNwb25zZSBiZSByZXNwb25zZU9iamVjdOKAmXMgcmVzcG9uc2UuXG4gIGNvbnN0IHJlc3BvbnNlID0gcmVzcG9uc2VPYmplY3Rba1N0YXRlXVxuXG4gIC8vIDUuIElmIHJlc3BvbnNl4oCZcyBib2R5IGlzIG5vdCBudWxsIGFuZCBpcyByZWFkYWJsZSwgdGhlbiBlcnJvciByZXNwb25zZeKAmXNcbiAgLy8gYm9keSB3aXRoIGVycm9yLlxuICBpZiAocmVzcG9uc2UuYm9keSAhPSBudWxsICYmIGlzUmVhZGFibGUocmVzcG9uc2UuYm9keT8uc3RyZWFtKSkge1xuICAgIHJlc3BvbnNlLmJvZHkuc3RyZWFtLmNhbmNlbChlcnJvcikuY2F0Y2goKGVycikgPT4ge1xuICAgICAgaWYgKGVyci5jb2RlID09PSAnRVJSX0lOVkFMSURfU1RBVEUnKSB7XG4gICAgICAgIC8vIE5vZGUgYnVnP1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2ZldGNoaW5nXG5mdW5jdGlvbiBmZXRjaGluZyAoe1xuICByZXF1ZXN0LFxuICBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgcHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHksXG4gIHByb2Nlc3NSZXNwb25zZSxcbiAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgdXNlUGFyYWxsZWxRdWV1ZSA9IGZhbHNlLFxuICBkaXNwYXRjaGVyID0gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpIC8vIHVuZGljaVxufSkge1xuICAvLyBFbnN1cmUgdGhhdCB0aGUgZGlzcGF0Y2hlciBpcyBzZXQgYWNjb3JkaW5nbHlcbiAgYXNzZXJ0KGRpc3BhdGNoZXIpXG5cbiAgLy8gMS4gTGV0IHRhc2tEZXN0aW5hdGlvbiBiZSBudWxsLlxuICBsZXQgdGFza0Rlc3RpbmF0aW9uID0gbnVsbFxuXG4gIC8vIDIuIExldCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSBiZSBmYWxzZS5cbiAgbGV0IGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID0gZmFsc2VcblxuICAvLyAzLiBJZiByZXF1ZXN04oCZcyBjbGllbnQgaXMgbm9uLW51bGwsIHRoZW46XG4gIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgLy8gMS4gU2V0IHRhc2tEZXN0aW5hdGlvbiB0byByZXF1ZXN04oCZcyBjbGllbnTigJlzIGdsb2JhbCBvYmplY3QuXG4gICAgdGFza0Rlc3RpbmF0aW9uID0gcmVxdWVzdC5jbGllbnQuZ2xvYmFsT2JqZWN0XG5cbiAgICAvLyAyLiBTZXQgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkgdG8gcmVxdWVzdOKAmXMgY2xpZW504oCZcyBjcm9zcy1vcmlnaW5cbiAgICAvLyBpc29sYXRlZCBjYXBhYmlsaXR5LlxuICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5ID1cbiAgICAgIHJlcXVlc3QuY2xpZW50LmNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gIH1cblxuICAvLyA0LiBJZiB1c2VQYXJhbGxlbFF1ZXVlIGlzIHRydWUsIHRoZW4gc2V0IHRhc2tEZXN0aW5hdGlvbiB0byB0aGUgcmVzdWx0IG9mXG4gIC8vIHN0YXJ0aW5nIGEgbmV3IHBhcmFsbGVsIHF1ZXVlLlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gTGV0IHRpbWluZ0luZm8gYmUgYSBuZXcgZmV0Y2ggdGltaW5nIGluZm8gd2hvc2Ugc3RhcnQgdGltZSBhbmRcbiAgLy8gcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lIGFyZSB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW5cbiAgLy8gY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkuXG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG4gIGNvbnN0IHRpbWluZ0luZm8gPSBjcmVhdGVPcGFxdWVUaW1pbmdJbmZvKHtcbiAgICBzdGFydFRpbWU6IGN1cnJlbnRUaW1lXG4gIH0pXG5cbiAgLy8gNi4gTGV0IGZldGNoUGFyYW1zIGJlIGEgbmV3IGZldGNoIHBhcmFtcyB3aG9zZVxuICAvLyByZXF1ZXN0IGlzIHJlcXVlc3QsXG4gIC8vIHRpbWluZyBpbmZvIGlzIHRpbWluZ0luZm8sXG4gIC8vIHByb2Nlc3MgcmVxdWVzdCBib2R5IGNodW5rIGxlbmd0aCBpcyBwcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aCxcbiAgLy8gcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5IGlzIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICAvLyBwcm9jZXNzIHJlc3BvbnNlIGlzIHByb2Nlc3NSZXNwb25zZSxcbiAgLy8gcHJvY2VzcyByZXNwb25zZSBjb25zdW1lIGJvZHkgaXMgcHJvY2Vzc1Jlc3BvbnNlQ29uc3VtZUJvZHksXG4gIC8vIHByb2Nlc3MgcmVzcG9uc2UgZW5kLW9mLWJvZHkgaXMgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LFxuICAvLyB0YXNrIGRlc3RpbmF0aW9uIGlzIHRhc2tEZXN0aW5hdGlvbixcbiAgLy8gYW5kIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5IGlzIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5LlxuICBjb25zdCBmZXRjaFBhcmFtcyA9IHtcbiAgICBjb250cm9sbGVyOiBuZXcgRmV0Y2goZGlzcGF0Y2hlciksXG4gICAgcmVxdWVzdCxcbiAgICB0aW1pbmdJbmZvLFxuICAgIHByb2Nlc3NSZXF1ZXN0Qm9keUNodW5rTGVuZ3RoLFxuICAgIHByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5LFxuICAgIHByb2Nlc3NSZXNwb25zZSxcbiAgICBwcm9jZXNzUmVzcG9uc2VDb25zdW1lQm9keSxcbiAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHksXG4gICAgdGFza0Rlc3RpbmF0aW9uLFxuICAgIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5XG4gIH1cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIGEgYnl0ZSBzZXF1ZW5jZSwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgYm9keSB0b1xuICAvLyAgICByZXF1ZXN04oCZcyBib2R5IGFzIGEgYm9keS5cbiAgLy8gTk9URTogU2luY2UgZmV0Y2hpbmcgaXMgb25seSBjYWxsZWQgZnJvbSBmZXRjaCwgYm9keSBzaG91bGQgYWxyZWFkeSBiZVxuICAvLyBleHRyYWN0ZWQuXG4gIGFzc2VydCghcmVxdWVzdC5ib2R5IHx8IHJlcXVlc3QuYm9keS5zdHJlYW0pXG5cbiAgLy8gOC4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwiY2xpZW50XCIsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHdpbmRvdyB0byByZXF1ZXN04oCZc1xuICAvLyBjbGllbnQsIGlmIHJlcXVlc3TigJlzIGNsaWVudOKAmXMgZ2xvYmFsIG9iamVjdCBpcyBhIFdpbmRvdyBvYmplY3Q7IG90aGVyd2lzZVxuICAvLyBcIm5vLXdpbmRvd1wiLlxuICBpZiAocmVxdWVzdC53aW5kb3cgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gVE9ETzogV2hhdCBpZiByZXF1ZXN0LmNsaWVudCBpcyBudWxsP1xuICAgIHJlcXVlc3Qud2luZG93ID1cbiAgICAgIHJlcXVlc3QuY2xpZW50Py5nbG9iYWxPYmplY3Q/LmNvbnN0cnVjdG9yPy5uYW1lID09PSAnV2luZG93J1xuICAgICAgICA/IHJlcXVlc3QuY2xpZW50XG4gICAgICAgIDogJ25vLXdpbmRvdydcbiAgfVxuXG4gIC8vIDkuIElmIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBcImNsaWVudFwiLCB0aGVuIHNldCByZXF1ZXN04oCZcyBvcmlnaW4gdG8gcmVxdWVzdOKAmXNcbiAgLy8gY2xpZW504oCZcyBvcmlnaW4uXG4gIGlmIChyZXF1ZXN0Lm9yaWdpbiA9PT0gJ2NsaWVudCcpIHtcbiAgICByZXF1ZXN0Lm9yaWdpbiA9IHJlcXVlc3QuY2xpZW50Lm9yaWdpblxuICB9XG5cbiAgLy8gMTAuIElmIGFsbCBvZiB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIFRPRE9cblxuICAvLyAxMS4gSWYgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciBpcyBcImNsaWVudFwiLCB0aGVuOlxuICBpZiAocmVxdWVzdC5wb2xpY3lDb250YWluZXIgPT09ICdjbGllbnQnKSB7XG4gICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgY2xpZW50IGlzIG5vbi1udWxsLCB0aGVuIHNldCByZXF1ZXN04oCZcyBwb2xpY3lcbiAgICAvLyBjb250YWluZXIgdG8gYSBjbG9uZSBvZiByZXF1ZXN04oCZcyBjbGllbnTigJlzIHBvbGljeSBjb250YWluZXIuIFtIVE1MXVxuICAgIGlmIChyZXF1ZXN0LmNsaWVudCAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0LnBvbGljeUNvbnRhaW5lciA9IGNsb25lUG9saWN5Q29udGFpbmVyKFxuICAgICAgICByZXF1ZXN0LmNsaWVudC5wb2xpY3lDb250YWluZXJcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gMi4gT3RoZXJ3aXNlLCBzZXQgcmVxdWVzdOKAmXMgcG9saWN5IGNvbnRhaW5lciB0byBhIG5ldyBwb2xpY3lcbiAgICAgIC8vIGNvbnRhaW5lci5cbiAgICAgIHJlcXVlc3QucG9saWN5Q29udGFpbmVyID0gbWFrZVBvbGljeUNvbnRhaW5lcigpXG4gICAgfVxuICB9XG5cbiAgLy8gMTIuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdGAsIHRoZW46XG4gIGlmICghcmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnYWNjZXB0JywgdHJ1ZSkpIHtcbiAgICAvLyAxLiBMZXQgdmFsdWUgYmUgYCovKmAuXG4gICAgY29uc3QgdmFsdWUgPSAnKi8qJ1xuXG4gICAgLy8gMi4gQSB1c2VyIGFnZW50IHNob3VsZCBzZXQgdmFsdWUgdG8gdGhlIGZpcnN0IG1hdGNoaW5nIHN0YXRlbWVudCwgaWZcbiAgICAvLyBhbnksIHN3aXRjaGluZyBvbiByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbjpcbiAgICAvLyBcImRvY3VtZW50XCJcbiAgICAvLyBcImZyYW1lXCJcbiAgICAvLyBcImlmcmFtZVwiXG4gICAgLy8gYHRleHQvaHRtbCxhcHBsaWNhdGlvbi94aHRtbCt4bWwsYXBwbGljYXRpb24veG1sO3E9MC45LCovKjtxPTAuOGBcbiAgICAvLyBcImltYWdlXCJcbiAgICAvLyBgaW1hZ2UvcG5nLGltYWdlL3N2Zyt4bWwsaW1hZ2UvKjtxPTAuOCwqLyo7cT0wLjVgXG4gICAgLy8gXCJzdHlsZVwiXG4gICAgLy8gYHRleHQvY3NzLCovKjtxPTAuMWBcbiAgICAvLyBUT0RPXG5cbiAgICAvLyAzLiBBcHBlbmQgYEFjY2VwdGAvdmFsdWUgdG8gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2FjY2VwdCcsIHZhbHVlLCB0cnVlKVxuICB9XG5cbiAgLy8gMTMuIElmIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0IGRvZXMgbm90IGNvbnRhaW4gYEFjY2VwdC1MYW5ndWFnZWAsIHRoZW5cbiAgLy8gdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgQWNjZXB0LUxhbmd1YWdlYC9hbiBhcHByb3ByaWF0ZSB2YWx1ZSB0b1xuICAvLyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdhY2NlcHQtbGFuZ3VhZ2UnLCB0cnVlKSkge1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtbGFuZ3VhZ2UnLCAnKicsIHRydWUpXG4gIH1cblxuICAvLyAxNC4gSWYgcmVxdWVzdOKAmXMgcHJpb3JpdHkgaXMgbnVsbCwgdGhlbiB1c2UgcmVxdWVzdOKAmXMgaW5pdGlhdG9yIGFuZFxuICAvLyBkZXN0aW5hdGlvbiBhcHByb3ByaWF0ZWx5IGluIHNldHRpbmcgcmVxdWVzdOKAmXMgcHJpb3JpdHkgdG8gYVxuICAvLyB1c2VyLWFnZW50LWRlZmluZWQgb2JqZWN0LlxuICBpZiAocmVxdWVzdC5wcmlvcml0eSA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE1LiBJZiByZXF1ZXN0IGlzIGEgc3VicmVzb3VyY2UgcmVxdWVzdCwgdGhlbjpcbiAgaWYgKHN1YnJlc291cmNlU2V0LmhhcyhyZXF1ZXN0LmRlc3RpbmF0aW9uKSkge1xuICAgIC8vIFRPRE9cbiAgfVxuXG4gIC8vIDE2LiBSdW4gbWFpbiBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgbWFpbkZldGNoKGZldGNoUGFyYW1zKVxuICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZXJyKVxuICAgIH0pXG5cbiAgLy8gMTcuIFJldHVybiBmZXRjaFBhcmFtJ3MgY29udHJvbGxlclxuICByZXR1cm4gZmV0Y2hQYXJhbXMuY29udHJvbGxlclxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1tYWluLWZldGNoXG5hc3luYyBmdW5jdGlvbiBtYWluRmV0Y2ggKGZldGNoUGFyYW1zLCByZWN1cnNpdmUgPSBmYWxzZSkge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgcmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IHJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDMuIElmIHJlcXVlc3TigJlzIGxvY2FsLVVSTHMtb25seSBmbGFnIGlzIHNldCBhbmQgcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXNcbiAgLy8gbm90IGxvY2FsLCB0aGVuIHNldCByZXNwb25zZSB0byBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChyZXF1ZXN0LmxvY2FsVVJMc09ubHkgJiYgIXVybElzTG9jYWwocmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKCdsb2NhbCBVUkxzIG9ubHknKVxuICB9XG5cbiAgLy8gNC4gUnVuIHJlcG9ydCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB2aW9sYXRpb25zIGZvciByZXF1ZXN0LlxuICAvLyBUT0RPXG5cbiAgLy8gNS4gVXBncmFkZSByZXF1ZXN0IHRvIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLCBpZiBhcHByb3ByaWF0ZS5cbiAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMKHJlcXVlc3QpXG5cbiAgLy8gNi4gSWYgc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBkdWUgdG8gYSBiYWQgcG9ydCwgc2hvdWxkIGZldGNoaW5nIHJlcXVlc3RcbiAgLy8gYmUgYmxvY2tlZCBhcyBtaXhlZCBjb250ZW50LCBvciBzaG91bGQgcmVxdWVzdCBiZSBibG9ja2VkIGJ5IENvbnRlbnRcbiAgLy8gU2VjdXJpdHkgUG9saWN5IHJldHVybnMgYmxvY2tlZCwgdGhlbiBzZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAocmVxdWVzdEJhZFBvcnQocmVxdWVzdCkgPT09ICdibG9ja2VkJykge1xuICAgIHJlc3BvbnNlID0gbWFrZU5ldHdvcmtFcnJvcignYmFkIHBvcnQnKVxuICB9XG4gIC8vIFRPRE86IHNob3VsZCBmZXRjaGluZyByZXF1ZXN0IGJlIGJsb2NrZWQgYXMgbWl4ZWQgY29udGVudD9cbiAgLy8gVE9ETzogc2hvdWxkIHJlcXVlc3QgYmUgYmxvY2tlZCBieSBDb250ZW50IFNlY3VyaXR5IFBvbGljeT9cblxuICAvLyA3LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgaXMgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgLy8gcmVmZXJyZXIgcG9saWN5IHRvIHJlcXVlc3TigJlzIHBvbGljeSBjb250YWluZXLigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgaWYgKHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPT09ICcnKSB7XG4gICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9IHJlcXVlc3QucG9saWN5Q29udGFpbmVyLnJlZmVycmVyUG9saWN5XG4gIH1cblxuICAvLyA4LiBJZiByZXF1ZXN04oCZcyByZWZlcnJlciBpcyBub3QgXCJuby1yZWZlcnJlclwiLCB0aGVuIHNldCByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlciB0byB0aGUgcmVzdWx0IG9mIGludm9raW5nIGRldGVybWluZSByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgaWYgKHJlcXVlc3QucmVmZXJyZXIgIT09ICduby1yZWZlcnJlcicpIHtcbiAgICByZXF1ZXN0LnJlZmVycmVyID0gZGV0ZXJtaW5lUmVxdWVzdHNSZWZlcnJlcihyZXF1ZXN0KVxuICB9XG5cbiAgLy8gOS4gU2V0IHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgdG8gXCJodHRwc1wiIGlmIGFsbCBvZiB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gIC8vIC0gcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIHNjaGVtZSBpcyBcImh0dHBcIlxuICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBob3N0IGlzIGEgZG9tYWluXG4gIC8vIC0gTWF0Y2hpbmcgcmVxdWVzdOKAmXMgY3VycmVudCBVUkzigJlzIGhvc3QgcGVyIEtub3duIEhTVFMgSG9zdCBEb21haW4gTmFtZVxuICAvLyAgIE1hdGNoaW5nIHJlc3VsdHMgaW4gZWl0aGVyIGEgc3VwZXJkb21haW4gbWF0Y2ggd2l0aCBhbiBhc3NlcnRlZFxuICAvLyAgIGluY2x1ZGVTdWJEb21haW5zIGRpcmVjdGl2ZSBvciBhIGNvbmdydWVudCBtYXRjaCAod2l0aCBvciB3aXRob3V0IGFuXG4gIC8vICAgYXNzZXJ0ZWQgaW5jbHVkZVN1YkRvbWFpbnMgZGlyZWN0aXZlKS4gW0hTVFNdXG4gIC8vIFRPRE9cblxuICAvLyAxMC4gSWYgcmVjdXJzaXZlIGlzIGZhbHNlLCB0aGVuIHJ1biB0aGUgcmVtYWluaW5nIHN0ZXBzIGluIHBhcmFsbGVsLlxuICAvLyBUT0RPXG5cbiAgLy8gMTEuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW4gc2V0IHJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAvLyB0aGUgc3RlcHMgY29ycmVzcG9uZGluZyB0byB0aGUgZmlyc3QgbWF0Y2hpbmcgc3RhdGVtZW50OlxuICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICByZXNwb25zZSA9IGF3YWl0IChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAgICAgaWYgKFxuICAgICAgICAvLyAtIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBvcmlnaW4gaXMgc2FtZSBvcmlnaW4gd2l0aCByZXF1ZXN04oCZcyBvcmlnaW4sXG4gICAgICAgIC8vICAgYW5kIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiYmFzaWNcIlxuICAgICAgICAoc2FtZU9yaWdpbihjdXJyZW50VVJMLCByZXF1ZXN0LnVybCkgJiYgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKSB8fFxuICAgICAgICAvLyByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgc2NoZW1lIGlzIFwiZGF0YVwiXG4gICAgICAgIChjdXJyZW50VVJMLnByb3RvY29sID09PSAnZGF0YTonKSB8fFxuICAgICAgICAvLyAtIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJuYXZpZ2F0ZVwiIG9yIFwid2Vic29ja2V0XCJcbiAgICAgICAgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJyB8fCByZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnKVxuICAgICAgKSB7XG4gICAgICAgIC8vIDEuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcImJhc2ljXCIuXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9ICdiYXNpYydcblxuICAgICAgICAvLyAyLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNjaGVtZSBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNjaGVtZUZldGNoKGZldGNoUGFyYW1zKVxuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN04oCZcyBtb2RlIGlzIFwic2FtZS1vcmlnaW5cIlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ3NhbWUtb3JpZ2luJykge1xuICAgICAgICAvLyAxLiBSZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcigncmVxdWVzdCBtb2RlIGNhbm5vdCBiZSBcInNhbWUtb3JpZ2luXCInKVxuICAgICAgfVxuXG4gICAgICAvLyByZXF1ZXN04oCZcyBtb2RlIGlzIFwibm8tY29yc1wiXG4gICAgICBpZiAocmVxdWVzdC5tb2RlID09PSAnbm8tY29ycycpIHtcbiAgICAgICAgLy8gMS4gSWYgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSBpcyBub3QgXCJmb2xsb3dcIiwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gICAgICAgIC8vIGVycm9yLlxuICAgICAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ2ZvbGxvdycpIHtcbiAgICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihcbiAgICAgICAgICAgICdyZWRpcmVjdCBtb2RlIGNhbm5vdCBiZSBcImZvbGxvd1wiIGZvciBcIm5vLWNvcnNcIiByZXF1ZXN0J1xuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDIuIFNldCByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyB0byBcIm9wYXF1ZVwiLlxuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPSAnb3BhcXVlJ1xuXG4gICAgICAgIC8vIDMuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgc2NoZW1lIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuICAgICAgICByZXR1cm4gYXdhaXQgc2NoZW1lRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgICB9XG5cbiAgICAgIC8vIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgbm90IGFuIEhUVFAoUykgc2NoZW1lXG4gICAgICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAvLyBSZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcignVVJMIHNjaGVtZSBtdXN0IGJlIGEgSFRUUChTKSBzY2hlbWUnKVxuICAgICAgfVxuXG4gICAgICAvLyAtIHJlcXVlc3TigJlzIHVzZS1DT1JTLXByZWZsaWdodCBmbGFnIGlzIHNldFxuICAgICAgLy8gLSByZXF1ZXN04oCZcyB1bnNhZmUtcmVxdWVzdCBmbGFnIGlzIHNldCBhbmQgZWl0aGVyIHJlcXVlc3TigJlzIG1ldGhvZCBpc1xuICAgICAgLy8gICBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgbWV0aG9kIG9yIENPUlMtdW5zYWZlIHJlcXVlc3QtaGVhZGVyIG5hbWVzIHdpdGhcbiAgICAgIC8vICAgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgaXMgbm90IGVtcHR5XG4gICAgICAvLyAgICAxLiBTZXQgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgdG8gXCJjb3JzXCIuXG4gICAgICAvLyAgICAyLiBMZXQgY29yc1dpdGhQcmVmbGlnaHRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaFxuICAgICAgLy8gICAgZ2l2ZW4gZmV0Y2hQYXJhbXMgYW5kIHRydWUuXG4gICAgICAvLyAgICAzLiBJZiBjb3JzV2l0aFByZWZsaWdodFJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciwgdGhlbiBjbGVhciBjYWNoZVxuICAgICAgLy8gICAgZW50cmllcyB1c2luZyByZXF1ZXN0LlxuICAgICAgLy8gICAgNC4gUmV0dXJuIGNvcnNXaXRoUHJlZmxpZ2h0UmVzcG9uc2UuXG4gICAgICAvLyBUT0RPXG5cbiAgICAgIC8vIE90aGVyd2lzZVxuICAgICAgLy8gICAgMS4gU2V0IHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIHRvIFwiY29yc1wiLlxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID0gJ2NvcnMnXG5cbiAgICAgIC8vICAgIDIuIFJldHVybiB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUCBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICAgIHJldHVybiBhd2FpdCBodHRwRmV0Y2goZmV0Y2hQYXJhbXMpXG4gICAgfSkoKVxuICB9XG5cbiAgLy8gMTIuIElmIHJlY3Vyc2l2ZSBpcyB0cnVlLCB0aGVuIHJldHVybiByZXNwb25zZS5cbiAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgLy8gMTMuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIHJlc3BvbnNlIGlzIG5vdCBhIGZpbHRlcmVkXG4gIC8vIHJlc3BvbnNlLCB0aGVuOlxuICBpZiAocmVzcG9uc2Uuc3RhdHVzICE9PSAwICYmICFyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgLy8gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJjb3JzXCIsIHRoZW46XG4gICAgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnKSB7XG4gICAgICAvLyAxLiBMZXQgaGVhZGVyTmFtZXMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlc1xuICAgICAgLy8gZ2l2ZW4gYEFjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZSBpcyBub3QgXCJpbmNsdWRlXCIgYW5kIGhlYWRlck5hbWVzXG4gICAgICAvLyBjb250YWlucyBgKmAsIHRoZW4gc2V0IHJlc3BvbnNl4oCZcyBDT1JTLWV4cG9zZWQgaGVhZGVyLW5hbWUgbGlzdCB0b1xuICAgICAgLy8gYWxsIHVuaXF1ZSBoZWFkZXIgbmFtZXMgaW4gcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gVE9ET1xuICAgICAgLy8gMy4gT3RoZXJ3aXNlLCBpZiBoZWFkZXJOYW1lcyBpcyBub3QgbnVsbCBvciBmYWlsdXJlLCB0aGVuIHNldFxuICAgICAgLy8gcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0IHRvIGhlYWRlck5hbWVzLlxuICAgICAgLy8gVE9ET1xuICAgIH1cblxuICAgIC8vIFNldCByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nIGZpbHRlcmVkIHJlc3BvbnNlIHdpdGggcmVzcG9uc2UgYXMgaXRzXG4gICAgLy8gaW50ZXJuYWwgcmVzcG9uc2UsIGRlcGVuZGluZyBvbiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZzpcbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKSB7XG4gICAgICByZXNwb25zZSA9IGZpbHRlclJlc3BvbnNlKHJlc3BvbnNlLCAnYmFzaWMnKVxuICAgIH0gZWxzZSBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycpIHtcbiAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdjb3JzJylcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ29wYXF1ZScpIHtcbiAgICAgIHJlc3BvbnNlID0gZmlsdGVyUmVzcG9uc2UocmVzcG9uc2UsICdvcGFxdWUnKVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgLy8gMTQuIExldCBpbnRlcm5hbFJlc3BvbnNlIGJlIHJlc3BvbnNlLCBpZiByZXNwb25zZSBpcyBhIG5ldHdvcmsgZXJyb3IsXG4gIC8vIGFuZCByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2Ugb3RoZXJ3aXNlLlxuICBsZXQgaW50ZXJuYWxSZXNwb25zZSA9XG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSAwID8gcmVzcG9uc2UgOiByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlXG5cbiAgLy8gMTUuIElmIGludGVybmFsUmVzcG9uc2XigJlzIFVSTCBsaXN0IGlzIGVtcHR5LCB0aGVuIHNldCBpdCB0byBhIGNsb25lIG9mXG4gIC8vIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICBpZiAoaW50ZXJuYWxSZXNwb25zZS51cmxMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIGludGVybmFsUmVzcG9uc2UudXJsTGlzdC5wdXNoKC4uLnJlcXVlc3QudXJsTGlzdClcbiAgfVxuXG4gIC8vIDE2LiBJZiByZXF1ZXN04oCZcyB0aW1pbmcgYWxsb3cgZmFpbGVkIGZsYWcgaXMgdW5zZXQsIHRoZW4gc2V0XG4gIC8vIGludGVybmFsUmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZy5cbiAgaWYgKCFyZXF1ZXN0LnRpbWluZ0FsbG93RmFpbGVkKSB7XG4gICAgcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQgPSB0cnVlXG4gIH1cblxuICAvLyAxNy4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgYW55IG9mIHRoZSBmb2xsb3dpbmcgcmV0dXJuc1xuICAvLyBibG9ja2VkXG4gIC8vIC0gc2hvdWxkIGludGVybmFsUmVzcG9uc2UgdG8gcmVxdWVzdCBiZSBibG9ja2VkIGFzIG1peGVkIGNvbnRlbnRcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgYnkgQ29udGVudCBTZWN1cml0eSBQb2xpY3lcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIGl0cyBNSU1FIHR5cGVcbiAgLy8gLSBzaG91bGQgaW50ZXJuYWxSZXNwb25zZSB0byByZXF1ZXN0IGJlIGJsb2NrZWQgZHVlIHRvIG5vc25pZmZcbiAgLy8gVE9ET1xuXG4gIC8vIDE4LiBJZiByZXNwb25zZeKAmXMgdHlwZSBpcyBcIm9wYXF1ZVwiLCBpbnRlcm5hbFJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgMjA2LFxuICAvLyBpbnRlcm5hbFJlc3BvbnNl4oCZcyByYW5nZS1yZXF1ZXN0ZWQgZmxhZyBpcyBzZXQsIGFuZCByZXF1ZXN04oCZcyBoZWFkZXJcbiAgLy8gbGlzdCBkb2VzIG5vdCBjb250YWluIGBSYW5nZWAsIHRoZW4gc2V0IHJlc3BvbnNlIGFuZCBpbnRlcm5hbFJlc3BvbnNlXG4gIC8vIHRvIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlc3BvbnNlLnR5cGUgPT09ICdvcGFxdWUnICYmXG4gICAgaW50ZXJuYWxSZXNwb25zZS5zdGF0dXMgPT09IDIwNiAmJlxuICAgIGludGVybmFsUmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgJiZcbiAgICAhcmVxdWVzdC5oZWFkZXJzLmNvbnRhaW5zKCdyYW5nZScsIHRydWUpXG4gICkge1xuICAgIHJlc3BvbnNlID0gaW50ZXJuYWxSZXNwb25zZSA9IG1ha2VOZXR3b3JrRXJyb3IoKVxuICB9XG5cbiAgLy8gMTkuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIGVpdGhlciByZXF1ZXN04oCZcyBtZXRob2QgaXNcbiAgLy8gYEhFQURgIG9yIGBDT05ORUNUYCwgb3IgaW50ZXJuYWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIGEgbnVsbCBib2R5IHN0YXR1cyxcbiAgLy8gc2V0IGludGVybmFsUmVzcG9uc2XigJlzIGJvZHkgdG8gbnVsbCBhbmQgZGlzcmVnYXJkIGFueSBlbnF1ZXVpbmcgdG93YXJkXG4gIC8vIGl0IChpZiBhbnkpLlxuICBpZiAoXG4gICAgcmVzcG9uc2Uuc3RhdHVzICE9PSAwICYmXG4gICAgKHJlcXVlc3QubWV0aG9kID09PSAnSEVBRCcgfHxcbiAgICAgIHJlcXVlc3QubWV0aG9kID09PSAnQ09OTkVDVCcgfHxcbiAgICAgIG51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKGludGVybmFsUmVzcG9uc2Uuc3RhdHVzKSlcbiAgKSB7XG4gICAgaW50ZXJuYWxSZXNwb25zZS5ib2R5ID0gbnVsbFxuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZHVtcCA9IHRydWVcbiAgfVxuXG4gIC8vIDIwLiBJZiByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEgaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIHRoZW46XG4gIGlmIChyZXF1ZXN0LmludGVncml0eSkge1xuICAgIC8vIDEuIExldCBwcm9jZXNzQm9keUVycm9yIGJlIHRoaXMgc3RlcDogcnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtc1xuICAgIC8vIGFuZCBhIG5ldHdvcmsgZXJyb3IuXG4gICAgY29uc3QgcHJvY2Vzc0JvZHlFcnJvciA9IChyZWFzb24pID0+XG4gICAgICBmZXRjaEZpbmFsZShmZXRjaFBhcmFtcywgbWFrZU5ldHdvcmtFcnJvcihyZWFzb24pKVxuXG4gICAgLy8gMi4gSWYgcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmcgaXMgXCJvcGFxdWVcIiwgb3IgcmVzcG9uc2XigJlzIGJvZHkgaXMgbnVsbCxcbiAgICAvLyB0aGVuIHJ1biBwcm9jZXNzQm9keUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnb3BhcXVlJyB8fCByZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICAgIHByb2Nlc3NCb2R5RXJyb3IocmVzcG9uc2UuZXJyb3IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAzLiBMZXQgcHJvY2Vzc0JvZHkgZ2l2ZW4gYnl0ZXMgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0JvZHkgPSAoYnl0ZXMpID0+IHtcbiAgICAgIC8vIDEuIElmIGJ5dGVzIGRvIG5vdCBtYXRjaCByZXF1ZXN04oCZcyBpbnRlZ3JpdHkgbWV0YWRhdGEsXG4gICAgICAvLyB0aGVuIHJ1biBwcm9jZXNzQm9keUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy4gW1NSSV1cbiAgICAgIGlmICghYnl0ZXNNYXRjaChieXRlcywgcmVxdWVzdC5pbnRlZ3JpdHkpKSB7XG4gICAgICAgIHByb2Nlc3NCb2R5RXJyb3IoJ2ludGVncml0eSBtaXNtYXRjaCcpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBTZXQgcmVzcG9uc2XigJlzIGJvZHkgdG8gYnl0ZXMgYXMgYSBib2R5LlxuICAgICAgcmVzcG9uc2UuYm9keSA9IHNhZmVseUV4dHJhY3RCb2R5KGJ5dGVzKVswXVxuXG4gICAgICAvLyAzLiBSdW4gZmV0Y2ggZmluYWxlIGdpdmVuIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZS5cbiAgICAgIGZldGNoRmluYWxlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcbiAgICB9XG5cbiAgICAvLyA0LiBGdWxseSByZWFkIHJlc3BvbnNl4oCZcyBib2R5IGdpdmVuIHByb2Nlc3NCb2R5IGFuZCBwcm9jZXNzQm9keUVycm9yLlxuICAgIGF3YWl0IGZ1bGx5UmVhZEJvZHkocmVzcG9uc2UuYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpXG4gIH0gZWxzZSB7XG4gICAgLy8gMjEuIE90aGVyd2lzZSwgcnVuIGZldGNoIGZpbmFsZSBnaXZlbiBmZXRjaFBhcmFtcyBhbmQgcmVzcG9uc2UuXG4gICAgZmV0Y2hGaW5hbGUoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LXNjaGVtZS1mZXRjaFxuLy8gZ2l2ZW4gYSBmZXRjaCBwYXJhbXMgZmV0Y2hQYXJhbXNcbmZ1bmN0aW9uIHNjaGVtZUZldGNoIChmZXRjaFBhcmFtcykge1xuICAvLyBOb3RlOiBzaW5jZSB0aGUgY29ubmVjdGlvbiBpcyBkZXN0cm95ZWQgb24gcmVkaXJlY3QsIHdoaWNoIHNldHMgZmV0Y2hQYXJhbXMgdG8gYVxuICAvLyBjYW5jZWxsZWQgc3RhdGUsIHdlIGRvIG5vdCB3YW50IHRoaXMgY29uZGl0aW9uIHRvIHRyaWdnZXIgKnVubGVzcyogdGhlcmUgaGF2ZSBiZWVuXG4gIC8vIG5vIHJlZGlyZWN0cy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL2lzc3Vlcy8xNzc2XG4gIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykgJiYgZmV0Y2hQYXJhbXMucmVxdWVzdC5yZWRpcmVjdENvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMpKVxuICB9XG5cbiAgLy8gMi4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHsgcmVxdWVzdCB9ID0gZmV0Y2hQYXJhbXNcblxuICBjb25zdCB7IHByb3RvY29sOiBzY2hlbWUgfSA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgLy8gMy4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgYW5kIHJ1biB0aGUgYXNzb2NpYXRlZCBzdGVwczpcbiAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICBjYXNlICdhYm91dDonOiB7XG4gICAgICAvLyBJZiByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgcGF0aCBpcyB0aGUgc3RyaW5nIFwiYmxhbmtcIiwgdGhlbiByZXR1cm4gYSBuZXcgcmVzcG9uc2VcbiAgICAgIC8vIHdob3NlIHN0YXR1cyBtZXNzYWdlIGlzIGBPS2AsIGhlYWRlciBsaXN0IGlzIMKrIChgQ29udGVudC1UeXBlYCwgYHRleHQvaHRtbDtjaGFyc2V0PXV0Zi04YCkgwrssXG4gICAgICAvLyBhbmQgYm9keSBpcyB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSBhcyBhIGJvZHkuXG5cbiAgICAgIC8vIE90aGVyd2lzZSwgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignYWJvdXQgc2NoZW1lIGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICB9XG4gICAgY2FzZSAnYmxvYjonOiB7XG4gICAgICBpZiAoIXJlc29sdmVPYmplY3RVUkwpIHtcbiAgICAgICAgcmVzb2x2ZU9iamVjdFVSTCA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJykucmVzb2x2ZU9iamVjdFVSTFxuICAgICAgfVxuXG4gICAgICAvLyAxLiBMZXQgYmxvYlVSTEVudHJ5IGJlIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBibG9iIFVSTCBlbnRyeS5cbiAgICAgIGNvbnN0IGJsb2JVUkxFbnRyeSA9IHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpXG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWItcGxhdGZvcm0tdGVzdHMvd3B0L2Jsb2IvN2IwZWJhY2NjNjJiNTY2YTE5NjUzOTZlNWJlN2JiMmJjMDZmODQxZi9GaWxlQVBJL3VybC9yZXNvdXJjZXMvZmV0Y2gtdGVzdHMuanMjTDUyLUw1NlxuICAgICAgLy8gQnVmZmVyLnJlc29sdmVPYmplY3RVUkwgZG9lcyBub3QgaWdub3JlIFVSTCBxdWVyaWVzLlxuICAgICAgaWYgKGJsb2JVUkxFbnRyeS5zZWFyY2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS4nKSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgYmxvYiA9IHJlc29sdmVPYmplY3RVUkwoYmxvYlVSTEVudHJ5LnRvU3RyaW5nKCkpXG5cbiAgICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBub3QgYEdFVGAsIGJsb2JVUkxFbnRyeSBpcyBudWxsLCBvciBibG9iVVJMRW50cnnigJlzXG4gICAgICAvLyAgICBvYmplY3QgaXMgbm90IGEgQmxvYiBvYmplY3QsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIGlmIChyZXF1ZXN0Lm1ldGhvZCAhPT0gJ0dFVCcgfHwgIWlzQmxvYkxpa2UoYmxvYikpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdpbnZhbGlkIG1ldGhvZCcpKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBMZXQgYmxvYiBiZSBibG9iVVJMRW50cnnigJlzIG9iamVjdC5cbiAgICAgIC8vIE5vdGU6IGRvbmUgYWJvdmVcblxuICAgICAgLy8gNC4gTGV0IHJlc3BvbnNlIGJlIGEgbmV3IHJlc3BvbnNlLlxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBtYWtlUmVzcG9uc2UoKVxuXG4gICAgICAvLyA1LiBMZXQgZnVsbExlbmd0aCBiZSBibG9i4oCZcyBzaXplLlxuICAgICAgY29uc3QgZnVsbExlbmd0aCA9IGJsb2Iuc2l6ZVxuXG4gICAgICAvLyA2LiBMZXQgc2VyaWFsaXplZEZ1bGxMZW5ndGggYmUgZnVsbExlbmd0aCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLlxuICAgICAgY29uc3Qgc2VyaWFsaXplZEZ1bGxMZW5ndGggPSBpc29tb3JwaGljRW5jb2RlKGAke2Z1bGxMZW5ndGh9YClcblxuICAgICAgLy8gNy4gTGV0IHR5cGUgYmUgYmxvYuKAmXMgdHlwZS5cbiAgICAgIGNvbnN0IHR5cGUgPSBibG9iLnR5cGVcblxuICAgICAgLy8gOC4gSWYgcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgUmFuZ2VgOlxuICAgICAgLy8gOS4gT3RoZXJ3aXNlOlxuICAgICAgaWYgKCFyZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdyYW5nZScsIHRydWUpKSB7XG4gICAgICAgIC8vIDEuIExldCBib2R5V2l0aFR5cGUgYmUgdGhlIHJlc3VsdCBvZiBzYWZlbHkgZXh0cmFjdGluZyBibG9iLlxuICAgICAgICAvLyBOb3RlOiBpbiB0aGUgRmlsZUFQSSBhIGJsb2IgXCJvYmplY3RcIiBpcyBhIEJsb2IgKm9yKiBhIE1lZGlhU291cmNlLlxuICAgICAgICAvLyBJbiBub2RlLCB0aGlzIGNhbiBvbmx5IGV2ZXIgYmUgYSBCbG9iLiBUaGVyZWZvcmUgd2UgY2FuIHNhZmVseVxuICAgICAgICAvLyB1c2UgZXh0cmFjdEJvZHkgZGlyZWN0bHkuXG4gICAgICAgIGNvbnN0IGJvZHlXaXRoVHlwZSA9IGV4dHJhY3RCb2R5KGJsb2IpXG5cbiAgICAgICAgLy8gMi4gU2V0IHJlc3BvbnNl4oCZcyBzdGF0dXMgbWVzc2FnZSB0byBgT0tgLlxuICAgICAgICByZXNwb25zZS5zdGF0dXNUZXh0ID0gJ09LJ1xuXG4gICAgICAgIC8vIDMuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byBib2R5V2l0aFR5cGXigJlzIGJvZHkuXG4gICAgICAgIHJlc3BvbnNlLmJvZHkgPSBib2R5V2l0aFR5cGVbMF1cblxuICAgICAgICAvLyA0LiBTZXQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0IHRvIMKrIChgQ29udGVudC1MZW5ndGhgLCBzZXJpYWxpemVkRnVsbExlbmd0aCksIChgQ29udGVudC1UeXBlYCwgdHlwZSkgwrsuXG4gICAgICAgIHJlc3BvbnNlLmhlYWRlcnNMaXN0LnNldCgnY29udGVudC1sZW5ndGgnLCBzZXJpYWxpemVkRnVsbExlbmd0aCwgdHJ1ZSlcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KCdjb250ZW50LXR5cGUnLCB0eXBlLCB0cnVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMS4gU2V0IHJlc3BvbnNl4oCZcyByYW5nZS1yZXF1ZXN0ZWQgZmxhZy5cbiAgICAgICAgcmVzcG9uc2UucmFuZ2VSZXF1ZXN0ZWQgPSB0cnVlXG5cbiAgICAgICAgLy8gMi4gTGV0IHJhbmdlSGVhZGVyIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBgUmFuZ2VgIGZyb20gcmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAgIGNvbnN0IHJhbmdlSGVhZGVyID0gcmVxdWVzdC5oZWFkZXJzTGlzdC5nZXQoJ3JhbmdlJywgdHJ1ZSlcblxuICAgICAgICAvLyAzLiBMZXQgcmFuZ2VWYWx1ZSBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgYSBzaW5nbGUgcmFuZ2UgaGVhZGVyIHZhbHVlIGdpdmVuIHJhbmdlSGVhZGVyIGFuZCB0cnVlLlxuICAgICAgICBjb25zdCByYW5nZVZhbHVlID0gc2ltcGxlUmFuZ2VIZWFkZXJWYWx1ZShyYW5nZUhlYWRlciwgdHJ1ZSlcblxuICAgICAgICAvLyA0LiBJZiByYW5nZVZhbHVlIGlzIGZhaWx1cmUsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgICAgaWYgKHJhbmdlVmFsdWUgPT09ICdmYWlsdXJlJykge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignZmFpbGVkIHRvIGZldGNoIHRoZSBkYXRhIFVSTCcpKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gNS4gTGV0IChyYW5nZVN0YXJ0LCByYW5nZUVuZCkgYmUgcmFuZ2VWYWx1ZS5cbiAgICAgICAgbGV0IHsgcmFuZ2VTdGFydFZhbHVlOiByYW5nZVN0YXJ0LCByYW5nZUVuZFZhbHVlOiByYW5nZUVuZCB9ID0gcmFuZ2VWYWx1ZVxuXG4gICAgICAgIC8vIDYuIElmIHJhbmdlU3RhcnQgaXMgbnVsbDpcbiAgICAgICAgLy8gNy4gT3RoZXJ3aXNlOlxuICAgICAgICBpZiAocmFuZ2VTdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIDEuIFNldCByYW5nZVN0YXJ0IHRvIGZ1bGxMZW5ndGgg4oiSIHJhbmdlRW5kLlxuICAgICAgICAgIHJhbmdlU3RhcnQgPSBmdWxsTGVuZ3RoIC0gcmFuZ2VFbmRcblxuICAgICAgICAgIC8vIDIuIFNldCByYW5nZUVuZCB0byByYW5nZVN0YXJ0ICsgcmFuZ2VFbmQg4oiSIDEuXG4gICAgICAgICAgcmFuZ2VFbmQgPSByYW5nZVN0YXJ0ICsgcmFuZ2VFbmQgLSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gMS4gSWYgcmFuZ2VTdGFydCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gZnVsbExlbmd0aCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgICAgIGlmIChyYW5nZVN0YXJ0ID49IGZ1bGxMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignUmFuZ2Ugc3RhcnQgaXMgZ3JlYXRlciB0aGFuIHRoZSBibG9iXFwncyBzaXplLicpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDIuIElmIHJhbmdlRW5kIGlzIG51bGwgb3IgcmFuZ2VFbmQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGZ1bGxMZW5ndGgsIHRoZW4gc2V0XG4gICAgICAgICAgLy8gICAgcmFuZ2VFbmQgdG8gZnVsbExlbmd0aCDiiJIgMS5cbiAgICAgICAgICBpZiAocmFuZ2VFbmQgPT09IG51bGwgfHwgcmFuZ2VFbmQgPj0gZnVsbExlbmd0aCkge1xuICAgICAgICAgICAgcmFuZ2VFbmQgPSBmdWxsTGVuZ3RoIC0gMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDguIExldCBzbGljZWRCbG9iIGJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgc2xpY2UgYmxvYiBnaXZlbiBibG9iLCByYW5nZVN0YXJ0LFxuICAgICAgICAvLyAgICByYW5nZUVuZCArIDEsIGFuZCB0eXBlLlxuICAgICAgICBjb25zdCBzbGljZWRCbG9iID0gYmxvYi5zbGljZShyYW5nZVN0YXJ0LCByYW5nZUVuZCwgdHlwZSlcblxuICAgICAgICAvLyA5LiBMZXQgc2xpY2VkQm9keVdpdGhUeXBlIGJlIHRoZSByZXN1bHQgb2Ygc2FmZWx5IGV4dHJhY3Rpbmcgc2xpY2VkQmxvYi5cbiAgICAgICAgLy8gTm90ZTogc2FtZSByZWFzb24gYXMgbWVudGlvbmVkIGFib3ZlIGFzIHRvIHdoeSB3ZSB1c2UgZXh0cmFjdEJvZHlcbiAgICAgICAgY29uc3Qgc2xpY2VkQm9keVdpdGhUeXBlID0gZXh0cmFjdEJvZHkoc2xpY2VkQmxvYilcblxuICAgICAgICAvLyAxMC4gU2V0IHJlc3BvbnNl4oCZcyBib2R5IHRvIHNsaWNlZEJvZHlXaXRoVHlwZeKAmXMgYm9keS5cbiAgICAgICAgcmVzcG9uc2UuYm9keSA9IHNsaWNlZEJvZHlXaXRoVHlwZVswXVxuXG4gICAgICAgIC8vIDExLiBMZXQgc2VyaWFsaXplZFNsaWNlZExlbmd0aCBiZSBzbGljZWRCbG9i4oCZcyBzaXplLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRTbGljZWRMZW5ndGggPSBpc29tb3JwaGljRW5jb2RlKGAke3NsaWNlZEJsb2Iuc2l6ZX1gKVxuXG4gICAgICAgIC8vIDEyLiBMZXQgY29udGVudFJhbmdlIGJlIHRoZSByZXN1bHQgb2YgaW52b2tpbmcgYnVpbGQgYSBjb250ZW50IHJhbmdlIGdpdmVuIHJhbmdlU3RhcnQsXG4gICAgICAgIC8vICAgICByYW5nZUVuZCwgYW5kIGZ1bGxMZW5ndGguXG4gICAgICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IGJ1aWxkQ29udGVudFJhbmdlKHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBmdWxsTGVuZ3RoKVxuXG4gICAgICAgIC8vIDEzLiBTZXQgcmVzcG9uc2XigJlzIHN0YXR1cyB0byAyMDYuXG4gICAgICAgIHJlc3BvbnNlLnN0YXR1cyA9IDIwNlxuXG4gICAgICAgIC8vIDE0LiBTZXQgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlIHRvIGBQYXJ0aWFsIENvbnRlbnRgLlxuICAgICAgICByZXNwb25zZS5zdGF0dXNUZXh0ID0gJ1BhcnRpYWwgQ29udGVudCdcblxuICAgICAgICAvLyAxNS4gU2V0IHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCB0byDCqyAoYENvbnRlbnQtTGVuZ3RoYCwgc2VyaWFsaXplZFNsaWNlZExlbmd0aCksXG4gICAgICAgIC8vICAgICAoYENvbnRlbnQtVHlwZWAsIHR5cGUpLCAoYENvbnRlbnQtUmFuZ2VgLCBjb250ZW50UmFuZ2UpIMK7LlxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtbGVuZ3RoJywgc2VyaWFsaXplZFNsaWNlZExlbmd0aCwgdHJ1ZSlcbiAgICAgICAgcmVzcG9uc2UuaGVhZGVyc0xpc3Quc2V0KCdjb250ZW50LXR5cGUnLCB0eXBlLCB0cnVlKVxuICAgICAgICByZXNwb25zZS5oZWFkZXJzTGlzdC5zZXQoJ2NvbnRlbnQtcmFuZ2UnLCBjb250ZW50UmFuZ2UsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIC8vIDEwLiBSZXR1cm4gcmVzcG9uc2UuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKVxuICAgIH1cbiAgICBjYXNlICdkYXRhOic6IHtcbiAgICAgIC8vIDEuIExldCBkYXRhVVJMU3RydWN0IGJlIHRoZSByZXN1bHQgb2YgcnVubmluZyB0aGVcbiAgICAgIC8vICAgIGRhdGE6IFVSTCBwcm9jZXNzb3Igb24gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgICBjb25zdCBjdXJyZW50VVJMID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcbiAgICAgIGNvbnN0IGRhdGFVUkxTdHJ1Y3QgPSBkYXRhVVJMUHJvY2Vzc29yKGN1cnJlbnRVUkwpXG5cbiAgICAgIC8vIDIuIElmIGRhdGFVUkxTdHJ1Y3QgaXMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYVxuICAgICAgLy8gICAgbmV0d29yayBlcnJvci5cbiAgICAgIGlmIChkYXRhVVJMU3RydWN0ID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdmYWlsZWQgdG8gZmV0Y2ggdGhlIGRhdGEgVVJMJykpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIExldCBtaW1lVHlwZSBiZSBkYXRhVVJMU3RydWN04oCZcyBNSU1FIHR5cGUsIHNlcmlhbGl6ZWQuXG4gICAgICBjb25zdCBtaW1lVHlwZSA9IHNlcmlhbGl6ZUFNaW1lVHlwZShkYXRhVVJMU3RydWN0Lm1pbWVUeXBlKVxuXG4gICAgICAvLyA0LiBSZXR1cm4gYSByZXNwb25zZSB3aG9zZSBzdGF0dXMgbWVzc2FnZSBpcyBgT0tgLFxuICAgICAgLy8gICAgaGVhZGVyIGxpc3QgaXMgwqsgKGBDb250ZW50LVR5cGVgLCBtaW1lVHlwZSkgwrssXG4gICAgICAvLyAgICBhbmQgYm9keSBpcyBkYXRhVVJMU3RydWN04oCZcyBib2R5IGFzIGEgYm9keS5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZVJlc3BvbnNlKHtcbiAgICAgICAgc3RhdHVzVGV4dDogJ09LJyxcbiAgICAgICAgaGVhZGVyc0xpc3Q6IFtcbiAgICAgICAgICBbJ2NvbnRlbnQtdHlwZScsIHsgbmFtZTogJ0NvbnRlbnQtVHlwZScsIHZhbHVlOiBtaW1lVHlwZSB9XVxuICAgICAgICBdLFxuICAgICAgICBib2R5OiBzYWZlbHlFeHRyYWN0Qm9keShkYXRhVVJMU3RydWN0LmJvZHkpWzBdXG4gICAgICB9KSlcbiAgICB9XG4gICAgY2FzZSAnZmlsZTonOiB7XG4gICAgICAvLyBGb3Igbm93LCB1bmZvcnR1bmF0ZSBhcyBpdCBpcywgZmlsZSBVUkxzIGFyZSBsZWZ0IGFzIGFuIGV4ZXJjaXNlIGZvciB0aGUgcmVhZGVyLlxuICAgICAgLy8gV2hlbiBpbiBkb3VidCwgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignbm90IGltcGxlbWVudGVkLi4uIHlldC4uLicpKVxuICAgIH1cbiAgICBjYXNlICdodHRwOic6XG4gICAgY2FzZSAnaHR0cHM6Jzoge1xuICAgICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBIVFRQIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLlxuXG4gICAgICByZXR1cm4gaHR0cEZldGNoKGZldGNoUGFyYW1zKVxuICAgICAgICAuY2F0Y2goKGVycikgPT4gbWFrZU5ldHdvcmtFcnJvcihlcnIpKVxuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoJ3Vua25vd24gc2NoZW1lJykpXG4gICAgfVxuICB9XG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNmaW5hbGl6ZS1yZXNwb25zZVxuZnVuY3Rpb24gZmluYWxpemVSZXNwb25zZSAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIFNldCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgZG9uZSBmbGFnLlxuICBmZXRjaFBhcmFtcy5yZXF1ZXN0LmRvbmUgPSB0cnVlXG5cbiAgLy8gMiwgSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgZG9uZSBpcyBub3QgbnVsbCwgdGhlbiBxdWV1ZSBhIGZldGNoXG4gIC8vIHRhc2sgdG8gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlc3BvbnNlIGRvbmUgZ2l2ZW4gcmVzcG9uc2UsIHdpdGhcbiAgLy8gZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24uXG4gIGlmIChmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VEb25lICE9IG51bGwpIHtcbiAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBmZXRjaFBhcmFtcy5wcm9jZXNzUmVzcG9uc2VEb25lKHJlc3BvbnNlKSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZmV0Y2gtZmluYWxlXG5mdW5jdGlvbiBmZXRjaEZpbmFsZSAoZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKSB7XG4gIC8vIDEuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgbGV0IHRpbWluZ0luZm8gPSBmZXRjaFBhcmFtcy50aW1pbmdJbmZvXG5cbiAgLy8gMi4gSWYgcmVzcG9uc2UgaXMgbm90IGEgbmV0d29yayBlcnJvciBhbmQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGNsaWVudCBpcyBhIHNlY3VyZSBjb250ZXh0LFxuICAvLyAgICB0aGVuIHNldCB0aW1pbmdJbmZv4oCZcyBzZXJ2ZXItdGltaW5nIGhlYWRlcnMgdG8gdGhlIHJlc3VsdCBvZiBnZXR0aW5nLCBkZWNvZGluZywgYW5kIHNwbGl0dGluZ1xuICAvLyAgICBgU2VydmVyLVRpbWluZ2AgZnJvbSByZXNwb25zZeKAmXMgaW50ZXJuYWwgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAvLyBUT0RPXG5cbiAgLy8gMy4gTGV0IHByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSBiZSB0aGUgZm9sbG93aW5nIHN0ZXBzOlxuICBjb25zdCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkgPSAoKSA9PiB7XG4gICAgLy8gMS4gTGV0IHVuc2FmZUVuZFRpbWUgYmUgdGhlIHVuc2FmZSBzaGFyZWQgY3VycmVudCB0aW1lLlxuICAgIGNvbnN0IHVuc2FmZUVuZFRpbWUgPSBEYXRlLm5vdygpIC8vID9cblxuICAgIC8vIDIuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBkZXN0aW5hdGlvbiBpcyBcImRvY3VtZW50XCIsIHRoZW4gc2V0IGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVy4oCZc1xuICAgIC8vICAgIGZ1bGwgdGltaW5nIGluZm8gdG8gZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICAgIGlmIChmZXRjaFBhcmFtcy5yZXF1ZXN0LmRlc3RpbmF0aW9uID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmZ1bGxUaW1pbmdJbmZvID0gdGltaW5nSW5mb1xuICAgIH1cblxuICAgIC8vIDMuIFNldCBmZXRjaFBhcmFtc+KAmXMgY29udHJvbGxlcuKAmXMgcmVwb3J0IHRpbWluZyBzdGVwcyB0byB0aGUgZm9sbG93aW5nIHN0ZXBzIGdpdmVuIGEgZ2xvYmFsIG9iamVjdCBnbG9iYWw6XG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXBvcnRUaW1pbmdTdGVwcyA9ICgpID0+IHtcbiAgICAgIC8vIDEuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBVUkzigJlzIHNjaGVtZSBpcyBub3QgYW4gSFRUUChTKSBzY2hlbWUsIHRoZW4gcmV0dXJuLlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QudXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IHRpbWluZ0luZm/igJlzIGVuZCB0aW1lIHRvIHRoZSByZWxhdGl2ZSBoaWdoIHJlc29sdXRpb24gdGltZSBnaXZlbiB1bnNhZmVFbmRUaW1lIGFuZCBnbG9iYWwuXG4gICAgICB0aW1pbmdJbmZvLmVuZFRpbWUgPSB1bnNhZmVFbmRUaW1lXG5cbiAgICAgIC8vIDMuIExldCBjYWNoZVN0YXRlIGJlIHJlc3BvbnNl4oCZcyBjYWNoZSBzdGF0ZS5cbiAgICAgIGxldCBjYWNoZVN0YXRlID0gcmVzcG9uc2UuY2FjaGVTdGF0ZVxuXG4gICAgICAvLyA0LiBMZXQgYm9keUluZm8gYmUgcmVzcG9uc2XigJlzIGJvZHkgaW5mby5cbiAgICAgIGNvbnN0IGJvZHlJbmZvID0gcmVzcG9uc2UuYm9keUluZm9cblxuICAgICAgLy8gNS4gSWYgcmVzcG9uc2XigJlzIHRpbWluZyBhbGxvdyBwYXNzZWQgZmxhZyBpcyBub3Qgc2V0LCB0aGVuIHNldCB0aW1pbmdJbmZvIHRvIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYW5cbiAgICAgIC8vICAgIG9wYXF1ZSB0aW1pbmcgaW5mbyBmb3IgdGltaW5nSW5mbyBhbmQgc2V0IGNhY2hlU3RhdGUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgIGlmICghcmVzcG9uc2UudGltaW5nQWxsb3dQYXNzZWQpIHtcbiAgICAgICAgdGltaW5nSW5mbyA9IGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8odGltaW5nSW5mbylcblxuICAgICAgICBjYWNoZVN0YXRlID0gJydcbiAgICAgIH1cblxuICAgICAgLy8gNi4gTGV0IHJlc3BvbnNlU3RhdHVzIGJlIDAuXG4gICAgICBsZXQgcmVzcG9uc2VTdGF0dXMgPSAwXG5cbiAgICAgIC8vIDcuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBtb2RlIGlzIG5vdCBcIm5hdmlnYXRlXCIgb3IgcmVzcG9uc2XigJlzIGhhcy1jcm9zcy1vcmlnaW4tcmVkaXJlY3RzIGlzIGZhbHNlOlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QubW9kZSAhPT0gJ25hdmlnYXRvcicgfHwgIXJlc3BvbnNlLmhhc0Nyb3NzT3JpZ2luUmVkaXJlY3RzKSB7XG4gICAgICAgIC8vIDEuIFNldCByZXNwb25zZVN0YXR1cyB0byByZXNwb25zZeKAmXMgc3RhdHVzLlxuICAgICAgICByZXNwb25zZVN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1c1xuXG4gICAgICAgIC8vIDIuIExldCBtaW1lVHlwZSBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgYSBNSU1FIHR5cGUgZnJvbSByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlID0gZXh0cmFjdE1pbWVUeXBlKHJlc3BvbnNlLmhlYWRlcnNMaXN0KVxuXG4gICAgICAgIC8vIDMuIElmIG1pbWVUeXBlIGlzIG5vdCBmYWlsdXJlLCB0aGVuIHNldCBib2R5SW5mb+KAmXMgY29udGVudCB0eXBlIHRvIHRoZSByZXN1bHQgb2YgbWluaW1pemluZyBhIHN1cHBvcnRlZCBNSU1FIHR5cGUgZ2l2ZW4gbWltZVR5cGUuXG4gICAgICAgIGlmIChtaW1lVHlwZSAhPT0gJ2ZhaWx1cmUnKSB7XG4gICAgICAgICAgYm9keUluZm8uY29udGVudFR5cGUgPSBtaW5pbWl6ZVN1cHBvcnRlZE1pbWVUeXBlKG1pbWVUeXBlKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDguIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBpbml0aWF0b3IgdHlwZSBpcyBub24tbnVsbCwgdGhlbiBtYXJrIHJlc291cmNlIHRpbWluZyBnaXZlbiB0aW1pbmdJbmZvLFxuICAgICAgLy8gICAgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIFVSTCwgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGluaXRpYXRvciB0eXBlLCBnbG9iYWwsIGNhY2hlU3RhdGUsIGJvZHlJbmZvLFxuICAgICAgLy8gICAgYW5kIHJlc3BvbnNlU3RhdHVzLlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QuaW5pdGlhdG9yVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IHVwZGF0ZSBtYXJrcmVzb3VyY2V0aW1pbmdcbiAgICAgICAgbWFya1Jlc291cmNlVGltaW5nKHRpbWluZ0luZm8sIGZldGNoUGFyYW1zLnJlcXVlc3QudXJsLmhyZWYsIGZldGNoUGFyYW1zLnJlcXVlc3QuaW5pdGlhdG9yVHlwZSwgZ2xvYmFsVGhpcywgY2FjaGVTdGF0ZSwgYm9keUluZm8sIHJlc3BvbnNlU3RhdHVzKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDQuIExldCBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHlUYXNrIGJlIHRoZSBmb2xsb3dpbmcgc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5VGFzayA9ICgpID0+IHtcbiAgICAgIC8vIDEuIFNldCBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgZG9uZSBmbGFnLlxuICAgICAgZmV0Y2hQYXJhbXMucmVxdWVzdC5kb25lID0gdHJ1ZVxuXG4gICAgICAvLyAyLiBJZiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXNwb25zZSBlbmQtb2YtYm9keSBpcyBub24tbnVsbCwgdGhlbiBydW4gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3NcbiAgICAgIC8vICAgIHJlc3BvbnNlIGVuZC1vZi1ib2R5IGdpdmVuIHJlc3BvbnNlLlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keSAhPSBudWxsKSB7XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZUVuZE9mQm9keShyZXNwb25zZSkpXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN04oCZcyBpbml0aWF0b3IgdHlwZSBpcyBub24tbnVsbCBhbmQgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3TigJlzIGNsaWVudOKAmXNcbiAgICAgIC8vICAgIGdsb2JhbCBvYmplY3QgaXMgZmV0Y2hQYXJhbXPigJlzIHRhc2sgZGVzdGluYXRpb24sIHRoZW4gcnVuIGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVy4oCZcyByZXBvcnRcbiAgICAgIC8vICAgIHRpbWluZyBzdGVwcyBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdOKAmXMgY2xpZW504oCZcyBnbG9iYWwgb2JqZWN0LlxuICAgICAgaWYgKGZldGNoUGFyYW1zLnJlcXVlc3QuaW5pdGlhdG9yVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIucmVwb3J0VGltaW5nU3RlcHMoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuIFF1ZXVlIGEgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5VGFzayB3aXRoIGZldGNoUGFyYW1z4oCZcyB0YXNrIGRlc3RpbmF0aW9uXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5VGFzaygpKVxuICB9XG5cbiAgLy8gNC4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVzcG9uc2UgaXMgbm9uLW51bGwsIHRoZW4gcXVldWUgYSBmZXRjaCB0YXNrIHRvIHJ1biBmZXRjaFBhcmFtc+KAmXNcbiAgLy8gICAgcHJvY2VzcyByZXNwb25zZSBnaXZlbiByZXNwb25zZSwgd2l0aCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgaWYgKGZldGNoUGFyYW1zLnByb2Nlc3NSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlKHJlc3BvbnNlKVxuICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1Jlc3BvbnNlID0gbnVsbFxuICAgIH0pXG4gIH1cblxuICAvLyA1LiBMZXQgaW50ZXJuYWxSZXNwb25zZSBiZSByZXNwb25zZSwgaWYgcmVzcG9uc2UgaXMgYSBuZXR3b3JrIGVycm9yOyBvdGhlcndpc2UgcmVzcG9uc2XigJlzIGludGVybmFsIHJlc3BvbnNlLlxuICBjb25zdCBpbnRlcm5hbFJlc3BvbnNlID0gcmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyA/IHJlc3BvbnNlIDogKHJlc3BvbnNlLmludGVybmFsUmVzcG9uc2UgPz8gcmVzcG9uc2UpXG5cbiAgLy8gNi4gSWYgaW50ZXJuYWxSZXNwb25zZeKAmXMgYm9keSBpcyBudWxsLCB0aGVuIHJ1biBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkuXG4gIC8vIDcuIE90aGVyd2lzZTpcbiAgaWYgKGludGVybmFsUmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5KClcbiAgfSBlbHNlIHtcbiAgICAvLyBtY29sbGluYTogYWxsIHRoZSBmb2xsb3dpbmcgc3RlcHMgb2YgdGhlIHNwZWNzIGFyZSBza2lwcGVkLlxuICAgIC8vIFRoZSBpbnRlcm5hbCB0cmFuc2Zvcm0gc3RyZWFtIGlzIG5vdCBuZWVkZWQuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvdW5kaWNpL3B1bGwvMzA5MyNpc3N1ZWNvbW1lbnQtMjA1MDE5ODU0MVxuXG4gICAgLy8gMS4gTGV0IHRyYW5zZm9ybVN0cmVhbSBiZSBhIG5ldyBUcmFuc2Zvcm1TdHJlYW0uXG4gICAgLy8gMi4gTGV0IGlkZW50aXR5VHJhbnNmb3JtQWxnb3JpdGhtIGJlIGFuIGFsZ29yaXRobSB3aGljaCwgZ2l2ZW4gY2h1bmssIGVucXVldWVzIGNodW5rIGluIHRyYW5zZm9ybVN0cmVhbS5cbiAgICAvLyAzLiBTZXQgdXAgdHJhbnNmb3JtU3RyZWFtIHdpdGggdHJhbnNmb3JtQWxnb3JpdGhtIHNldCB0byBpZGVudGl0eVRyYW5zZm9ybUFsZ29yaXRobSBhbmQgZmx1c2hBbGdvcml0aG1cbiAgICAvLyAgICBzZXQgdG8gcHJvY2Vzc1Jlc3BvbnNlRW5kT2ZCb2R5LlxuICAgIC8vIDQuIFNldCBpbnRlcm5hbFJlc3BvbnNl4oCZcyBib2R54oCZcyBzdHJlYW0gdG8gdGhlIHJlc3VsdCBvZiBpbnRlcm5hbFJlc3BvbnNl4oCZcyBib2R54oCZcyBzdHJlYW0gcGlwZWQgdGhyb3VnaCB0cmFuc2Zvcm1TdHJlYW0uXG5cbiAgICBmaW5pc2hlZChpbnRlcm5hbFJlc3BvbnNlLmJvZHkuc3RyZWFtLCAoKSA9PiB7XG4gICAgICBwcm9jZXNzUmVzcG9uc2VFbmRPZkJvZHkoKVxuICAgIH0pXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtZmV0Y2hcbmFzeW5jIGZ1bmN0aW9uIGh0dHBGZXRjaCAoZmV0Y2hQYXJhbXMpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3QgYmUgZmV0Y2hQYXJhbXPigJlzIHJlcXVlc3QuXG4gIGNvbnN0IHJlcXVlc3QgPSBmZXRjaFBhcmFtcy5yZXF1ZXN0XG5cbiAgLy8gMi4gTGV0IHJlc3BvbnNlIGJlIG51bGwuXG4gIGxldCByZXNwb25zZSA9IG51bGxcblxuICAvLyAzLiBMZXQgYWN0dWFsUmVzcG9uc2UgYmUgbnVsbC5cbiAgbGV0IGFjdHVhbFJlc3BvbnNlID0gbnVsbFxuXG4gIC8vIDQuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyA1LiBJZiByZXF1ZXN04oCZcyBzZXJ2aWNlLXdvcmtlcnMgbW9kZSBpcyBcImFsbFwiLCB0aGVuOlxuICBpZiAocmVxdWVzdC5zZXJ2aWNlV29ya2VycyA9PT0gJ2FsbCcpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyA2LiBJZiByZXNwb25zZSBpcyBudWxsLCB0aGVuOlxuICBpZiAocmVzcG9uc2UgPT09IG51bGwpIHtcbiAgICAvLyAxLiBJZiBtYWtlQ09SU1ByZWZsaWdodCBpcyB0cnVlIGFuZCBvbmUgb2YgdGhlc2UgY29uZGl0aW9ucyBpcyB0cnVlOlxuICAgIC8vIFRPRE9cblxuICAgIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgaXMgXCJmb2xsb3dcIiwgdGhlbiBzZXQgcmVxdWVzdOKAmXNcbiAgICAvLyBzZXJ2aWNlLXdvcmtlcnMgbW9kZSB0byBcIm5vbmVcIi5cbiAgICBpZiAocmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2ZvbGxvdycpIHtcbiAgICAgIHJlcXVlc3Quc2VydmljZVdvcmtlcnMgPSAnbm9uZSdcbiAgICB9XG5cbiAgICAvLyAzLiBTZXQgcmVzcG9uc2UgYW5kIGFjdHVhbFJlc3BvbnNlIHRvIHRoZSByZXN1bHQgb2YgcnVubmluZ1xuICAgIC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBnaXZlbiBmZXRjaFBhcmFtcy5cbiAgICBhY3R1YWxSZXNwb25zZSA9IHJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2goZmV0Y2hQYXJhbXMpXG5cbiAgICAvLyA0LiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiBhbmQgYSBDT1JTIGNoZWNrXG4gICAgLy8gZm9yIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHJldHVybnMgZmFpbHVyZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnICYmXG4gICAgICBjb3JzQ2hlY2socmVxdWVzdCwgcmVzcG9uc2UpID09PSAnZmFpbHVyZSdcbiAgICApIHtcbiAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdjb3JzIGZhaWx1cmUnKVxuICAgIH1cblxuICAgIC8vIDUuIElmIHRoZSBUQU8gY2hlY2sgZm9yIHJlcXVlc3QgYW5kIHJlc3BvbnNlIHJldHVybnMgZmFpbHVyZSwgdGhlbiBzZXRcbiAgICAvLyByZXF1ZXN04oCZcyB0aW1pbmcgYWxsb3cgZmFpbGVkIGZsYWcuXG4gICAgaWYgKFRBT0NoZWNrKHJlcXVlc3QsIHJlc3BvbnNlKSA9PT0gJ2ZhaWx1cmUnKSB7XG4gICAgICByZXF1ZXN0LnRpbWluZ0FsbG93RmFpbGVkID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIDcuIElmIGVpdGhlciByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBvciByZXNwb25zZeKAmXMgdHlwZVxuICAvLyBpcyBcIm9wYXF1ZVwiLCBhbmQgdGhlIGNyb3NzLW9yaWdpbiByZXNvdXJjZSBwb2xpY3kgY2hlY2sgd2l0aFxuICAvLyByZXF1ZXN04oCZcyBvcmlnaW4sIHJlcXVlc3TigJlzIGNsaWVudCwgcmVxdWVzdOKAmXMgZGVzdGluYXRpb24sXG4gIC8vIGFuZCBhY3R1YWxSZXNwb25zZSByZXR1cm5zIGJsb2NrZWQsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIChyZXF1ZXN0LnJlc3BvbnNlVGFpbnRpbmcgPT09ICdvcGFxdWUnIHx8IHJlc3BvbnNlLnR5cGUgPT09ICdvcGFxdWUnKSAmJlxuICAgIGNyb3NzT3JpZ2luUmVzb3VyY2VQb2xpY3lDaGVjayhcbiAgICAgIHJlcXVlc3Qub3JpZ2luLFxuICAgICAgcmVxdWVzdC5jbGllbnQsXG4gICAgICByZXF1ZXN0LmRlc3RpbmF0aW9uLFxuICAgICAgYWN0dWFsUmVzcG9uc2VcbiAgICApID09PSAnYmxvY2tlZCdcbiAgKSB7XG4gICAgcmV0dXJuIG1ha2VOZXR3b3JrRXJyb3IoJ2Jsb2NrZWQnKVxuICB9XG5cbiAgLy8gOC4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhIHJlZGlyZWN0IHN0YXR1cywgdGhlbjpcbiAgaWYgKHJlZGlyZWN0U3RhdHVzU2V0LmhhcyhhY3R1YWxSZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgLy8gMS4gSWYgYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyBub3QgMzAzLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vdCBudWxsLFxuICAgIC8vIGFuZCB0aGUgY29ubmVjdGlvbiB1c2VzIEhUVFAvMiwgdGhlbiB1c2VyIGFnZW50cyBtYXksIGFuZCBhcmUgZXZlblxuICAgIC8vIGVuY291cmFnZWQgdG8sIHRyYW5zbWl0IGFuIFJTVF9TVFJFQU0gZnJhbWUuXG4gICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2ZldGNoL2lzc3Vlcy8xMjg4XG4gICAgaWYgKHJlcXVlc3QucmVkaXJlY3QgIT09ICdtYW51YWwnKSB7XG4gICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveSh1bmRlZmluZWQsIGZhbHNlKVxuICAgIH1cblxuICAgIC8vIDIuIFN3aXRjaCBvbiByZXF1ZXN04oCZcyByZWRpcmVjdCBtb2RlOlxuICAgIGlmIChyZXF1ZXN0LnJlZGlyZWN0ID09PSAnZXJyb3InKSB7XG4gICAgICAvLyBTZXQgcmVzcG9uc2UgdG8gYSBuZXR3b3JrIGVycm9yLlxuICAgICAgcmVzcG9uc2UgPSBtYWtlTmV0d29ya0Vycm9yKCd1bmV4cGVjdGVkIHJlZGlyZWN0JylcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09ICdtYW51YWwnKSB7XG4gICAgICAvLyBTZXQgcmVzcG9uc2UgdG8gYW4gb3BhcXVlLXJlZGlyZWN0IGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIGludGVybmFsXG4gICAgICAvLyByZXNwb25zZSBpcyBhY3R1YWxSZXNwb25zZS5cbiAgICAgIC8vIE5PVEUoc3BlYyk6IE9uIHRoZSB3ZWIgdGhpcyB3b3VsZCByZXR1cm4gYW4gYG9wYXF1ZXJlZGlyZWN0YCByZXNwb25zZSxcbiAgICAgIC8vIGJ1dCB0aGF0IGRvZXNuJ3QgbWFrZSBzZW5zZSBzZXJ2ZXIgc2lkZS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTE5My5cbiAgICAgIHJlc3BvbnNlID0gYWN0dWFsUmVzcG9uc2VcbiAgICB9IGVsc2UgaWYgKHJlcXVlc3QucmVkaXJlY3QgPT09ICdmb2xsb3cnKSB7XG4gICAgICAvLyBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtcmVkaXJlY3QgZmV0Y2ggZ2l2ZW5cbiAgICAgIC8vIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZS5cbiAgICAgIHJlc3BvbnNlID0gYXdhaXQgaHR0cFJlZGlyZWN0RmV0Y2goZmV0Y2hQYXJhbXMsIHJlc3BvbnNlKVxuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgLy8gOS4gU2V0IHJlc3BvbnNl4oCZcyB0aW1pbmcgaW5mbyB0byB0aW1pbmdJbmZvLlxuICByZXNwb25zZS50aW1pbmdJbmZvID0gdGltaW5nSW5mb1xuXG4gIC8vIDEwLiBSZXR1cm4gcmVzcG9uc2UuXG4gIHJldHVybiByZXNwb25zZVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1yZWRpcmVjdC1mZXRjaFxuZnVuY3Rpb24gaHR0cFJlZGlyZWN0RmV0Y2ggKGZldGNoUGFyYW1zLCByZXNwb25zZSkge1xuICAvLyAxLiBMZXQgcmVxdWVzdCBiZSBmZXRjaFBhcmFtc+KAmXMgcmVxdWVzdC5cbiAgY29uc3QgcmVxdWVzdCA9IGZldGNoUGFyYW1zLnJlcXVlc3RcblxuICAvLyAyLiBMZXQgYWN0dWFsUmVzcG9uc2UgYmUgcmVzcG9uc2UsIGlmIHJlc3BvbnNlIGlzIG5vdCBhIGZpbHRlcmVkIHJlc3BvbnNlLFxuICAvLyBhbmQgcmVzcG9uc2XigJlzIGludGVybmFsIHJlc3BvbnNlIG90aGVyd2lzZS5cbiAgY29uc3QgYWN0dWFsUmVzcG9uc2UgPSByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlXG4gICAgPyByZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlXG4gICAgOiByZXNwb25zZVxuXG4gIC8vIDMuIExldCBsb2NhdGlvblVSTCBiZSBhY3R1YWxSZXNwb25zZeKAmXMgbG9jYXRpb24gVVJMIGdpdmVuIHJlcXVlc3TigJlzIGN1cnJlbnRcbiAgLy8gVVJM4oCZcyBmcmFnbWVudC5cbiAgbGV0IGxvY2F0aW9uVVJMXG5cbiAgdHJ5IHtcbiAgICBsb2NhdGlvblVSTCA9IHJlc3BvbnNlTG9jYXRpb25VUkwoXG4gICAgICBhY3R1YWxSZXNwb25zZSxcbiAgICAgIHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpLmhhc2hcbiAgICApXG5cbiAgICAvLyA0LiBJZiBsb2NhdGlvblVSTCBpcyBudWxsLCB0aGVuIHJldHVybiByZXNwb25zZS5cbiAgICBpZiAobG9jYXRpb25VUkwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyA1LiBJZiBsb2NhdGlvblVSTCBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKGVycikpXG4gIH1cblxuICAvLyA2LiBJZiBsb2NhdGlvblVSTOKAmXMgc2NoZW1lIGlzIG5vdCBhbiBIVFRQKFMpIHNjaGVtZSwgdGhlbiByZXR1cm4gYSBuZXR3b3JrXG4gIC8vIGVycm9yLlxuICBpZiAoIXVybElzSHR0cEh0dHBzU2NoZW1lKGxvY2F0aW9uVVJMKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignVVJMIHNjaGVtZSBtdXN0IGJlIGEgSFRUUChTKSBzY2hlbWUnKSlcbiAgfVxuXG4gIC8vIDcuIElmIHJlcXVlc3TigJlzIHJlZGlyZWN0IGNvdW50IGlzIDIwLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIGlmIChyZXF1ZXN0LnJlZGlyZWN0Q291bnQgPT09IDIwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtYWtlTmV0d29ya0Vycm9yKCdyZWRpcmVjdCBjb3VudCBleGNlZWRlZCcpKVxuICB9XG5cbiAgLy8gOC4gSW5jcmVhc2UgcmVxdWVzdOKAmXMgcmVkaXJlY3QgY291bnQgYnkgMS5cbiAgcmVxdWVzdC5yZWRpcmVjdENvdW50ICs9IDFcblxuICAvLyA5LiBJZiByZXF1ZXN04oCZcyBtb2RlIGlzIFwiY29yc1wiLCBsb2NhdGlvblVSTCBpbmNsdWRlcyBjcmVkZW50aWFscywgYW5kXG4gIC8vIHJlcXVlc3TigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCBsb2NhdGlvblVSTOKAmXMgb3JpZ2luLCB0aGVuIHJldHVyblxuICAvLyAgYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgcmVxdWVzdC5tb2RlID09PSAnY29ycycgJiZcbiAgICAobG9jYXRpb25VUkwudXNlcm5hbWUgfHwgbG9jYXRpb25VUkwucGFzc3dvcmQpICYmXG4gICAgIXNhbWVPcmlnaW4ocmVxdWVzdCwgbG9jYXRpb25VUkwpXG4gICkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWFrZU5ldHdvcmtFcnJvcignY3Jvc3Mgb3JpZ2luIG5vdCBhbGxvd2VkIGZvciByZXF1ZXN0IG1vZGUgXCJjb3JzXCInKSlcbiAgfVxuXG4gIC8vIDEwLiBJZiByZXF1ZXN04oCZcyByZXNwb25zZSB0YWludGluZyBpcyBcImNvcnNcIiBhbmQgbG9jYXRpb25VUkwgaW5jbHVkZXNcbiAgLy8gY3JlZGVudGlhbHMsIHRoZW4gcmV0dXJuIGEgbmV0d29yayBlcnJvci5cbiAgaWYgKFxuICAgIHJlcXVlc3QucmVzcG9uc2VUYWludGluZyA9PT0gJ2NvcnMnICYmXG4gICAgKGxvY2F0aW9uVVJMLnVzZXJuYW1lIHx8IGxvY2F0aW9uVVJMLnBhc3N3b3JkKVxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoXG4gICAgICAnVVJMIGNhbm5vdCBjb250YWluIGNyZWRlbnRpYWxzIGZvciByZXF1ZXN0IG1vZGUgXCJjb3JzXCInXG4gICAgKSlcbiAgfVxuXG4gIC8vIDExLiBJZiBhY3R1YWxSZXNwb25zZeKAmXMgc3RhdHVzIGlzIG5vdCAzMDMsIHJlcXVlc3TigJlzIGJvZHkgaXMgbm9uLW51bGwsXG4gIC8vIGFuZCByZXF1ZXN04oCZcyBib2R54oCZcyBzb3VyY2UgaXMgbnVsbCwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICBpZiAoXG4gICAgYWN0dWFsUmVzcG9uc2Uuc3RhdHVzICE9PSAzMDMgJiZcbiAgICByZXF1ZXN0LmJvZHkgIT0gbnVsbCAmJlxuICAgIHJlcXVlc3QuYm9keS5zb3VyY2UgPT0gbnVsbFxuICApIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG1ha2VOZXR3b3JrRXJyb3IoKSlcbiAgfVxuXG4gIC8vIDEyLiBJZiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlXG4gIC8vIC0gYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyAzMDEgb3IgMzAyIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgYFBPU1RgXG4gIC8vIC0gYWN0dWFsUmVzcG9uc2XigJlzIHN0YXR1cyBpcyAzMDMgYW5kIHJlcXVlc3TigJlzIG1ldGhvZCBpcyBub3QgYEdFVGAgb3IgYEhFQURgXG4gIGlmIChcbiAgICAoWzMwMSwgMzAyXS5pbmNsdWRlcyhhY3R1YWxSZXNwb25zZS5zdGF0dXMpICYmIHJlcXVlc3QubWV0aG9kID09PSAnUE9TVCcpIHx8XG4gICAgKGFjdHVhbFJlc3BvbnNlLnN0YXR1cyA9PT0gMzAzICYmXG4gICAgICAhR0VUX09SX0hFQUQuaW5jbHVkZXMocmVxdWVzdC5tZXRob2QpKVxuICApIHtcbiAgICAvLyB0aGVuOlxuICAgIC8vIDEuIFNldCByZXF1ZXN04oCZcyBtZXRob2QgdG8gYEdFVGAgYW5kIHJlcXVlc3TigJlzIGJvZHkgdG8gbnVsbC5cbiAgICByZXF1ZXN0Lm1ldGhvZCA9ICdHRVQnXG4gICAgcmVxdWVzdC5ib2R5ID0gbnVsbFxuXG4gICAgLy8gMi4gRm9yIGVhY2ggaGVhZGVyTmFtZSBvZiByZXF1ZXN0LWJvZHktaGVhZGVyIG5hbWUsIGRlbGV0ZSBoZWFkZXJOYW1lIGZyb21cbiAgICAvLyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICBmb3IgKGNvbnN0IGhlYWRlck5hbWUgb2YgcmVxdWVzdEJvZHlIZWFkZXIpIHtcbiAgICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKGhlYWRlck5hbWUpXG4gICAgfVxuICB9XG5cbiAgLy8gMTMuIElmIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBvcmlnaW4gaXMgbm90IHNhbWUgb3JpZ2luIHdpdGggbG9jYXRpb25VUkzigJlzXG4gIC8vICAgICBvcmlnaW4sIHRoZW4gZm9yIGVhY2ggaGVhZGVyTmFtZSBvZiBDT1JTIG5vbi13aWxkY2FyZCByZXF1ZXN0LWhlYWRlciBuYW1lLFxuICAvLyAgICAgZGVsZXRlIGhlYWRlck5hbWUgZnJvbSByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKCFzYW1lT3JpZ2luKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpLCBsb2NhdGlvblVSTCkpIHtcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29ycy1ub24td2lsZGNhcmQtcmVxdWVzdC1oZWFkZXItbmFtZVxuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdhdXRob3JpemF0aW9uJywgdHJ1ZSlcblxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNhdXRoZW50aWNhdGlvbi1lbnRyaWVzXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5kZWxldGUoJ3Byb3h5LWF1dGhvcml6YXRpb24nLCB0cnVlKVxuXG4gICAgLy8gXCJDb29raWVcIiBhbmQgXCJIb3N0XCIgYXJlIGZvcmJpZGRlbiByZXF1ZXN0LWhlYWRlcnMsIHdoaWNoIHVuZGljaSBkb2Vzbid0IGltcGxlbWVudC5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnY29va2llJywgdHJ1ZSlcbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmRlbGV0ZSgnaG9zdCcsIHRydWUpXG4gIH1cblxuICAvLyAxNC4gSWYgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgYm9keSB0byB0aGUgZmlyc3QgcmV0dXJuXG4gIC8vIHZhbHVlIG9mIHNhZmVseSBleHRyYWN0aW5nIHJlcXVlc3TigJlzIGJvZHnigJlzIHNvdXJjZS5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG4gICAgYXNzZXJ0KHJlcXVlc3QuYm9keS5zb3VyY2UgIT0gbnVsbClcbiAgICByZXF1ZXN0LmJvZHkgPSBzYWZlbHlFeHRyYWN0Qm9keShyZXF1ZXN0LmJvZHkuc291cmNlKVswXVxuICB9XG5cbiAgLy8gMTUuIExldCB0aW1pbmdJbmZvIGJlIGZldGNoUGFyYW1z4oCZcyB0aW1pbmcgaW5mby5cbiAgY29uc3QgdGltaW5nSW5mbyA9IGZldGNoUGFyYW1zLnRpbWluZ0luZm9cblxuICAvLyAxNi4gU2V0IHRpbWluZ0luZm/igJlzIHJlZGlyZWN0IGVuZCB0aW1lIGFuZCBwb3N0LXJlZGlyZWN0IHN0YXJ0IHRpbWUgdG8gdGhlXG4gIC8vIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudCB0aW1lIGdpdmVuIGZldGNoUGFyYW1z4oCZcyBjcm9zcy1vcmlnaW4gaXNvbGF0ZWRcbiAgLy8gY2FwYWJpbGl0eS5cbiAgdGltaW5nSW5mby5yZWRpcmVjdEVuZFRpbWUgPSB0aW1pbmdJbmZvLnBvc3RSZWRpcmVjdFN0YXJ0VGltZSA9XG4gICAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoZmV0Y2hQYXJhbXMuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG5cbiAgLy8gMTcuIElmIHRpbWluZ0luZm/igJlzIHJlZGlyZWN0IHN0YXJ0IHRpbWUgaXMgMCwgdGhlbiBzZXQgdGltaW5nSW5mb+KAmXNcbiAgLy8gIHJlZGlyZWN0IHN0YXJ0IHRpbWUgdG8gdGltaW5nSW5mb+KAmXMgc3RhcnQgdGltZS5cbiAgaWYgKHRpbWluZ0luZm8ucmVkaXJlY3RTdGFydFRpbWUgPT09IDApIHtcbiAgICB0aW1pbmdJbmZvLnJlZGlyZWN0U3RhcnRUaW1lID0gdGltaW5nSW5mby5zdGFydFRpbWVcbiAgfVxuXG4gIC8vIDE4LiBBcHBlbmQgbG9jYXRpb25VUkwgdG8gcmVxdWVzdOKAmXMgVVJMIGxpc3QuXG4gIHJlcXVlc3QudXJsTGlzdC5wdXNoKGxvY2F0aW9uVVJMKVxuXG4gIC8vIDE5LiBJbnZva2Ugc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSBvbiByZWRpcmVjdCBvbiByZXF1ZXN0IGFuZFxuICAvLyBhY3R1YWxSZXNwb25zZS5cbiAgc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdChyZXF1ZXN0LCBhY3R1YWxSZXNwb25zZSlcblxuICAvLyAyMC4gUmV0dXJuIHRoZSByZXN1bHQgb2YgcnVubmluZyBtYWluIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zIGFuZCB0cnVlLlxuICByZXR1cm4gbWFpbkZldGNoKGZldGNoUGFyYW1zLCB0cnVlKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jaHR0cC1uZXR3b3JrLW9yLWNhY2hlLWZldGNoXG5hc3luYyBmdW5jdGlvbiBodHRwTmV0d29ya09yQ2FjaGVGZXRjaCAoXG4gIGZldGNoUGFyYW1zLFxuICBpc0F1dGhlbnRpY2F0aW9uRmV0Y2ggPSBmYWxzZSxcbiAgaXNOZXdDb25uZWN0aW9uRmV0Y2ggPSBmYWxzZVxuKSB7XG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCBodHRwRmV0Y2hQYXJhbXMgYmUgbnVsbC5cbiAgbGV0IGh0dHBGZXRjaFBhcmFtcyA9IG51bGxcblxuICAvLyAzLiBMZXQgaHR0cFJlcXVlc3QgYmUgbnVsbC5cbiAgbGV0IGh0dHBSZXF1ZXN0ID0gbnVsbFxuXG4gIC8vIDQuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gNS4gTGV0IHN0b3JlZFJlc3BvbnNlIGJlIG51bGwuXG4gIC8vIFRPRE86IGNhY2hlXG5cbiAgLy8gNi4gTGV0IGh0dHBDYWNoZSBiZSBudWxsLlxuICBjb25zdCBodHRwQ2FjaGUgPSBudWxsXG5cbiAgLy8gNy4gTGV0IHRoZSByZXZhbGlkYXRpbmdGbGFnIGJlIHVuc2V0LlxuICBjb25zdCByZXZhbGlkYXRpbmdGbGFnID0gZmFsc2VcblxuICAvLyA4LiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQ6XG5cbiAgLy8gICAgMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIFwibm8td2luZG93XCIgYW5kIHJlcXVlc3TigJlzIHJlZGlyZWN0IG1vZGUgaXNcbiAgLy8gICAgXCJlcnJvclwiLCB0aGVuIHNldCBodHRwRmV0Y2hQYXJhbXMgdG8gZmV0Y2hQYXJhbXMgYW5kIGh0dHBSZXF1ZXN0IHRvXG4gIC8vICAgIHJlcXVlc3QuXG4gIGlmIChyZXF1ZXN0LndpbmRvdyA9PT0gJ25vLXdpbmRvdycgJiYgcmVxdWVzdC5yZWRpcmVjdCA9PT0gJ2Vycm9yJykge1xuICAgIGh0dHBGZXRjaFBhcmFtcyA9IGZldGNoUGFyYW1zXG4gICAgaHR0cFJlcXVlc3QgPSByZXF1ZXN0XG4gIH0gZWxzZSB7XG4gICAgLy8gT3RoZXJ3aXNlOlxuXG4gICAgLy8gMS4gU2V0IGh0dHBSZXF1ZXN0IHRvIGEgY2xvbmUgb2YgcmVxdWVzdC5cbiAgICBodHRwUmVxdWVzdCA9IGNsb25lUmVxdWVzdChyZXF1ZXN0KVxuXG4gICAgLy8gMi4gU2V0IGh0dHBGZXRjaFBhcmFtcyB0byBhIGNvcHkgb2YgZmV0Y2hQYXJhbXMuXG4gICAgaHR0cEZldGNoUGFyYW1zID0geyAuLi5mZXRjaFBhcmFtcyB9XG5cbiAgICAvLyAzLiBTZXQgaHR0cEZldGNoUGFyYW1z4oCZcyByZXF1ZXN0IHRvIGh0dHBSZXF1ZXN0LlxuICAgIGh0dHBGZXRjaFBhcmFtcy5yZXF1ZXN0ID0gaHR0cFJlcXVlc3RcbiAgfVxuXG4gIC8vICAgIDMuIExldCBpbmNsdWRlQ3JlZGVudGlhbHMgYmUgdHJ1ZSBpZiBvbmUgb2ZcbiAgY29uc3QgaW5jbHVkZUNyZWRlbnRpYWxzID1cbiAgICByZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScgfHxcbiAgICAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ3NhbWUtb3JpZ2luJyAmJlxuICAgICAgcmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnYmFzaWMnKVxuXG4gIC8vICAgIDQuIExldCBjb250ZW50TGVuZ3RoIGJlIGh0dHBSZXF1ZXN04oCZcyBib2R54oCZcyBsZW5ndGgsIGlmIGh0dHBSZXF1ZXN04oCZc1xuICAvLyAgICBib2R5IGlzIG5vbi1udWxsOyBvdGhlcndpc2UgbnVsbC5cbiAgY29uc3QgY29udGVudExlbmd0aCA9IGh0dHBSZXF1ZXN0LmJvZHkgPyBodHRwUmVxdWVzdC5ib2R5Lmxlbmd0aCA6IG51bGxcblxuICAvLyAgICA1LiBMZXQgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGJlIG51bGwuXG4gIGxldCBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBudWxsXG5cbiAgLy8gICAgNi4gSWYgaHR0cFJlcXVlc3TigJlzIGJvZHkgaXMgbnVsbCBhbmQgaHR0cFJlcXVlc3TigJlzIG1ldGhvZCBpcyBgUE9TVGAgb3JcbiAgLy8gICAgYFBVVGAsIHRoZW4gc2V0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0byBgMGAuXG4gIGlmIChcbiAgICBodHRwUmVxdWVzdC5ib2R5ID09IG51bGwgJiZcbiAgICBbJ1BPU1QnLCAnUFVUJ10uaW5jbHVkZXMoaHR0cFJlcXVlc3QubWV0aG9kKVxuICApIHtcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSAnMCdcbiAgfVxuXG4gIC8vICAgIDcuIElmIGNvbnRlbnRMZW5ndGggaXMgbm9uLW51bGwsIHRoZW4gc2V0IGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSB0b1xuICAvLyAgICBjb250ZW50TGVuZ3RoLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gIGlmIChjb250ZW50TGVuZ3RoICE9IG51bGwpIHtcbiAgICBjb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgPSBpc29tb3JwaGljRW5jb2RlKGAke2NvbnRlbnRMZW5ndGh9YClcbiAgfVxuXG4gIC8vICAgIDguIElmIGNvbnRlbnRMZW5ndGhIZWFkZXJWYWx1ZSBpcyBub24tbnVsbCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYENvbnRlbnQtTGVuZ3RoYC9jb250ZW50TGVuZ3RoSGVhZGVyVmFsdWUgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlclxuICAvLyAgICBsaXN0LlxuICBpZiAoY29udGVudExlbmd0aEhlYWRlclZhbHVlICE9IG51bGwpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtbGVuZ3RoJywgY29udGVudExlbmd0aEhlYWRlclZhbHVlLCB0cnVlKVxuICB9XG5cbiAgLy8gICAgOS4gSWYgY29udGVudExlbmd0aEhlYWRlclZhbHVlIGlzIG5vbi1udWxsLCB0aGVuIGFwcGVuZCAoYENvbnRlbnQtTGVuZ3RoYCxcbiAgLy8gICAgY29udGVudExlbmd0aEhlYWRlclZhbHVlKSB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG5cbiAgLy8gICAgMTAuIElmIGNvbnRlbnRMZW5ndGggaXMgbm9uLW51bGwgYW5kIGh0dHBSZXF1ZXN04oCZcyBrZWVwYWxpdmUgaXMgdHJ1ZSxcbiAgLy8gICAgdGhlbjpcbiAgaWYgKGNvbnRlbnRMZW5ndGggIT0gbnVsbCAmJiBodHRwUmVxdWVzdC5rZWVwYWxpdmUpIHtcbiAgICAvLyBOT1RFOiBrZWVwYWxpdmUgaXMgYSBub29wIG91dHNpZGUgb2YgYnJvd3NlciBjb250ZXh0LlxuICB9XG5cbiAgLy8gICAgMTEuIElmIGh0dHBSZXF1ZXN04oCZcyByZWZlcnJlciBpcyBhIFVSTCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYFJlZmVyZXJgL2h0dHBSZXF1ZXN04oCZcyByZWZlcnJlciwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkLFxuICAvLyAgICAgdG8gaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoaHR0cFJlcXVlc3QucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3JlZmVyZXInLCBpc29tb3JwaGljRW5jb2RlKGh0dHBSZXF1ZXN0LnJlZmVycmVyLmhyZWYpLCB0cnVlKVxuICB9XG5cbiAgLy8gICAgMTIuIEFwcGVuZCBhIHJlcXVlc3QgYE9yaWdpbmAgaGVhZGVyIGZvciBodHRwUmVxdWVzdC5cbiAgYXBwZW5kUmVxdWVzdE9yaWdpbkhlYWRlcihodHRwUmVxdWVzdClcblxuICAvLyAgICAxMy4gQXBwZW5kIHRoZSBGZXRjaCBtZXRhZGF0YSBoZWFkZXJzIGZvciBodHRwUmVxdWVzdC4gW0ZFVENILU1FVEFEQVRBXVxuICBhcHBlbmRGZXRjaE1ldGFkYXRhKGh0dHBSZXF1ZXN0KVxuXG4gIC8vICAgIDE0LiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgVXNlci1BZ2VudGAsIHRoZW5cbiAgLy8gICAgdXNlciBhZ2VudHMgc2hvdWxkIGFwcGVuZCBgVXNlci1BZ2VudGAvZGVmYXVsdCBgVXNlci1BZ2VudGAgdmFsdWUgdG9cbiAgLy8gICAgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCd1c2VyLWFnZW50JywgdHJ1ZSkpIHtcbiAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3VzZXItYWdlbnQnLCBkZWZhdWx0VXNlckFnZW50KVxuICB9XG5cbiAgLy8gICAgMTUuIElmIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwiZGVmYXVsdFwiIGFuZCBodHRwUmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vICAgIGxpc3QgY29udGFpbnMgYElmLU1vZGlmaWVkLVNpbmNlYCwgYElmLU5vbmUtTWF0Y2hgLFxuICAvLyAgICBgSWYtVW5tb2RpZmllZC1TaW5jZWAsIGBJZi1NYXRjaGAsIG9yIGBJZi1SYW5nZWAsIHRoZW4gc2V0XG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvIFwibm8tc3RvcmVcIi5cbiAgaWYgKFxuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnZGVmYXVsdCcgJiZcbiAgICAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2lmLW1vZGlmaWVkLXNpbmNlJywgdHJ1ZSkgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1ub25lLW1hdGNoJywgdHJ1ZSkgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi11bm1vZGlmaWVkLXNpbmNlJywgdHJ1ZSkgfHxcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdpZi1tYXRjaCcsIHRydWUpIHx8XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnaWYtcmFuZ2UnLCB0cnVlKSlcbiAgKSB7XG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG4gIH1cblxuICAvLyAgICAxNi4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJuby1jYWNoZVwiLCBodHRwUmVxdWVzdOKAmXMgcHJldmVudFxuICAvLyAgICBuby1jYWNoZSBjYWNoZS1jb250cm9sIGhlYWRlciBtb2RpZmljYXRpb24gZmxhZyBpcyB1bnNldCwgYW5kXG4gIC8vICAgIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBDYWNoZS1Db250cm9sYCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYENhY2hlLUNvbnRyb2xgL2BtYXgtYWdlPTBgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgaWYgKFxuICAgIGh0dHBSZXF1ZXN0LmNhY2hlID09PSAnbm8tY2FjaGUnICYmXG4gICAgIWh0dHBSZXF1ZXN0LnByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uICYmXG4gICAgIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdjYWNoZS1jb250cm9sJywgdHJ1ZSlcbiAgKSB7XG4gICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdjYWNoZS1jb250cm9sJywgJ21heC1hZ2U9MCcsIHRydWUpXG4gIH1cblxuICAvLyAgICAxNy4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJuby1zdG9yZVwiIG9yIFwicmVsb2FkXCIsIHRoZW46XG4gIGlmIChodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBodHRwUmVxdWVzdC5jYWNoZSA9PT0gJ3JlbG9hZCcpIHtcbiAgICAvLyAxLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgUHJhZ21hYCwgdGhlbiBhcHBlbmRcbiAgICAvLyBgUHJhZ21hYC9gbm8tY2FjaGVgIHRvIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICBpZiAoIWh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdwcmFnbWEnLCB0cnVlKSkge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdwcmFnbWEnLCAnbm8tY2FjaGUnLCB0cnVlKVxuICAgIH1cblxuICAgIC8vIDIuIElmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluIGBDYWNoZS1Db250cm9sYCxcbiAgICAvLyB0aGVuIGFwcGVuZCBgQ2FjaGUtQ29udHJvbGAvYG5vLWNhY2hlYCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gICAgaWYgKCFodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygnY2FjaGUtY29udHJvbCcsIHRydWUpKSB7XG4gICAgICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NhY2hlLWNvbnRyb2wnLCAnbm8tY2FjaGUnLCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIC8vICAgIDE4LiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFJhbmdlYCwgdGhlbiBhcHBlbmRcbiAgLy8gICAgYEFjY2VwdC1FbmNvZGluZ2AvYGlkZW50aXR5YCB0byBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QuXG4gIGlmIChodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5jb250YWlucygncmFuZ2UnLCB0cnVlKSkge1xuICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2lkZW50aXR5JywgdHJ1ZSlcbiAgfVxuXG4gIC8vICAgIDE5LiBNb2RpZnkgaHR0cFJlcXVlc3TigJlzIGhlYWRlciBsaXN0IHBlciBIVFRQLiBEbyBub3QgYXBwZW5kIGEgZ2l2ZW5cbiAgLy8gICAgaGVhZGVyIGlmIGh0dHBSZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyB0aGF0IGhlYWRlcuKAmXMgbmFtZS5cbiAgLy8gICAgVE9ETzogaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMTI4NSNpc3N1ZWNvbW1lbnQtODk2NTYwMTI5XG4gIGlmICghaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ2FjY2VwdC1lbmNvZGluZycsIHRydWUpKSB7XG4gICAgaWYgKHVybEhhc0h0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKGh0dHBSZXF1ZXN0KSkpIHtcbiAgICAgIGh0dHBSZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnYWNjZXB0LWVuY29kaW5nJywgJ2JyLCBnemlwLCBkZWZsYXRlJywgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdhY2NlcHQtZW5jb2RpbmcnLCAnZ3ppcCwgZGVmbGF0ZScsIHRydWUpXG4gICAgfVxuICB9XG5cbiAgaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuZGVsZXRlKCdob3N0JywgdHJ1ZSlcblxuICAvLyAgICAyMC4gSWYgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUsIHRoZW46XG4gIGlmIChpbmNsdWRlQ3JlZGVudGlhbHMpIHtcbiAgICAvLyAxLiBJZiB0aGUgdXNlciBhZ2VudCBpcyBub3QgY29uZmlndXJlZCB0byBibG9jayBjb29raWVzIGZvciBodHRwUmVxdWVzdFxuICAgIC8vIChzZWUgc2VjdGlvbiA3IG9mIFtDT09LSUVTXSksIHRoZW46XG4gICAgLy8gVE9ETzogY3JlZGVudGlhbHNcbiAgICAvLyAyLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgZG9lcyBub3QgY29udGFpbiBgQXV0aG9yaXphdGlvbmAsIHRoZW46XG4gICAgLy8gVE9ETzogY3JlZGVudGlhbHNcbiAgfVxuXG4gIC8vICAgIDIxLiBJZiB0aGVyZeKAmXMgYSBwcm94eS1hdXRoZW50aWNhdGlvbiBlbnRyeSwgdXNlIGl0IGFzIGFwcHJvcHJpYXRlLlxuICAvLyAgICBUT0RPOiBwcm94eS1hdXRoZW50aWNhdGlvblxuXG4gIC8vICAgIDIyLiBTZXQgaHR0cENhY2hlIHRvIHRoZSByZXN1bHQgb2YgZGV0ZXJtaW5pbmcgdGhlIEhUVFAgY2FjaGVcbiAgLy8gICAgcGFydGl0aW9uLCBnaXZlbiBodHRwUmVxdWVzdC5cbiAgLy8gICAgVE9ETzogY2FjaGVcblxuICAvLyAgICAyMy4gSWYgaHR0cENhY2hlIGlzIG51bGwsIHRoZW4gc2V0IGh0dHBSZXF1ZXN04oCZcyBjYWNoZSBtb2RlIHRvXG4gIC8vICAgIFwibm8tc3RvcmVcIi5cbiAgaWYgKGh0dHBDYWNoZSA9PSBudWxsKSB7XG4gICAgaHR0cFJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG4gIH1cblxuICAvLyAgICAyNC4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgbmVpdGhlciBcIm5vLXN0b3JlXCIgbm9yIFwicmVsb2FkXCIsXG4gIC8vICAgIHRoZW46XG4gIGlmIChodHRwUmVxdWVzdC5jYWNoZSAhPT0gJ25vLXN0b3JlJyAmJiBodHRwUmVxdWVzdC5jYWNoZSAhPT0gJ3JlbG9hZCcpIHtcbiAgICAvLyBUT0RPOiBjYWNoZVxuICB9XG5cbiAgLy8gOS4gSWYgYWJvcnRlZCwgdGhlbiByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG5ldHdvcmsgZXJyb3IgZm9yIGZldGNoUGFyYW1zLlxuICAvLyBUT0RPXG5cbiAgLy8gMTAuIElmIHJlc3BvbnNlIGlzIG51bGwsIHRoZW46XG4gIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgLy8gMS4gSWYgaHR0cFJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXMgXCJvbmx5LWlmLWNhY2hlZFwiLCB0aGVuIHJldHVybiBhXG4gICAgLy8gbmV0d29yayBlcnJvci5cbiAgICBpZiAoaHR0cFJlcXVlc3QuY2FjaGUgPT09ICdvbmx5LWlmLWNhY2hlZCcpIHtcbiAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdvbmx5IGlmIGNhY2hlZCcpXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGZvcndhcmRSZXNwb25zZSBiZSB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1uZXR3b3JrIGZldGNoXG4gICAgLy8gZ2l2ZW4gaHR0cEZldGNoUGFyYW1zLCBpbmNsdWRlQ3JlZGVudGlhbHMsIGFuZCBpc05ld0Nvbm5lY3Rpb25GZXRjaC5cbiAgICBjb25zdCBmb3J3YXJkUmVzcG9uc2UgPSBhd2FpdCBodHRwTmV0d29ya0ZldGNoKFxuICAgICAgaHR0cEZldGNoUGFyYW1zLFxuICAgICAgaW5jbHVkZUNyZWRlbnRpYWxzLFxuICAgICAgaXNOZXdDb25uZWN0aW9uRmV0Y2hcbiAgICApXG5cbiAgICAvLyAzLiBJZiBodHRwUmVxdWVzdOKAmXMgbWV0aG9kIGlzIHVuc2FmZSBhbmQgZm9yd2FyZFJlc3BvbnNl4oCZcyBzdGF0dXMgaXNcbiAgICAvLyBpbiB0aGUgcmFuZ2UgMjAwIHRvIDM5OSwgaW5jbHVzaXZlLCBpbnZhbGlkYXRlIGFwcHJvcHJpYXRlIHN0b3JlZFxuICAgIC8vIHJlc3BvbnNlcyBpbiBodHRwQ2FjaGUsIGFzIHBlciB0aGUgXCJJbnZhbGlkYXRpb25cIiBjaGFwdGVyIG9mIEhUVFBcbiAgICAvLyBDYWNoaW5nLCBhbmQgc2V0IHN0b3JlZFJlc3BvbnNlIHRvIG51bGwuIFtIVFRQLUNBQ0hJTkddXG4gICAgaWYgKFxuICAgICAgIXNhZmVNZXRob2RzU2V0LmhhcyhodHRwUmVxdWVzdC5tZXRob2QpICYmXG4gICAgICBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzID49IDIwMCAmJlxuICAgICAgZm9yd2FyZFJlc3BvbnNlLnN0YXR1cyA8PSAzOTlcbiAgICApIHtcbiAgICAgIC8vIFRPRE86IGNhY2hlXG4gICAgfVxuXG4gICAgLy8gNC4gSWYgdGhlIHJldmFsaWRhdGluZ0ZsYWcgaXMgc2V0IGFuZCBmb3J3YXJkUmVzcG9uc2XigJlzIHN0YXR1cyBpcyAzMDQsXG4gICAgLy8gdGhlbjpcbiAgICBpZiAocmV2YWxpZGF0aW5nRmxhZyAmJiBmb3J3YXJkUmVzcG9uc2Uuc3RhdHVzID09PSAzMDQpIHtcbiAgICAgIC8vIFRPRE86IGNhY2hlXG4gICAgfVxuXG4gICAgLy8gNS4gSWYgcmVzcG9uc2UgaXMgbnVsbCwgdGhlbjpcbiAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuICAgICAgLy8gMS4gU2V0IHJlc3BvbnNlIHRvIGZvcndhcmRSZXNwb25zZS5cbiAgICAgIHJlc3BvbnNlID0gZm9yd2FyZFJlc3BvbnNlXG5cbiAgICAgIC8vIDIuIFN0b3JlIGh0dHBSZXF1ZXN0IGFuZCBmb3J3YXJkUmVzcG9uc2UgaW4gaHR0cENhY2hlLCBhcyBwZXIgdGhlXG4gICAgICAvLyBcIlN0b3JpbmcgUmVzcG9uc2VzIGluIENhY2hlc1wiIGNoYXB0ZXIgb2YgSFRUUCBDYWNoaW5nLiBbSFRUUC1DQUNISU5HXVxuICAgICAgLy8gVE9ETzogY2FjaGVcbiAgICB9XG4gIH1cblxuICAvLyAxMS4gU2V0IHJlc3BvbnNl4oCZcyBVUkwgbGlzdCB0byBhIGNsb25lIG9mIGh0dHBSZXF1ZXN04oCZcyBVUkwgbGlzdC5cbiAgcmVzcG9uc2UudXJsTGlzdCA9IFsuLi5odHRwUmVxdWVzdC51cmxMaXN0XVxuXG4gIC8vIDEyLiBJZiBodHRwUmVxdWVzdOKAmXMgaGVhZGVyIGxpc3QgY29udGFpbnMgYFJhbmdlYCwgdGhlbiBzZXQgcmVzcG9uc2XigJlzXG4gIC8vIHJhbmdlLXJlcXVlc3RlZCBmbGFnLlxuICBpZiAoaHR0cFJlcXVlc3QuaGVhZGVyc0xpc3QuY29udGFpbnMoJ3JhbmdlJywgdHJ1ZSkpIHtcbiAgICByZXNwb25zZS5yYW5nZVJlcXVlc3RlZCA9IHRydWVcbiAgfVxuXG4gIC8vIDEzLiBTZXQgcmVzcG9uc2XigJlzIHJlcXVlc3QtaW5jbHVkZXMtY3JlZGVudGlhbHMgdG8gaW5jbHVkZUNyZWRlbnRpYWxzLlxuICByZXNwb25zZS5yZXF1ZXN0SW5jbHVkZXNDcmVkZW50aWFscyA9IGluY2x1ZGVDcmVkZW50aWFsc1xuXG4gIC8vIDE0LiBJZiByZXNwb25zZeKAmXMgc3RhdHVzIGlzIDQwMSwgaHR0cFJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIG5vdFxuICAvLyBcImNvcnNcIiwgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUsIGFuZCByZXF1ZXN04oCZcyB3aW5kb3cgaXMgYW4gZW52aXJvbm1lbnRcbiAgLy8gc2V0dGluZ3Mgb2JqZWN0LCB0aGVuOlxuICAvLyBUT0RPXG5cbiAgLy8gMTUuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgNDA3LCB0aGVuOlxuICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDcpIHtcbiAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyB3aW5kb3cgaXMgXCJuby13aW5kb3dcIiwgdGhlbiByZXR1cm4gYSBuZXR3b3JrIGVycm9yLlxuICAgIGlmIChyZXF1ZXN0LndpbmRvdyA9PT0gJ25vLXdpbmRvdycpIHtcbiAgICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKClcbiAgICB9XG5cbiAgICAvLyAyLiA/Pz9cblxuICAgIC8vIDMuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcylcbiAgICB9XG5cbiAgICAvLyA0LiBQcm9tcHQgdGhlIGVuZCB1c2VyIGFzIGFwcHJvcHJpYXRlIGluIHJlcXVlc3TigJlzIHdpbmRvdyBhbmQgc3RvcmVcbiAgICAvLyB0aGUgcmVzdWx0IGFzIGEgcHJveHktYXV0aGVudGljYXRpb24gZW50cnkuIFtIVFRQLUFVVEhdXG4gICAgLy8gVE9ETzogSW52b2tlIHNvbWUga2luZCBvZiBjYWxsYmFjaz9cblxuICAgIC8vIDUuIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIHJ1bm5pbmcgSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIGdpdmVuXG4gICAgLy8gZmV0Y2hQYXJhbXMuXG4gICAgLy8gVE9ET1xuICAgIHJldHVybiBtYWtlTmV0d29ya0Vycm9yKCdwcm94eSBhdXRoZW50aWNhdGlvbiByZXF1aXJlZCcpXG4gIH1cblxuICAvLyAxNi4gSWYgYWxsIG9mIHRoZSBmb2xsb3dpbmcgYXJlIHRydWVcbiAgaWYgKFxuICAgIC8vIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgNDIxXG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSA0MjEgJiZcbiAgICAvLyBpc05ld0Nvbm5lY3Rpb25GZXRjaCBpcyBmYWxzZVxuICAgICFpc05ld0Nvbm5lY3Rpb25GZXRjaCAmJlxuICAgIC8vIHJlcXVlc3TigJlzIGJvZHkgaXMgbnVsbCwgb3IgcmVxdWVzdOKAmXMgYm9keSBpcyBub24tbnVsbCBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG5vbi1udWxsXG4gICAgKHJlcXVlc3QuYm9keSA9PSBudWxsIHx8IHJlcXVlc3QuYm9keS5zb3VyY2UgIT0gbnVsbClcbiAgKSB7XG4gICAgLy8gdGhlbjpcblxuICAgIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgbmV0d29yayBlcnJvciBmb3IgZmV0Y2hQYXJhbXMuXG4gICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIG1ha2VBcHByb3ByaWF0ZU5ldHdvcmtFcnJvcihmZXRjaFBhcmFtcylcbiAgICB9XG5cbiAgICAvLyAyLiBTZXQgcmVzcG9uc2UgdG8gdGhlIHJlc3VsdCBvZiBydW5uaW5nIEhUVFAtbmV0d29yay1vci1jYWNoZVxuICAgIC8vIGZldGNoIGdpdmVuIGZldGNoUGFyYW1zLCBpc0F1dGhlbnRpY2F0aW9uRmV0Y2gsIGFuZCB0cnVlLlxuXG4gICAgLy8gVE9ETyAoc3BlYyk6IFRoZSBzcGVjIGRvZXNuJ3Qgc3BlY2lmeSB0aGlzIGJ1dCB3ZSBuZWVkIHRvIGNhbmNlbFxuICAgIC8vIHRoZSBhY3RpdmUgcmVzcG9uc2UgYmVmb3JlIHdlIGNhbiBzdGFydCBhIG5ldyBvbmUuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9mZXRjaC9pc3N1ZXMvMTI5M1xuICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcblxuICAgIHJlc3BvbnNlID0gYXdhaXQgaHR0cE5ldHdvcmtPckNhY2hlRmV0Y2goXG4gICAgICBmZXRjaFBhcmFtcyxcbiAgICAgIGlzQXV0aGVudGljYXRpb25GZXRjaCxcbiAgICAgIHRydWVcbiAgICApXG4gIH1cblxuICAvLyAxNy4gSWYgaXNBdXRoZW50aWNhdGlvbkZldGNoIGlzIHRydWUsIHRoZW4gY3JlYXRlIGFuIGF1dGhlbnRpY2F0aW9uIGVudHJ5XG4gIGlmIChpc0F1dGhlbnRpY2F0aW9uRmV0Y2gpIHtcbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyAxOC4gUmV0dXJuIHJlc3BvbnNlLlxuICByZXR1cm4gcmVzcG9uc2Vcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2h0dHAtbmV0d29yay1mZXRjaFxuYXN5bmMgZnVuY3Rpb24gaHR0cE5ldHdvcmtGZXRjaCAoXG4gIGZldGNoUGFyYW1zLFxuICBpbmNsdWRlQ3JlZGVudGlhbHMgPSBmYWxzZSxcbiAgZm9yY2VOZXdDb25uZWN0aW9uID0gZmFsc2Vcbikge1xuICBhc3NlcnQoIWZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbiB8fCBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbm5lY3Rpb24uZGVzdHJveWVkKVxuXG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbiA9IHtcbiAgICBhYm9ydDogbnVsbCxcbiAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgIGRlc3Ryb3kgKGVyciwgYWJvcnQgPSB0cnVlKSB7XG4gICAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZVxuICAgICAgICBpZiAoYWJvcnQpIHtcbiAgICAgICAgICB0aGlzLmFib3J0Py4oZXJyID8/IG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIDEuIExldCByZXF1ZXN0IGJlIGZldGNoUGFyYW1z4oCZcyByZXF1ZXN0LlxuICBjb25zdCByZXF1ZXN0ID0gZmV0Y2hQYXJhbXMucmVxdWVzdFxuXG4gIC8vIDIuIExldCByZXNwb25zZSBiZSBudWxsLlxuICBsZXQgcmVzcG9uc2UgPSBudWxsXG5cbiAgLy8gMy4gTGV0IHRpbWluZ0luZm8gYmUgZmV0Y2hQYXJhbXPigJlzIHRpbWluZyBpbmZvLlxuICBjb25zdCB0aW1pbmdJbmZvID0gZmV0Y2hQYXJhbXMudGltaW5nSW5mb1xuXG4gIC8vIDQuIExldCBodHRwQ2FjaGUgYmUgdGhlIHJlc3VsdCBvZiBkZXRlcm1pbmluZyB0aGUgSFRUUCBjYWNoZSBwYXJ0aXRpb24sXG4gIC8vIGdpdmVuIHJlcXVlc3QuXG4gIC8vIFRPRE86IGNhY2hlXG4gIGNvbnN0IGh0dHBDYWNoZSA9IG51bGxcblxuICAvLyA1LiBJZiBodHRwQ2FjaGUgaXMgbnVsbCwgdGhlbiBzZXQgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0byBcIm5vLXN0b3JlXCIuXG4gIGlmIChodHRwQ2FjaGUgPT0gbnVsbCkge1xuICAgIHJlcXVlc3QuY2FjaGUgPSAnbm8tc3RvcmUnXG4gIH1cblxuICAvLyA2LiBMZXQgbmV0d29ya1BhcnRpdGlvbktleSBiZSB0aGUgcmVzdWx0IG9mIGRldGVybWluaW5nIHRoZSBuZXR3b3JrXG4gIC8vIHBhcnRpdGlvbiBrZXkgZ2l2ZW4gcmVxdWVzdC5cbiAgLy8gVE9ET1xuXG4gIC8vIDcuIExldCBuZXdDb25uZWN0aW9uIGJlIFwieWVzXCIgaWYgZm9yY2VOZXdDb25uZWN0aW9uIGlzIHRydWU7IG90aGVyd2lzZVxuICAvLyBcIm5vXCIuXG4gIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSBmb3JjZU5ld0Nvbm5lY3Rpb24gPyAneWVzJyA6ICdubycgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gIC8vIDguIFN3aXRjaCBvbiByZXF1ZXN04oCZcyBtb2RlOlxuICBpZiAocmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0Jykge1xuICAgIC8vIExldCBjb25uZWN0aW9uIGJlIHRoZSByZXN1bHQgb2Ygb2J0YWluaW5nIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24sXG4gICAgLy8gZ2l2ZW4gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgLy8gVE9ET1xuICB9IGVsc2Uge1xuICAgIC8vIExldCBjb25uZWN0aW9uIGJlIHRoZSByZXN1bHQgb2Ygb2J0YWluaW5nIGEgY29ubmVjdGlvbiwgZ2l2ZW5cbiAgICAvLyBuZXR3b3JrUGFydGl0aW9uS2V5LCByZXF1ZXN04oCZcyBjdXJyZW50IFVSTOKAmXMgb3JpZ2luLFxuICAgIC8vIGluY2x1ZGVDcmVkZW50aWFscywgYW5kIGZvcmNlTmV3Q29ubmVjdGlvbi5cbiAgICAvLyBUT0RPXG4gIH1cblxuICAvLyA5LiBSdW4gdGhlc2Ugc3RlcHMsIGJ1dCBhYm9ydCB3aGVuIHRoZSBvbmdvaW5nIGZldGNoIGlzIHRlcm1pbmF0ZWQ6XG5cbiAgLy8gICAgMS4gSWYgY29ubmVjdGlvbiBpcyBmYWlsdXJlLCB0aGVuIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gICAgMi4gU2V0IHRpbWluZ0luZm/igJlzIGZpbmFsIGNvbm5lY3Rpb24gdGltaW5nIGluZm8gdG8gdGhlIHJlc3VsdCBvZlxuICAvLyAgICBjYWxsaW5nIGNsYW1wIGFuZCBjb2Fyc2VuIGNvbm5lY3Rpb24gdGltaW5nIGluZm8gd2l0aCBjb25uZWN0aW9u4oCZc1xuICAvLyAgICB0aW1pbmcgaW5mbywgdGltaW5nSW5mb+KAmXMgcG9zdC1yZWRpcmVjdCBzdGFydCB0aW1lLCBhbmQgZmV0Y2hQYXJhbXPigJlzXG4gIC8vICAgIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LlxuXG4gIC8vICAgIDMuIElmIGNvbm5lY3Rpb24gaXMgbm90IGFuIEhUVFAvMiBjb25uZWN0aW9uLCByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLFxuICAvLyAgICBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsIHRoZW4gYXBwZW5kIChgVHJhbnNmZXItRW5jb2RpbmdgLFxuICAvLyAgICBgY2h1bmtlZGApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuXG4gIC8vICAgIDQuIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlcXVlc3Qgc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkXG4gIC8vICAgIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZFxuICAvLyAgICBjYXBhYmlsaXR5LlxuXG4gIC8vICAgIDUuIFNldCByZXNwb25zZSB0byB0aGUgcmVzdWx0IG9mIG1ha2luZyBhbiBIVFRQIHJlcXVlc3Qgb3ZlciBjb25uZWN0aW9uXG4gIC8vICAgIHVzaW5nIHJlcXVlc3Qgd2l0aCB0aGUgZm9sbG93aW5nIGNhdmVhdHM6XG5cbiAgLy8gICAgICAgIC0gRm9sbG93IHRoZSByZWxldmFudCByZXF1aXJlbWVudHMgZnJvbSBIVFRQLiBbSFRUUF0gW0hUVFAtU0VNQU5USUNTXVxuICAvLyAgICAgICAgW0hUVFAtQ09ORF0gW0hUVFAtQ0FDSElOR10gW0hUVFAtQVVUSF1cblxuICAvLyAgICAgICAgLSBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLCBhbmQgcmVxdWVzdOKAmXMgYm9keeKAmXMgc291cmNlIGlzIG51bGwsXG4gIC8vICAgICAgICB0aGVuIHRoZSB1c2VyIGFnZW50IG1heSBoYXZlIGEgYnVmZmVyIG9mIHVwIHRvIDY0IGtpYmlieXRlcyBhbmQgc3RvcmVcbiAgLy8gICAgICAgIGEgcGFydCBvZiByZXF1ZXN04oCZcyBib2R5IGluIHRoYXQgYnVmZmVyLiBJZiB0aGUgdXNlciBhZ2VudCByZWFkcyBmcm9tXG4gIC8vICAgICAgICByZXF1ZXN04oCZcyBib2R5IGJleW9uZCB0aGF0IGJ1ZmZlcuKAmXMgc2l6ZSBhbmQgdGhlIHVzZXIgYWdlbnQgbmVlZHMgdG9cbiAgLy8gICAgICAgIHJlc2VuZCByZXF1ZXN0LCB0aGVuIGluc3RlYWQgcmV0dXJuIGEgbmV0d29yayBlcnJvci5cblxuICAvLyAgICAgICAgLSBTZXQgdGltaW5nSW5mb+KAmXMgZmluYWwgbmV0d29yay1yZXNwb25zZSBzdGFydCB0aW1lIHRvIHRoZSBjb2Fyc2VuZWRcbiAgLy8gICAgICAgIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LFxuICAvLyAgICAgICAgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIHVzZXIgYWdlbnTigJlzIEhUVFAgcGFyc2VyIHJlY2VpdmVzIHRoZSBmaXJzdCBieXRlXG4gIC8vICAgICAgICBvZiB0aGUgcmVzcG9uc2UgKGUuZy4sIGZyYW1lIGhlYWRlciBieXRlcyBmb3IgSFRUUC8yIG9yIHJlc3BvbnNlIHN0YXR1c1xuICAvLyAgICAgICAgbGluZSBmb3IgSFRUUC8xLngpLlxuXG4gIC8vICAgICAgICAtIFdhaXQgdW50aWwgYWxsIHRoZSBoZWFkZXJzIGFyZSB0cmFuc21pdHRlZC5cblxuICAvLyAgICAgICAgLSBBbnkgcmVzcG9uc2VzIHdob3NlIHN0YXR1cyBpcyBpbiB0aGUgcmFuZ2UgMTAwIHRvIDE5OSwgaW5jbHVzaXZlLFxuICAvLyAgICAgICAgYW5kIGlzIG5vdCAxMDEsIGFyZSB0byBiZSBpZ25vcmVkLCBleGNlcHQgZm9yIHRoZSBwdXJwb3NlcyBvZiBzZXR0aW5nXG4gIC8vICAgICAgICB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlc3BvbnNlIHN0YXJ0IHRpbWUgYWJvdmUuXG5cbiAgLy8gICAgLSBJZiByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBjb250YWlucyBgVHJhbnNmZXItRW5jb2RpbmdgL2BjaHVua2VkYCBhbmRcbiAgLy8gICAgcmVzcG9uc2UgaXMgdHJhbnNmZXJyZWQgdmlhIEhUVFAvMS4wIG9yIG9sZGVyLCB0aGVuIHJldHVybiBhIG5ldHdvcmtcbiAgLy8gICAgZXJyb3IuXG5cbiAgLy8gICAgLSBJZiB0aGUgSFRUUCByZXF1ZXN0IHJlc3VsdHMgaW4gYSBUTFMgY2xpZW50IGNlcnRpZmljYXRlIGRpYWxvZywgdGhlbjpcblxuICAvLyAgICAgICAgMS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50IHNldHRpbmdzIG9iamVjdCwgbWFrZSB0aGVcbiAgLy8gICAgICAgIGRpYWxvZyBhdmFpbGFibGUgaW4gcmVxdWVzdOKAmXMgd2luZG93LlxuXG4gIC8vICAgICAgICAyLiBPdGhlcndpc2UsIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG5cbiAgLy8gVG8gdHJhbnNtaXQgcmVxdWVzdOKAmXMgYm9keSBib2R5LCBydW4gdGhlc2Ugc3RlcHM6XG4gIGxldCByZXF1ZXN0Qm9keSA9IG51bGxcbiAgLy8gMS4gSWYgYm9keSBpcyBudWxsIGFuZCBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0IGVuZC1vZi1ib2R5IGlzXG4gIC8vIG5vbi1udWxsLCB0aGVuIHF1ZXVlIGEgZmV0Y2ggdGFzayBnaXZlbiBmZXRjaFBhcmFtc+KAmXMgcHJvY2VzcyByZXF1ZXN0XG4gIC8vIGVuZC1vZi1ib2R5IGFuZCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgaWYgKHJlcXVlc3QuYm9keSA9PSBudWxsICYmIGZldGNoUGFyYW1zLnByb2Nlc3NSZXF1ZXN0RW5kT2ZCb2R5KSB7XG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4gZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkoKSlcbiAgfSBlbHNlIGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuICAgIC8vIDIuIE90aGVyd2lzZSwgaWYgYm9keSBpcyBub24tbnVsbDpcblxuICAgIC8vICAgIDEuIExldCBwcm9jZXNzQm9keUNodW5rIGdpdmVuIGJ5dGVzIGJlIHRoZXNlIHN0ZXBzOlxuICAgIGNvbnN0IHByb2Nlc3NCb2R5Q2h1bmsgPSBhc3luYyBmdW5jdGlvbiAqIChieXRlcykge1xuICAgICAgLy8gMS4gSWYgdGhlIG9uZ29pbmcgZmV0Y2ggaXMgdGVybWluYXRlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFJ1biB0aGlzIHN0ZXAgaW4gcGFyYWxsZWw6IHRyYW5zbWl0IGJ5dGVzLlxuICAgICAgeWllbGQgYnl0ZXNcblxuICAgICAgLy8gMy4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHJ1blxuICAgICAgLy8gZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBib2R5IGdpdmVuIGJ5dGVz4oCZcyBsZW5ndGguXG4gICAgICBmZXRjaFBhcmFtcy5wcm9jZXNzUmVxdWVzdEJvZHlDaHVua0xlbmd0aD8uKGJ5dGVzLmJ5dGVMZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IHByb2Nlc3NFbmRPZkJvZHkgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0VuZE9mQm9keSA9ICgpID0+IHtcbiAgICAgIC8vIDEuIElmIGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLCB0aGVuIGFib3J0IHRoZXNlIHN0ZXBzLlxuICAgICAgaWYgKGlzQ2FuY2VsbGVkKGZldGNoUGFyYW1zKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gMi4gSWYgZmV0Y2hQYXJhbXPigJlzIHByb2Nlc3MgcmVxdWVzdCBlbmQtb2YtYm9keSBpcyBub24tbnVsbCxcbiAgICAgIC8vIHRoZW4gcnVuIGZldGNoUGFyYW1z4oCZcyBwcm9jZXNzIHJlcXVlc3QgZW5kLW9mLWJvZHkuXG4gICAgICBpZiAoZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMucHJvY2Vzc1JlcXVlc3RFbmRPZkJvZHkoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMuIExldCBwcm9jZXNzQm9keUVycm9yIGdpdmVuIGUgYmUgdGhlc2Ugc3RlcHM6XG4gICAgY29uc3QgcHJvY2Vzc0JvZHlFcnJvciA9IChlKSA9PiB7XG4gICAgICAvLyAxLiBJZiBmZXRjaFBhcmFtcyBpcyBjYW5jZWxlZCwgdGhlbiBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICAgIGlmIChpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIGUgaXMgYW4gXCJBYm9ydEVycm9yXCIgRE9NRXhjZXB0aW9uLCB0aGVuIGFib3J0IGZldGNoUGFyYW1z4oCZcyBjb250cm9sbGVyLlxuICAgICAgaWYgKGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuYWJvcnQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci50ZXJtaW5hdGUoZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBJbmNyZW1lbnRhbGx5IHJlYWQgcmVxdWVzdOKAmXMgYm9keSBnaXZlbiBwcm9jZXNzQm9keUNodW5rLCBwcm9jZXNzRW5kT2ZCb2R5LFxuICAgIC8vIHByb2Nlc3NCb2R5RXJyb3IsIGFuZCBmZXRjaFBhcmFtc+KAmXMgdGFzayBkZXN0aW5hdGlvbi5cbiAgICByZXF1ZXN0Qm9keSA9IChhc3luYyBmdW5jdGlvbiAqICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgYnl0ZXMgb2YgcmVxdWVzdC5ib2R5LnN0cmVhbSkge1xuICAgICAgICAgIHlpZWxkICogcHJvY2Vzc0JvZHlDaHVuayhieXRlcylcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzRW5kT2ZCb2R5KClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBwcm9jZXNzQm9keUVycm9yKGVycilcbiAgICAgIH1cbiAgICB9KSgpXG4gIH1cblxuICB0cnkge1xuICAgIC8vIHNvY2tldCBpcyBvbmx5IHByb3ZpZGVkIGZvciB3ZWJzb2NrZXRzXG4gICAgY29uc3QgeyBib2R5LCBzdGF0dXMsIHN0YXR1c1RleHQsIGhlYWRlcnNMaXN0LCBzb2NrZXQgfSA9IGF3YWl0IGRpc3BhdGNoKHsgYm9keTogcmVxdWVzdEJvZHkgfSlcblxuICAgIGlmIChzb2NrZXQpIHtcbiAgICAgIHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHsgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCwgc29ja2V0IH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGl0ZXJhdG9yID0gYm9keVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKVxuICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5uZXh0ID0gKCkgPT4gaXRlcmF0b3IubmV4dCgpXG5cbiAgICAgIHJlc3BvbnNlID0gbWFrZVJlc3BvbnNlKHsgc3RhdHVzLCBzdGF0dXNUZXh0LCBoZWFkZXJzTGlzdCB9KVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gMTAuIElmIGFib3J0ZWQsIHRoZW46XG4gICAgaWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgIC8vIDEuIElmIGNvbm5lY3Rpb24gdXNlcyBIVFRQLzIsIHRoZW4gdHJhbnNtaXQgYW4gUlNUX1NUUkVBTSBmcmFtZS5cbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29ubmVjdGlvbi5kZXN0cm95KClcblxuICAgICAgLy8gMi4gUmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuZXR3b3JrIGVycm9yIGZvciBmZXRjaFBhcmFtcy5cbiAgICAgIHJldHVybiBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IoZmV0Y2hQYXJhbXMsIGVycilcbiAgICB9XG5cbiAgICByZXR1cm4gbWFrZU5ldHdvcmtFcnJvcihlcnIpXG4gIH1cblxuICAvLyAxMS4gTGV0IHB1bGxBbGdvcml0aG0gYmUgYW4gYWN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgb25nb2luZyBmZXRjaFxuICAvLyBpZiBpdCBpcyBzdXNwZW5kZWQuXG4gIGNvbnN0IHB1bGxBbGdvcml0aG0gPSBhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5yZXN1bWUoKVxuICB9XG5cbiAgLy8gMTIuIExldCBjYW5jZWxBbGdvcml0aG0gYmUgYW4gYWxnb3JpdGhtIHRoYXQgYWJvcnRzIGZldGNoUGFyYW1z4oCZc1xuICAvLyBjb250cm9sbGVyIHdpdGggcmVhc29uLCBnaXZlbiByZWFzb24uXG4gIGNvbnN0IGNhbmNlbEFsZ29yaXRobSA9IChyZWFzb24pID0+IHtcbiAgICAvLyBJZiB0aGUgYWJvcnRlZCBmZXRjaCB3YXMgYWxyZWFkeSB0ZXJtaW5hdGVkLCB0aGVuIHdlIGRvIG5vdFxuICAgIC8vIG5lZWQgdG8gZG8gYW55dGhpbmcuXG4gICAgaWYgKCFpc0NhbmNlbGxlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuYWJvcnQocmVhc29uKVxuICAgIH1cbiAgfVxuXG4gIC8vIDEzLiBMZXQgaGlnaFdhdGVyTWFyayBiZSBhIG5vbi1uZWdhdGl2ZSwgbm9uLU5hTiBudW1iZXIsIGNob3NlbiBieVxuICAvLyB0aGUgdXNlciBhZ2VudC5cbiAgLy8gVE9ET1xuXG4gIC8vIDE0LiBMZXQgc2l6ZUFsZ29yaXRobSBiZSBhbiBhbGdvcml0aG0gdGhhdCBhY2NlcHRzIGEgY2h1bmsgb2JqZWN0XG4gIC8vIGFuZCByZXR1cm5zIGEgbm9uLW5lZ2F0aXZlLCBub24tTmFOLCBub24taW5maW5pdGUgbnVtYmVyLCBjaG9zZW4gYnkgdGhlIHVzZXIgYWdlbnQuXG4gIC8vIFRPRE9cblxuICAvLyAxNS4gTGV0IHN0cmVhbSBiZSBhIG5ldyBSZWFkYWJsZVN0cmVhbS5cbiAgLy8gMTYuIFNldCB1cCBzdHJlYW0gd2l0aCBieXRlIHJlYWRpbmcgc3VwcG9ydCB3aXRoIHB1bGxBbGdvcml0aG0gc2V0IHRvIHB1bGxBbGdvcml0aG0sXG4gIC8vICAgICBjYW5jZWxBbGdvcml0aG0gc2V0IHRvIGNhbmNlbEFsZ29yaXRobS5cbiAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKFxuICAgIHtcbiAgICAgIGFzeW5jIHN0YXJ0IChjb250cm9sbGVyKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlciA9IGNvbnRyb2xsZXJcbiAgICAgIH0sXG4gICAgICBhc3luYyBwdWxsIChjb250cm9sbGVyKSB7XG4gICAgICAgIGF3YWl0IHB1bGxBbGdvcml0aG0oY29udHJvbGxlcilcbiAgICAgIH0sXG4gICAgICBhc3luYyBjYW5jZWwgKHJlYXNvbikge1xuICAgICAgICBhd2FpdCBjYW5jZWxBbGdvcml0aG0ocmVhc29uKVxuICAgICAgfSxcbiAgICAgIHR5cGU6ICdieXRlcydcbiAgICB9XG4gIClcblxuICAvLyAxNy4gUnVuIHRoZXNlIHN0ZXBzLCBidXQgYWJvcnQgd2hlbiB0aGUgb25nb2luZyBmZXRjaCBpcyB0ZXJtaW5hdGVkOlxuXG4gIC8vICAgIDEuIFNldCByZXNwb25zZeKAmXMgYm9keSB0byBhIG5ldyBib2R5IHdob3NlIHN0cmVhbSBpcyBzdHJlYW0uXG4gIHJlc3BvbnNlLmJvZHkgPSB7IHN0cmVhbSwgc291cmNlOiBudWxsLCBsZW5ndGg6IG51bGwgfVxuXG4gIC8vICAgIDIuIElmIHJlc3BvbnNlIGlzIG5vdCBhIG5ldHdvcmsgZXJyb3IgYW5kIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUgaXNcbiAgLy8gICAgbm90IFwibm8tc3RvcmVcIiwgdGhlbiB1cGRhdGUgcmVzcG9uc2UgaW4gaHR0cENhY2hlIGZvciByZXF1ZXN0LlxuICAvLyAgICBUT0RPXG5cbiAgLy8gICAgMy4gSWYgaW5jbHVkZUNyZWRlbnRpYWxzIGlzIHRydWUgYW5kIHRoZSB1c2VyIGFnZW50IGlzIG5vdCBjb25maWd1cmVkXG4gIC8vICAgIHRvIGJsb2NrIGNvb2tpZXMgZm9yIHJlcXVlc3QgKHNlZSBzZWN0aW9uIDcgb2YgW0NPT0tJRVNdKSwgdGhlbiBydW4gdGhlXG4gIC8vICAgIFwic2V0LWNvb2tpZS1zdHJpbmdcIiBwYXJzaW5nIGFsZ29yaXRobSAoc2VlIHNlY3Rpb24gNS4yIG9mIFtDT09LSUVTXSkgb25cbiAgLy8gICAgdGhlIHZhbHVlIG9mIGVhY2ggaGVhZGVyIHdob3NlIG5hbWUgaXMgYSBieXRlLWNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yXG4gIC8vICAgIGBTZXQtQ29va2llYCBpbiByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QsIGlmIGFueSwgYW5kIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJMLlxuICAvLyAgICBUT0RPXG5cbiAgLy8gMTguIElmIGFib3J0ZWQsIHRoZW46XG4gIC8vIFRPRE9cblxuICAvLyAxOS4gUnVuIHRoZXNlIHN0ZXBzIGluIHBhcmFsbGVsOlxuXG4gIC8vICAgIDEuIFJ1biB0aGVzZSBzdGVwcywgYnV0IGFib3J0IHdoZW4gZmV0Y2hQYXJhbXMgaXMgY2FuY2VsZWQ6XG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub25BYm9ydGVkID0gb25BYm9ydGVkXG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub24oJ3Rlcm1pbmF0ZWQnLCBvbkFib3J0ZWQpXG4gIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIucmVzdW1lID0gYXN5bmMgKCkgPT4ge1xuICAgIC8vIDEuIFdoaWxlIHRydWVcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gMS0zLiBTZWUgb25EYXRhLi4uXG5cbiAgICAgIC8vIDQuIFNldCBieXRlcyB0byB0aGUgcmVzdWx0IG9mIGhhbmRsaW5nIGNvbnRlbnQgY29kaW5ncyBnaXZlblxuICAgICAgLy8gY29kaW5ncyBhbmQgYnl0ZXMuXG4gICAgICBsZXQgYnl0ZXNcbiAgICAgIGxldCBpc0ZhaWx1cmVcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIubmV4dCgpXG5cbiAgICAgICAgaWYgKGlzQWJvcnRlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgYnl0ZXMgPSBkb25lID8gdW5kZWZpbmVkIDogdmFsdWVcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZmV0Y2hQYXJhbXMuY29udHJvbGxlci5lbmRlZCAmJiAhdGltaW5nSW5mby5lbmNvZGVkQm9keVNpemUpIHtcbiAgICAgICAgICAvLyB6bGliIGRvZXNuJ3QgbGlrZSBlbXB0eSBzdHJlYW1zLlxuICAgICAgICAgIGJ5dGVzID0gdW5kZWZpbmVkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnl0ZXMgPSBlcnJcblxuICAgICAgICAgIC8vIGVyciBtYXkgYmUgcHJvcGFnYXRlZCBmcm9tIHRoZSByZXN1bHQgb2YgY2FsbGluZyByZWFkYWJsZXN0cmVhbS5jYW5jZWwsXG4gICAgICAgICAgLy8gd2hpY2ggbWlnaHQgbm90IGJlIGFuIGVycm9yLiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMjAwOVxuICAgICAgICAgIGlzRmFpbHVyZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYnl0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyAyLiBPdGhlcndpc2UsIGlmIHRoZSBieXRlcyB0cmFuc21pc3Npb24gZm9yIHJlc3BvbnNl4oCZcyBtZXNzYWdlXG4gICAgICAgIC8vIGJvZHkgaXMgZG9uZSBub3JtYWxseSBhbmQgc3RyZWFtIGlzIHJlYWRhYmxlLCB0aGVuIGNsb3NlXG4gICAgICAgIC8vIHN0cmVhbSwgZmluYWxpemUgcmVzcG9uc2UgZm9yIGZldGNoUGFyYW1zIGFuZCByZXNwb25zZSwgYW5kXG4gICAgICAgIC8vIGFib3J0IHRoZXNlIGluLXBhcmFsbGVsIHN0ZXBzLlxuICAgICAgICByZWFkYWJsZVN0cmVhbUNsb3NlKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlcilcblxuICAgICAgICBmaW5hbGl6ZVJlc3BvbnNlKGZldGNoUGFyYW1zLCByZXNwb25zZSlcblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNS4gSW5jcmVhc2UgdGltaW5nSW5mb+KAmXMgZGVjb2RlZCBib2R5IHNpemUgYnkgYnl0ZXPigJlzIGxlbmd0aC5cbiAgICAgIHRpbWluZ0luZm8uZGVjb2RlZEJvZHlTaXplICs9IGJ5dGVzPy5ieXRlTGVuZ3RoID8/IDBcblxuICAgICAgLy8gNi4gSWYgYnl0ZXMgaXMgZmFpbHVyZSwgdGhlbiB0ZXJtaW5hdGUgZmV0Y2hQYXJhbXPigJlzIGNvbnRyb2xsZXIuXG4gICAgICBpZiAoaXNGYWlsdXJlKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIudGVybWluYXRlKGJ5dGVzKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gNy4gRW5xdWV1ZSBhIFVpbnQ4QXJyYXkgd3JhcHBpbmcgYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyBieXRlc1xuICAgICAgLy8gaW50byBzdHJlYW0uXG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShieXRlcylcbiAgICAgIGlmIChidWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZW5xdWV1ZShidWZmZXIpXG4gICAgICB9XG5cbiAgICAgIC8vIDguIElmIHN0cmVhbSBpcyBlcnJvcmVkLCB0aGVuIHRlcm1pbmF0ZSB0aGUgb25nb2luZyBmZXRjaC5cbiAgICAgIGlmIChpc0Vycm9yZWQoc3RyZWFtKSkge1xuICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyA5LiBJZiBzdHJlYW0gZG9lc27igJl0IG5lZWQgbW9yZSBkYXRhIGFzayB0aGUgdXNlciBhZ2VudCB0byBzdXNwZW5kXG4gICAgICAvLyB0aGUgb25nb2luZyBmZXRjaC5cbiAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPD0gMCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAgICAyLiBJZiBhYm9ydGVkLCB0aGVuOlxuICBmdW5jdGlvbiBvbkFib3J0ZWQgKHJlYXNvbikge1xuICAgIC8vIDIuIElmIGZldGNoUGFyYW1zIGlzIGFib3J0ZWQsIHRoZW46XG4gICAgaWYgKGlzQWJvcnRlZChmZXRjaFBhcmFtcykpIHtcbiAgICAgIC8vIDEuIFNldCByZXNwb25zZeKAmXMgYWJvcnRlZCBmbGFnLlxuICAgICAgcmVzcG9uc2UuYWJvcnRlZCA9IHRydWVcblxuICAgICAgLy8gMi4gSWYgc3RyZWFtIGlzIHJlYWRhYmxlLCB0aGVuIGVycm9yIHN0cmVhbSB3aXRoIHRoZSByZXN1bHQgb2ZcbiAgICAgIC8vICAgIGRlc2VyaWFsaXplIGEgc2VyaWFsaXplZCBhYm9ydCByZWFzb24gZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzXG4gICAgICAvLyAgICBjb250cm9sbGVy4oCZcyBzZXJpYWxpemVkIGFib3J0IHJlYXNvbiBhbmQgYW5cbiAgICAgIC8vICAgIGltcGxlbWVudGF0aW9uLWRlZmluZWQgcmVhbG0uXG4gICAgICBpZiAoaXNSZWFkYWJsZShzdHJlYW0pKSB7XG4gICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcihcbiAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnNlcmlhbGl6ZWRBYm9ydFJlYXNvblxuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDMuIE90aGVyd2lzZSwgaWYgc3RyZWFtIGlzIHJlYWRhYmxlLCBlcnJvciBzdHJlYW0gd2l0aCBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChpc1JlYWRhYmxlKHN0cmVhbSkpIHtcbiAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb250cm9sbGVyLmVycm9yKG5ldyBUeXBlRXJyb3IoJ3Rlcm1pbmF0ZWQnLCB7XG4gICAgICAgICAgY2F1c2U6IGlzRXJyb3JMaWtlKHJlYXNvbikgPyByZWFzb24gOiB1bmRlZmluZWRcbiAgICAgICAgfSkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gNC4gSWYgY29ubmVjdGlvbiB1c2VzIEhUVFAvMiwgdGhlbiB0cmFuc21pdCBhbiBSU1RfU1RSRUFNIGZyYW1lLlxuICAgIC8vIDUuIE90aGVyd2lzZSwgdGhlIHVzZXIgYWdlbnQgc2hvdWxkIGNsb3NlIGNvbm5lY3Rpb24gdW5sZXNzIGl0IHdvdWxkIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgdG8gZG8gc28uXG4gICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5jb25uZWN0aW9uLmRlc3Ryb3koKVxuICB9XG5cbiAgLy8gMjAuIFJldHVybiByZXNwb25zZS5cbiAgcmV0dXJuIHJlc3BvbnNlXG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2ggKHsgYm9keSB9KSB7XG4gICAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcbiAgICAvKiogQHR5cGUge2ltcG9ydCgnLi4vLi4nKS5BZ2VudH0gKi9cbiAgICBjb25zdCBhZ2VudCA9IGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZGlzcGF0Y2hlclxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IGFnZW50LmRpc3BhdGNoKFxuICAgICAge1xuICAgICAgICBwYXRoOiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoLFxuICAgICAgICBvcmlnaW46IHVybC5vcmlnaW4sXG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIGJvZHk6IGFnZW50LmlzTW9ja0FjdGl2ZSA/IHJlcXVlc3QuYm9keSAmJiAocmVxdWVzdC5ib2R5LnNvdXJjZSB8fCByZXF1ZXN0LmJvZHkuc3RyZWFtKSA6IGJvZHksXG4gICAgICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVyc0xpc3QuZW50cmllcyxcbiAgICAgICAgbWF4UmVkaXJlY3Rpb25zOiAwLFxuICAgICAgICB1cGdyYWRlOiByZXF1ZXN0Lm1vZGUgPT09ICd3ZWJzb2NrZXQnID8gJ3dlYnNvY2tldCcgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJvZHk6IG51bGwsXG4gICAgICAgIGFib3J0OiBudWxsLFxuXG4gICAgICAgIG9uQ29ubmVjdCAoYWJvcnQpIHtcbiAgICAgICAgICAvLyBUT0RPIChmaXgpOiBEbyB3ZSBuZWVkIGNvbm5lY3Rpb24gaGVyZT9cbiAgICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb24gfSA9IGZldGNoUGFyYW1zLmNvbnRyb2xsZXJcblxuICAgICAgICAgIC8vIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBjb25uZWN0aW9uIHRpbWluZyBpbmZvIHRvIHRoZSByZXN1bHQgb2YgY2FsbGluZyBjbGFtcCBhbmQgY29hcnNlblxuICAgICAgICAgIC8vIGNvbm5lY3Rpb24gdGltaW5nIGluZm8gd2l0aCBjb25uZWN0aW9u4oCZcyB0aW1pbmcgaW5mbywgdGltaW5nSW5mb+KAmXMgcG9zdC1yZWRpcmVjdCBzdGFydFxuICAgICAgICAgIC8vIHRpbWUsIGFuZCBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHkuXG4gICAgICAgICAgLy8gVE9ETzogaW1wbGVtZW50IGNvbm5lY3Rpb24gdGltaW5nXG4gICAgICAgICAgdGltaW5nSW5mby5maW5hbENvbm5lY3Rpb25UaW1pbmdJbmZvID0gY2xhbXBBbmRDb2Fyc2VuQ29ubmVjdGlvblRpbWluZ0luZm8odW5kZWZpbmVkLCB0aW1pbmdJbmZvLnBvc3RSZWRpcmVjdFN0YXJ0VGltZSwgZmV0Y2hQYXJhbXMuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG5cbiAgICAgICAgICBpZiAoY29ubmVjdGlvbi5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIGFib3J0KG5ldyBET01FeGNlcHRpb24oJ1RoZSBvcGVyYXRpb24gd2FzIGFib3J0ZWQuJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmV0Y2hQYXJhbXMuY29udHJvbGxlci5vbigndGVybWluYXRlZCcsIGFib3J0KVxuICAgICAgICAgICAgdGhpcy5hYm9ydCA9IGNvbm5lY3Rpb24uYWJvcnQgPSBhYm9ydFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlcXVlc3Qgc3RhcnQgdGltZSB0byB0aGUgY29hcnNlbmVkIHNoYXJlZCBjdXJyZW50IHRpbWUgZ2l2ZW5cbiAgICAgICAgICAvLyBmZXRjaFBhcmFtc+KAmXMgY3Jvc3Mtb3JpZ2luIGlzb2xhdGVkIGNhcGFiaWxpdHkuXG4gICAgICAgICAgdGltaW5nSW5mby5maW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoZmV0Y2hQYXJhbXMuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25SZXNwb25zZVN0YXJ0ZWQgKCkge1xuICAgICAgICAgIC8vIFNldCB0aW1pbmdJbmZv4oCZcyBmaW5hbCBuZXR3b3JrLXJlc3BvbnNlIHN0YXJ0IHRpbWUgdG8gdGhlIGNvYXJzZW5lZCBzaGFyZWQgY3VycmVudFxuICAgICAgICAgIC8vIHRpbWUgZ2l2ZW4gZmV0Y2hQYXJhbXPigJlzIGNyb3NzLW9yaWdpbiBpc29sYXRlZCBjYXBhYmlsaXR5LCBpbW1lZGlhdGVseSBhZnRlciB0aGVcbiAgICAgICAgICAvLyB1c2VyIGFnZW504oCZcyBIVFRQIHBhcnNlciByZWNlaXZlcyB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgcmVzcG9uc2UgKGUuZy4sIGZyYW1lIGhlYWRlclxuICAgICAgICAgIC8vIGJ5dGVzIGZvciBIVFRQLzIgb3IgcmVzcG9uc2Ugc3RhdHVzIGxpbmUgZm9yIEhUVFAvMS54KS5cbiAgICAgICAgICB0aW1pbmdJbmZvLmZpbmFsTmV0d29ya1Jlc3BvbnNlU3RhcnRUaW1lID0gY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUoZmV0Y2hQYXJhbXMuY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25IZWFkZXJzIChzdGF0dXMsIHJhd0hlYWRlcnMsIHJlc3VtZSwgc3RhdHVzVGV4dCkge1xuICAgICAgICAgIGlmIChzdGF0dXMgPCAyMDApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8qKiBAdHlwZSB7c3RyaW5nW119ICovXG4gICAgICAgICAgbGV0IGNvZGluZ3MgPSBbXVxuICAgICAgICAgIGxldCBsb2NhdGlvbiA9ICcnXG5cbiAgICAgICAgICBjb25zdCBoZWFkZXJzTGlzdCA9IG5ldyBIZWFkZXJzTGlzdCgpXG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0hlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNMaXN0LmFwcGVuZChidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lKHJhd0hlYWRlcnNbaV0pLCByYXdIZWFkZXJzW2kgKyAxXS50b1N0cmluZygnbGF0aW4xJyksIHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IGhlYWRlcnNMaXN0LmdldCgnY29udGVudC1lbmNvZGluZycsIHRydWUpXG4gICAgICAgICAgaWYgKGNvbnRlbnRFbmNvZGluZykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzcyMzEjc2VjdGlvbi0zLjEuMi4xXG4gICAgICAgICAgICAvLyBcIkFsbCBjb250ZW50LWNvZGluZyB2YWx1ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUuLi5cIlxuICAgICAgICAgICAgY29kaW5ncyA9IGNvbnRlbnRFbmNvZGluZy50b0xvd2VyQ2FzZSgpLnNwbGl0KCcsJykubWFwKCh4KSA9PiB4LnRyaW0oKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9jYXRpb24gPSBoZWFkZXJzTGlzdC5nZXQoJ2xvY2F0aW9uJywgdHJ1ZSlcblxuICAgICAgICAgIHRoaXMuYm9keSA9IG5ldyBSZWFkYWJsZSh7IHJlYWQ6IHJlc3VtZSB9KVxuXG4gICAgICAgICAgY29uc3QgZGVjb2RlcnMgPSBbXVxuXG4gICAgICAgICAgY29uc3Qgd2lsbEZvbGxvdyA9IGxvY2F0aW9uICYmIHJlcXVlc3QucmVkaXJlY3QgPT09ICdmb2xsb3cnICYmXG4gICAgICAgICAgICByZWRpcmVjdFN0YXR1c1NldC5oYXMoc3RhdHVzKVxuXG4gICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtRW5jb2RpbmdcbiAgICAgICAgICBpZiAoY29kaW5ncy5sZW5ndGggIT09IDAgJiYgcmVxdWVzdC5tZXRob2QgIT09ICdIRUFEJyAmJiByZXF1ZXN0Lm1ldGhvZCAhPT0gJ0NPTk5FQ1QnICYmICFudWxsQm9keVN0YXR1cy5pbmNsdWRlcyhzdGF0dXMpICYmICF3aWxsRm9sbG93KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY29kaW5ncy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICBjb25zdCBjb2RpbmcgPSBjb2RpbmdzW2ldXG4gICAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MTEyLmh0bWwjc2VjdGlvbi03LjJcbiAgICAgICAgICAgICAgaWYgKGNvZGluZyA9PT0gJ3gtZ3ppcCcgfHwgY29kaW5nID09PSAnZ3ppcCcpIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5wdXNoKHpsaWIuY3JlYXRlR3VuemlwKHtcbiAgICAgICAgICAgICAgICAgIC8vIEJlIGxlc3Mgc3RyaWN0IHdoZW4gZGVjb2RpbmcgY29tcHJlc3NlZCByZXNwb25zZXMsIHNpbmNlIHNvbWV0aW1lc1xuICAgICAgICAgICAgICAgICAgLy8gc2VydmVycyBzZW5kIHNsaWdodGx5IGludmFsaWQgcmVzcG9uc2VzIHRoYXQgYXJlIHN0aWxsIGFjY2VwdGVkXG4gICAgICAgICAgICAgICAgICAvLyBieSBjb21tb24gYnJvd3NlcnMuXG4gICAgICAgICAgICAgICAgICAvLyBBbHdheXMgdXNpbmcgWl9TWU5DX0ZMVVNIIGlzIHdoYXQgY1VSTCBkb2VzLlxuICAgICAgICAgICAgICAgICAgZmx1c2g6IHpsaWIuY29uc3RhbnRzLlpfU1lOQ19GTFVTSCxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaEZsdXNoOiB6bGliLmNvbnN0YW50cy5aX1NZTkNfRkxVU0hcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb2RpbmcgPT09ICdkZWZsYXRlJykge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goY3JlYXRlSW5mbGF0ZSh7XG4gICAgICAgICAgICAgICAgICBmbHVzaDogemxpYi5jb25zdGFudHMuWl9TWU5DX0ZMVVNILFxuICAgICAgICAgICAgICAgICAgZmluaXNoRmx1c2g6IHpsaWIuY29uc3RhbnRzLlpfU1lOQ19GTFVTSFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNvZGluZyA9PT0gJ2JyJykge1xuICAgICAgICAgICAgICAgIGRlY29kZXJzLnB1c2goemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKHtcbiAgICAgICAgICAgICAgICAgIGZsdXNoOiB6bGliLmNvbnN0YW50cy5CUk9UTElfT1BFUkFUSU9OX0ZMVVNILFxuICAgICAgICAgICAgICAgICAgZmluaXNoRmx1c2g6IHpsaWIuY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRkxVU0hcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWNvZGVycy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IG9uRXJyb3IgPSB0aGlzLm9uRXJyb3IuYmluZCh0aGlzKVxuXG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyc0xpc3QsXG4gICAgICAgICAgICBib2R5OiBkZWNvZGVycy5sZW5ndGhcbiAgICAgICAgICAgICAgPyBwaXBlbGluZSh0aGlzLmJvZHksIC4uLmRlY29kZXJzLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKGVycilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLm9uKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgICAgICAgICAgIDogdGhpcy5ib2R5Lm9uKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EYXRhIChjaHVuaykge1xuICAgICAgICAgIGlmIChmZXRjaFBhcmFtcy5jb250cm9sbGVyLmR1bXApIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIDEuIElmIG9uZSBvciBtb3JlIGJ5dGVzIGhhdmUgYmVlbiB0cmFuc21pdHRlZCBmcm9tIHJlc3BvbnNl4oCZc1xuICAgICAgICAgIC8vIG1lc3NhZ2UgYm9keSwgdGhlbjpcblxuICAgICAgICAgIC8vICAxLiBMZXQgYnl0ZXMgYmUgdGhlIHRyYW5zbWl0dGVkIGJ5dGVzLlxuICAgICAgICAgIGNvbnN0IGJ5dGVzID0gY2h1bmtcblxuICAgICAgICAgIC8vICAyLiBMZXQgY29kaW5ncyBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzXG4gICAgICAgICAgLy8gIGdpdmVuIGBDb250ZW50LUVuY29kaW5nYCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICAgICAgICAgIC8vICBTZWUgcHVsbEFsZ29yaXRobS5cblxuICAgICAgICAgIC8vICAzLiBJbmNyZWFzZSB0aW1pbmdJbmZv4oCZcyBlbmNvZGVkIGJvZHkgc2l6ZSBieSBieXRlc+KAmXMgbGVuZ3RoLlxuICAgICAgICAgIHRpbWluZ0luZm8uZW5jb2RlZEJvZHlTaXplICs9IGJ5dGVzLmJ5dGVMZW5ndGhcblxuICAgICAgICAgIC8vICA0LiBTZWUgcHVsbEFsZ29yaXRobS4uLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5wdXNoKGJ5dGVzKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ29tcGxldGUgKCkge1xuICAgICAgICAgIGlmICh0aGlzLmFib3J0KSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZigndGVybWluYXRlZCcsIHRoaXMuYWJvcnQpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub25BYm9ydGVkKSB7XG4gICAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLm9mZigndGVybWluYXRlZCcsIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub25BYm9ydGVkKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIuZW5kZWQgPSB0cnVlXG5cbiAgICAgICAgICB0aGlzLmJvZHkucHVzaChudWxsKVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uRXJyb3IgKGVycm9yKSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWJvcnQpIHtcbiAgICAgICAgICAgIGZldGNoUGFyYW1zLmNvbnRyb2xsZXIub2ZmKCd0ZXJtaW5hdGVkJywgdGhpcy5hYm9ydClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmJvZHk/LmRlc3Ryb3koZXJyb3IpXG5cbiAgICAgICAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnRlcm1pbmF0ZShlcnJvcilcblxuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfSxcblxuICAgICAgICBvblVwZ3JhZGUgKHN0YXR1cywgcmF3SGVhZGVycywgc29ja2V0KSB7XG4gICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMTAxKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBoZWFkZXJzTGlzdCA9IG5ldyBIZWFkZXJzTGlzdCgpXG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhd0hlYWRlcnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNMaXN0LmFwcGVuZChidWZmZXJUb0xvd2VyQ2FzZWRIZWFkZXJOYW1lKHJhd0hlYWRlcnNbaV0pLCByYXdIZWFkZXJzW2kgKyAxXS50b1N0cmluZygnbGF0aW4xJyksIHRydWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiBTVEFUVVNfQ09ERVNbc3RhdHVzXSxcbiAgICAgICAgICAgIGhlYWRlcnNMaXN0LFxuICAgICAgICAgICAgc29ja2V0XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBmZXRjaCxcbiAgRmV0Y2gsXG4gIGZldGNoaW5nLFxuICBmaW5hbGl6ZUFuZFJlcG9ydFRpbWluZ1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/request.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/request.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* globals AbortController */\n\n\n\nconst { extractBody, mixinBody, cloneBody, bodyUnusable } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\")\nconst { Headers, fill: fillHeaders, HeadersList, setHeadersGuard, getHeadersGuard, setHeadersList, getHeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { FinalizationRegistry } = __webpack_require__(/*! ./dispatcher-weakref */ \"(rsc)/./node_modules/undici/lib/web/fetch/dispatcher-weakref.js\")()\nconst util = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\nconst {\n  isValidHTTPToken,\n  sameOrigin,\n  environmentSettingsObject\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst {\n  forbiddenMethodsSet,\n  corsSafeListedMethodsSet,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  requestDuplex\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { kEnumerableProperty, normalizedMethodRecordsBase, normalizedMethodRecords } = util\nconst { kHeaders, kSignal, kState, kDispatcher } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __webpack_require__(/*! node:events */ \"node:events\")\n\nconst kAbortController = Symbol('abortController')\n\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n  signal.removeEventListener('abort', abort)\n})\n\nconst dependentControllerMap = new WeakMap()\n\nfunction buildAbort (acRef) {\n  return abort\n\n  function abort () {\n    const ac = acRef.deref()\n    if (ac !== undefined) {\n      // Currently, there is a problem with FinalizationRegistry.\n      // https://github.com/nodejs/node/issues/49344\n      // https://github.com/nodejs/node/issues/47748\n      // In the case of abort, the first step is to unregister from it.\n      // If the controller can refer to it, it is still registered.\n      // It will be removed in the future.\n      requestFinalizer.unregister(abort)\n\n      // Unsubscribe a listener.\n      // FinalizationRegistry will no longer be called, so this must be done.\n      this.removeEventListener('abort', abort)\n\n      ac.abort(this.reason)\n\n      const controllerList = dependentControllerMap.get(ac.signal)\n\n      if (controllerList !== undefined) {\n        if (controllerList.size !== 0) {\n          for (const ref of controllerList) {\n            const ctrl = ref.deref()\n            if (ctrl !== undefined) {\n              ctrl.abort(this.reason)\n            }\n          }\n          controllerList.clear()\n        }\n        dependentControllerMap.delete(ac.signal)\n      }\n    }\n  }\n}\n\nlet patchMethodWarning = false\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (input, init = {}) {\n    webidl.util.markAsUncloneable(this)\n    if (input === kConstruct) {\n      return\n    }\n\n    const prefix = 'Request constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    input = webidl.converters.RequestInfo(input, prefix, 'input')\n    init = webidl.converters.RequestInit(init, prefix, 'init')\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be this’s relevant settings object’s API base URL.\n    const baseUrl = environmentSettingsObject.settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      this[kDispatcher] = init.dispatcher\n\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        throw new TypeError('Failed to parse URL from ' + input, { cause: err })\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      this[kDispatcher] = init.dispatcher || input[kDispatcher]\n\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(input instanceof Request)\n\n      // 8. Set request to input’s request.\n      request = input[kState]\n\n      // 9. Set signal to input’s signal.\n      signal = input[kSignal]\n    }\n\n    // 7. Let origin be this’s relevant settings object’s origin.\n    const origin = environmentSettingsObject.settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If request’s window is an environment settings object and its origin\n    // is same origin with origin, then set window to request’s window.\n    if (\n      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&\n      sameOrigin(request.window, origin)\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if (init.window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if ('window' in init) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      // URL request’s URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method request’s method.\n      method: request.method,\n      // header list A copy of request’s header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set.\n      unsafeRequest: request.unsafeRequest,\n      // client This’s relevant settings object.\n      client: environmentSettingsObject.settingsObject,\n      // window window.\n      window,\n      // priority request’s priority.\n      priority: request.priority,\n      // origin request’s origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different\n      // from the current client.\n      origin: request.origin,\n      // referrer request’s referrer.\n      referrer: request.referrer,\n      // referrer policy request’s referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode request’s mode.\n      mode: request.mode,\n      // credentials mode request’s credentials mode.\n      credentials: request.credentials,\n      // cache mode request’s cache mode.\n      cache: request.cache,\n      // redirect mode request’s redirect mode.\n      redirect: request.redirect,\n      // integrity metadata request’s integrity metadata.\n      integrity: request.integrity,\n      // keepalive request’s keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag request’s reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag request’s history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of request’s URL list.\n      urlList: [...request.urlList]\n    })\n\n    const initHasKey = Object.keys(init).length !== 0\n\n    // 13. If init is not empty, then:\n    if (initHasKey) {\n      // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset request’s reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset request’s history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set request’s origin to \"client\".\n      request.origin = 'client'\n\n      // 5. Set request’s referrer to \"client\"\n      request.referrer = 'client'\n\n      // 6. Set request’s referrer policy to the empty string.\n      request.referrerPolicy = ''\n\n      // 7. Set request’s URL to request’s current URL.\n      request.url = request.urlList[request.urlList.length - 1]\n\n      // 8. Set request’s URL list to « request’s URL ».\n      request.urlList = [request.url]\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if (init.referrer !== undefined) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n      if (referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          throw new TypeError(`Referrer \"${referrer}\" is not a valid URL.`, { cause: err })\n        }\n\n        // 3. If one of the following is true\n        // - parsedReferrer’s scheme is \"about\" and path is the string \"client\"\n        // - parsedReferrer’s origin is not same origin with origin\n        // then set request’s referrer to \"client\".\n        if (\n          (parsedReferrer.protocol === 'about:' && parsedReferrer.hostname === 'client') ||\n          (origin && !sameOrigin(parsedReferrer, environmentSettingsObject.settingsObject.baseUrl))\n        ) {\n          request.referrer = 'client'\n        } else {\n          // 4. Otherwise, set request’s referrer to parsedReferrer.\n          request.referrer = parsedReferrer\n        }\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n    // to it.\n    if (init.referrerPolicy !== undefined) {\n      request.referrerPolicy = init.referrerPolicy\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if (init.mode !== undefined) {\n      mode = init.mode\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw webidl.errors.exception({\n        header: 'Request constructor',\n        message: 'invalid request mode navigate.'\n      })\n    }\n\n    // 18. If mode is non-null, set request’s mode to mode.\n    if (mode != null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n    // to it.\n    if (init.credentials !== undefined) {\n      request.credentials = init.credentials\n    }\n\n    // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n    if (init.cache !== undefined) {\n      request.cache = init.cache\n    }\n\n    // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n    if (init.redirect !== undefined) {\n      request.redirect = init.redirect\n    }\n\n    // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n    if (init.integrity != null) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n    if (init.keepalive !== undefined) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if (init.method !== undefined) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      const mayBeNormalized = normalizedMethodRecords[method]\n\n      if (mayBeNormalized !== undefined) {\n        // Note: Bypass validation DELETE, GET, HEAD, OPTIONS, POST, PUT, PATCH and these lowercase ones\n        request.method = mayBeNormalized\n      } else {\n        // 2. If method is not a method or method is a forbidden method, then\n        // throw a TypeError.\n        if (!isValidHTTPToken(method)) {\n          throw new TypeError(`'${method}' is not a valid HTTP method.`)\n        }\n\n        const upperCase = method.toUpperCase()\n\n        if (forbiddenMethodsSet.has(upperCase)) {\n          throw new TypeError(`'${method}' HTTP method is unsupported.`)\n        }\n\n        // 3. Normalize method.\n        // https://fetch.spec.whatwg.org/#concept-method-normalize\n        // Note: must be in uppercase\n        method = normalizedMethodRecordsBase[upperCase] ?? method\n\n        // 4. Set request’s method to method.\n        request.method = method\n      }\n\n      if (!patchMethodWarning && request.method === 'patch') {\n        process.emitWarning('Using `patch` is highly likely to result in a `405 Method Not Allowed`. `PATCH` is much more likely to succeed.', {\n          code: 'UNDICI-FETCH-patch'\n        })\n\n        patchMethodWarning = true\n      }\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if (init.signal !== undefined) {\n      signal = init.signal\n    }\n\n    // 27. Set this’s request to request.\n    this[kState] = request\n\n    // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n    // Realm.\n    // TODO: could this be simplified with AbortSignal.any\n    // (https://dom.spec.whatwg.org/#dom-abortsignal-any)\n    const ac = new AbortController()\n    this[kSignal] = ac.signal\n\n    // 29. If signal is not null, then make this’s signal follow signal.\n    if (signal != null) {\n      if (\n        !signal ||\n        typeof signal.aborted !== 'boolean' ||\n        typeof signal.addEventListener !== 'function'\n      ) {\n        throw new TypeError(\n          \"Failed to construct 'Request': member signal is not of type AbortSignal.\"\n        )\n      }\n\n      if (signal.aborted) {\n        ac.abort(signal.reason)\n      } else {\n        // Keep a strong ref to ac while request object\n        // is alive. This is needed to prevent AbortController\n        // from being prematurely garbage collected.\n        // See, https://github.com/nodejs/undici/issues/1926.\n        this[kAbortController] = ac\n\n        const acRef = new WeakRef(ac)\n        const abort = buildAbort(acRef)\n\n        // Third-party AbortControllers may not work with these.\n        // See, https://github.com/nodejs/undici/pull/1910#issuecomment-1464495619.\n        try {\n          // If the max amount of listeners is equal to the default, increase it\n          // This is only available in node >= v19.9.0\n          if (typeof getMaxListeners === 'function' && getMaxListeners(signal) === defaultMaxListeners) {\n            setMaxListeners(1500, signal)\n          } else if (getEventListeners(signal, 'abort').length >= defaultMaxListeners) {\n            setMaxListeners(1500, signal)\n          }\n        } catch {}\n\n        util.addAbortListener(signal, abort)\n        // The third argument must be a registry key to be unregistered.\n        // Without it, you cannot unregister.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n        // abort is used as the unregister key. (because it is unique)\n        requestFinalizer.register(ac, { signal, abort }, abort)\n      }\n    }\n\n    // 30. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is request’s header list and guard is\n    // \"request\".\n    this[kHeaders] = new Headers(kConstruct)\n    setHeadersList(this[kHeaders], request.headersList)\n    setHeadersGuard(this[kHeaders], 'request')\n\n    // 31. If this’s request’s mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If this’s request’s method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethodsSet.has(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set this’s headers’s guard to \"request-no-cors\".\n      setHeadersGuard(this[kHeaders], 'request-no-cors')\n    }\n\n    // 32. If init is not empty, then:\n    if (initHasKey) {\n      /** @type {HeadersList} */\n      const headersList = getHeadersList(this[kHeaders])\n      // 1. Let headers be a copy of this’s headers and its associated header\n      // list.\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      const headers = init.headers !== undefined ? init.headers : new HeadersList(headersList)\n\n      // 3. Empty this’s headers’s header list.\n      headersList.clear()\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append header’s name/header’s value to this’s headers.\n      if (headers instanceof HeadersList) {\n        for (const { name, value } of headers.rawValues()) {\n          headersList.append(name, value, false)\n        }\n        // Note: Copy the `set-cookie` meta-data.\n        headersList.cookies = headers.cookies\n      } else {\n        // 5. Otherwise, fill this’s headers with headers.\n        fillHeaders(this[kHeaders], headers)\n      }\n    }\n\n    // 33. Let inputBody be input’s request’s body if input is a Request\n    // object; otherwise null.\n    const inputBody = input instanceof Request ? input[kState].body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and request’s method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      (init.body != null || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if (init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to request’s keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and this’s headers’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // this’s headers.\n      if (contentType && !getHeadersList(this[kHeaders]).contains('content-type', true)) {\n        this[kHeaders].append('content-type', contentType)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If initBody is non-null and init[\"duplex\"] does not exist,\n      //    then throw a TypeError.\n      if (initBody != null && init.duplex == null) {\n        throw new TypeError('RequestInit: duplex option is required when sending a body.')\n      }\n\n      // 2. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 3. Set this’s request’s use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (bodyUnusable(input)) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set this’s request’s body to finalBody.\n    this[kState].body = finalBody\n  }\n\n  // Returns request’s HTTP method, which is \"GET\" by default.\n  get method () {\n    webidl.brandCheck(this, Request)\n\n    // The method getter steps are to return this’s request’s method.\n    return this[kState].method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    webidl.brandCheck(this, Request)\n\n    // The url getter steps are to return this’s request’s URL, serialized.\n    return URLSerializer(this[kState].url)\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    webidl.brandCheck(this, Request)\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    webidl.brandCheck(this, Request)\n\n    // The destination getter are to return this’s request’s destination.\n    return this[kState].destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the global’s default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this’s request’s referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this[kState].referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If this’s request’s referrer is \"client\", then return\n    // \"about:client\".\n    if (this[kState].referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return this’s request’s referrer, serialized.\n    return this[kState].referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the request’s\n  // referrer.\n  get referrerPolicy () {\n    webidl.brandCheck(this, Request)\n\n    // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n    return this[kState].referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    webidl.brandCheck(this, Request)\n\n    // The mode getter steps are to return this’s request’s mode.\n    return this[kState].mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    // The credentials getter steps are to return this’s request’s credentials mode.\n    return this[kState].credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browser’s cache when fetching.\n  get cache () {\n    webidl.brandCheck(this, Request)\n\n    // The cache getter steps are to return this’s request’s cache mode.\n    return this[kState].cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    webidl.brandCheck(this, Request)\n\n    // The redirect getter steps are to return this’s request’s redirect mode.\n    return this[kState].redirect\n  }\n\n  // Returns request’s subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    webidl.brandCheck(this, Request)\n\n    // The integrity getter steps are to return this’s request’s integrity\n    // metadata.\n    return this[kState].integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    webidl.brandCheck(this, Request)\n\n    // The keepalive getter steps are to return this’s request’s keepalive.\n    return this[kState].keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isReloadNavigation getter steps are to return true if this’s\n    // request’s reload-navigation flag is set; otherwise false.\n    return this[kState].reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-forward navigation).\n  get isHistoryNavigation () {\n    webidl.brandCheck(this, Request)\n\n    // The isHistoryNavigation getter steps are to return true if this’s request’s\n    // history-navigation flag is set; otherwise false.\n    return this[kState].historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    webidl.brandCheck(this, Request)\n\n    // The signal getter steps are to return this’s signal.\n    return this[kSignal]\n  }\n\n  get body () {\n    webidl.brandCheck(this, Request)\n\n    return this[kState].body ? this[kState].body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Request)\n\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n  }\n\n  get duplex () {\n    webidl.brandCheck(this, Request)\n\n    return 'half'\n  }\n\n  // Returns a clone of request.\n  clone () {\n    webidl.brandCheck(this, Request)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (bodyUnusable(this)) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning this’s request.\n    const clonedRequest = cloneRequest(this[kState])\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n    // 4. Make clonedRequestObject’s signal follow this’s signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort(this.signal.reason)\n    } else {\n      let list = dependentControllerMap.get(this.signal)\n      if (list === undefined) {\n        list = new Set()\n        dependentControllerMap.set(this.signal, list)\n      }\n      const acRef = new WeakRef(ac)\n      list.add(acRef)\n      util.addAbortListener(\n        ac.signal,\n        buildAbort(acRef)\n      )\n    }\n\n    // 4. Return clonedRequestObject.\n    return fromInnerRequest(clonedRequest, ac.signal, getHeadersGuard(this[kHeaders]))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      method: this.method,\n      url: this.url,\n      headers: this.headers,\n      destination: this.destination,\n      referrer: this.referrer,\n      referrerPolicy: this.referrerPolicy,\n      mode: this.mode,\n      credentials: this.credentials,\n      cache: this.cache,\n      redirect: this.redirect,\n      integrity: this.integrity,\n      keepalive: this.keepalive,\n      isReloadNavigation: this.isReloadNavigation,\n      isHistoryNavigation: this.isHistoryNavigation,\n      signal: this.signal\n    }\n\n    return `Request ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n}\n\nmixinBody(Request)\n\n// https://fetch.spec.whatwg.org/#requests\nfunction makeRequest (init) {\n  return {\n    method: init.method ?? 'GET',\n    localURLsOnly: init.localURLsOnly ?? false,\n    unsafeRequest: init.unsafeRequest ?? false,\n    body: init.body ?? null,\n    client: init.client ?? null,\n    reservedClient: init.reservedClient ?? null,\n    replacesClientId: init.replacesClientId ?? '',\n    window: init.window ?? 'client',\n    keepalive: init.keepalive ?? false,\n    serviceWorkers: init.serviceWorkers ?? 'all',\n    initiator: init.initiator ?? '',\n    destination: init.destination ?? '',\n    priority: init.priority ?? null,\n    origin: init.origin ?? 'client',\n    policyContainer: init.policyContainer ?? 'client',\n    referrer: init.referrer ?? 'client',\n    referrerPolicy: init.referrerPolicy ?? '',\n    mode: init.mode ?? 'no-cors',\n    useCORSPreflightFlag: init.useCORSPreflightFlag ?? false,\n    credentials: init.credentials ?? 'same-origin',\n    useCredentials: init.useCredentials ?? false,\n    cache: init.cache ?? 'default',\n    redirect: init.redirect ?? 'follow',\n    integrity: init.integrity ?? '',\n    cryptoGraphicsNonceMetadata: init.cryptoGraphicsNonceMetadata ?? '',\n    parserMetadata: init.parserMetadata ?? '',\n    reloadNavigation: init.reloadNavigation ?? false,\n    historyNavigation: init.historyNavigation ?? false,\n    userActivation: init.userActivation ?? false,\n    taintedOrigin: init.taintedOrigin ?? false,\n    redirectCount: init.redirectCount ?? 0,\n    responseTainting: init.responseTainting ?? 'basic',\n    preventNoCacheCacheControlHeaderModification: init.preventNoCacheCacheControlHeaderModification ?? false,\n    done: init.done ?? false,\n    timingAllowFailed: init.timingAllowFailed ?? false,\n    urlList: init.urlList,\n    url: init.urlList[0],\n    headersList: init.headersList\n      ? new HeadersList(init.headersList)\n      : new HeadersList()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If request’s body is non-null, set newRequest’s body to the\n  // result of cloning request’s body.\n  if (request.body != null) {\n    newRequest.body = cloneBody(newRequest, request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#request-create\n * @param {any} innerRequest\n * @param {AbortSignal} signal\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Request}\n */\nfunction fromInnerRequest (innerRequest, signal, guard) {\n  const request = new Request(kConstruct)\n  request[kState] = innerRequest\n  request[kSignal] = signal\n  request[kHeaders] = new Headers(kConstruct)\n  setHeadersList(request[kHeaders], innerRequest.headersList)\n  setHeadersGuard(request[kHeaders], guard)\n  return request\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty,\n  duplex: kEnumerableProperty,\n  destination: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  isHistoryNavigation: kEnumerableProperty,\n  isReloadNavigation: kEnumerableProperty,\n  keepalive: kEnumerableProperty,\n  integrity: kEnumerableProperty,\n  cache: kEnumerableProperty,\n  credentials: kEnumerableProperty,\n  attribute: kEnumerableProperty,\n  referrerPolicy: kEnumerableProperty,\n  referrer: kEnumerableProperty,\n  mode: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Request',\n    configurable: true\n  }\n})\n\nwebidl.converters.Request = webidl.interfaceConverter(\n  Request\n)\n\n// https://fetch.spec.whatwg.org/#requestinfo\nwebidl.converters.RequestInfo = function (V, prefix, argument) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V, prefix, argument)\n  }\n\n  if (V instanceof Request) {\n    return webidl.converters.Request(V, prefix, argument)\n  }\n\n  return webidl.converters.USVString(V, prefix, argument)\n}\n\nwebidl.converters.AbortSignal = webidl.interfaceConverter(\n  AbortSignal\n)\n\n// https://fetch.spec.whatwg.org/#requestinit\nwebidl.converters.RequestInit = webidl.dictionaryConverter([\n  {\n    key: 'method',\n    converter: webidl.converters.ByteString\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  },\n  {\n    key: 'body',\n    converter: webidl.nullableConverter(\n      webidl.converters.BodyInit\n    )\n  },\n  {\n    key: 'referrer',\n    converter: webidl.converters.USVString\n  },\n  {\n    key: 'referrerPolicy',\n    converter: webidl.converters.DOMString,\n    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy\n    allowedValues: referrerPolicy\n  },\n  {\n    key: 'mode',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#concept-request-mode\n    allowedValues: requestMode\n  },\n  {\n    key: 'credentials',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcredentials\n    allowedValues: requestCredentials\n  },\n  {\n    key: 'cache',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestcache\n    allowedValues: requestCache\n  },\n  {\n    key: 'redirect',\n    converter: webidl.converters.DOMString,\n    // https://fetch.spec.whatwg.org/#requestredirect\n    allowedValues: requestRedirect\n  },\n  {\n    key: 'integrity',\n    converter: webidl.converters.DOMString\n  },\n  {\n    key: 'keepalive',\n    converter: webidl.converters.boolean\n  },\n  {\n    key: 'signal',\n    converter: webidl.nullableConverter(\n      (signal) => webidl.converters.AbortSignal(\n        signal,\n        'RequestInit',\n        'signal',\n        { strict: false }\n      )\n    )\n  },\n  {\n    key: 'window',\n    converter: webidl.converters.any\n  },\n  {\n    key: 'duplex',\n    converter: webidl.converters.DOMString,\n    allowedValues: requestDuplex\n  },\n  {\n    key: 'dispatcher', // undici specific option\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = { Request, makeRequest, fromInnerRequest, cloneRequest }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFWTs7QUFFWixRQUFRLGtEQUFrRCxFQUFFLG1CQUFPLENBQUMsaUVBQVE7QUFDNUUsUUFBUSw0R0FBNEcsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQ3pJLFFBQVEsdUJBQXVCLEVBQUUsbUJBQU8sQ0FBQyw2RkFBc0I7QUFDL0QsYUFBYSxtQkFBTyxDQUFDLHFFQUFpQjtBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyw0QkFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFhO0FBQ3pCLFFBQVEsNEVBQTRFO0FBQ3BGLFFBQVEseUNBQXlDLEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUN0RSxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHFFQUFVO0FBQ3JDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUM5QyxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDJFQUFvQjtBQUNuRCxlQUFlLG1CQUFPLENBQUMsZ0NBQWE7QUFDcEMsUUFBUSwyRUFBMkUsRUFBRSxtQkFBTyxDQUFDLGdDQUFhOztBQUUxRzs7QUFFQSxxREFBcUQsZUFBZTtBQUNwRTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixtRUFBbUUsWUFBWTtBQUMvRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixzQkFBc0I7O0FBRXBEO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwyQ0FBMkMsU0FBUywwQkFBMEIsWUFBWTtBQUMxRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6Qzs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZUFBZTtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhEQUE4RDtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLGdEQUFnRDtBQUN0RTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsd0JBQXdCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLG1FQUFtRTtBQUM5RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxyZXF1ZXN0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgQWJvcnRDb250cm9sbGVyICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGV4dHJhY3RCb2R5LCBtaXhpbkJvZHksIGNsb25lQm9keSwgYm9keVVudXNhYmxlIH0gPSByZXF1aXJlKCcuL2JvZHknKVxuY29uc3QgeyBIZWFkZXJzLCBmaWxsOiBmaWxsSGVhZGVycywgSGVhZGVyc0xpc3QsIHNldEhlYWRlcnNHdWFyZCwgZ2V0SGVhZGVyc0d1YXJkLCBzZXRIZWFkZXJzTGlzdCwgZ2V0SGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IEZpbmFsaXphdGlvblJlZ2lzdHJ5IH0gPSByZXF1aXJlKCcuL2Rpc3BhdGNoZXItd2Vha3JlZicpKClcbmNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuY29uc3Qgbm9kZVV0aWwgPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3Qge1xuICBpc1ZhbGlkSFRUUFRva2VuLFxuICBzYW1lT3JpZ2luLFxuICBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0XG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHtcbiAgZm9yYmlkZGVuTWV0aG9kc1NldCxcbiAgY29yc1NhZmVMaXN0ZWRNZXRob2RzU2V0LFxuICByZWZlcnJlclBvbGljeSxcbiAgcmVxdWVzdFJlZGlyZWN0LFxuICByZXF1ZXN0TW9kZSxcbiAgcmVxdWVzdENyZWRlbnRpYWxzLFxuICByZXF1ZXN0Q2FjaGUsXG4gIHJlcXVlc3REdXBsZXhcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHksIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSwgbm9ybWFsaXplZE1ldGhvZFJlY29yZHMgfSA9IHV0aWxcbmNvbnN0IHsga0hlYWRlcnMsIGtTaWduYWwsIGtTdGF0ZSwga0Rpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi93ZWJpZGwnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgZ2V0TWF4TGlzdGVuZXJzLCBzZXRNYXhMaXN0ZW5lcnMsIGdldEV2ZW50TGlzdGVuZXJzLCBkZWZhdWx0TWF4TGlzdGVuZXJzIH0gPSByZXF1aXJlKCdub2RlOmV2ZW50cycpXG5cbmNvbnN0IGtBYm9ydENvbnRyb2xsZXIgPSBTeW1ib2woJ2Fib3J0Q29udHJvbGxlcicpXG5cbmNvbnN0IHJlcXVlc3RGaW5hbGl6ZXIgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHsgc2lnbmFsLCBhYm9ydCB9KSA9PiB7XG4gIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0KVxufSlcblxuY29uc3QgZGVwZW5kZW50Q29udHJvbGxlck1hcCA9IG5ldyBXZWFrTWFwKClcblxuZnVuY3Rpb24gYnVpbGRBYm9ydCAoYWNSZWYpIHtcbiAgcmV0dXJuIGFib3J0XG5cbiAgZnVuY3Rpb24gYWJvcnQgKCkge1xuICAgIGNvbnN0IGFjID0gYWNSZWYuZGVyZWYoKVxuICAgIGlmIChhYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDdXJyZW50bHksIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIEZpbmFsaXphdGlvblJlZ2lzdHJ5LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80OTM0NFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy80Nzc0OFxuICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYWJvcnQsIHRoZSBmaXJzdCBzdGVwIGlzIHRvIHVucmVnaXN0ZXIgZnJvbSBpdC5cbiAgICAgIC8vIElmIHRoZSBjb250cm9sbGVyIGNhbiByZWZlciB0byBpdCwgaXQgaXMgc3RpbGwgcmVnaXN0ZXJlZC5cbiAgICAgIC8vIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuICAgICAgcmVxdWVzdEZpbmFsaXplci51bnJlZ2lzdGVyKGFib3J0KVxuXG4gICAgICAvLyBVbnN1YnNjcmliZSBhIGxpc3RlbmVyLlxuICAgICAgLy8gRmluYWxpemF0aW9uUmVnaXN0cnkgd2lsbCBubyBsb25nZXIgYmUgY2FsbGVkLCBzbyB0aGlzIG11c3QgYmUgZG9uZS5cbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydClcblxuICAgICAgYWMuYWJvcnQodGhpcy5yZWFzb24pXG5cbiAgICAgIGNvbnN0IGNvbnRyb2xsZXJMaXN0ID0gZGVwZW5kZW50Q29udHJvbGxlck1hcC5nZXQoYWMuc2lnbmFsKVxuXG4gICAgICBpZiAoY29udHJvbGxlckxpc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoY29udHJvbGxlckxpc3Quc2l6ZSAhPT0gMCkge1xuICAgICAgICAgIGZvciAoY29uc3QgcmVmIG9mIGNvbnRyb2xsZXJMaXN0KSB7XG4gICAgICAgICAgICBjb25zdCBjdHJsID0gcmVmLmRlcmVmKClcbiAgICAgICAgICAgIGlmIChjdHJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3RybC5hYm9ydCh0aGlzLnJlYXNvbilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlckxpc3QuY2xlYXIoKVxuICAgICAgICB9XG4gICAgICAgIGRlcGVuZGVudENvbnRyb2xsZXJNYXAuZGVsZXRlKGFjLnNpZ25hbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubGV0IHBhdGNoTWV0aG9kV2FybmluZyA9IGZhbHNlXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWNsYXNzXG5jbGFzcyBSZXF1ZXN0IHtcbiAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0XG4gIGNvbnN0cnVjdG9yIChpbnB1dCwgaW5pdCA9IHt9KSB7XG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcbiAgICBpZiAoaW5wdXQgPT09IGtDb25zdHJ1Y3QpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByZWZpeCA9ICdSZXF1ZXN0IGNvbnN0cnVjdG9yJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgaW5wdXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyhpbnB1dCwgcHJlZml4LCAnaW5wdXQnKVxuICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5pdChpbml0LCBwcmVmaXgsICdpbml0JylcblxuICAgIC8vIDEuIExldCByZXF1ZXN0IGJlIG51bGwuXG4gICAgbGV0IHJlcXVlc3QgPSBudWxsXG5cbiAgICAvLyAyLiBMZXQgZmFsbGJhY2tNb2RlIGJlIG51bGwuXG4gICAgbGV0IGZhbGxiYWNrTW9kZSA9IG51bGxcblxuICAgIC8vIDMuIExldCBiYXNlVVJMIGJlIHRoaXPigJlzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdOKAmXMgQVBJIGJhc2UgVVJMLlxuICAgIGNvbnN0IGJhc2VVcmwgPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0LmJhc2VVcmxcblxuICAgIC8vIDQuIExldCBzaWduYWwgYmUgbnVsbC5cbiAgICBsZXQgc2lnbmFsID0gbnVsbFxuXG4gICAgLy8gNS4gSWYgaW5wdXQgaXMgYSBzdHJpbmcsIHRoZW46XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXNba0Rpc3BhdGNoZXJdID0gaW5pdC5kaXNwYXRjaGVyXG5cbiAgICAgIC8vIDEuIExldCBwYXJzZWRVUkwgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIGlucHV0IHdpdGggYmFzZVVSTC5cbiAgICAgIC8vIDIuIElmIHBhcnNlZFVSTCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgbGV0IHBhcnNlZFVSTFxuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkVVJMID0gbmV3IFVSTChpbnB1dCwgYmFzZVVybClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGYWlsZWQgdG8gcGFyc2UgVVJMIGZyb20gJyArIGlucHV0LCB7IGNhdXNlOiBlcnIgfSlcbiAgICAgIH1cblxuICAgICAgLy8gMy4gSWYgcGFyc2VkVVJMIGluY2x1ZGVzIGNyZWRlbnRpYWxzLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHBhcnNlZFVSTC51c2VybmFtZSB8fCBwYXJzZWRVUkwucGFzc3dvcmQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnUmVxdWVzdCBjYW5ub3QgYmUgY29uc3RydWN0ZWQgZnJvbSBhIFVSTCB0aGF0IGluY2x1ZGVzIGNyZWRlbnRpYWxzOiAnICtcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gNC4gU2V0IHJlcXVlc3QgdG8gYSBuZXcgcmVxdWVzdCB3aG9zZSBVUkwgaXMgcGFyc2VkVVJMLlxuICAgICAgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHsgdXJsTGlzdDogW3BhcnNlZFVSTF0gfSlcblxuICAgICAgLy8gNS4gU2V0IGZhbGxiYWNrTW9kZSB0byBcImNvcnNcIi5cbiAgICAgIGZhbGxiYWNrTW9kZSA9ICdjb3JzJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tEaXNwYXRjaGVyXSA9IGluaXQuZGlzcGF0Y2hlciB8fCBpbnB1dFtrRGlzcGF0Y2hlcl1cblxuICAgICAgLy8gNi4gT3RoZXJ3aXNlOlxuXG4gICAgICAvLyA3LiBBc3NlcnQ6IGlucHV0IGlzIGEgUmVxdWVzdCBvYmplY3QuXG4gICAgICBhc3NlcnQoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KVxuXG4gICAgICAvLyA4LiBTZXQgcmVxdWVzdCB0byBpbnB1dOKAmXMgcmVxdWVzdC5cbiAgICAgIHJlcXVlc3QgPSBpbnB1dFtrU3RhdGVdXG5cbiAgICAgIC8vIDkuIFNldCBzaWduYWwgdG8gaW5wdXTigJlzIHNpZ25hbC5cbiAgICAgIHNpZ25hbCA9IGlucHV0W2tTaWduYWxdXG4gICAgfVxuXG4gICAgLy8gNy4gTGV0IG9yaWdpbiBiZSB0aGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3TigJlzIG9yaWdpbi5cbiAgICBjb25zdCBvcmlnaW4gPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0Lm9yaWdpblxuXG4gICAgLy8gOC4gTGV0IHdpbmRvdyBiZSBcImNsaWVudFwiLlxuICAgIGxldCB3aW5kb3cgPSAnY2xpZW50J1xuXG4gICAgLy8gOS4gSWYgcmVxdWVzdOKAmXMgd2luZG93IGlzIGFuIGVudmlyb25tZW50IHNldHRpbmdzIG9iamVjdCBhbmQgaXRzIG9yaWdpblxuICAgIC8vIGlzIHNhbWUgb3JpZ2luIHdpdGggb3JpZ2luLCB0aGVuIHNldCB3aW5kb3cgdG8gcmVxdWVzdOKAmXMgd2luZG93LlxuICAgIGlmIChcbiAgICAgIHJlcXVlc3Qud2luZG93Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vudmlyb25tZW50U2V0dGluZ3NPYmplY3QnICYmXG4gICAgICBzYW1lT3JpZ2luKHJlcXVlc3Qud2luZG93LCBvcmlnaW4pXG4gICAgKSB7XG4gICAgICB3aW5kb3cgPSByZXF1ZXN0LndpbmRvd1xuICAgIH1cblxuICAgIC8vIDEwLiBJZiBpbml0W1wid2luZG93XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKGluaXQud2luZG93ICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCd3aW5kb3cnIG9wdGlvbiAnJHt3aW5kb3d9JyBtdXN0IGJlIG51bGxgKVxuICAgIH1cblxuICAgIC8vIDExLiBJZiBpbml0W1wid2luZG93XCJdIGV4aXN0cywgdGhlbiBzZXQgd2luZG93IHRvIFwibm8td2luZG93XCIuXG4gICAgaWYgKCd3aW5kb3cnIGluIGluaXQpIHtcbiAgICAgIHdpbmRvdyA9ICduby13aW5kb3cnXG4gICAgfVxuXG4gICAgLy8gMTIuIFNldCByZXF1ZXN0IHRvIGEgbmV3IHJlcXVlc3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHtcbiAgICAgIC8vIFVSTCByZXF1ZXN04oCZcyBVUkwuXG4gICAgICAvLyB1bmRpY2kgaW1wbGVtZW50YXRpb24gbm90ZTogdGhpcyBpcyBzZXQgYXMgdGhlIGZpcnN0IGl0ZW0gaW4gcmVxdWVzdCdzIHVybExpc3QgaW4gbWFrZVJlcXVlc3RcbiAgICAgIC8vIG1ldGhvZCByZXF1ZXN04oCZcyBtZXRob2QuXG4gICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgLy8gaGVhZGVyIGxpc3QgQSBjb3B5IG9mIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAgICAgLy8gdW5kaWNpIGltcGxlbWVudGF0aW9uIG5vdGU6IGhlYWRlcnNMaXN0IGlzIGNsb25lZCBpbiBtYWtlUmVxdWVzdFxuICAgICAgaGVhZGVyc0xpc3Q6IHJlcXVlc3QuaGVhZGVyc0xpc3QsXG4gICAgICAvLyB1bnNhZmUtcmVxdWVzdCBmbGFnIFNldC5cbiAgICAgIHVuc2FmZVJlcXVlc3Q6IHJlcXVlc3QudW5zYWZlUmVxdWVzdCxcbiAgICAgIC8vIGNsaWVudCBUaGlz4oCZcyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QuXG4gICAgICBjbGllbnQ6IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QsXG4gICAgICAvLyB3aW5kb3cgd2luZG93LlxuICAgICAgd2luZG93LFxuICAgICAgLy8gcHJpb3JpdHkgcmVxdWVzdOKAmXMgcHJpb3JpdHkuXG4gICAgICBwcmlvcml0eTogcmVxdWVzdC5wcmlvcml0eSxcbiAgICAgIC8vIG9yaWdpbiByZXF1ZXN04oCZcyBvcmlnaW4uIFRoZSBwcm9wYWdhdGlvbiBvZiB0aGUgb3JpZ2luIGlzIG9ubHkgc2lnbmlmaWNhbnQgZm9yIG5hdmlnYXRpb24gcmVxdWVzdHNcbiAgICAgIC8vIGJlaW5nIGhhbmRsZWQgYnkgYSBzZXJ2aWNlIHdvcmtlci4gSW4gdGhpcyBzY2VuYXJpbyBhIHJlcXVlc3QgY2FuIGhhdmUgYW4gb3JpZ2luIHRoYXQgaXMgZGlmZmVyZW50XG4gICAgICAvLyBmcm9tIHRoZSBjdXJyZW50IGNsaWVudC5cbiAgICAgIG9yaWdpbjogcmVxdWVzdC5vcmlnaW4sXG4gICAgICAvLyByZWZlcnJlciByZXF1ZXN04oCZcyByZWZlcnJlci5cbiAgICAgIHJlZmVycmVyOiByZXF1ZXN0LnJlZmVycmVyLFxuICAgICAgLy8gcmVmZXJyZXIgcG9saWN5IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgICAgIHJlZmVycmVyUG9saWN5OiByZXF1ZXN0LnJlZmVycmVyUG9saWN5LFxuICAgICAgLy8gbW9kZSByZXF1ZXN04oCZcyBtb2RlLlxuICAgICAgbW9kZTogcmVxdWVzdC5tb2RlLFxuICAgICAgLy8gY3JlZGVudGlhbHMgbW9kZSByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlLlxuICAgICAgY3JlZGVudGlhbHM6IHJlcXVlc3QuY3JlZGVudGlhbHMsXG4gICAgICAvLyBjYWNoZSBtb2RlIHJlcXVlc3TigJlzIGNhY2hlIG1vZGUuXG4gICAgICBjYWNoZTogcmVxdWVzdC5jYWNoZSxcbiAgICAgIC8vIHJlZGlyZWN0IG1vZGUgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZS5cbiAgICAgIHJlZGlyZWN0OiByZXF1ZXN0LnJlZGlyZWN0LFxuICAgICAgLy8gaW50ZWdyaXR5IG1ldGFkYXRhIHJlcXVlc3TigJlzIGludGVncml0eSBtZXRhZGF0YS5cbiAgICAgIGludGVncml0eTogcmVxdWVzdC5pbnRlZ3JpdHksXG4gICAgICAvLyBrZWVwYWxpdmUgcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgICAga2VlcGFsaXZlOiByZXF1ZXN0LmtlZXBhbGl2ZSxcbiAgICAgIC8vIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcgcmVxdWVzdOKAmXMgcmVsb2FkLW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlbG9hZE5hdmlnYXRpb246IHJlcXVlc3QucmVsb2FkTmF2aWdhdGlvbixcbiAgICAgIC8vIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnIHJlcXVlc3TigJlzIGhpc3RvcnktbmF2aWdhdGlvbiBmbGFnLlxuICAgICAgaGlzdG9yeU5hdmlnYXRpb246IHJlcXVlc3QuaGlzdG9yeU5hdmlnYXRpb24sXG4gICAgICAvLyBVUkwgbGlzdCBBIGNsb25lIG9mIHJlcXVlc3TigJlzIFVSTCBsaXN0LlxuICAgICAgdXJsTGlzdDogWy4uLnJlcXVlc3QudXJsTGlzdF1cbiAgICB9KVxuXG4gICAgY29uc3QgaW5pdEhhc0tleSA9IE9iamVjdC5rZXlzKGluaXQpLmxlbmd0aCAhPT0gMFxuXG4gICAgLy8gMTMuIElmIGluaXQgaXMgbm90IGVtcHR5LCB0aGVuOlxuICAgIGlmIChpbml0SGFzS2V5KSB7XG4gICAgICAvLyAxLiBJZiByZXF1ZXN04oCZcyBtb2RlIGlzIFwibmF2aWdhdGVcIiwgdGhlbiBzZXQgaXQgdG8gXCJzYW1lLW9yaWdpblwiLlxuICAgICAgaWYgKHJlcXVlc3QubW9kZSA9PT0gJ25hdmlnYXRlJykge1xuICAgICAgICByZXF1ZXN0Lm1vZGUgPSAnc2FtZS1vcmlnaW4nXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFVuc2V0IHJlcXVlc3TigJlzIHJlbG9hZC1uYXZpZ2F0aW9uIGZsYWcuXG4gICAgICByZXF1ZXN0LnJlbG9hZE5hdmlnYXRpb24gPSBmYWxzZVxuXG4gICAgICAvLyAzLiBVbnNldCByZXF1ZXN04oCZcyBoaXN0b3J5LW5hdmlnYXRpb24gZmxhZy5cbiAgICAgIHJlcXVlc3QuaGlzdG9yeU5hdmlnYXRpb24gPSBmYWxzZVxuXG4gICAgICAvLyA0LiBTZXQgcmVxdWVzdOKAmXMgb3JpZ2luIHRvIFwiY2xpZW50XCIuXG4gICAgICByZXF1ZXN0Lm9yaWdpbiA9ICdjbGllbnQnXG5cbiAgICAgIC8vIDUuIFNldCByZXF1ZXN04oCZcyByZWZlcnJlciB0byBcImNsaWVudFwiXG4gICAgICByZXF1ZXN0LnJlZmVycmVyID0gJ2NsaWVudCdcblxuICAgICAgLy8gNi4gU2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeSB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgcmVxdWVzdC5yZWZlcnJlclBvbGljeSA9ICcnXG5cbiAgICAgIC8vIDcuIFNldCByZXF1ZXN04oCZcyBVUkwgdG8gcmVxdWVzdOKAmXMgY3VycmVudCBVUkwuXG4gICAgICByZXF1ZXN0LnVybCA9IHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cblxuICAgICAgLy8gOC4gU2V0IHJlcXVlc3TigJlzIFVSTCBsaXN0IHRvIMKrIHJlcXVlc3TigJlzIFVSTCDCuy5cbiAgICAgIHJlcXVlc3QudXJsTGlzdCA9IFtyZXF1ZXN0LnVybF1cbiAgICB9XG5cbiAgICAvLyAxNC4gSWYgaW5pdFtcInJlZmVycmVyXCJdIGV4aXN0cywgdGhlbjpcbiAgICBpZiAoaW5pdC5yZWZlcnJlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAxLiBMZXQgcmVmZXJyZXIgYmUgaW5pdFtcInJlZmVycmVyXCJdLlxuICAgICAgY29uc3QgcmVmZXJyZXIgPSBpbml0LnJlZmVycmVyXG5cbiAgICAgIC8vIDIuIElmIHJlZmVycmVyIGlzIHRoZSBlbXB0eSBzdHJpbmcsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIFwibm8tcmVmZXJyZXJcIi5cbiAgICAgIGlmIChyZWZlcnJlciA9PT0gJycpIHtcbiAgICAgICAgcmVxdWVzdC5yZWZlcnJlciA9ICduby1yZWZlcnJlcidcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDEuIExldCBwYXJzZWRSZWZlcnJlciBiZSB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgcmVmZXJyZXIgd2l0aFxuICAgICAgICAvLyBiYXNlVVJMLlxuICAgICAgICAvLyAyLiBJZiBwYXJzZWRSZWZlcnJlciBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICBsZXQgcGFyc2VkUmVmZXJyZXJcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWRSZWZlcnJlciA9IG5ldyBVUkwocmVmZXJyZXIsIGJhc2VVcmwpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlZmVycmVyIFwiJHtyZWZlcnJlcn1cIiBpcyBub3QgYSB2YWxpZCBVUkwuYCwgeyBjYXVzZTogZXJyIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBJZiBvbmUgb2YgdGhlIGZvbGxvd2luZyBpcyB0cnVlXG4gICAgICAgIC8vIC0gcGFyc2VkUmVmZXJyZXLigJlzIHNjaGVtZSBpcyBcImFib3V0XCIgYW5kIHBhdGggaXMgdGhlIHN0cmluZyBcImNsaWVudFwiXG4gICAgICAgIC8vIC0gcGFyc2VkUmVmZXJyZXLigJlzIG9yaWdpbiBpcyBub3Qgc2FtZSBvcmlnaW4gd2l0aCBvcmlnaW5cbiAgICAgICAgLy8gdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXIgdG8gXCJjbGllbnRcIi5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChwYXJzZWRSZWZlcnJlci5wcm90b2NvbCA9PT0gJ2Fib3V0OicgJiYgcGFyc2VkUmVmZXJyZXIuaG9zdG5hbWUgPT09ICdjbGllbnQnKSB8fFxuICAgICAgICAgIChvcmlnaW4gJiYgIXNhbWVPcmlnaW4ocGFyc2VkUmVmZXJyZXIsIGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QuYmFzZVVybCkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSAnY2xpZW50J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIDQuIE90aGVyd2lzZSwgc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHRvIHBhcnNlZFJlZmVycmVyLlxuICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSBwYXJzZWRSZWZlcnJlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMTUuIElmIGluaXRbXCJyZWZlcnJlclBvbGljeVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeVxuICAgIC8vIHRvIGl0LlxuICAgIGlmIChpbml0LnJlZmVycmVyUG9saWN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSBpbml0LnJlZmVycmVyUG9saWN5XG4gICAgfVxuXG4gICAgLy8gMTYuIExldCBtb2RlIGJlIGluaXRbXCJtb2RlXCJdIGlmIGl0IGV4aXN0cywgYW5kIGZhbGxiYWNrTW9kZSBvdGhlcndpc2UuXG4gICAgbGV0IG1vZGVcbiAgICBpZiAoaW5pdC5tb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1vZGUgPSBpbml0Lm1vZGVcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZSA9IGZhbGxiYWNrTW9kZVxuICAgIH1cblxuICAgIC8vIDE3LiBJZiBtb2RlIGlzIFwibmF2aWdhdGVcIiwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAobW9kZSA9PT0gJ25hdmlnYXRlJykge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdSZXF1ZXN0IGNvbnN0cnVjdG9yJyxcbiAgICAgICAgbWVzc2FnZTogJ2ludmFsaWQgcmVxdWVzdCBtb2RlIG5hdmlnYXRlLidcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMTguIElmIG1vZGUgaXMgbm9uLW51bGwsIHNldCByZXF1ZXN04oCZcyBtb2RlIHRvIG1vZGUuXG4gICAgaWYgKG1vZGUgIT0gbnVsbCkge1xuICAgICAgcmVxdWVzdC5tb2RlID0gbW9kZVxuICAgIH1cblxuICAgIC8vIDE5LiBJZiBpbml0W1wiY3JlZGVudGlhbHNcIl0gZXhpc3RzLCB0aGVuIHNldCByZXF1ZXN04oCZcyBjcmVkZW50aWFscyBtb2RlXG4gICAgLy8gdG8gaXQuXG4gICAgaWYgKGluaXQuY3JlZGVudGlhbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5jcmVkZW50aWFscyA9IGluaXQuY3JlZGVudGlhbHNcbiAgICB9XG5cbiAgICAvLyAxOC4gSWYgaW5pdFtcImNhY2hlXCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgY2FjaGUgbW9kZSB0byBpdC5cbiAgICBpZiAoaW5pdC5jYWNoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LmNhY2hlID0gaW5pdC5jYWNoZVxuICAgIH1cblxuICAgIC8vIDIxLiBJZiByZXF1ZXN04oCZcyBjYWNoZSBtb2RlIGlzIFwib25seS1pZi1jYWNoZWRcIiBhbmQgcmVxdWVzdOKAmXMgbW9kZSBpc1xuICAgIC8vIG5vdCBcInNhbWUtb3JpZ2luXCIsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHJlcXVlc3QuY2FjaGUgPT09ICdvbmx5LWlmLWNhY2hlZCcgJiYgcmVxdWVzdC5tb2RlICE9PSAnc2FtZS1vcmlnaW4nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIidvbmx5LWlmLWNhY2hlZCcgY2FuIGJlIHNldCBvbmx5IHdpdGggJ3NhbWUtb3JpZ2luJyBtb2RlXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyAyMi4gSWYgaW5pdFtcInJlZGlyZWN0XCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZSB0byBpdC5cbiAgICBpZiAoaW5pdC5yZWRpcmVjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0LnJlZGlyZWN0ID0gaW5pdC5yZWRpcmVjdFxuICAgIH1cblxuICAgIC8vIDIzLiBJZiBpbml0W1wiaW50ZWdyaXR5XCJdIGV4aXN0cywgdGhlbiBzZXQgcmVxdWVzdOKAmXMgaW50ZWdyaXR5IG1ldGFkYXRhIHRvIGl0LlxuICAgIGlmIChpbml0LmludGVncml0eSAhPSBudWxsKSB7XG4gICAgICByZXF1ZXN0LmludGVncml0eSA9IFN0cmluZyhpbml0LmludGVncml0eSlcbiAgICB9XG5cbiAgICAvLyAyNC4gSWYgaW5pdFtcImtlZXBhbGl2ZVwiXSBleGlzdHMsIHRoZW4gc2V0IHJlcXVlc3TigJlzIGtlZXBhbGl2ZSB0byBpdC5cbiAgICBpZiAoaW5pdC5rZWVwYWxpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdC5rZWVwYWxpdmUgPSBCb29sZWFuKGluaXQua2VlcGFsaXZlKVxuICAgIH1cblxuICAgIC8vIDI1LiBJZiBpbml0W1wibWV0aG9kXCJdIGV4aXN0cywgdGhlbjpcbiAgICBpZiAoaW5pdC5tZXRob2QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gMS4gTGV0IG1ldGhvZCBiZSBpbml0W1wibWV0aG9kXCJdLlxuICAgICAgbGV0IG1ldGhvZCA9IGluaXQubWV0aG9kXG5cbiAgICAgIGNvbnN0IG1heUJlTm9ybWFsaXplZCA9IG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzW21ldGhvZF1cblxuICAgICAgaWYgKG1heUJlTm9ybWFsaXplZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIE5vdGU6IEJ5cGFzcyB2YWxpZGF0aW9uIERFTEVURSwgR0VULCBIRUFELCBPUFRJT05TLCBQT1NULCBQVVQsIFBBVENIIGFuZCB0aGVzZSBsb3dlcmNhc2Ugb25lc1xuICAgICAgICByZXF1ZXN0Lm1ldGhvZCA9IG1heUJlTm9ybWFsaXplZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gMi4gSWYgbWV0aG9kIGlzIG5vdCBhIG1ldGhvZCBvciBtZXRob2QgaXMgYSBmb3JiaWRkZW4gbWV0aG9kLCB0aGVuXG4gICAgICAgIC8vIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgICBpZiAoIWlzVmFsaWRIVFRQVG9rZW4obWV0aG9kKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCcke21ldGhvZH0nIGlzIG5vdCBhIHZhbGlkIEhUVFAgbWV0aG9kLmApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cHBlckNhc2UgPSBtZXRob2QudG9VcHBlckNhc2UoKVxuXG4gICAgICAgIGlmIChmb3JiaWRkZW5NZXRob2RzU2V0Lmhhcyh1cHBlckNhc2UpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJyR7bWV0aG9kfScgSFRUUCBtZXRob2QgaXMgdW5zdXBwb3J0ZWQuYClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIE5vcm1hbGl6ZSBtZXRob2QuXG4gICAgICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1ldGhvZC1ub3JtYWxpemVcbiAgICAgICAgLy8gTm90ZTogbXVzdCBiZSBpbiB1cHBlcmNhc2VcbiAgICAgICAgbWV0aG9kID0gbm9ybWFsaXplZE1ldGhvZFJlY29yZHNCYXNlW3VwcGVyQ2FzZV0gPz8gbWV0aG9kXG5cbiAgICAgICAgLy8gNC4gU2V0IHJlcXVlc3TigJlzIG1ldGhvZCB0byBtZXRob2QuXG4gICAgICAgIHJlcXVlc3QubWV0aG9kID0gbWV0aG9kXG4gICAgICB9XG5cbiAgICAgIGlmICghcGF0Y2hNZXRob2RXYXJuaW5nICYmIHJlcXVlc3QubWV0aG9kID09PSAncGF0Y2gnKSB7XG4gICAgICAgIHByb2Nlc3MuZW1pdFdhcm5pbmcoJ1VzaW5nIGBwYXRjaGAgaXMgaGlnaGx5IGxpa2VseSB0byByZXN1bHQgaW4gYSBgNDA1IE1ldGhvZCBOb3QgQWxsb3dlZGAuIGBQQVRDSGAgaXMgbXVjaCBtb3JlIGxpa2VseSB0byBzdWNjZWVkLicsIHtcbiAgICAgICAgICBjb2RlOiAnVU5ESUNJLUZFVENILXBhdGNoJ1xuICAgICAgICB9KVxuXG4gICAgICAgIHBhdGNoTWV0aG9kV2FybmluZyA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAyNi4gSWYgaW5pdFtcInNpZ25hbFwiXSBleGlzdHMsIHRoZW4gc2V0IHNpZ25hbCB0byBpdC5cbiAgICBpZiAoaW5pdC5zaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2lnbmFsID0gaW5pdC5zaWduYWxcbiAgICB9XG5cbiAgICAvLyAyNy4gU2V0IHRoaXPigJlzIHJlcXVlc3QgdG8gcmVxdWVzdC5cbiAgICB0aGlzW2tTdGF0ZV0gPSByZXF1ZXN0XG5cbiAgICAvLyAyOC4gU2V0IHRoaXPigJlzIHNpZ25hbCB0byBhIG5ldyBBYm9ydFNpZ25hbCBvYmplY3Qgd2l0aCB0aGlz4oCZcyByZWxldmFudFxuICAgIC8vIFJlYWxtLlxuICAgIC8vIFRPRE86IGNvdWxkIHRoaXMgYmUgc2ltcGxpZmllZCB3aXRoIEFib3J0U2lnbmFsLmFueVxuICAgIC8vIChodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1hYm9ydHNpZ25hbC1hbnkpXG4gICAgY29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgICB0aGlzW2tTaWduYWxdID0gYWMuc2lnbmFsXG5cbiAgICAvLyAyOS4gSWYgc2lnbmFsIGlzIG5vdCBudWxsLCB0aGVuIG1ha2UgdGhpc+KAmXMgc2lnbmFsIGZvbGxvdyBzaWduYWwuXG4gICAgaWYgKHNpZ25hbCAhPSBudWxsKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFzaWduYWwgfHxcbiAgICAgICAgdHlwZW9mIHNpZ25hbC5hYm9ydGVkICE9PSAnYm9vbGVhbicgfHxcbiAgICAgICAgdHlwZW9mIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyICE9PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1JlcXVlc3QnOiBtZW1iZXIgc2lnbmFsIGlzIG5vdCBvZiB0eXBlIEFib3J0U2lnbmFsLlwiXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFjLmFib3J0KHNpZ25hbC5yZWFzb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBLZWVwIGEgc3Ryb25nIHJlZiB0byBhYyB3aGlsZSByZXF1ZXN0IG9iamVjdFxuICAgICAgICAvLyBpcyBhbGl2ZS4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudCBBYm9ydENvbnRyb2xsZXJcbiAgICAgICAgLy8gZnJvbSBiZWluZyBwcmVtYXR1cmVseSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICAgICAgLy8gU2VlLCBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9pc3N1ZXMvMTkyNi5cbiAgICAgICAgdGhpc1trQWJvcnRDb250cm9sbGVyXSA9IGFjXG5cbiAgICAgICAgY29uc3QgYWNSZWYgPSBuZXcgV2Vha1JlZihhYylcbiAgICAgICAgY29uc3QgYWJvcnQgPSBidWlsZEFib3J0KGFjUmVmKVxuXG4gICAgICAgIC8vIFRoaXJkLXBhcnR5IEFib3J0Q29udHJvbGxlcnMgbWF5IG5vdCB3b3JrIHdpdGggdGhlc2UuXG4gICAgICAgIC8vIFNlZSwgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy91bmRpY2kvcHVsbC8xOTEwI2lzc3VlY29tbWVudC0xNDY0NDk1NjE5LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIElmIHRoZSBtYXggYW1vdW50IG9mIGxpc3RlbmVycyBpcyBlcXVhbCB0byB0aGUgZGVmYXVsdCwgaW5jcmVhc2UgaXRcbiAgICAgICAgICAvLyBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGluIG5vZGUgPj0gdjE5LjkuMFxuICAgICAgICAgIGlmICh0eXBlb2YgZ2V0TWF4TGlzdGVuZXJzID09PSAnZnVuY3Rpb24nICYmIGdldE1heExpc3RlbmVycyhzaWduYWwpID09PSBkZWZhdWx0TWF4TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBzZXRNYXhMaXN0ZW5lcnMoMTUwMCwgc2lnbmFsKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZ2V0RXZlbnRMaXN0ZW5lcnMoc2lnbmFsLCAnYWJvcnQnKS5sZW5ndGggPj0gZGVmYXVsdE1heExpc3RlbmVycykge1xuICAgICAgICAgICAgc2V0TWF4TGlzdGVuZXJzKDE1MDAsIHNpZ25hbClcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge31cblxuICAgICAgICB1dGlsLmFkZEFib3J0TGlzdGVuZXIoc2lnbmFsLCBhYm9ydClcbiAgICAgICAgLy8gVGhlIHRoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSByZWdpc3RyeSBrZXkgdG8gYmUgdW5yZWdpc3RlcmVkLlxuICAgICAgICAvLyBXaXRob3V0IGl0LCB5b3UgY2Fubm90IHVucmVnaXN0ZXIuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgICAgIC8vIGFib3J0IGlzIHVzZWQgYXMgdGhlIHVucmVnaXN0ZXIga2V5LiAoYmVjYXVzZSBpdCBpcyB1bmlxdWUpXG4gICAgICAgIHJlcXVlc3RGaW5hbGl6ZXIucmVnaXN0ZXIoYWMsIHsgc2lnbmFsLCBhYm9ydCB9LCBhYm9ydClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzMC4gU2V0IHRoaXPigJlzIGhlYWRlcnMgdG8gYSBuZXcgSGVhZGVycyBvYmplY3Qgd2l0aCB0aGlz4oCZcyByZWxldmFudFxuICAgIC8vIFJlYWxtLCB3aG9zZSBoZWFkZXIgbGlzdCBpcyByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdCBhbmQgZ3VhcmQgaXNcbiAgICAvLyBcInJlcXVlc3RcIi5cbiAgICB0aGlzW2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gICAgc2V0SGVhZGVyc0xpc3QodGhpc1trSGVhZGVyc10sIHJlcXVlc3QuaGVhZGVyc0xpc3QpXG4gICAgc2V0SGVhZGVyc0d1YXJkKHRoaXNba0hlYWRlcnNdLCAncmVxdWVzdCcpXG5cbiAgICAvLyAzMS4gSWYgdGhpc+KAmXMgcmVxdWVzdOKAmXMgbW9kZSBpcyBcIm5vLWNvcnNcIiwgdGhlbjpcbiAgICBpZiAobW9kZSA9PT0gJ25vLWNvcnMnKSB7XG4gICAgICAvLyAxLiBJZiB0aGlz4oCZcyByZXF1ZXN04oCZcyBtZXRob2QgaXMgbm90IGEgQ09SUy1zYWZlbGlzdGVkIG1ldGhvZCxcbiAgICAgIC8vIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgICBpZiAoIWNvcnNTYWZlTGlzdGVkTWV0aG9kc1NldC5oYXMocmVxdWVzdC5tZXRob2QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYCcke3JlcXVlc3QubWV0aG9kfSBpcyB1bnN1cHBvcnRlZCBpbiBuby1jb3JzIG1vZGUuYFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIFNldCB0aGlz4oCZcyBoZWFkZXJz4oCZcyBndWFyZCB0byBcInJlcXVlc3Qtbm8tY29yc1wiLlxuICAgICAgc2V0SGVhZGVyc0d1YXJkKHRoaXNba0hlYWRlcnNdLCAncmVxdWVzdC1uby1jb3JzJylcbiAgICB9XG5cbiAgICAvLyAzMi4gSWYgaW5pdCBpcyBub3QgZW1wdHksIHRoZW46XG4gICAgaWYgKGluaXRIYXNLZXkpIHtcbiAgICAgIC8qKiBAdHlwZSB7SGVhZGVyc0xpc3R9ICovXG4gICAgICBjb25zdCBoZWFkZXJzTGlzdCA9IGdldEhlYWRlcnNMaXN0KHRoaXNba0hlYWRlcnNdKVxuICAgICAgLy8gMS4gTGV0IGhlYWRlcnMgYmUgYSBjb3B5IG9mIHRoaXPigJlzIGhlYWRlcnMgYW5kIGl0cyBhc3NvY2lhdGVkIGhlYWRlclxuICAgICAgLy8gbGlzdC5cbiAgICAgIC8vIDIuIElmIGluaXRbXCJoZWFkZXJzXCJdIGV4aXN0cywgdGhlbiBzZXQgaGVhZGVycyB0byBpbml0W1wiaGVhZGVyc1wiXS5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBpbml0LmhlYWRlcnMgIT09IHVuZGVmaW5lZCA/IGluaXQuaGVhZGVycyA6IG5ldyBIZWFkZXJzTGlzdChoZWFkZXJzTGlzdClcblxuICAgICAgLy8gMy4gRW1wdHkgdGhpc+KAmXMgaGVhZGVyc+KAmXMgaGVhZGVyIGxpc3QuXG4gICAgICBoZWFkZXJzTGlzdC5jbGVhcigpXG5cbiAgICAgIC8vIDQuIElmIGhlYWRlcnMgaXMgYSBIZWFkZXJzIG9iamVjdCwgdGhlbiBmb3IgZWFjaCBoZWFkZXIgaW4gaXRzIGhlYWRlclxuICAgICAgLy8gbGlzdCwgYXBwZW5kIGhlYWRlcuKAmXMgbmFtZS9oZWFkZXLigJlzIHZhbHVlIHRvIHRoaXPigJlzIGhlYWRlcnMuXG4gICAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnNMaXN0KSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBuYW1lLCB2YWx1ZSB9IG9mIGhlYWRlcnMucmF3VmFsdWVzKCkpIHtcbiAgICAgICAgICBoZWFkZXJzTGlzdC5hcHBlbmQobmFtZSwgdmFsdWUsIGZhbHNlKVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IENvcHkgdGhlIGBzZXQtY29va2llYCBtZXRhLWRhdGEuXG4gICAgICAgIGhlYWRlcnNMaXN0LmNvb2tpZXMgPSBoZWFkZXJzLmNvb2tpZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDUuIE90aGVyd2lzZSwgZmlsbCB0aGlz4oCZcyBoZWFkZXJzIHdpdGggaGVhZGVycy5cbiAgICAgICAgZmlsbEhlYWRlcnModGhpc1trSGVhZGVyc10sIGhlYWRlcnMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gMzMuIExldCBpbnB1dEJvZHkgYmUgaW5wdXTigJlzIHJlcXVlc3TigJlzIGJvZHkgaWYgaW5wdXQgaXMgYSBSZXF1ZXN0XG4gICAgLy8gb2JqZWN0OyBvdGhlcndpc2UgbnVsbC5cbiAgICBjb25zdCBpbnB1dEJvZHkgPSBpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QgPyBpbnB1dFtrU3RhdGVdLmJvZHkgOiBudWxsXG5cbiAgICAvLyAzNC4gSWYgZWl0aGVyIGluaXRbXCJib2R5XCJdIGV4aXN0cyBhbmQgaXMgbm9uLW51bGwgb3IgaW5wdXRCb2R5IGlzXG4gICAgLy8gbm9uLW51bGwsIGFuZCByZXF1ZXN04oCZcyBtZXRob2QgaXMgYEdFVGAgb3IgYEhFQURgLCB0aGVuIHRocm93IGFcbiAgICAvLyBUeXBlRXJyb3IuXG4gICAgaWYgKFxuICAgICAgKGluaXQuYm9keSAhPSBudWxsIHx8IGlucHV0Qm9keSAhPSBudWxsKSAmJlxuICAgICAgKHJlcXVlc3QubWV0aG9kID09PSAnR0VUJyB8fCByZXF1ZXN0Lm1ldGhvZCA9PT0gJ0hFQUQnKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVxdWVzdCB3aXRoIEdFVC9IRUFEIG1ldGhvZCBjYW5ub3QgaGF2ZSBib2R5LicpXG4gICAgfVxuXG4gICAgLy8gMzUuIExldCBpbml0Qm9keSBiZSBudWxsLlxuICAgIGxldCBpbml0Qm9keSA9IG51bGxcblxuICAgIC8vIDM2LiBJZiBpbml0W1wiYm9keVwiXSBleGlzdHMgYW5kIGlzIG5vbi1udWxsLCB0aGVuOlxuICAgIGlmIChpbml0LmJvZHkgIT0gbnVsbCkge1xuICAgICAgLy8gMS4gTGV0IENvbnRlbnQtVHlwZSBiZSBudWxsLlxuICAgICAgLy8gMi4gU2V0IGluaXRCb2R5IGFuZCBDb250ZW50LVR5cGUgdG8gdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nXG4gICAgICAvLyBpbml0W1wiYm9keVwiXSwgd2l0aCBrZWVwYWxpdmUgc2V0IHRvIHJlcXVlc3TigJlzIGtlZXBhbGl2ZS5cbiAgICAgIGNvbnN0IFtleHRyYWN0ZWRCb2R5LCBjb250ZW50VHlwZV0gPSBleHRyYWN0Qm9keShcbiAgICAgICAgaW5pdC5ib2R5LFxuICAgICAgICByZXF1ZXN0LmtlZXBhbGl2ZVxuICAgICAgKVxuICAgICAgaW5pdEJvZHkgPSBleHRyYWN0ZWRCb2R5XG5cbiAgICAgIC8vIDMsIElmIENvbnRlbnQtVHlwZSBpcyBub24tbnVsbCBhbmQgdGhpc+KAmXMgaGVhZGVyc+KAmXMgaGVhZGVyIGxpc3QgZG9lc1xuICAgICAgLy8gbm90IGNvbnRhaW4gYENvbnRlbnQtVHlwZWAsIHRoZW4gYXBwZW5kIGBDb250ZW50LVR5cGVgL0NvbnRlbnQtVHlwZSB0b1xuICAgICAgLy8gdGhpc+KAmXMgaGVhZGVycy5cbiAgICAgIGlmIChjb250ZW50VHlwZSAmJiAhZ2V0SGVhZGVyc0xpc3QodGhpc1trSGVhZGVyc10pLmNvbnRhaW5zKCdjb250ZW50LXR5cGUnLCB0cnVlKSkge1xuICAgICAgICB0aGlzW2tIZWFkZXJzXS5hcHBlbmQoJ2NvbnRlbnQtdHlwZScsIGNvbnRlbnRUeXBlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDM3LiBMZXQgaW5wdXRPckluaXRCb2R5IGJlIGluaXRCb2R5IGlmIGl0IGlzIG5vbi1udWxsOyBvdGhlcndpc2VcbiAgICAvLyBpbnB1dEJvZHkuXG4gICAgY29uc3QgaW5wdXRPckluaXRCb2R5ID0gaW5pdEJvZHkgPz8gaW5wdXRCb2R5XG5cbiAgICAvLyAzOC4gSWYgaW5wdXRPckluaXRCb2R5IGlzIG5vbi1udWxsIGFuZCBpbnB1dE9ySW5pdEJvZHnigJlzIHNvdXJjZSBpc1xuICAgIC8vIG51bGwsIHRoZW46XG4gICAgaWYgKGlucHV0T3JJbml0Qm9keSAhPSBudWxsICYmIGlucHV0T3JJbml0Qm9keS5zb3VyY2UgPT0gbnVsbCkge1xuICAgICAgLy8gMS4gSWYgaW5pdEJvZHkgaXMgbm9uLW51bGwgYW5kIGluaXRbXCJkdXBsZXhcIl0gZG9lcyBub3QgZXhpc3QsXG4gICAgICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKGluaXRCb2R5ICE9IG51bGwgJiYgaW5pdC5kdXBsZXggPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZXF1ZXN0SW5pdDogZHVwbGV4IG9wdGlvbiBpcyByZXF1aXJlZCB3aGVuIHNlbmRpbmcgYSBib2R5LicpXG4gICAgICB9XG5cbiAgICAgIC8vIDIuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIG1vZGUgaXMgbmVpdGhlciBcInNhbWUtb3JpZ2luXCIgbm9yIFwiY29yc1wiLFxuICAgICAgLy8gdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChyZXF1ZXN0Lm1vZGUgIT09ICdzYW1lLW9yaWdpbicgJiYgcmVxdWVzdC5tb2RlICE9PSAnY29ycycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnSWYgcmVxdWVzdCBpcyBtYWRlIGZyb20gUmVhZGFibGVTdHJlYW0sIG1vZGUgc2hvdWxkIGJlIFwic2FtZS1vcmlnaW5cIiBvciBcImNvcnNcIidcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBTZXQgdGhpc+KAmXMgcmVxdWVzdOKAmXMgdXNlLUNPUlMtcHJlZmxpZ2h0IGZsYWcuXG4gICAgICByZXF1ZXN0LnVzZUNPUlNQcmVmbGlnaHRGbGFnID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIDM5LiBMZXQgZmluYWxCb2R5IGJlIGlucHV0T3JJbml0Qm9keS5cbiAgICBsZXQgZmluYWxCb2R5ID0gaW5wdXRPckluaXRCb2R5XG5cbiAgICAvLyA0MC4gSWYgaW5pdEJvZHkgaXMgbnVsbCBhbmQgaW5wdXRCb2R5IGlzIG5vbi1udWxsLCB0aGVuOlxuICAgIGlmIChpbml0Qm9keSA9PSBudWxsICYmIGlucHV0Qm9keSAhPSBudWxsKSB7XG4gICAgICAvLyAxLiBJZiBpbnB1dCBpcyB1bnVzYWJsZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAgIGlmIChib2R5VW51c2FibGUoaW5wdXQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjb25zdHJ1Y3QgYSBSZXF1ZXN0IHdpdGggYSBSZXF1ZXN0IG9iamVjdCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gdXNlZC4nXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gMi4gU2V0IGZpbmFsQm9keSB0byB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgcHJveHkgZm9yIGlucHV0Qm9keS5cbiAgICAgIC8vIGh0dHBzOi8vc3RyZWFtcy5zcGVjLndoYXR3Zy5vcmcvI3JlYWRhYmxlc3RyZWFtLWNyZWF0ZS1hLXByb3h5XG4gICAgICBjb25zdCBpZGVudGl0eVRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKVxuICAgICAgaW5wdXRCb2R5LnN0cmVhbS5waXBlVGhyb3VnaChpZGVudGl0eVRyYW5zZm9ybSlcbiAgICAgIGZpbmFsQm9keSA9IHtcbiAgICAgICAgc291cmNlOiBpbnB1dEJvZHkuc291cmNlLFxuICAgICAgICBsZW5ndGg6IGlucHV0Qm9keS5sZW5ndGgsXG4gICAgICAgIHN0cmVhbTogaWRlbnRpdHlUcmFuc2Zvcm0ucmVhZGFibGVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0MS4gU2V0IHRoaXPigJlzIHJlcXVlc3TigJlzIGJvZHkgdG8gZmluYWxCb2R5LlxuICAgIHRoaXNba1N0YXRlXS5ib2R5ID0gZmluYWxCb2R5XG4gIH1cblxuICAvLyBSZXR1cm5zIHJlcXVlc3TigJlzIEhUVFAgbWV0aG9kLCB3aGljaCBpcyBcIkdFVFwiIGJ5IGRlZmF1bHQuXG4gIGdldCBtZXRob2QgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgbWV0aG9kIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIG1ldGhvZC5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLm1ldGhvZFxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgVVJMIG9mIHJlcXVlc3QgYXMgYSBzdHJpbmcuXG4gIGdldCB1cmwgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgdXJsIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIFVSTCwgc2VyaWFsaXplZC5cbiAgICByZXR1cm4gVVJMU2VyaWFsaXplcih0aGlzW2tTdGF0ZV0udXJsKVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIEhlYWRlcnMgb2JqZWN0IGNvbnNpc3Rpbmcgb2YgdGhlIGhlYWRlcnMgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QuXG4gIC8vIE5vdGUgdGhhdCBoZWFkZXJzIGFkZGVkIGluIHRoZSBuZXR3b3JrIGxheWVyIGJ5IHRoZSB1c2VyIGFnZW50IHdpbGwgbm90XG4gIC8vIGJlIGFjY291bnRlZCBmb3IgaW4gdGhpcyBvYmplY3QsIGUuZy4sIHRoZSBcIkhvc3RcIiBoZWFkZXIuXG4gIGdldCBoZWFkZXJzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIGhlYWRlcnMgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgaGVhZGVycy5cbiAgICByZXR1cm4gdGhpc1trSGVhZGVyc11cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGtpbmQgb2YgcmVzb3VyY2UgcmVxdWVzdGVkIGJ5IHJlcXVlc3QsIGUuZy4sIFwiZG9jdW1lbnRcIlxuICAvLyBvciBcInNjcmlwdFwiLlxuICBnZXQgZGVzdGluYXRpb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgZGVzdGluYXRpb24gZ2V0dGVyIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgZGVzdGluYXRpb24uXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5kZXN0aW5hdGlvblxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVmZXJyZXIgb2YgcmVxdWVzdC4gSXRzIHZhbHVlIGNhbiBiZSBhIHNhbWUtb3JpZ2luIFVSTCBpZlxuICAvLyBleHBsaWNpdGx5IHNldCBpbiBpbml0LCB0aGUgZW1wdHkgc3RyaW5nIHRvIGluZGljYXRlIG5vIHJlZmVycmVyLCBhbmRcbiAgLy8gXCJhYm91dDpjbGllbnRcIiB3aGVuIGRlZmF1bHRpbmcgdG8gdGhlIGdsb2JhbOKAmXMgZGVmYXVsdC4gVGhpcyBpcyB1c2VkXG4gIC8vIGR1cmluZyBmZXRjaGluZyB0byBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIHRoZSBgUmVmZXJlcmAgaGVhZGVyIG9mIHRoZVxuICAvLyByZXF1ZXN0IGJlaW5nIG1hZGUuXG4gIGdldCByZWZlcnJlciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIDEuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyIGlzIFwibm8tcmVmZXJyZXJcIiwgdGhlbiByZXR1cm4gdGhlXG4gICAgLy8gZW1wdHkgc3RyaW5nLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0ucmVmZXJyZXIgPT09ICduby1yZWZlcnJlcicpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIC8vIDIuIElmIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyIGlzIFwiY2xpZW50XCIsIHRoZW4gcmV0dXJuXG4gICAgLy8gXCJhYm91dDpjbGllbnRcIi5cbiAgICBpZiAodGhpc1trU3RhdGVdLnJlZmVycmVyID09PSAnY2xpZW50Jykge1xuICAgICAgcmV0dXJuICdhYm91dDpjbGllbnQnXG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVmZXJyZXIudG9TdHJpbmcoKVxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVmZXJyZXIgcG9saWN5IGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LlxuICAvLyBUaGlzIGlzIHVzZWQgZHVyaW5nIGZldGNoaW5nIHRvIGNvbXB1dGUgdGhlIHZhbHVlIG9mIHRoZSByZXF1ZXN04oCZc1xuICAvLyByZWZlcnJlci5cbiAgZ2V0IHJlZmVycmVyUG9saWN5ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIHJlZmVycmVyUG9saWN5IGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlZmVycmVyUG9saWN5XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBtb2RlIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LCB3aGljaCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nXG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3Qgd2lsbCB1c2UgQ09SUywgb3Igd2lsbCBiZSByZXN0cmljdGVkIHRvIHNhbWUtb3JpZ2luXG4gIC8vIFVSTHMuXG4gIGdldCBtb2RlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXF1ZXN0KVxuXG4gICAgLy8gVGhlIG1vZGUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgbW9kZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLm1vZGVcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGNyZWRlbnRpYWxzIG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsXG4gIC8vIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgd2hldGhlciBjcmVkZW50aWFscyB3aWxsIGJlIHNlbnQgd2l0aCB0aGVcbiAgLy8gcmVxdWVzdCBhbHdheXMsIG5ldmVyLCBvciBvbmx5IHdoZW4gc2VudCB0byBhIHNhbWUtb3JpZ2luIFVSTC5cbiAgZ2V0IGNyZWRlbnRpYWxzICgpIHtcbiAgICAvLyBUaGUgY3JlZGVudGlhbHMgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgY3JlZGVudGlhbHMgbW9kZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmNyZWRlbnRpYWxzXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBjYWNoZSBtb2RlIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LFxuICAvLyB3aGljaCBpcyBhIHN0cmluZyBpbmRpY2F0aW5nIGhvdyB0aGUgcmVxdWVzdCB3aWxsXG4gIC8vIGludGVyYWN0IHdpdGggdGhlIGJyb3dzZXLigJlzIGNhY2hlIHdoZW4gZmV0Y2hpbmcuXG4gIGdldCBjYWNoZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBjYWNoZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyByZXF1ZXN04oCZcyBjYWNoZSBtb2RlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uY2FjaGVcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIHJlZGlyZWN0IG1vZGUgYXNzb2NpYXRlZCB3aXRoIHJlcXVlc3QsXG4gIC8vIHdoaWNoIGlzIGEgc3RyaW5nIGluZGljYXRpbmcgaG93IHJlZGlyZWN0cyBmb3IgdGhlXG4gIC8vIHJlcXVlc3Qgd2lsbCBiZSBoYW5kbGVkIGR1cmluZyBmZXRjaGluZy4gQSByZXF1ZXN0XG4gIC8vIHdpbGwgZm9sbG93IHJlZGlyZWN0cyBieSBkZWZhdWx0LlxuICBnZXQgcmVkaXJlY3QgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgcmVkaXJlY3QgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMgcmVkaXJlY3QgbW9kZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnJlZGlyZWN0XG4gIH1cblxuICAvLyBSZXR1cm5zIHJlcXVlc3TigJlzIHN1YnJlc291cmNlIGludGVncml0eSBtZXRhZGF0YSwgd2hpY2ggaXMgYVxuICAvLyBjcnlwdG9ncmFwaGljIGhhc2ggb2YgdGhlIHJlc291cmNlIGJlaW5nIGZldGNoZWQuIEl0cyB2YWx1ZVxuICAvLyBjb25zaXN0cyBvZiBtdWx0aXBsZSBoYXNoZXMgc2VwYXJhdGVkIGJ5IHdoaXRlc3BhY2UuIFtTUkldXG4gIGdldCBpbnRlZ3JpdHkgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaW50ZWdyaXR5IGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlcXVlc3TigJlzIGludGVncml0eVxuICAgIC8vIG1ldGFkYXRhLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uaW50ZWdyaXR5XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgY2FuIG91dGxpdmUgdGhlXG4gIC8vIGdsb2JhbCBpbiB3aGljaCBpdCB3YXMgY3JlYXRlZC5cbiAgZ2V0IGtlZXBhbGl2ZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBrZWVwYWxpdmUgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVxdWVzdOKAmXMga2VlcGFsaXZlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ua2VlcGFsaXZlXG4gIH1cblxuICAvLyBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgb3Igbm90IHJlcXVlc3QgaXMgZm9yIGEgcmVsb2FkXG4gIC8vIG5hdmlnYXRpb24uXG4gIGdldCBpc1JlbG9hZE5hdmlnYXRpb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaXNSZWxvYWROYXZpZ2F0aW9uIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXNcbiAgICAvLyByZXF1ZXN04oCZcyByZWxvYWQtbmF2aWdhdGlvbiBmbGFnIGlzIHNldDsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0ucmVsb2FkTmF2aWdhdGlvblxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCByZXF1ZXN0IGlzIGZvciBhIGhpc3RvcnlcbiAgLy8gbmF2aWdhdGlvbiAoYS5rLmEuIGJhY2stZm9yd2FyZCBuYXZpZ2F0aW9uKS5cbiAgZ2V0IGlzSGlzdG9yeU5hdmlnYXRpb24gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlcXVlc3QpXG5cbiAgICAvLyBUaGUgaXNIaXN0b3J5TmF2aWdhdGlvbiBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoaXPigJlzIHJlcXVlc3TigJlzXG4gICAgLy8gaGlzdG9yeS1uYXZpZ2F0aW9uIGZsYWcgaXMgc2V0OyBvdGhlcndpc2UgZmFsc2UuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5oaXN0b3J5TmF2aWdhdGlvblxuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgc2lnbmFsIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0LCB3aGljaCBpcyBhbiBBYm9ydFNpZ25hbFxuICAvLyBvYmplY3QgaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQsIGFuZCBpdHNcbiAgLy8gYWJvcnQgZXZlbnQgaGFuZGxlci5cbiAgZ2V0IHNpZ25hbCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIFRoZSBzaWduYWwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgc2lnbmFsLlxuICAgIHJldHVybiB0aGlzW2tTaWduYWxdXG4gIH1cblxuICBnZXQgYm9keSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uYm9keSA/IHRoaXNba1N0YXRlXS5ib2R5LnN0cmVhbSA6IG51bGxcbiAgfVxuXG4gIGdldCBib2R5VXNlZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIHJldHVybiAhIXRoaXNba1N0YXRlXS5ib2R5ICYmIHV0aWwuaXNEaXN0dXJiZWQodGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtKVxuICB9XG5cbiAgZ2V0IGR1cGxleCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIHJldHVybiAnaGFsZidcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBjbG9uZSBvZiByZXF1ZXN0LlxuICBjbG9uZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVxdWVzdClcblxuICAgIC8vIDEuIElmIHRoaXMgaXMgdW51c2FibGUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKGJvZHlVbnVzYWJsZSh0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndW51c2FibGUnKVxuICAgIH1cblxuICAgIC8vIDIuIExldCBjbG9uZWRSZXF1ZXN0IGJlIHRoZSByZXN1bHQgb2YgY2xvbmluZyB0aGlz4oCZcyByZXF1ZXN0LlxuICAgIGNvbnN0IGNsb25lZFJlcXVlc3QgPSBjbG9uZVJlcXVlc3QodGhpc1trU3RhdGVdKVxuXG4gICAgLy8gMy4gTGV0IGNsb25lZFJlcXVlc3RPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlcXVlc3Qgb2JqZWN0LFxuICAgIC8vIGdpdmVuIGNsb25lZFJlcXVlc3QsIHRoaXPigJlzIGhlYWRlcnPigJlzIGd1YXJkLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgLy8gNC4gTWFrZSBjbG9uZWRSZXF1ZXN0T2JqZWN04oCZcyBzaWduYWwgZm9sbG93IHRoaXPigJlzIHNpZ25hbC5cbiAgICBjb25zdCBhYyA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgIGlmICh0aGlzLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBhYy5hYm9ydCh0aGlzLnNpZ25hbC5yZWFzb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsaXN0ID0gZGVwZW5kZW50Q29udHJvbGxlck1hcC5nZXQodGhpcy5zaWduYWwpXG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpc3QgPSBuZXcgU2V0KClcbiAgICAgICAgZGVwZW5kZW50Q29udHJvbGxlck1hcC5zZXQodGhpcy5zaWduYWwsIGxpc3QpXG4gICAgICB9XG4gICAgICBjb25zdCBhY1JlZiA9IG5ldyBXZWFrUmVmKGFjKVxuICAgICAgbGlzdC5hZGQoYWNSZWYpXG4gICAgICB1dGlsLmFkZEFib3J0TGlzdGVuZXIoXG4gICAgICAgIGFjLnNpZ25hbCxcbiAgICAgICAgYnVpbGRBYm9ydChhY1JlZilcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4gY2xvbmVkUmVxdWVzdE9iamVjdC5cbiAgICByZXR1cm4gZnJvbUlubmVyUmVxdWVzdChjbG9uZWRSZXF1ZXN0LCBhYy5zaWduYWwsIGdldEhlYWRlcnNHdWFyZCh0aGlzW2tIZWFkZXJzXSkpXG4gIH1cblxuICBbbm9kZVV0aWwuaW5zcGVjdC5jdXN0b21dIChkZXB0aCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRlcHRoID09PSBudWxsKSB7XG4gICAgICBvcHRpb25zLmRlcHRoID0gMlxuICAgIH1cblxuICAgIG9wdGlvbnMuY29sb3JzID8/PSB0cnVlXG5cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBkZXN0aW5hdGlvbjogdGhpcy5kZXN0aW5hdGlvbixcbiAgICAgIHJlZmVycmVyOiB0aGlzLnJlZmVycmVyLFxuICAgICAgcmVmZXJyZXJQb2xpY3k6IHRoaXMucmVmZXJyZXJQb2xpY3ksXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBjcmVkZW50aWFsczogdGhpcy5jcmVkZW50aWFscyxcbiAgICAgIGNhY2hlOiB0aGlzLmNhY2hlLFxuICAgICAgcmVkaXJlY3Q6IHRoaXMucmVkaXJlY3QsXG4gICAgICBpbnRlZ3JpdHk6IHRoaXMuaW50ZWdyaXR5LFxuICAgICAga2VlcGFsaXZlOiB0aGlzLmtlZXBhbGl2ZSxcbiAgICAgIGlzUmVsb2FkTmF2aWdhdGlvbjogdGhpcy5pc1JlbG9hZE5hdmlnYXRpb24sXG4gICAgICBpc0hpc3RvcnlOYXZpZ2F0aW9uOiB0aGlzLmlzSGlzdG9yeU5hdmlnYXRpb24sXG4gICAgICBzaWduYWw6IHRoaXMuc2lnbmFsXG4gICAgfVxuXG4gICAgcmV0dXJuIGBSZXF1ZXN0ICR7bm9kZVV0aWwuZm9ybWF0V2l0aE9wdGlvbnMob3B0aW9ucywgcHJvcGVydGllcyl9YFxuICB9XG59XG5cbm1peGluQm9keShSZXF1ZXN0KVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdHNcbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0IChpbml0KSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBpbml0Lm1ldGhvZCA/PyAnR0VUJyxcbiAgICBsb2NhbFVSTHNPbmx5OiBpbml0LmxvY2FsVVJMc09ubHkgPz8gZmFsc2UsXG4gICAgdW5zYWZlUmVxdWVzdDogaW5pdC51bnNhZmVSZXF1ZXN0ID8/IGZhbHNlLFxuICAgIGJvZHk6IGluaXQuYm9keSA/PyBudWxsLFxuICAgIGNsaWVudDogaW5pdC5jbGllbnQgPz8gbnVsbCxcbiAgICByZXNlcnZlZENsaWVudDogaW5pdC5yZXNlcnZlZENsaWVudCA/PyBudWxsLFxuICAgIHJlcGxhY2VzQ2xpZW50SWQ6IGluaXQucmVwbGFjZXNDbGllbnRJZCA/PyAnJyxcbiAgICB3aW5kb3c6IGluaXQud2luZG93ID8/ICdjbGllbnQnLFxuICAgIGtlZXBhbGl2ZTogaW5pdC5rZWVwYWxpdmUgPz8gZmFsc2UsXG4gICAgc2VydmljZVdvcmtlcnM6IGluaXQuc2VydmljZVdvcmtlcnMgPz8gJ2FsbCcsXG4gICAgaW5pdGlhdG9yOiBpbml0LmluaXRpYXRvciA/PyAnJyxcbiAgICBkZXN0aW5hdGlvbjogaW5pdC5kZXN0aW5hdGlvbiA/PyAnJyxcbiAgICBwcmlvcml0eTogaW5pdC5wcmlvcml0eSA/PyBudWxsLFxuICAgIG9yaWdpbjogaW5pdC5vcmlnaW4gPz8gJ2NsaWVudCcsXG4gICAgcG9saWN5Q29udGFpbmVyOiBpbml0LnBvbGljeUNvbnRhaW5lciA/PyAnY2xpZW50JyxcbiAgICByZWZlcnJlcjogaW5pdC5yZWZlcnJlciA/PyAnY2xpZW50JyxcbiAgICByZWZlcnJlclBvbGljeTogaW5pdC5yZWZlcnJlclBvbGljeSA/PyAnJyxcbiAgICBtb2RlOiBpbml0Lm1vZGUgPz8gJ25vLWNvcnMnLFxuICAgIHVzZUNPUlNQcmVmbGlnaHRGbGFnOiBpbml0LnVzZUNPUlNQcmVmbGlnaHRGbGFnID8/IGZhbHNlLFxuICAgIGNyZWRlbnRpYWxzOiBpbml0LmNyZWRlbnRpYWxzID8/ICdzYW1lLW9yaWdpbicsXG4gICAgdXNlQ3JlZGVudGlhbHM6IGluaXQudXNlQ3JlZGVudGlhbHMgPz8gZmFsc2UsXG4gICAgY2FjaGU6IGluaXQuY2FjaGUgPz8gJ2RlZmF1bHQnLFxuICAgIHJlZGlyZWN0OiBpbml0LnJlZGlyZWN0ID8/ICdmb2xsb3cnLFxuICAgIGludGVncml0eTogaW5pdC5pbnRlZ3JpdHkgPz8gJycsXG4gICAgY3J5cHRvR3JhcGhpY3NOb25jZU1ldGFkYXRhOiBpbml0LmNyeXB0b0dyYXBoaWNzTm9uY2VNZXRhZGF0YSA/PyAnJyxcbiAgICBwYXJzZXJNZXRhZGF0YTogaW5pdC5wYXJzZXJNZXRhZGF0YSA/PyAnJyxcbiAgICByZWxvYWROYXZpZ2F0aW9uOiBpbml0LnJlbG9hZE5hdmlnYXRpb24gPz8gZmFsc2UsXG4gICAgaGlzdG9yeU5hdmlnYXRpb246IGluaXQuaGlzdG9yeU5hdmlnYXRpb24gPz8gZmFsc2UsXG4gICAgdXNlckFjdGl2YXRpb246IGluaXQudXNlckFjdGl2YXRpb24gPz8gZmFsc2UsXG4gICAgdGFpbnRlZE9yaWdpbjogaW5pdC50YWludGVkT3JpZ2luID8/IGZhbHNlLFxuICAgIHJlZGlyZWN0Q291bnQ6IGluaXQucmVkaXJlY3RDb3VudCA/PyAwLFxuICAgIHJlc3BvbnNlVGFpbnRpbmc6IGluaXQucmVzcG9uc2VUYWludGluZyA/PyAnYmFzaWMnLFxuICAgIHByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uOiBpbml0LnByZXZlbnROb0NhY2hlQ2FjaGVDb250cm9sSGVhZGVyTW9kaWZpY2F0aW9uID8/IGZhbHNlLFxuICAgIGRvbmU6IGluaXQuZG9uZSA/PyBmYWxzZSxcbiAgICB0aW1pbmdBbGxvd0ZhaWxlZDogaW5pdC50aW1pbmdBbGxvd0ZhaWxlZCA/PyBmYWxzZSxcbiAgICB1cmxMaXN0OiBpbml0LnVybExpc3QsXG4gICAgdXJsOiBpbml0LnVybExpc3RbMF0sXG4gICAgaGVhZGVyc0xpc3Q6IGluaXQuaGVhZGVyc0xpc3RcbiAgICAgID8gbmV3IEhlYWRlcnNMaXN0KGluaXQuaGVhZGVyc0xpc3QpXG4gICAgICA6IG5ldyBIZWFkZXJzTGlzdCgpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1jbG9uZVxuZnVuY3Rpb24gY2xvbmVSZXF1ZXN0IChyZXF1ZXN0KSB7XG4gIC8vIFRvIGNsb25lIGEgcmVxdWVzdCByZXF1ZXN0LCBydW4gdGhlc2Ugc3RlcHM6XG5cbiAgLy8gMS4gTGV0IG5ld1JlcXVlc3QgYmUgYSBjb3B5IG9mIHJlcXVlc3QsIGV4Y2VwdCBmb3IgaXRzIGJvZHkuXG4gIGNvbnN0IG5ld1JlcXVlc3QgPSBtYWtlUmVxdWVzdCh7IC4uLnJlcXVlc3QsIGJvZHk6IG51bGwgfSlcblxuICAvLyAyLiBJZiByZXF1ZXN04oCZcyBib2R5IGlzIG5vbi1udWxsLCBzZXQgbmV3UmVxdWVzdOKAmXMgYm9keSB0byB0aGVcbiAgLy8gcmVzdWx0IG9mIGNsb25pbmcgcmVxdWVzdOKAmXMgYm9keS5cbiAgaWYgKHJlcXVlc3QuYm9keSAhPSBudWxsKSB7XG4gICAgbmV3UmVxdWVzdC5ib2R5ID0gY2xvbmVCb2R5KG5ld1JlcXVlc3QsIHJlcXVlc3QuYm9keSlcbiAgfVxuXG4gIC8vIDMuIFJldHVybiBuZXdSZXF1ZXN0LlxuICByZXR1cm4gbmV3UmVxdWVzdFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3QtY3JlYXRlXG4gKiBAcGFyYW0ge2FueX0gaW5uZXJSZXF1ZXN0XG4gKiBAcGFyYW0ge0Fib3J0U2lnbmFsfSBzaWduYWxcbiAqIEBwYXJhbSB7J3JlcXVlc3QnIHwgJ2ltbXV0YWJsZScgfCAncmVxdWVzdC1uby1jb3JzJyB8ICdyZXNwb25zZScgfCAnbm9uZSd9IGd1YXJkXG4gKiBAcmV0dXJucyB7UmVxdWVzdH1cbiAqL1xuZnVuY3Rpb24gZnJvbUlubmVyUmVxdWVzdCAoaW5uZXJSZXF1ZXN0LCBzaWduYWwsIGd1YXJkKSB7XG4gIGNvbnN0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChrQ29uc3RydWN0KVxuICByZXF1ZXN0W2tTdGF0ZV0gPSBpbm5lclJlcXVlc3RcbiAgcmVxdWVzdFtrU2lnbmFsXSA9IHNpZ25hbFxuICByZXF1ZXN0W2tIZWFkZXJzXSA9IG5ldyBIZWFkZXJzKGtDb25zdHJ1Y3QpXG4gIHNldEhlYWRlcnNMaXN0KHJlcXVlc3Rba0hlYWRlcnNdLCBpbm5lclJlcXVlc3QuaGVhZGVyc0xpc3QpXG4gIHNldEhlYWRlcnNHdWFyZChyZXF1ZXN0W2tIZWFkZXJzXSwgZ3VhcmQpXG4gIHJldHVybiByZXF1ZXN0XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlcXVlc3QucHJvdG90eXBlLCB7XG4gIG1ldGhvZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvbmU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHNpZ25hbDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZHVwbGV4OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBkZXN0aW5hdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keVVzZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGlzSGlzdG9yeU5hdmlnYXRpb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGlzUmVsb2FkTmF2aWdhdGlvbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAga2VlcGFsaXZlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBpbnRlZ3JpdHk6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNhY2hlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjcmVkZW50aWFsczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYXR0cmlidXRlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWZlcnJlclBvbGljeToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVmZXJyZXI6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG1vZGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdSZXF1ZXN0JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIFJlcXVlc3RcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RpbmZvXG53ZWJpZGwuY29udmVydGVycy5SZXF1ZXN0SW5mbyA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIGlmICh0eXBlb2YgViA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKFYsIHByZWZpeCwgYXJndW1lbnQpXG4gIH1cblxuICBpZiAoViBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdChWLCBwcmVmaXgsIGFyZ3VtZW50KVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWLCBwcmVmaXgsIGFyZ3VtZW50KVxufVxuXG53ZWJpZGwuY29udmVydGVycy5BYm9ydFNpZ25hbCA9IHdlYmlkbC5pbnRlcmZhY2VDb252ZXJ0ZXIoXG4gIEFib3J0U2lnbmFsXG4pXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuUmVxdWVzdEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdtZXRob2QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAnaGVhZGVycycsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdFxuICB9LFxuICB7XG4gICAga2V5OiAnYm9keScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIoXG4gICAgICB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdFxuICAgIClcbiAgfSxcbiAge1xuICAgIGtleTogJ3JlZmVycmVyJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZ1xuICB9LFxuICB7XG4gICAga2V5OiAncmVmZXJyZXJQb2xpY3knLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNyZWZlcnJlci1wb2xpY3lcbiAgICBhbGxvd2VkVmFsdWVzOiByZWZlcnJlclBvbGljeVxuICB9LFxuICB7XG4gICAga2V5OiAnbW9kZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVxdWVzdC1tb2RlXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdE1vZGVcbiAgfSxcbiAge1xuICAgIGtleTogJ2NyZWRlbnRpYWxzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGNyZWRlbnRpYWxzXG4gICAgYWxsb3dlZFZhbHVlczogcmVxdWVzdENyZWRlbnRpYWxzXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYWNoZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcsXG4gICAgLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3JlcXVlc3RjYWNoZVxuICAgIGFsbG93ZWRWYWx1ZXM6IHJlcXVlc3RDYWNoZVxuICB9LFxuICB7XG4gICAga2V5OiAncmVkaXJlY3QnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0cmVkaXJlY3RcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0UmVkaXJlY3RcbiAgfSxcbiAge1xuICAgIGtleTogJ2ludGVncml0eScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmdcbiAgfSxcbiAge1xuICAgIGtleTogJ2tlZXBhbGl2ZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzaWduYWwnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLm51bGxhYmxlQ29udmVydGVyKFxuICAgICAgKHNpZ25hbCkgPT4gd2ViaWRsLmNvbnZlcnRlcnMuQWJvcnRTaWduYWwoXG4gICAgICAgIHNpZ25hbCxcbiAgICAgICAgJ1JlcXVlc3RJbml0JyxcbiAgICAgICAgJ3NpZ25hbCcsXG4gICAgICAgIHsgc3RyaWN0OiBmYWxzZSB9XG4gICAgICApXG4gICAgKVxuICB9LFxuICB7XG4gICAga2V5OiAnd2luZG93JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmFueVxuICB9LFxuICB7XG4gICAga2V5OiAnZHVwbGV4JyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBhbGxvd2VkVmFsdWVzOiByZXF1ZXN0RHVwbGV4XG4gIH0sXG4gIHtcbiAgICBrZXk6ICdkaXNwYXRjaGVyJywgLy8gdW5kaWNpIHNwZWNpZmljIG9wdGlvblxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0geyBSZXF1ZXN0LCBtYWtlUmVxdWVzdCwgZnJvbUlubmVyUmVxdWVzdCwgY2xvbmVSZXF1ZXN0IH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/request.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/response.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/response.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Headers, HeadersList, fill, getHeadersGuard, setHeadersGuard, setHeadersList } = __webpack_require__(/*! ./headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { extractBody, cloneBody, mixinBody, hasFinalizationRegistry, streamRegistry, bodyUnusable } = __webpack_require__(/*! ./body */ \"(rsc)/./node_modules/undici/lib/web/fetch/body.js\")\nconst util = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst nodeUtil = __webpack_require__(/*! node:util */ \"node:util\")\nconst { kEnumerableProperty } = util\nconst {\n  isValidReasonPhrase,\n  isCancelled,\n  isAborted,\n  isBlobLike,\n  serializeJavascriptValueToJSONString,\n  isErrorLike,\n  isomorphicEncode,\n  environmentSettingsObject: relevantRealm\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst {\n  redirectStatusSet,\n  nullBodyStatus\n} = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { kState, kHeaders } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/fetch/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { FormData } = __webpack_require__(/*! ./formdata */ \"(rsc)/./node_modules/undici/lib/web/fetch/formdata.js\")\nconst { URLSerializer } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\")\n\nconst textEncoder = new TextEncoder('utf-8')\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = fromInnerResponse(makeNetworkError(), 'immutable')\n\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response-json\n  static json (data, init = {}) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.json')\n\n    if (init !== null) {\n      init = webidl.converters.ResponseInit(init)\n    }\n\n    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.\n    const bytes = textEncoder.encode(\n      serializeJavascriptValueToJSONString(data)\n    )\n\n    // 2. Let body be the result of extracting bytes.\n    const body = extractBody(bytes)\n\n    // 3. Let responseObject be the result of creating a Response object, given a new response,\n    //    \"response\", and this’s relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'response')\n\n    // 4. Perform initialize a response given responseObject, init, and (body, \"application/json\").\n    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })\n\n    // 5. Return responseObject.\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (url, status = 302) {\n    webidl.argumentLengthCheck(arguments, 1, 'Response.redirect')\n\n    url = webidl.converters.USVString(url)\n    status = webidl.converters['unsigned short'](status)\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url, relevantRealm.settingsObject.baseUrl)\n    } catch (err) {\n      throw new TypeError(`Failed to parse URL from ${url}`, { cause: err })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatusSet.has(status)) {\n      throw new RangeError(`Invalid status code ${status}`)\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = fromInnerResponse(makeResponse({}), 'immutable')\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    const value = isomorphicEncode(URLSerializer(parsedURL))\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.append('location', value, true)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (body = null, init = {}) {\n    webidl.util.markAsUncloneable(this)\n    if (body === kConstruct) {\n      return\n    }\n\n    if (body !== null) {\n      body = webidl.converters.BodyInit(body)\n    }\n\n    init = webidl.converters.ResponseInit(init)\n\n    // 1. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 2. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers(kConstruct)\n    setHeadersGuard(this[kHeaders], 'response')\n    setHeadersList(this[kHeaders], this[kState].headersList)\n\n    // 3. Let bodyWithType be null.\n    let bodyWithType = null\n\n    // 4. If body is non-null, then set bodyWithType to the result of extracting body.\n    if (body != null) {\n      const [extractedBody, type] = extractBody(body)\n      bodyWithType = { body: extractedBody, type }\n    }\n\n    // 5. Perform initialize a response given this, init, and bodyWithType.\n    initializeResponse(this, init, bodyWithType)\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    webidl.brandCheck(this, Response)\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    webidl.brandCheck(this, Response)\n\n    const urlList = this[kState].urlList\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    const url = urlList[urlList.length - 1] ?? null\n\n    if (url === null) {\n      return ''\n    }\n\n    return URLSerializer(url, true)\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    webidl.brandCheck(this, Response)\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    webidl.brandCheck(this, Response)\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    webidl.brandCheck(this, Response)\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    webidl.brandCheck(this, Response)\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    webidl.brandCheck(this, Response)\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  get body () {\n    webidl.brandCheck(this, Response)\n\n    return this[kState].body ? this[kState].body.stream : null\n  }\n\n  get bodyUsed () {\n    webidl.brandCheck(this, Response)\n\n    return !!this[kState].body && util.isDisturbed(this[kState].body.stream)\n  }\n\n  // Returns a clone of response.\n  clone () {\n    webidl.brandCheck(this, Response)\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (bodyUnusable(this)) {\n      throw webidl.errors.exception({\n        header: 'Response.clone',\n        message: 'Body has already been consumed.'\n      })\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    return fromInnerResponse(clonedResponse, getHeadersGuard(this[kHeaders]))\n  }\n\n  [nodeUtil.inspect.custom] (depth, options) {\n    if (options.depth === null) {\n      options.depth = 2\n    }\n\n    options.colors ??= true\n\n    const properties = {\n      status: this.status,\n      statusText: this.statusText,\n      headers: this.headers,\n      body: this.body,\n      bodyUsed: this.bodyUsed,\n      ok: this.ok,\n      redirected: this.redirected,\n      type: this.type,\n      url: this.url\n    }\n\n    return `Response ${nodeUtil.formatWithOptions(options, properties)}`\n  }\n}\n\nmixinBody(Response)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  body: kEnumerableProperty,\n  bodyUsed: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'Response',\n    configurable: true\n  }\n})\n\nObject.defineProperties(Response, {\n  json: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(newResponse, response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    requestIncludesCredentials: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init?.headersList\n      ? new HeadersList(init?.headersList)\n      : new HeadersList(),\n    urlList: init?.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  const isError = isErrorLike(reason)\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: isError\n      ? reason\n      : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\n// @see https://fetch.spec.whatwg.org/#concept-network-error\nfunction isNetworkError (response) {\n  return (\n    // A network error is a response whose type is \"error\",\n    response.type === 'error' &&\n    // status is 0\n    response.status === 0\n  )\n}\n\nfunction makeFilteredResponse (response, state) {\n  state = {\n    internalResponse: response,\n    ...state\n  }\n\n  return new Proxy(response, {\n    get (target, p) {\n      return p in state ? state[p] : target[p]\n    },\n    set (target, p, value) {\n      assert(!(p in state))\n      target[p] = value\n      return true\n    }\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    // Note: undici does not implement forbidden response-header names\n    return makeFilteredResponse(response, {\n      type: 'basic',\n      headersList: response.headersList\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // Note: undici does not implement CORS-safelisted response-header names\n    return makeFilteredResponse(response, {\n      type: 'cors',\n      headersList: response.headersList\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaque',\n      urlList: Object.freeze([]),\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeFilteredResponse(response, {\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: [],\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#appropriate-network-error\nfunction makeAppropriateNetworkError (fetchParams, err = null) {\n  // 1. Assert: fetchParams is canceled.\n  assert(isCancelled(fetchParams))\n\n  // 2. Return an aborted network error if fetchParams is aborted;\n  // otherwise return a network error.\n  return isAborted(fetchParams)\n    ? makeNetworkError(Object.assign(new DOMException('The operation was aborted.', 'AbortError'), { cause: err }))\n    : makeNetworkError(Object.assign(new DOMException('Request was cancelled.'), { cause: err }))\n}\n\n// https://whatpr.org/fetch/1392.html#initialize-a-response\nfunction initializeResponse (response, init, body) {\n  // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n  //    throw a RangeError.\n  if (init.status !== null && (init.status < 200 || init.status > 599)) {\n    throw new RangeError('init[\"status\"] must be in the range of 200 to 599, inclusive.')\n  }\n\n  // 2. If init[\"statusText\"] does not match the reason-phrase token production,\n  //    then throw a TypeError.\n  if ('statusText' in init && init.statusText != null) {\n    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n    if (!isValidReasonPhrase(String(init.statusText))) {\n      throw new TypeError('Invalid statusText')\n    }\n  }\n\n  // 3. Set response’s response’s status to init[\"status\"].\n  if ('status' in init && init.status != null) {\n    response[kState].status = init.status\n  }\n\n  // 4. Set response’s response’s status message to init[\"statusText\"].\n  if ('statusText' in init && init.statusText != null) {\n    response[kState].statusText = init.statusText\n  }\n\n  // 5. If init[\"headers\"] exists, then fill response’s headers with init[\"headers\"].\n  if ('headers' in init && init.headers != null) {\n    fill(response[kHeaders], init.headers)\n  }\n\n  // 6. If body was given, then:\n  if (body) {\n    // 1. If response's status is a null body status, then throw a TypeError.\n    if (nullBodyStatus.includes(response.status)) {\n      throw webidl.errors.exception({\n        header: 'Response constructor',\n        message: `Invalid response status code ${response.status}`\n      })\n    }\n\n    // 2. Set response's body to body's body.\n    response[kState].body = body.body\n\n    // 3. If body's type is non-null and response's header list does not contain\n    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.\n    if (body.type != null && !response[kState].headersList.contains('content-type', true)) {\n      response[kState].headersList.append('content-type', body.type, true)\n    }\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#response-create\n * @param {any} innerResponse\n * @param {'request' | 'immutable' | 'request-no-cors' | 'response' | 'none'} guard\n * @returns {Response}\n */\nfunction fromInnerResponse (innerResponse, guard) {\n  const response = new Response(kConstruct)\n  response[kState] = innerResponse\n  response[kHeaders] = new Headers(kConstruct)\n  setHeadersList(response[kHeaders], innerResponse.headersList)\n  setHeadersGuard(response[kHeaders], guard)\n\n  if (hasFinalizationRegistry && innerResponse.body?.stream) {\n    // If the target (response) is reclaimed, the cleanup callback may be called at some point with\n    // the held value provided for it (innerResponse.body.stream). The held value can be any value:\n    // a primitive or an object, even undefined. If the held value is an object, the registry keeps\n    // a strong reference to it (so it can pass it to the cleanup callback later). Reworded from\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n    streamRegistry.register(response, new WeakRef(innerResponse.body.stream))\n  }\n\n  return response\n}\n\nwebidl.converters.ReadableStream = webidl.interfaceConverter(\n  ReadableStream\n)\n\nwebidl.converters.FormData = webidl.interfaceConverter(\n  FormData\n)\n\nwebidl.converters.URLSearchParams = webidl.interfaceConverter(\n  URLSearchParams\n)\n\n// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit\nwebidl.converters.XMLHttpRequestBodyInit = function (V, prefix, name) {\n  if (typeof V === 'string') {\n    return webidl.converters.USVString(V, prefix, name)\n  }\n\n  if (isBlobLike(V)) {\n    return webidl.converters.Blob(V, prefix, name, { strict: false })\n  }\n\n  if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n    return webidl.converters.BufferSource(V, prefix, name)\n  }\n\n  if (util.isFormDataLike(V)) {\n    return webidl.converters.FormData(V, prefix, name, { strict: false })\n  }\n\n  if (V instanceof URLSearchParams) {\n    return webidl.converters.URLSearchParams(V, prefix, name)\n  }\n\n  return webidl.converters.DOMString(V, prefix, name)\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit\nwebidl.converters.BodyInit = function (V, prefix, argument) {\n  if (V instanceof ReadableStream) {\n    return webidl.converters.ReadableStream(V, prefix, argument)\n  }\n\n  // Note: the spec doesn't include async iterables,\n  // this is an undici extension.\n  if (V?.[Symbol.asyncIterator]) {\n    return V\n  }\n\n  return webidl.converters.XMLHttpRequestBodyInit(V, prefix, argument)\n}\n\nwebidl.converters.ResponseInit = webidl.dictionaryConverter([\n  {\n    key: 'status',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 200\n  },\n  {\n    key: 'statusText',\n    converter: webidl.converters.ByteString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'headers',\n    converter: webidl.converters.HeadersInit\n  }\n])\n\nmodule.exports = {\n  isNetworkError,\n  makeNetworkError,\n  makeResponse,\n  makeAppropriateNetworkError,\n  filterResponse,\n  Response,\n  cloneResponse,\n  fromInnerResponse\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvcmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSwrRUFBK0UsRUFBRSxtQkFBTyxDQUFDLHVFQUFXO0FBQzVHLFFBQVEsMkZBQTJGLEVBQUUsbUJBQU8sQ0FBQyxpRUFBUTtBQUNySCxhQUFhLG1CQUFPLENBQUMscUVBQWlCO0FBQ3RDLGlCQUFpQixtQkFBTyxDQUFDLDRCQUFXO0FBQ3BDLFFBQVEsc0JBQXNCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLGlFQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFhO0FBQ3pCLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyx1RUFBVztBQUNoRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHFFQUFVO0FBQ3JDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMseUVBQVk7QUFDekMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLHlFQUFZO0FBQzlDLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25ELGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLFFBQVEsRUFBRSxtQkFBTyxDQUFDLDRCQUFXOztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQSwrQ0FBK0MseUNBQXlDOztBQUV4RjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxtRUFBbUU7QUFDOUUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELGVBQWU7QUFDcEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlELGVBQWU7QUFDeEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmV0Y2hcXHJlc3BvbnNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEhlYWRlcnMsIEhlYWRlcnNMaXN0LCBmaWxsLCBnZXRIZWFkZXJzR3VhcmQsIHNldEhlYWRlcnNHdWFyZCwgc2V0SGVhZGVyc0xpc3QgfSA9IHJlcXVpcmUoJy4vaGVhZGVycycpXG5jb25zdCB7IGV4dHJhY3RCb2R5LCBjbG9uZUJvZHksIG1peGluQm9keSwgaGFzRmluYWxpemF0aW9uUmVnaXN0cnksIHN0cmVhbVJlZ2lzdHJ5LCBib2R5VW51c2FibGUgfSA9IHJlcXVpcmUoJy4vYm9keScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IG5vZGVVdGlsID0gcmVxdWlyZSgnbm9kZTp1dGlsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gdXRpbFxuY29uc3Qge1xuICBpc1ZhbGlkUmVhc29uUGhyYXNlLFxuICBpc0NhbmNlbGxlZCxcbiAgaXNBYm9ydGVkLFxuICBpc0Jsb2JMaWtlLFxuICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcsXG4gIGlzRXJyb3JMaWtlLFxuICBpc29tb3JwaGljRW5jb2RlLFxuICBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0OiByZWxldmFudFJlYWxtXG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHtcbiAgcmVkaXJlY3RTdGF0dXNTZXQsXG4gIG51bGxCb2R5U3RhdHVzXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBrU3RhdGUsIGtIZWFkZXJzIH0gPSByZXF1aXJlKCcuL3N5bWJvbHMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcbmNvbnN0IHsgRm9ybURhdGEgfSA9IHJlcXVpcmUoJy4vZm9ybWRhdGEnKVxuY29uc3QgeyBVUkxTZXJpYWxpemVyIH0gPSByZXF1aXJlKCcuL2RhdGEtdXJsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgdHlwZXMgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCd1dGYtOCcpXG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzc1xuY2xhc3MgUmVzcG9uc2Uge1xuICAvLyBDcmVhdGVzIG5ldHdvcmsgZXJyb3IgUmVzcG9uc2UuXG4gIHN0YXRpYyBlcnJvciAoKSB7XG4gICAgLy8gVGhlIHN0YXRpYyBlcnJvcigpIG1ldGhvZCBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYVxuICAgIC8vIFJlc3BvbnNlIG9iamVjdCwgZ2l2ZW4gYSBuZXcgbmV0d29yayBlcnJvciwgXCJpbW11dGFibGVcIiwgYW5kIHRoaXPigJlzXG4gICAgLy8gcmVsZXZhbnQgUmVhbG0uXG4gICAgY29uc3QgcmVzcG9uc2VPYmplY3QgPSBmcm9tSW5uZXJSZXNwb25zZShtYWtlTmV0d29ya0Vycm9yKCksICdpbW11dGFibGUnKVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlc3BvbnNlLWpzb25cbiAgc3RhdGljIGpzb24gKGRhdGEsIGluaXQgPSB7fSkge1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ1Jlc3BvbnNlLmpzb24nKVxuXG4gICAgaWYgKGluaXQgIT09IG51bGwpIHtcbiAgICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdClcbiAgICB9XG5cbiAgICAvLyAxLiBMZXQgYnl0ZXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIHNlcmlhbGl6ZSBhIEphdmFTY3JpcHQgdmFsdWUgdG8gSlNPTiBieXRlcyBvbiBkYXRhLlxuICAgIGNvbnN0IGJ5dGVzID0gdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgc2VyaWFsaXplSmF2YXNjcmlwdFZhbHVlVG9KU09OU3RyaW5nKGRhdGEpXG4gICAgKVxuXG4gICAgLy8gMi4gTGV0IGJvZHkgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGJ5dGVzLlxuICAgIGNvbnN0IGJvZHkgPSBleHRyYWN0Qm9keShieXRlcylcblxuICAgIC8vIDMuIExldCByZXNwb25zZU9iamVjdCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGEgUmVzcG9uc2Ugb2JqZWN0LCBnaXZlbiBhIG5ldyByZXNwb25zZSxcbiAgICAvLyAgICBcInJlc3BvbnNlXCIsIGFuZCB0aGlz4oCZcyByZWxldmFudCBSZWFsbS5cbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IGZyb21Jbm5lclJlc3BvbnNlKG1ha2VSZXNwb25zZSh7fSksICdyZXNwb25zZScpXG5cbiAgICAvLyA0LiBQZXJmb3JtIGluaXRpYWxpemUgYSByZXNwb25zZSBnaXZlbiByZXNwb25zZU9iamVjdCwgaW5pdCwgYW5kIChib2R5LCBcImFwcGxpY2F0aW9uL2pzb25cIikuXG4gICAgaW5pdGlhbGl6ZVJlc3BvbnNlKHJlc3BvbnNlT2JqZWN0LCBpbml0LCB7IGJvZHk6IGJvZHlbMF0sIHR5cGU6ICdhcHBsaWNhdGlvbi9qc29uJyB9KVxuXG4gICAgLy8gNS4gUmV0dXJuIHJlc3BvbnNlT2JqZWN0LlxuICAgIHJldHVybiByZXNwb25zZU9iamVjdFxuICB9XG5cbiAgLy8gQ3JlYXRlcyBhIHJlZGlyZWN0IFJlc3BvbnNlIHRoYXQgcmVkaXJlY3RzIHRvIHVybCB3aXRoIHN0YXR1cyBzdGF0dXMuXG4gIHN0YXRpYyByZWRpcmVjdCAodXJsLCBzdGF0dXMgPSAzMDIpIHtcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdSZXNwb25zZS5yZWRpcmVjdCcpXG5cbiAgICB1cmwgPSB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcodXJsKVxuICAgIHN0YXR1cyA9IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBzaG9ydCddKHN0YXR1cylcblxuICAgIC8vIDEuIExldCBwYXJzZWRVUkwgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHVybCB3aXRoIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAvLyBvYmplY3TigJlzIEFQSSBiYXNlIFVSTC5cbiAgICAvLyAyLiBJZiBwYXJzZWRVUkwgaXMgZmFpbHVyZSwgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICAvLyBUT0RPOiBiYXNlLVVSTD9cbiAgICBsZXQgcGFyc2VkVVJMXG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVSTCA9IG5ldyBVUkwodXJsLCByZWxldmFudFJlYWxtLnNldHRpbmdzT2JqZWN0LmJhc2VVcmwpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBGYWlsZWQgdG8gcGFyc2UgVVJMIGZyb20gJHt1cmx9YCwgeyBjYXVzZTogZXJyIH0pXG4gICAgfVxuXG4gICAgLy8gMy4gSWYgc3RhdHVzIGlzIG5vdCBhIHJlZGlyZWN0IHN0YXR1cywgdGhlbiB0aHJvdyBhIFJhbmdlRXJyb3IuXG4gICAgaWYgKCFyZWRpcmVjdFN0YXR1c1NldC5oYXMoc3RhdHVzKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgc3RhdHVzIGNvZGUgJHtzdGF0dXN9YClcbiAgICB9XG5cbiAgICAvLyA0LiBMZXQgcmVzcG9uc2VPYmplY3QgYmUgdGhlIHJlc3VsdCBvZiBjcmVhdGluZyBhIFJlc3BvbnNlIG9iamVjdCxcbiAgICAvLyBnaXZlbiBhIG5ldyByZXNwb25zZSwgXCJpbW11dGFibGVcIiwgYW5kIHRoaXPigJlzIHJlbGV2YW50IFJlYWxtLlxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0gZnJvbUlubmVyUmVzcG9uc2UobWFrZVJlc3BvbnNlKHt9KSwgJ2ltbXV0YWJsZScpXG5cbiAgICAvLyA1LiBTZXQgcmVzcG9uc2VPYmplY3TigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gc3RhdHVzLlxuICAgIHJlc3BvbnNlT2JqZWN0W2tTdGF0ZV0uc3RhdHVzID0gc3RhdHVzXG5cbiAgICAvLyA2LiBMZXQgdmFsdWUgYmUgcGFyc2VkVVJMLCBzZXJpYWxpemVkIGFuZCBpc29tb3JwaGljIGVuY29kZWQuXG4gICAgY29uc3QgdmFsdWUgPSBpc29tb3JwaGljRW5jb2RlKFVSTFNlcmlhbGl6ZXIocGFyc2VkVVJMKSlcblxuICAgIC8vIDcuIEFwcGVuZCBgTG9jYXRpb25gL3ZhbHVlIHRvIHJlc3BvbnNlT2JqZWN04oCZcyByZXNwb25zZeKAmXMgaGVhZGVyIGxpc3QuXG4gICAgcmVzcG9uc2VPYmplY3Rba1N0YXRlXS5oZWFkZXJzTGlzdC5hcHBlbmQoJ2xvY2F0aW9uJywgdmFsdWUsIHRydWUpXG5cbiAgICAvLyA4LiBSZXR1cm4gcmVzcG9uc2VPYmplY3QuXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0XG4gIH1cblxuICAvLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jZG9tLXJlc3BvbnNlXG4gIGNvbnN0cnVjdG9yIChib2R5ID0gbnVsbCwgaW5pdCA9IHt9KSB7XG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcbiAgICBpZiAoYm9keSA9PT0ga0NvbnN0cnVjdCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGJvZHkgIT09IG51bGwpIHtcbiAgICAgIGJvZHkgPSB3ZWJpZGwuY29udmVydGVycy5Cb2R5SW5pdChib2R5KVxuICAgIH1cblxuICAgIGluaXQgPSB3ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQoaW5pdClcblxuICAgIC8vIDEuIFNldCB0aGlz4oCZcyByZXNwb25zZSB0byBhIG5ldyByZXNwb25zZS5cbiAgICB0aGlzW2tTdGF0ZV0gPSBtYWtlUmVzcG9uc2Uoe30pXG5cbiAgICAvLyAyLiBTZXQgdGhpc+KAmXMgaGVhZGVycyB0byBhIG5ldyBIZWFkZXJzIG9iamVjdCB3aXRoIHRoaXPigJlzIHJlbGV2YW50XG4gICAgLy8gUmVhbG0sIHdob3NlIGhlYWRlciBsaXN0IGlzIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCBhbmQgZ3VhcmRcbiAgICAvLyBpcyBcInJlc3BvbnNlXCIuXG4gICAgdGhpc1trSGVhZGVyc10gPSBuZXcgSGVhZGVycyhrQ29uc3RydWN0KVxuICAgIHNldEhlYWRlcnNHdWFyZCh0aGlzW2tIZWFkZXJzXSwgJ3Jlc3BvbnNlJylcbiAgICBzZXRIZWFkZXJzTGlzdCh0aGlzW2tIZWFkZXJzXSwgdGhpc1trU3RhdGVdLmhlYWRlcnNMaXN0KVxuXG4gICAgLy8gMy4gTGV0IGJvZHlXaXRoVHlwZSBiZSBudWxsLlxuICAgIGxldCBib2R5V2l0aFR5cGUgPSBudWxsXG5cbiAgICAvLyA0LiBJZiBib2R5IGlzIG5vbi1udWxsLCB0aGVuIHNldCBib2R5V2l0aFR5cGUgdG8gdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGJvZHkuXG4gICAgaWYgKGJvZHkgIT0gbnVsbCkge1xuICAgICAgY29uc3QgW2V4dHJhY3RlZEJvZHksIHR5cGVdID0gZXh0cmFjdEJvZHkoYm9keSlcbiAgICAgIGJvZHlXaXRoVHlwZSA9IHsgYm9keTogZXh0cmFjdGVkQm9keSwgdHlwZSB9XG4gICAgfVxuXG4gICAgLy8gNS4gUGVyZm9ybSBpbml0aWFsaXplIGEgcmVzcG9uc2UgZ2l2ZW4gdGhpcywgaW5pdCwgYW5kIGJvZHlXaXRoVHlwZS5cbiAgICBpbml0aWFsaXplUmVzcG9uc2UodGhpcywgaW5pdCwgYm9keVdpdGhUeXBlKVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgdHlwZSwgZS5nLiwgXCJjb3JzXCIuXG4gIGdldCB0eXBlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSB0eXBlIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlc3BvbnNl4oCZcyB0eXBlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0udHlwZVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgVVJMLCBpZiBpdCBoYXMgb25lOyBvdGhlcndpc2UgdGhlIGVtcHR5IHN0cmluZy5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICBjb25zdCB1cmxMaXN0ID0gdGhpc1trU3RhdGVdLnVybExpc3RcblxuICAgIC8vIFRoZSB1cmwgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhlIGVtcHR5IHN0cmluZyBpZiB0aGlz4oCZc1xuICAgIC8vIHJlc3BvbnNl4oCZcyBVUkwgaXMgbnVsbDsgb3RoZXJ3aXNlIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBVUkwsXG4gICAgLy8gc2VyaWFsaXplZCB3aXRoIGV4Y2x1ZGUgZnJhZ21lbnQgc2V0IHRvIHRydWUuXG4gICAgY29uc3QgdXJsID0gdXJsTGlzdFt1cmxMaXN0Lmxlbmd0aCAtIDFdID8/IG51bGxcblxuICAgIGlmICh1cmwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHVybCwgdHJ1ZSlcbiAgfVxuXG4gIC8vIFJldHVybnMgd2hldGhlciByZXNwb25zZSB3YXMgb2J0YWluZWQgdGhyb3VnaCBhIHJlZGlyZWN0LlxuICBnZXQgcmVkaXJlY3RlZCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgcmVkaXJlY3RlZCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0cnVlIGlmIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBVUkxcbiAgICAvLyBsaXN0IGhhcyBtb3JlIHRoYW4gb25lIGl0ZW07IG90aGVyd2lzZSBmYWxzZS5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnVybExpc3QubGVuZ3RoID4gMVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgc3RhdHVzLlxuICBnZXQgc3RhdHVzICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSBzdGF0dXMgZ2V0dGVyIHN0ZXBzIGFyZSB0byByZXR1cm4gdGhpc+KAmXMgcmVzcG9uc2XigJlzIHN0YXR1cy5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLnN0YXR1c1xuICB9XG5cbiAgLy8gUmV0dXJucyB3aGV0aGVyIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgYW4gb2sgc3RhdHVzLlxuICBnZXQgb2sgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgLy8gVGhlIG9rIGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRydWUgaWYgdGhpc+KAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyBpcyBhblxuICAgIC8vIG9rIHN0YXR1czsgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uc3RhdHVzID49IDIwMCAmJiB0aGlzW2tTdGF0ZV0uc3RhdHVzIDw9IDI5OVxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgc3RhdHVzIG1lc3NhZ2UuXG4gIGdldCBzdGF0dXNUZXh0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIC8vIFRoZSBzdGF0dXNUZXh0IGdldHRlciBzdGVwcyBhcmUgdG8gcmV0dXJuIHRoaXPigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXNcbiAgICAvLyBtZXNzYWdlLlxuICAgIHJldHVybiB0aGlzW2tTdGF0ZV0uc3RhdHVzVGV4dFxuICB9XG5cbiAgLy8gUmV0dXJucyByZXNwb25zZeKAmXMgaGVhZGVycyBhcyBIZWFkZXJzLlxuICBnZXQgaGVhZGVycyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyBUaGUgaGVhZGVycyBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlz4oCZcyBoZWFkZXJzLlxuICAgIHJldHVybiB0aGlzW2tIZWFkZXJzXVxuICB9XG5cbiAgZ2V0IGJvZHkgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFJlc3BvbnNlKVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS5ib2R5ID8gdGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtIDogbnVsbFxuICB9XG5cbiAgZ2V0IGJvZHlVc2VkICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBSZXNwb25zZSlcblxuICAgIHJldHVybiAhIXRoaXNba1N0YXRlXS5ib2R5ICYmIHV0aWwuaXNEaXN0dXJiZWQodGhpc1trU3RhdGVdLmJvZHkuc3RyZWFtKVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGNsb25lIG9mIHJlc3BvbnNlLlxuICBjbG9uZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgUmVzcG9uc2UpXG5cbiAgICAvLyAxLiBJZiB0aGlzIGlzIHVudXNhYmxlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChib2R5VW51c2FibGUodGhpcykpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVzcG9uc2UuY2xvbmUnLFxuICAgICAgICBtZXNzYWdlOiAnQm9keSBoYXMgYWxyZWFkeSBiZWVuIGNvbnN1bWVkLidcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IGNsb25lZFJlc3BvbnNlIGJlIHRoZSByZXN1bHQgb2YgY2xvbmluZyB0aGlz4oCZcyByZXNwb25zZS5cbiAgICBjb25zdCBjbG9uZWRSZXNwb25zZSA9IGNsb25lUmVzcG9uc2UodGhpc1trU3RhdGVdKVxuXG4gICAgLy8gMy4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY3JlYXRpbmcgYSBSZXNwb25zZSBvYmplY3QsIGdpdmVuXG4gICAgLy8gY2xvbmVkUmVzcG9uc2UsIHRoaXPigJlzIGhlYWRlcnPigJlzIGd1YXJkLCBhbmQgdGhpc+KAmXMgcmVsZXZhbnQgUmVhbG0uXG4gICAgcmV0dXJuIGZyb21Jbm5lclJlc3BvbnNlKGNsb25lZFJlc3BvbnNlLCBnZXRIZWFkZXJzR3VhcmQodGhpc1trSGVhZGVyc10pKVxuICB9XG5cbiAgW25vZGVVdGlsLmluc3BlY3QuY3VzdG9tXSAoZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kZXB0aCA9PT0gbnVsbCkge1xuICAgICAgb3B0aW9ucy5kZXB0aCA9IDJcbiAgICB9XG5cbiAgICBvcHRpb25zLmNvbG9ycyA/Pz0gdHJ1ZVxuXG4gICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICBib2R5OiB0aGlzLmJvZHksXG4gICAgICBib2R5VXNlZDogdGhpcy5ib2R5VXNlZCxcbiAgICAgIG9rOiB0aGlzLm9rLFxuICAgICAgcmVkaXJlY3RlZDogdGhpcy5yZWRpcmVjdGVkLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH1cblxuICAgIHJldHVybiBgUmVzcG9uc2UgJHtub2RlVXRpbC5mb3JtYXRXaXRoT3B0aW9ucyhvcHRpb25zLCBwcm9wZXJ0aWVzKX1gXG4gIH1cbn1cblxubWl4aW5Cb2R5KFJlc3BvbnNlKVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZXNwb25zZS5wcm90b3R5cGUsIHtcbiAgdHlwZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgdXJsOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzdGF0dXM6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9rOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICByZWRpcmVjdGVkOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBzdGF0dXNUZXh0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBoZWFkZXJzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBjbG9uZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYm9keVVzZWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdSZXNwb25zZScsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlc3BvbnNlLCB7XG4gIGpzb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlZGlyZWN0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtY2xvbmVcbmZ1bmN0aW9uIGNsb25lUmVzcG9uc2UgKHJlc3BvbnNlKSB7XG4gIC8vIFRvIGNsb25lIGEgcmVzcG9uc2UgcmVzcG9uc2UsIHJ1biB0aGVzZSBzdGVwczpcblxuICAvLyAxLiBJZiByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlLCB0aGVuIHJldHVybiBhIG5ldyBpZGVudGljYWxcbiAgLy8gZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgaW50ZXJuYWwgcmVzcG9uc2UgaXMgYSBjbG9uZSBvZiByZXNwb25zZeKAmXNcbiAgLy8gaW50ZXJuYWwgcmVzcG9uc2UuXG4gIGlmIChyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIGZpbHRlclJlc3BvbnNlKFxuICAgICAgY2xvbmVSZXNwb25zZShyZXNwb25zZS5pbnRlcm5hbFJlc3BvbnNlKSxcbiAgICAgIHJlc3BvbnNlLnR5cGVcbiAgICApXG4gIH1cblxuICAvLyAyLiBMZXQgbmV3UmVzcG9uc2UgYmUgYSBjb3B5IG9mIHJlc3BvbnNlLCBleGNlcHQgZm9yIGl0cyBib2R5LlxuICBjb25zdCBuZXdSZXNwb25zZSA9IG1ha2VSZXNwb25zZSh7IC4uLnJlc3BvbnNlLCBib2R5OiBudWxsIH0pXG5cbiAgLy8gMy4gSWYgcmVzcG9uc2XigJlzIGJvZHkgaXMgbm9uLW51bGwsIHRoZW4gc2V0IG5ld1Jlc3BvbnNl4oCZcyBib2R5IHRvIHRoZVxuICAvLyByZXN1bHQgb2YgY2xvbmluZyByZXNwb25zZeKAmXMgYm9keS5cbiAgaWYgKHJlc3BvbnNlLmJvZHkgIT0gbnVsbCkge1xuICAgIG5ld1Jlc3BvbnNlLmJvZHkgPSBjbG9uZUJvZHkobmV3UmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gIH1cblxuICAvLyA0LiBSZXR1cm4gbmV3UmVzcG9uc2UuXG4gIHJldHVybiBuZXdSZXNwb25zZVxufVxuXG5mdW5jdGlvbiBtYWtlUmVzcG9uc2UgKGluaXQpIHtcbiAgcmV0dXJuIHtcbiAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICByYW5nZVJlcXVlc3RlZDogZmFsc2UsXG4gICAgdGltaW5nQWxsb3dQYXNzZWQ6IGZhbHNlLFxuICAgIHJlcXVlc3RJbmNsdWRlc0NyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICB0eXBlOiAnZGVmYXVsdCcsXG4gICAgc3RhdHVzOiAyMDAsXG4gICAgdGltaW5nSW5mbzogbnVsbCxcbiAgICBjYWNoZVN0YXRlOiAnJyxcbiAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAuLi5pbml0LFxuICAgIGhlYWRlcnNMaXN0OiBpbml0Py5oZWFkZXJzTGlzdFxuICAgICAgPyBuZXcgSGVhZGVyc0xpc3QoaW5pdD8uaGVhZGVyc0xpc3QpXG4gICAgICA6IG5ldyBIZWFkZXJzTGlzdCgpLFxuICAgIHVybExpc3Q6IGluaXQ/LnVybExpc3QgPyBbLi4uaW5pdC51cmxMaXN0XSA6IFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZU5ldHdvcmtFcnJvciAocmVhc29uKSB7XG4gIGNvbnN0IGlzRXJyb3IgPSBpc0Vycm9yTGlrZShyZWFzb24pXG4gIHJldHVybiBtYWtlUmVzcG9uc2Uoe1xuICAgIHR5cGU6ICdlcnJvcicsXG4gICAgc3RhdHVzOiAwLFxuICAgIGVycm9yOiBpc0Vycm9yXG4gICAgICA/IHJlYXNvblxuICAgICAgOiBuZXcgRXJyb3IocmVhc29uID8gU3RyaW5nKHJlYXNvbikgOiByZWFzb24pLFxuICAgIGFib3J0ZWQ6IHJlYXNvbiAmJiByZWFzb24ubmFtZSA9PT0gJ0Fib3J0RXJyb3InXG4gIH0pXG59XG5cbi8vIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbmV0d29yay1lcnJvclxuZnVuY3Rpb24gaXNOZXR3b3JrRXJyb3IgKHJlc3BvbnNlKSB7XG4gIHJldHVybiAoXG4gICAgLy8gQSBuZXR3b3JrIGVycm9yIGlzIGEgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpcyBcImVycm9yXCIsXG4gICAgcmVzcG9uc2UudHlwZSA9PT0gJ2Vycm9yJyAmJlxuICAgIC8vIHN0YXR1cyBpcyAwXG4gICAgcmVzcG9uc2Uuc3RhdHVzID09PSAwXG4gIClcbn1cblxuZnVuY3Rpb24gbWFrZUZpbHRlcmVkUmVzcG9uc2UgKHJlc3BvbnNlLCBzdGF0ZSkge1xuICBzdGF0ZSA9IHtcbiAgICBpbnRlcm5hbFJlc3BvbnNlOiByZXNwb25zZSxcbiAgICAuLi5zdGF0ZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm94eShyZXNwb25zZSwge1xuICAgIGdldCAodGFyZ2V0LCBwKSB7XG4gICAgICByZXR1cm4gcCBpbiBzdGF0ZSA/IHN0YXRlW3BdIDogdGFyZ2V0W3BdXG4gICAgfSxcbiAgICBzZXQgKHRhcmdldCwgcCwgdmFsdWUpIHtcbiAgICAgIGFzc2VydCghKHAgaW4gc3RhdGUpKVxuICAgICAgdGFyZ2V0W3BdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9KVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1maWx0ZXJlZC1yZXNwb25zZVxuZnVuY3Rpb24gZmlsdGVyUmVzcG9uc2UgKHJlc3BvbnNlLCB0eXBlKSB7XG4gIC8vIFNldCByZXNwb25zZSB0byB0aGUgZm9sbG93aW5nIGZpbHRlcmVkIHJlc3BvbnNlIHdpdGggcmVzcG9uc2UgYXMgaXRzXG4gIC8vIGludGVybmFsIHJlc3BvbnNlLCBkZXBlbmRpbmcgb24gcmVxdWVzdOKAmXMgcmVzcG9uc2UgdGFpbnRpbmc6XG4gIGlmICh0eXBlID09PSAnYmFzaWMnKSB7XG4gICAgLy8gQSBiYXNpYyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJiYXNpY1wiXG4gICAgLy8gYW5kIGhlYWRlciBsaXN0IGV4Y2x1ZGVzIGFueSBoZWFkZXJzIGluIGludGVybmFsIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdFxuICAgIC8vIHdob3NlIG5hbWUgaXMgYSBmb3JiaWRkZW4gcmVzcG9uc2UtaGVhZGVyIG5hbWUuXG5cbiAgICAvLyBOb3RlOiB1bmRpY2kgZG9lcyBub3QgaW1wbGVtZW50IGZvcmJpZGRlbiByZXNwb25zZS1oZWFkZXIgbmFtZXNcbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdiYXNpYycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb3JzJykge1xuICAgIC8vIEEgQ09SUyBmaWx0ZXJlZCByZXNwb25zZSBpcyBhIGZpbHRlcmVkIHJlc3BvbnNlIHdob3NlIHR5cGUgaXMgXCJjb3JzXCJcbiAgICAvLyBhbmQgaGVhZGVyIGxpc3QgZXhjbHVkZXMgYW55IGhlYWRlcnMgaW4gaW50ZXJuYWwgcmVzcG9uc2XigJlzIGhlYWRlclxuICAgIC8vIGxpc3Qgd2hvc2UgbmFtZSBpcyBub3QgYSBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWUsIGdpdmVuXG4gICAgLy8gaW50ZXJuYWwgcmVzcG9uc2XigJlzIENPUlMtZXhwb3NlZCBoZWFkZXItbmFtZSBsaXN0LlxuXG4gICAgLy8gTm90ZTogdW5kaWNpIGRvZXMgbm90IGltcGxlbWVudCBDT1JTLXNhZmVsaXN0ZWQgcmVzcG9uc2UtaGVhZGVyIG5hbWVzXG4gICAgcmV0dXJuIG1ha2VGaWx0ZXJlZFJlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgICB0eXBlOiAnY29ycycsXG4gICAgICBoZWFkZXJzTGlzdDogcmVzcG9uc2UuaGVhZGVyc0xpc3RcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWUnKSB7XG4gICAgLy8gQW4gb3BhcXVlIGZpbHRlcmVkIHJlc3BvbnNlIGlzIGEgZmlsdGVyZWQgcmVzcG9uc2Ugd2hvc2UgdHlwZSBpc1xuICAgIC8vIFwib3BhcXVlXCIsIFVSTCBsaXN0IGlzIHRoZSBlbXB0eSBsaXN0LCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2VcbiAgICAvLyBpcyB0aGUgZW1wdHkgYnl0ZSBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWUnLFxuICAgICAgdXJsTGlzdDogT2JqZWN0LmZyZWV6ZShbXSksXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGFxdWVyZWRpcmVjdCcpIHtcbiAgICAvLyBBbiBvcGFxdWUtcmVkaXJlY3QgZmlsdGVyZWQgcmVzcG9uc2UgaXMgYSBmaWx0ZXJlZCByZXNwb25zZSB3aG9zZSB0eXBlXG4gICAgLy8gaXMgXCJvcGFxdWVyZWRpcmVjdFwiLCBzdGF0dXMgaXMgMCwgc3RhdHVzIG1lc3NhZ2UgaXMgdGhlIGVtcHR5IGJ5dGVcbiAgICAvLyBzZXF1ZW5jZSwgaGVhZGVyIGxpc3QgaXMgZW1wdHksIGFuZCBib2R5IGlzIG51bGwuXG5cbiAgICByZXR1cm4gbWFrZUZpbHRlcmVkUmVzcG9uc2UocmVzcG9uc2UsIHtcbiAgICAgIHR5cGU6ICdvcGFxdWVyZWRpcmVjdCcsXG4gICAgICBzdGF0dXM6IDAsXG4gICAgICBzdGF0dXNUZXh0OiAnJyxcbiAgICAgIGhlYWRlcnNMaXN0OiBbXSxcbiAgICAgIGJvZHk6IG51bGxcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGFzc2VydChmYWxzZSlcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYXBwcm9wcmlhdGUtbmV0d29yay1lcnJvclxuZnVuY3Rpb24gbWFrZUFwcHJvcHJpYXRlTmV0d29ya0Vycm9yIChmZXRjaFBhcmFtcywgZXJyID0gbnVsbCkge1xuICAvLyAxLiBBc3NlcnQ6IGZldGNoUGFyYW1zIGlzIGNhbmNlbGVkLlxuICBhc3NlcnQoaXNDYW5jZWxsZWQoZmV0Y2hQYXJhbXMpKVxuXG4gIC8vIDIuIFJldHVybiBhbiBhYm9ydGVkIG5ldHdvcmsgZXJyb3IgaWYgZmV0Y2hQYXJhbXMgaXMgYWJvcnRlZDtcbiAgLy8gb3RoZXJ3aXNlIHJldHVybiBhIG5ldHdvcmsgZXJyb3IuXG4gIHJldHVybiBpc0Fib3J0ZWQoZmV0Y2hQYXJhbXMpXG4gICAgPyBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignVGhlIG9wZXJhdGlvbiB3YXMgYWJvcnRlZC4nLCAnQWJvcnRFcnJvcicpLCB7IGNhdXNlOiBlcnIgfSkpXG4gICAgOiBtYWtlTmV0d29ya0Vycm9yKE9iamVjdC5hc3NpZ24obmV3IERPTUV4Y2VwdGlvbignUmVxdWVzdCB3YXMgY2FuY2VsbGVkLicpLCB7IGNhdXNlOiBlcnIgfSkpXG59XG5cbi8vIGh0dHBzOi8vd2hhdHByLm9yZy9mZXRjaC8xMzkyLmh0bWwjaW5pdGlhbGl6ZS1hLXJlc3BvbnNlXG5mdW5jdGlvbiBpbml0aWFsaXplUmVzcG9uc2UgKHJlc3BvbnNlLCBpbml0LCBib2R5KSB7XG4gIC8vIDEuIElmIGluaXRbXCJzdGF0dXNcIl0gaXMgbm90IGluIHRoZSByYW5nZSAyMDAgdG8gNTk5LCBpbmNsdXNpdmUsIHRoZW5cbiAgLy8gICAgdGhyb3cgYSBSYW5nZUVycm9yLlxuICBpZiAoaW5pdC5zdGF0dXMgIT09IG51bGwgJiYgKGluaXQuc3RhdHVzIDwgMjAwIHx8IGluaXQuc3RhdHVzID4gNTk5KSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbml0W1wic3RhdHVzXCJdIG11c3QgYmUgaW4gdGhlIHJhbmdlIG9mIDIwMCB0byA1OTksIGluY2x1c2l2ZS4nKVxuICB9XG5cbiAgLy8gMi4gSWYgaW5pdFtcInN0YXR1c1RleHRcIl0gZG9lcyBub3QgbWF0Y2ggdGhlIHJlYXNvbi1waHJhc2UgdG9rZW4gcHJvZHVjdGlvbixcbiAgLy8gICAgdGhlbiB0aHJvdyBhIFR5cGVFcnJvci5cbiAgaWYgKCdzdGF0dXNUZXh0JyBpbiBpbml0ICYmIGluaXQuc3RhdHVzVGV4dCAhPSBudWxsKSB7XG4gICAgLy8gU2VlLCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjEuMjpcbiAgICAvLyAgIHJlYXNvbi1waHJhc2UgID0gKiggSFRBQiAvIFNQIC8gVkNIQVIgLyBvYnMtdGV4dCApXG4gICAgaWYgKCFpc1ZhbGlkUmVhc29uUGhyYXNlKFN0cmluZyhpbml0LnN0YXR1c1RleHQpKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdGF0dXNUZXh0JylcbiAgICB9XG4gIH1cblxuICAvLyAzLiBTZXQgcmVzcG9uc2XigJlzIHJlc3BvbnNl4oCZcyBzdGF0dXMgdG8gaW5pdFtcInN0YXR1c1wiXS5cbiAgaWYgKCdzdGF0dXMnIGluIGluaXQgJiYgaW5pdC5zdGF0dXMgIT0gbnVsbCkge1xuICAgIHJlc3BvbnNlW2tTdGF0ZV0uc3RhdHVzID0gaW5pdC5zdGF0dXNcbiAgfVxuXG4gIC8vIDQuIFNldCByZXNwb25zZeKAmXMgcmVzcG9uc2XigJlzIHN0YXR1cyBtZXNzYWdlIHRvIGluaXRbXCJzdGF0dXNUZXh0XCJdLlxuICBpZiAoJ3N0YXR1c1RleHQnIGluIGluaXQgJiYgaW5pdC5zdGF0dXNUZXh0ICE9IG51bGwpIHtcbiAgICByZXNwb25zZVtrU3RhdGVdLnN0YXR1c1RleHQgPSBpbml0LnN0YXR1c1RleHRcbiAgfVxuXG4gIC8vIDUuIElmIGluaXRbXCJoZWFkZXJzXCJdIGV4aXN0cywgdGhlbiBmaWxsIHJlc3BvbnNl4oCZcyBoZWFkZXJzIHdpdGggaW5pdFtcImhlYWRlcnNcIl0uXG4gIGlmICgnaGVhZGVycycgaW4gaW5pdCAmJiBpbml0LmhlYWRlcnMgIT0gbnVsbCkge1xuICAgIGZpbGwocmVzcG9uc2Vba0hlYWRlcnNdLCBpbml0LmhlYWRlcnMpXG4gIH1cblxuICAvLyA2LiBJZiBib2R5IHdhcyBnaXZlbiwgdGhlbjpcbiAgaWYgKGJvZHkpIHtcbiAgICAvLyAxLiBJZiByZXNwb25zZSdzIHN0YXR1cyBpcyBhIG51bGwgYm9keSBzdGF0dXMsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKG51bGxCb2R5U3RhdHVzLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnUmVzcG9uc2UgY29uc3RydWN0b3InLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCByZXNwb25zZSBzdGF0dXMgY29kZSAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIDIuIFNldCByZXNwb25zZSdzIGJvZHkgdG8gYm9keSdzIGJvZHkuXG4gICAgcmVzcG9uc2Vba1N0YXRlXS5ib2R5ID0gYm9keS5ib2R5XG5cbiAgICAvLyAzLiBJZiBib2R5J3MgdHlwZSBpcyBub24tbnVsbCBhbmQgcmVzcG9uc2UncyBoZWFkZXIgbGlzdCBkb2VzIG5vdCBjb250YWluXG4gICAgLy8gICAgYENvbnRlbnQtVHlwZWAsIHRoZW4gYXBwZW5kIChgQ29udGVudC1UeXBlYCwgYm9keSdzIHR5cGUpIHRvIHJlc3BvbnNlJ3MgaGVhZGVyIGxpc3QuXG4gICAgaWYgKGJvZHkudHlwZSAhPSBudWxsICYmICFyZXNwb25zZVtrU3RhdGVdLmhlYWRlcnNMaXN0LmNvbnRhaW5zKCdjb250ZW50LXR5cGUnLCB0cnVlKSkge1xuICAgICAgcmVzcG9uc2Vba1N0YXRlXS5oZWFkZXJzTGlzdC5hcHBlbmQoJ2NvbnRlbnQtdHlwZScsIGJvZHkudHlwZSwgdHJ1ZSlcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jcmVhdGVcbiAqIEBwYXJhbSB7YW55fSBpbm5lclJlc3BvbnNlXG4gKiBAcGFyYW0geydyZXF1ZXN0JyB8ICdpbW11dGFibGUnIHwgJ3JlcXVlc3Qtbm8tY29ycycgfCAncmVzcG9uc2UnIHwgJ25vbmUnfSBndWFyZFxuICogQHJldHVybnMge1Jlc3BvbnNlfVxuICovXG5mdW5jdGlvbiBmcm9tSW5uZXJSZXNwb25zZSAoaW5uZXJSZXNwb25zZSwgZ3VhcmQpIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2Uoa0NvbnN0cnVjdClcbiAgcmVzcG9uc2Vba1N0YXRlXSA9IGlubmVyUmVzcG9uc2VcbiAgcmVzcG9uc2Vba0hlYWRlcnNdID0gbmV3IEhlYWRlcnMoa0NvbnN0cnVjdClcbiAgc2V0SGVhZGVyc0xpc3QocmVzcG9uc2Vba0hlYWRlcnNdLCBpbm5lclJlc3BvbnNlLmhlYWRlcnNMaXN0KVxuICBzZXRIZWFkZXJzR3VhcmQocmVzcG9uc2Vba0hlYWRlcnNdLCBndWFyZClcblxuICBpZiAoaGFzRmluYWxpemF0aW9uUmVnaXN0cnkgJiYgaW5uZXJSZXNwb25zZS5ib2R5Py5zdHJlYW0pIHtcbiAgICAvLyBJZiB0aGUgdGFyZ2V0IChyZXNwb25zZSkgaXMgcmVjbGFpbWVkLCB0aGUgY2xlYW51cCBjYWxsYmFjayBtYXkgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgd2l0aFxuICAgIC8vIHRoZSBoZWxkIHZhbHVlIHByb3ZpZGVkIGZvciBpdCAoaW5uZXJSZXNwb25zZS5ib2R5LnN0cmVhbSkuIFRoZSBoZWxkIHZhbHVlIGNhbiBiZSBhbnkgdmFsdWU6XG4gICAgLy8gYSBwcmltaXRpdmUgb3IgYW4gb2JqZWN0LCBldmVuIHVuZGVmaW5lZC4gSWYgdGhlIGhlbGQgdmFsdWUgaXMgYW4gb2JqZWN0LCB0aGUgcmVnaXN0cnkga2VlcHNcbiAgICAvLyBhIHN0cm9uZyByZWZlcmVuY2UgdG8gaXQgKHNvIGl0IGNhbiBwYXNzIGl0IHRvIHRoZSBjbGVhbnVwIGNhbGxiYWNrIGxhdGVyKS4gUmV3b3JkZWQgZnJvbVxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ZpbmFsaXphdGlvblJlZ2lzdHJ5XG4gICAgc3RyZWFtUmVnaXN0cnkucmVnaXN0ZXIocmVzcG9uc2UsIG5ldyBXZWFrUmVmKGlubmVyUmVzcG9uc2UuYm9keS5zdHJlYW0pKVxuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlJlYWRhYmxlU3RyZWFtID0gd2ViaWRsLmludGVyZmFjZUNvbnZlcnRlcihcbiAgUmVhZGFibGVTdHJlYW1cbilcblxud2ViaWRsLmNvbnZlcnRlcnMuRm9ybURhdGEgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBGb3JtRGF0YVxuKVxuXG53ZWJpZGwuY29udmVydGVycy5VUkxTZWFyY2hQYXJhbXMgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKFxuICBVUkxTZWFyY2hQYXJhbXNcbilcblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI3R5cGVkZWZkZWYteG1saHR0cHJlcXVlc3Rib2R5aW5pdFxud2ViaWRsLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdCA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiBWID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcoViwgcHJlZml4LCBuYW1lKVxuICB9XG5cbiAgaWYgKGlzQmxvYkxpa2UoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQmxvYihWLCBwcmVmaXgsIG5hbWUsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhWKSB8fCB0eXBlcy5pc0FycmF5QnVmZmVyKFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZShWLCBwcmVmaXgsIG5hbWUpXG4gIH1cblxuICBpZiAodXRpbC5pc0Zvcm1EYXRhTGlrZShWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5Gb3JtRGF0YShWLCBwcmVmaXgsIG5hbWUsIHsgc3RyaWN0OiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKFYgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuVVJMU2VhcmNoUGFyYW1zKFYsIHByZWZpeCwgbmFtZSlcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoViwgcHJlZml4LCBuYW1lKVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYm9keWluaXRcbndlYmlkbC5jb252ZXJ0ZXJzLkJvZHlJbml0ID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgaWYgKFYgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5SZWFkYWJsZVN0cmVhbShWLCBwcmVmaXgsIGFyZ3VtZW50KVxuICB9XG5cbiAgLy8gTm90ZTogdGhlIHNwZWMgZG9lc24ndCBpbmNsdWRlIGFzeW5jIGl0ZXJhYmxlcyxcbiAgLy8gdGhpcyBpcyBhbiB1bmRpY2kgZXh0ZW5zaW9uLlxuICBpZiAoVj8uW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSkge1xuICAgIHJldHVybiBWXG4gIH1cblxuICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuWE1MSHR0cFJlcXVlc3RCb2R5SW5pdChWLCBwcmVmaXgsIGFyZ3VtZW50KVxufVxuXG53ZWJpZGwuY29udmVydGVycy5SZXNwb25zZUluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdzdGF0dXMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAyMDBcbiAgfSxcbiAge1xuICAgIGtleTogJ3N0YXR1c1RleHQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdoZWFkZXJzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkhlYWRlcnNJbml0XG4gIH1cbl0pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc05ldHdvcmtFcnJvcixcbiAgbWFrZU5ldHdvcmtFcnJvcixcbiAgbWFrZVJlc3BvbnNlLFxuICBtYWtlQXBwcm9wcmlhdGVOZXR3b3JrRXJyb3IsXG4gIGZpbHRlclJlc3BvbnNlLFxuICBSZXNwb25zZSxcbiAgY2xvbmVSZXNwb25zZSxcbiAgZnJvbUlubmVyUmVzcG9uc2Vcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/response.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/symbols.js":
/*!******************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kUrl: Symbol('url'),\n  kHeaders: Symbol('headers'),\n  kSignal: Symbol('signal'),\n  kState: Symbol('state'),\n  kDispatcher: Symbol('dispatcher')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvc3ltYm9scy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFxzeW1ib2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga1VybDogU3ltYm9sKCd1cmwnKSxcbiAga0hlYWRlcnM6IFN5bWJvbCgnaGVhZGVycycpLFxuICBrU2lnbmFsOiBTeW1ib2woJ3NpZ25hbCcpLFxuICBrU3RhdGU6IFN5bWJvbCgnc3RhdGUnKSxcbiAga0Rpc3BhdGNoZXI6IFN5bWJvbCgnZGlzcGF0Y2hlcicpXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/util.js":
/*!***************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Transform } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst zlib = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/fetch/constants.js\")\nconst { getGlobalOrigin } = __webpack_require__(/*! ./global */ \"(rsc)/./node_modules/undici/lib/web/fetch/global.js\")\nconst { collectASequenceOfCodePoints, collectAnHTTPQuotedString, removeChars, parseMIMEType } = __webpack_require__(/*! ./data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { performance } = __webpack_require__(/*! node:perf_hooks */ \"node:perf_hooks\")\nconst { isBlobLike, ReadableStreamFrom, isValidHTTPToken, normalizedMethodRecordsBase } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { isUint8Array } = __webpack_require__(/*! node:util/types */ \"node:util/types\")\nconst { webidl } = __webpack_require__(/*! ./webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\n\nlet supportedHashes = []\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n  const possibleRelevantHashes = ['sha256', 'sha384', 'sha512']\n  supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash))\n/* c8 ignore next 3 */\n} catch {\n\n}\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatusSet.has(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location', true)\n\n  // 3. If location is a header value, then set location to the result of\n  //    parsing location with response’s URL.\n  if (location !== null && isValidHeaderValue(location)) {\n    if (!isValidEncodedURL(location)) {\n      // Some websites respond location header in UTF-8 form without encoding them as ASCII\n      // and major browsers redirect them to correctly UTF-8 encoded addresses.\n      // Here, we handle that behavior in the same way.\n      location = normalizeBinaryStringToUtf8(location)\n    }\n    location = new URL(location, responseURL(response))\n  }\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc1738#section-2.2\n * @param {string} url\n * @returns {boolean}\n */\nfunction isValidEncodedURL (url) {\n  for (let i = 0; i < url.length; ++i) {\n    const code = url.charCodeAt(i)\n\n    if (\n      code > 0x7E || // Non-US-ASCII + DEL\n      code < 0x20 // Control characters NUL - US\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * If string contains non-ASCII characters, assumes it's UTF-8 encoded and decodes it.\n * Since UTF-8 is a superset of ASCII, this will work for ASCII strings as well.\n * @param {string} value\n * @returns {string}\n */\nfunction normalizeBinaryStringToUtf8 (value) {\n  return Buffer.from(value, 'binary').toString('utf8')\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-name\n * @param {string} potentialValue\n */\nconst isValidHeaderName = isValidHTTPToken\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  return (\n    potentialValue[0] === '\\t' ||\n    potentialValue[0] === ' ' ||\n    potentialValue[potentialValue.length - 1] === '\\t' ||\n    potentialValue[potentialValue.length - 1] === ' ' ||\n    potentialValue.includes('\\n') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\0')\n  ) === false\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const { headersList } = actualResponse\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy', true) ?? '').split(',')\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = ''\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.has(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header, true)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin\n  //    with request.\n  // TODO: implement \"byte-serializing a request origin\"\n  let serializedOrigin = request.origin\n\n  // - \"'client' is changed to an origin during fetching.\"\n  //   This doesn't happen in undici (in most cases) because undici, by default,\n  //   has no concept of origin.\n  // - request.origin can also be set to request.client.origin (client being\n  //   an environment settings object), which is undefined without using\n  //   setGlobalOrigin.\n  if (serializedOrigin === 'client' || serializedOrigin === undefined) {\n    return\n  }\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\",\n  //    then append (`Origin`, serializedOrigin) to request’s header list.\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    request.headersList.append('origin', serializedOrigin, true)\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and\n        // request’s current URL’s scheme is not \"https\", then set\n        // serializedOrigin to `null`.\n        if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s\n        // origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n    request.headersList.append('origin', serializedOrigin, true)\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsen-time\nfunction coarsenTime (timestamp, crossOriginIsolatedCapability) {\n  // TODO\n  return timestamp\n}\n\n// https://fetch.spec.whatwg.org/#clamp-and-coarsen-connection-timing-info\nfunction clampAndCoarsenConnectionTimingInfo (connectionTimingInfo, defaultStartTime, crossOriginIsolatedCapability) {\n  if (!connectionTimingInfo?.startTime || connectionTimingInfo.startTime < defaultStartTime) {\n    return {\n      domainLookupStartTime: defaultStartTime,\n      domainLookupEndTime: defaultStartTime,\n      connectionStartTime: defaultStartTime,\n      connectionEndTime: defaultStartTime,\n      secureConnectionStartTime: defaultStartTime,\n      ALPNNegotiatedProtocol: connectionTimingInfo?.ALPNNegotiatedProtocol\n    }\n  }\n\n  return {\n    domainLookupStartTime: coarsenTime(connectionTimingInfo.domainLookupStartTime, crossOriginIsolatedCapability),\n    domainLookupEndTime: coarsenTime(connectionTimingInfo.domainLookupEndTime, crossOriginIsolatedCapability),\n    connectionStartTime: coarsenTime(connectionTimingInfo.connectionStartTime, crossOriginIsolatedCapability),\n    connectionEndTime: coarsenTime(connectionTimingInfo.connectionEndTime, crossOriginIsolatedCapability),\n    secureConnectionStartTime: coarsenTime(connectionTimingInfo.secureConnectionStartTime, crossOriginIsolatedCapability),\n    ALPNNegotiatedProtocol: connectionTimingInfo.ALPNNegotiatedProtocol\n  }\n}\n\n// https://w3c.github.io/hr-time/#dfn-coarsened-shared-current-time\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  return coarsenTime(performance.now(), crossOriginIsolatedCapability)\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // Note: the fetch spec doesn't make use of embedder policy or CSP list\n  return {\n    referrerPolicy: 'strict-origin-when-cross-origin'\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer (policyContainer) {\n  return {\n    referrerPolicy: policyContainer.referrerPolicy\n  }\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Note: policy cannot (shouldn't) be null or an empty string.\n  assert(policy)\n\n  // 2. Let environment be request’s client.\n\n  let referrerSource = null\n\n  // 3. Switch on request’s referrer:\n  if (request.referrer === 'client') {\n    // Note: node isn't a browser and doesn't implement document/iframes,\n    // so we bypass this step and replace it with our own.\n\n    const globalOrigin = getGlobalOrigin()\n\n    if (!globalOrigin || globalOrigin.origin === 'null') {\n      return 'no-referrer'\n    }\n\n    // note: we need to clone it as it's mutated\n    referrerSource = new URL(globalOrigin)\n  } else if (request.referrer instanceof URL) {\n    // Let referrerSource be request’s referrer.\n    referrerSource = request.referrer\n  }\n\n  // 4. Let request’s referrerURL be the result of stripping referrerSource for\n  //    use as a referrer.\n  let referrerURL = stripURLForReferrer(referrerSource)\n\n  // 5. Let referrerOrigin be the result of stripping referrerSource for use as\n  //    a referrer, with the origin-only flag set to true.\n  const referrerOrigin = stripURLForReferrer(referrerSource, true)\n\n  // 6. If the result of serializing referrerURL is a string whose length is\n  //    greater than 4096, set referrerURL to referrerOrigin.\n  if (referrerURL.toString().length > 4096) {\n    referrerURL = referrerOrigin\n  }\n\n  const areSameOrigin = sameOrigin(request, referrerURL)\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) &&\n    !isURLPotentiallyTrustworthy(request.url)\n\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url': return referrerURL\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer'\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerURL : referrerOrigin\n    case 'strict-origin-when-cross-origin': {\n      const currentURL = requestCurrentURL(request)\n\n      // 1. If the origin of referrerURL and the origin of request’s current\n      //    URL are the same, then return referrerURL.\n      if (sameOrigin(referrerURL, currentURL)) {\n        return referrerURL\n      }\n\n      // 2. If referrerURL is a potentially trustworthy URL and request’s\n      //    current URL is not a potentially trustworthy URL, then return no\n      //    referrer.\n      if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {\n        return 'no-referrer'\n      }\n\n      // 3. Return referrerOrigin.\n      return referrerOrigin\n    }\n    case 'strict-origin': // eslint-disable-line\n      /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n      /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n\n    default: // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-referrer-policy/#strip-url\n * @param {URL} url\n * @param {boolean|undefined} originOnly\n */\nfunction stripURLForReferrer (url, originOnly) {\n  // 1. Assert: url is a URL.\n  assert(url instanceof URL)\n\n  url = new URL(url)\n\n  // 2. If url’s scheme is a local scheme, then return no referrer.\n  if (url.protocol === 'file:' || url.protocol === 'about:' || url.protocol === 'blank:') {\n    return 'no-referrer'\n  }\n\n  // 3. Set url’s username to the empty string.\n  url.username = ''\n\n  // 4. Set url’s password to the empty string.\n  url.password = ''\n\n  // 5. Set url’s fragment to null.\n  url.hash = ''\n\n  // 6. If the origin-only flag is true, then:\n  if (originOnly) {\n    // 1. Set url’s path to « the empty string ».\n    url.pathname = ''\n\n    // 2. Set url’s query to null.\n    url.search = ''\n  }\n\n  // 7. Return url.\n  return url\n}\n\nfunction isURLPotentiallyTrustworthy (url) {\n  if (!(url instanceof URL)) {\n    return false\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true\n\n  // If file, return true\n  if (url.protocol === 'file:') return true\n\n  return isOriginPotentiallyTrustworthy(url.origin)\n\n  function isOriginPotentiallyTrustworthy (origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false\n\n    const originAsURL = new URL(origin)\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) ||\n     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||\n     (originAsURL.hostname.endsWith('.localhost'))) {\n      return true\n    }\n\n    // If any other, return false\n    return false\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If response is not eligible for integrity validation, return false.\n  // TODO\n\n  // 4. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 5. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const strongest = getStrongestMetadata(parsedMetadata)\n  const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest)\n\n  // 6. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash\n\n    // See https://github.com/web-platform-tests/wpt/commit/e4c5cc7a5e48093220528dfdd1c4012dc3837a0e\n    // \"be liberal with padding\". This is annoying, and it's not even in the spec.\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    let actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    if (actualValue[actualValue.length - 1] === '=') {\n      if (actualValue[actualValue.length - 2] === '=') {\n        actualValue = actualValue.slice(0, -2)\n      } else {\n        actualValue = actualValue.slice(0, -1)\n      }\n    }\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (compareBase64Mixed(actualValue, expectedValue)) {\n      return true\n    }\n  }\n\n  // 7. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\\s|$)( +[!-~]*)?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (\n      parsedToken === null ||\n      parsedToken.groups === undefined ||\n      parsedToken.groups.algo === undefined\n    ) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo.toLowerCase()\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm)) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n/**\n * @param {{ algo: 'sha256' | 'sha384' | 'sha512' }[]} metadataList\n */\nfunction getStrongestMetadata (metadataList) {\n  // Let algorithm be the algo component of the first item in metadataList.\n  // Can be sha256\n  let algorithm = metadataList[0].algo\n  // If the algorithm is sha512, then it is the strongest\n  // and we can return immediately\n  if (algorithm[3] === '5') {\n    return algorithm\n  }\n\n  for (let i = 1; i < metadataList.length; ++i) {\n    const metadata = metadataList[i]\n    // If the algorithm is sha512, then it is the strongest\n    // and we can break the loop immediately\n    if (metadata.algo[3] === '5') {\n      algorithm = 'sha512'\n      break\n    // If the algorithm is sha384, then a potential sha256 or sha384 is ignored\n    } else if (algorithm[3] === '3') {\n      continue\n    // algorithm is sha256, check if algorithm is sha384 and if so, set it as\n    // the strongest\n    } else if (metadata.algo[3] === '3') {\n      algorithm = 'sha384'\n    }\n  }\n  return algorithm\n}\n\nfunction filterMetadataListByAlgorithm (metadataList, algorithm) {\n  if (metadataList.length === 1) {\n    return metadataList\n  }\n\n  let pos = 0\n  for (let i = 0; i < metadataList.length; ++i) {\n    if (metadataList[i].algo === algorithm) {\n      metadataList[pos++] = metadataList[i]\n    }\n  }\n\n  metadataList.length = pos\n\n  return metadataList\n}\n\n/**\n * Compares two base64 strings, allowing for base64url\n * in the second string.\n *\n* @param {string} actualValue always base64\n * @param {string} expectedValue base64 or base64url\n * @returns {boolean}\n */\nfunction compareBase64Mixed (actualValue, expectedValue) {\n  if (actualValue.length !== expectedValue.length) {\n    return false\n  }\n  for (let i = 0; i < actualValue.length; ++i) {\n    if (actualValue[i] !== expectedValue[i]) {\n      if (\n        (actualValue[i] === '+' && expectedValue[i] === '-') ||\n        (actualValue[i] === '/' && expectedValue[i] === '_')\n      ) {\n        continue\n      }\n      return false\n    }\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  if (A.origin === B.origin && A.origin === 'null') {\n    return true\n  }\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-method-normalize\n * @param {string} method\n */\nfunction normalizeMethod (method) {\n  return normalizedMethodRecordsBase[method.toLowerCase()] ?? method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction createIterator (name, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  class FastIterableIterator {\n    /** @type {any} */\n    #target\n    /** @type {'key' | 'value' | 'key+value'} */\n    #kind\n    /** @type {number} */\n    #index\n\n    /**\n     * @see https://webidl.spec.whatwg.org/#dfn-default-iterator-object\n     * @param {unknown} target\n     * @param {'key' | 'value' | 'key+value'} kind\n     */\n    constructor (target, kind) {\n      this.#target = target\n      this.#kind = kind\n      this.#index = 0\n    }\n\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n      // 2. Let thisValue be the this value.\n      // 3. Let object be ? ToObject(thisValue).\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (typeof this !== 'object' || this === null || !(#target in this)) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const index = this.#index\n      const values = this.#target[kInternalIterator]\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const { [keyIndex]: key, [valueIndex]: value } = values[index]\n\n      // 12. Set object’s index to index + 1.\n      this.#index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n\n      // https://webidl.spec.whatwg.org/#iterator-result\n\n      // 1. Let result be a value determined by the value of kind:\n      let result\n      switch (this.#kind) {\n        case 'key':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 3. result is key.\n          result = key\n          break\n        case 'value':\n          // 1. Let idlValue be pair’s value.\n          // 2. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 3. result is value.\n          result = value\n          break\n        case 'key+value':\n          // 1. Let idlKey be pair’s key.\n          // 2. Let idlValue be pair’s value.\n          // 3. Let key be the result of converting idlKey to an\n          //    ECMAScript value.\n          // 4. Let value be the result of converting idlValue to\n          //    an ECMAScript value.\n          // 5. Let array be ! ArrayCreate(2).\n          // 6. Call ! CreateDataProperty(array, \"0\", key).\n          // 7. Call ! CreateDataProperty(array, \"1\", value).\n          // 8. result is array.\n          result = [key, value]\n          break\n      }\n\n      // 2. Return CreateIterResultObject(result, false).\n      return {\n        value: result,\n        done: false\n      }\n    }\n  }\n\n  // https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n  // @ts-ignore\n  delete FastIterableIterator.prototype.constructor\n\n  Object.setPrototypeOf(FastIterableIterator.prototype, esIteratorPrototype)\n\n  Object.defineProperties(FastIterableIterator.prototype, {\n    [Symbol.toStringTag]: {\n      writable: false,\n      enumerable: false,\n      configurable: true,\n      value: `${name} Iterator`\n    },\n    next: { writable: true, enumerable: true, configurable: true }\n  })\n\n  /**\n   * @param {unknown} target\n   * @param {'key' | 'value' | 'key+value'} kind\n   * @returns {IterableIterator<any>}\n   */\n  return function (target, kind) {\n    return new FastIterableIterator(target, kind)\n  }\n}\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {string} name name of the instance\n * @param {any} object class\n * @param {symbol} kInternalIterator\n * @param {string | number} [keyIndex]\n * @param {string | number} [valueIndex]\n */\nfunction iteratorMixin (name, object, kInternalIterator, keyIndex = 0, valueIndex = 1) {\n  const makeIterator = createIterator(name, kInternalIterator, keyIndex, valueIndex)\n\n  const properties = {\n    keys: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function keys () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key')\n      }\n    },\n    values: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function values () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'value')\n      }\n    },\n    entries: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function entries () {\n        webidl.brandCheck(this, object)\n        return makeIterator(this, 'key+value')\n      }\n    },\n    forEach: {\n      writable: true,\n      enumerable: true,\n      configurable: true,\n      value: function forEach (callbackfn, thisArg = globalThis) {\n        webidl.brandCheck(this, object)\n        webidl.argumentLengthCheck(arguments, 1, `${name}.forEach`)\n        if (typeof callbackfn !== 'function') {\n          throw new TypeError(\n            `Failed to execute 'forEach' on '${name}': parameter 1 is not of type 'Function'.`\n          )\n        }\n        for (const { 0: key, 1: value } of makeIterator(this, 'key+value')) {\n          callbackfn.call(thisArg, value, key, this)\n        }\n      }\n    }\n  }\n\n  return Object.defineProperties(object.prototype, {\n    ...properties,\n    [Symbol.iterator]: {\n      writable: true,\n      enumerable: false,\n      configurable: true,\n      value: properties.entries.value\n    }\n  })\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nasync function fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = processBody\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = processBodyError\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader\n\n  try {\n    reader = body.stream.getReader()\n  } catch (e) {\n    errorSteps(e)\n    return\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  try {\n    successSteps(await readAllBytes(reader))\n  } catch (e) {\n    errorSteps(e)\n  }\n}\n\nfunction isReadableStreamLike (stream) {\n  return stream instanceof ReadableStream || (\n    stream[Symbol.toStringTag] === 'ReadableStream' &&\n    typeof stream.tee === 'function'\n  )\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n    controller.byobRequest?.respond(0)\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed') && !err.message.includes('ReadableStream is already closed')) {\n      throw err\n    }\n  }\n}\n\nconst invalidIsomorphicEncodeValueRegex = /[^\\x00-\\xFF]/ // eslint-disable-line\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  assert(!invalidIsomorphicEncodeValueRegex.test(input))\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n */\nasync function readAllBytes (reader) {\n  const bytes = []\n  let byteLength = 0\n\n  while (true) {\n    const { done, value: chunk } = await reader.read()\n\n    if (done) {\n      // 1. Call successSteps with bytes.\n      return Buffer.concat(bytes, byteLength)\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      throw new TypeError('Received non-Uint8Array chunk')\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk)\n    byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#is-local\n * @param {URL} url\n */\nfunction urlIsLocal (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'about:' || protocol === 'blob:' || protocol === 'data:'\n}\n\n/**\n * @param {string|URL} url\n * @returns {boolean}\n */\nfunction urlHasHttpsScheme (url) {\n  return (\n    (\n      typeof url === 'string' &&\n      url[5] === ':' &&\n      url[0] === 'h' &&\n      url[1] === 't' &&\n      url[2] === 't' &&\n      url[3] === 'p' &&\n      url[4] === 's'\n    ) ||\n    url.protocol === 'https:'\n  )\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#http-scheme\n * @param {URL} url\n */\nfunction urlIsHttpHttpsScheme (url) {\n  assert('protocol' in url) // ensure it's a url object\n\n  const protocol = url.protocol\n\n  return protocol === 'http:' || protocol === 'https:'\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#simple-range-header-value\n * @param {string} value\n * @param {boolean} allowWhitespace\n */\nfunction simpleRangeHeaderValue (value, allowWhitespace) {\n  // 1. Let data be the isomorphic decoding of value.\n  // Note: isomorphic decoding takes a sequence of bytes (ie. a Uint8Array) and turns it into a string,\n  // nothing more. We obviously don't need to do that if value is a string already.\n  const data = value\n\n  // 2. If data does not start with \"bytes\", then return failure.\n  if (!data.startsWith('bytes')) {\n    return 'failure'\n  }\n\n  // 3. Let position be a position variable for data, initially pointing at the 5th code point of data.\n  const position = { position: 5 }\n\n  // 4. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //    from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 5. If the code point at position within data is not U+003D (=), then return failure.\n  if (data.charCodeAt(position.position) !== 0x3D) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1.\n  position.position++\n\n  // 7. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space, from\n  //    data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 8. Let rangeStart be the result of collecting a sequence of code points that are ASCII digits,\n  //    from data given position.\n  const rangeStart = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 9. Let rangeStartValue be rangeStart, interpreted as decimal number, if rangeStart is not the\n  //    empty string; otherwise null.\n  const rangeStartValue = rangeStart.length ? Number(rangeStart) : null\n\n  // 10. If allowWhitespace is true, collect a sequence of code points that are HTTP tab or space,\n  //     from data given position.\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 11. If the code point at position within data is not U+002D (-), then return failure.\n  if (data.charCodeAt(position.position) !== 0x2D) {\n    return 'failure'\n  }\n\n  // 12. Advance position by 1.\n  position.position++\n\n  // 13. If allowWhitespace is true, collect a sequence of code points that are HTTP tab\n  //     or space, from data given position.\n  // Note from Khafra: its the same step as in #8 again lol\n  if (allowWhitespace) {\n    collectASequenceOfCodePoints(\n      (char) => char === '\\t' || char === ' ',\n      data,\n      position\n    )\n  }\n\n  // 14. Let rangeEnd be the result of collecting a sequence of code points that are\n  //     ASCII digits, from data given position.\n  // Note from Khafra: you wouldn't guess it, but this is also the same step as #8\n  const rangeEnd = collectASequenceOfCodePoints(\n    (char) => {\n      const code = char.charCodeAt(0)\n\n      return code >= 0x30 && code <= 0x39\n    },\n    data,\n    position\n  )\n\n  // 15. Let rangeEndValue be rangeEnd, interpreted as decimal number, if rangeEnd\n  //     is not the empty string; otherwise null.\n  // Note from Khafra: THE SAME STEP, AGAIN!!!\n  // Note: why interpret as a decimal if we only collect ascii digits?\n  const rangeEndValue = rangeEnd.length ? Number(rangeEnd) : null\n\n  // 16. If position is not past the end of data, then return failure.\n  if (position.position < data.length) {\n    return 'failure'\n  }\n\n  // 17. If rangeEndValue and rangeStartValue are null, then return failure.\n  if (rangeEndValue === null && rangeStartValue === null) {\n    return 'failure'\n  }\n\n  // 18. If rangeStartValue and rangeEndValue are numbers, and rangeStartValue is\n  //     greater than rangeEndValue, then return failure.\n  // Note: ... when can they not be numbers?\n  if (rangeStartValue > rangeEndValue) {\n    return 'failure'\n  }\n\n  // 19. Return (rangeStartValue, rangeEndValue).\n  return { rangeStartValue, rangeEndValue }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#build-a-content-range\n * @param {number} rangeStart\n * @param {number} rangeEnd\n * @param {number} fullLength\n */\nfunction buildContentRange (rangeStart, rangeEnd, fullLength) {\n  // 1. Let contentRange be `bytes `.\n  let contentRange = 'bytes '\n\n  // 2. Append rangeStart, serialized and isomorphic encoded, to contentRange.\n  contentRange += isomorphicEncode(`${rangeStart}`)\n\n  // 3. Append 0x2D (-) to contentRange.\n  contentRange += '-'\n\n  // 4. Append rangeEnd, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${rangeEnd}`)\n\n  // 5. Append 0x2F (/) to contentRange.\n  contentRange += '/'\n\n  // 6. Append fullLength, serialized and isomorphic encoded to contentRange.\n  contentRange += isomorphicEncode(`${fullLength}`)\n\n  // 7. Return contentRange.\n  return contentRange\n}\n\n// A Stream, which pipes the response to zlib.createInflate() or\n// zlib.createInflateRaw() depending on the first byte of the Buffer.\n// If the lower byte of the first byte is 0x08, then the stream is\n// interpreted as a zlib stream, otherwise it's interpreted as a\n// raw deflate stream.\nclass InflateStream extends Transform {\n  #zlibOptions\n\n  /** @param {zlib.ZlibOptions} [zlibOptions] */\n  constructor (zlibOptions) {\n    super()\n    this.#zlibOptions = zlibOptions\n  }\n\n  _transform (chunk, encoding, callback) {\n    if (!this._inflateStream) {\n      if (chunk.length === 0) {\n        callback()\n        return\n      }\n      this._inflateStream = (chunk[0] & 0x0F) === 0x08\n        ? zlib.createInflate(this.#zlibOptions)\n        : zlib.createInflateRaw(this.#zlibOptions)\n\n      this._inflateStream.on('data', this.push.bind(this))\n      this._inflateStream.on('end', () => this.push(null))\n      this._inflateStream.on('error', (err) => this.destroy(err))\n    }\n\n    this._inflateStream.write(chunk, encoding, callback)\n  }\n\n  _final (callback) {\n    if (this._inflateStream) {\n      this._inflateStream.end()\n      this._inflateStream = null\n    }\n    callback()\n  }\n}\n\n/**\n * @param {zlib.ZlibOptions} [zlibOptions]\n * @returns {InflateStream}\n */\nfunction createInflate (zlibOptions) {\n  return new InflateStream(zlibOptions)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-extract-mime-type\n * @param {import('./headers').HeadersList} headers\n */\nfunction extractMimeType (headers) {\n  // 1. Let charset be null.\n  let charset = null\n\n  // 2. Let essence be null.\n  let essence = null\n\n  // 3. Let mimeType be null.\n  let mimeType = null\n\n  // 4. Let values be the result of getting, decoding, and splitting `Content-Type` from headers.\n  const values = getDecodeSplit('content-type', headers)\n\n  // 5. If values is null, then return failure.\n  if (values === null) {\n    return 'failure'\n  }\n\n  // 6. For each value of values:\n  for (const value of values) {\n    // 6.1. Let temporaryMimeType be the result of parsing value.\n    const temporaryMimeType = parseMIMEType(value)\n\n    // 6.2. If temporaryMimeType is failure or its essence is \"*/*\", then continue.\n    if (temporaryMimeType === 'failure' || temporaryMimeType.essence === '*/*') {\n      continue\n    }\n\n    // 6.3. Set mimeType to temporaryMimeType.\n    mimeType = temporaryMimeType\n\n    // 6.4. If mimeType’s essence is not essence, then:\n    if (mimeType.essence !== essence) {\n      // 6.4.1. Set charset to null.\n      charset = null\n\n      // 6.4.2. If mimeType’s parameters[\"charset\"] exists, then set charset to\n      //        mimeType’s parameters[\"charset\"].\n      if (mimeType.parameters.has('charset')) {\n        charset = mimeType.parameters.get('charset')\n      }\n\n      // 6.4.3. Set essence to mimeType’s essence.\n      essence = mimeType.essence\n    } else if (!mimeType.parameters.has('charset') && charset !== null) {\n      // 6.5. Otherwise, if mimeType’s parameters[\"charset\"] does not exist, and\n      //      charset is non-null, set mimeType’s parameters[\"charset\"] to charset.\n      mimeType.parameters.set('charset', charset)\n    }\n  }\n\n  // 7. If mimeType is null, then return failure.\n  if (mimeType == null) {\n    return 'failure'\n  }\n\n  // 8. Return mimeType.\n  return mimeType\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value-get-decode-and-split\n * @param {string|null} value\n */\nfunction gettingDecodingSplitting (value) {\n  // 1. Let input be the result of isomorphic decoding value.\n  const input = value\n\n  // 2. Let position be a position variable for input, initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let values be a list of strings, initially empty.\n  const values = []\n\n  // 4. Let temporaryValue be the empty string.\n  let temporaryValue = ''\n\n  // 5. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 5.1. Append the result of collecting a sequence of code points that are not U+0022 (\")\n    //      or U+002C (,) from input, given position, to temporaryValue.\n    temporaryValue += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== ',',\n      input,\n      position\n    )\n\n    // 5.2. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 5.2.1. If the code point at position within input is U+0022 (\"), then:\n      if (input.charCodeAt(position.position) === 0x22) {\n        // 5.2.1.1. Append the result of collecting an HTTP quoted string from input, given position, to temporaryValue.\n        temporaryValue += collectAnHTTPQuotedString(\n          input,\n          position\n        )\n\n        // 5.2.1.2. If position is not past the end of input, then continue.\n        if (position.position < input.length) {\n          continue\n        }\n      } else {\n        // 5.2.2. Otherwise:\n\n        // 5.2.2.1. Assert: the code point at position within input is U+002C (,).\n        assert(input.charCodeAt(position.position) === 0x2C)\n\n        // 5.2.2.2. Advance position by 1.\n        position.position++\n      }\n    }\n\n    // 5.3. Remove all HTTP tab or space from the start and end of temporaryValue.\n    temporaryValue = removeChars(temporaryValue, true, true, (char) => char === 0x9 || char === 0x20)\n\n    // 5.4. Append temporaryValue to values.\n    values.push(temporaryValue)\n\n    // 5.6. Set temporaryValue to the empty string.\n    temporaryValue = ''\n  }\n\n  // 6. Return values.\n  return values\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#concept-header-list-get-decode-split\n * @param {string} name lowercase header name\n * @param {import('./headers').HeadersList} list\n */\nfunction getDecodeSplit (name, list) {\n  // 1. Let value be the result of getting name from list.\n  const value = list.get(name, true)\n\n  // 2. If value is null, then return null.\n  if (value === null) {\n    return null\n  }\n\n  // 3. Return the result of getting, decoding, and splitting value.\n  return gettingDecodingSplitting(value)\n}\n\nconst textDecoder = new TextDecoder()\n\n/**\n * @see https://encoding.spec.whatwg.org/#utf-8-decode\n * @param {Buffer} buffer\n */\nfunction utf8DecodeBytes (buffer) {\n  if (buffer.length === 0) {\n    return ''\n  }\n\n  // 1. Let buffer be the result of peeking three bytes from\n  //    ioQueue, converted to a byte sequence.\n\n  // 2. If buffer is 0xEF 0xBB 0xBF, then read three\n  //    bytes from ioQueue. (Do nothing with those bytes.)\n  if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {\n    buffer = buffer.subarray(3)\n  }\n\n  // 3. Process a queue with an instance of UTF-8’s\n  //    decoder, ioQueue, output, and \"replacement\".\n  const output = textDecoder.decode(buffer)\n\n  // 4. Return output.\n  return output\n}\n\nclass EnvironmentSettingsObjectBase {\n  get baseUrl () {\n    return getGlobalOrigin()\n  }\n\n  get origin () {\n    return this.baseUrl?.origin\n  }\n\n  policyContainer = makePolicyContainer()\n}\n\nclass EnvironmentSettingsObject {\n  settingsObject = new EnvironmentSettingsObjectBase()\n}\n\nconst environmentSettingsObject = new EnvironmentSettingsObject()\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  isValidEncodedURL,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  clampAndCoarsenConnectionTimingInfo,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  iteratorMixin,\n  createIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  urlIsLocal,\n  urlHasHttpsScheme,\n  urlIsHttpHttpsScheme,\n  readAllBytes,\n  simpleRangeHeaderValue,\n  buildContentRange,\n  parseMetadata,\n  createInflate,\n  extractMimeType,\n  getDecodeSplit,\n  utf8DecodeBytes,\n  environmentSettingsObject\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGdDQUFhO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyw0QkFBVztBQUNoQyxRQUFRLDBFQUEwRSxFQUFFLG1CQUFPLENBQUMsMkVBQWE7QUFDekcsUUFBUSxrQkFBa0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFVO0FBQzlDLFFBQVEsc0ZBQXNGLEVBQUUsbUJBQU8sQ0FBQyx5RUFBWTtBQUNwSCxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLHdDQUFpQjtBQUNqRCxRQUFRLGdGQUFnRixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ25ILGVBQWUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNwQyxRQUFRLGVBQWUsRUFBRSxtQkFBTyxDQUFDLHdDQUFpQjtBQUNsRCxRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLHFFQUFVOztBQUVyQzs7QUFFQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLElBQUk7O0FBRXpHO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0QkFBNEIsSUFBSTtBQUMvQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHNDQUFzQyxJQUFJO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUM7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixlQUFlLCtCQUErQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsTUFBTTtBQUNoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyx1Q0FBdUM7O0FBRXJEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QixLQUFLO0FBQ0wsWUFBWTtBQUNaLEdBQUc7O0FBRUg7QUFDQSxhQUFhLFNBQVM7QUFDdEIsYUFBYSwrQkFBK0I7QUFDNUMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxLQUFLO0FBQ3pEO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHNDQUFzQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHFCQUFxQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsV0FBVzs7QUFFakQ7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxTQUFTOztBQUUvQztBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLFdBQVc7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGlDQUFpQztBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IFRyYW5zZm9ybSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ25vZGU6emxpYicpXG5jb25zdCB7IHJlZGlyZWN0U3RhdHVzU2V0LCByZWZlcnJlclBvbGljeVNldDogcmVmZXJyZXJQb2xpY3lUb2tlbnMsIGJhZFBvcnRzU2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IGdldEdsb2JhbE9yaWdpbiB9ID0gcmVxdWlyZSgnLi9nbG9iYWwnKVxuY29uc3QgeyBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzLCBjb2xsZWN0QW5IVFRQUXVvdGVkU3RyaW5nLCByZW1vdmVDaGFycywgcGFyc2VNSU1FVHlwZSB9ID0gcmVxdWlyZSgnLi9kYXRhLXVybCcpXG5jb25zdCB7IHBlcmZvcm1hbmNlIH0gPSByZXF1aXJlKCdub2RlOnBlcmZfaG9va3MnKVxuY29uc3QgeyBpc0Jsb2JMaWtlLCBSZWFkYWJsZVN0cmVhbUZyb20sIGlzVmFsaWRIVFRQVG9rZW4sIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ25vZGU6YXNzZXJ0JylcbmNvbnN0IHsgaXNVaW50OEFycmF5IH0gPSByZXF1aXJlKCdub2RlOnV0aWwvdHlwZXMnKVxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4vd2ViaWRsJylcblxubGV0IHN1cHBvcnRlZEhhc2hlcyA9IFtdXG5cbi8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvY3J5cHRvLmh0bWwjZGV0ZXJtaW5pbmctaWYtY3J5cHRvLXN1cHBvcnQtaXMtdW5hdmFpbGFibGVcbi8qKiBAdHlwZSB7aW1wb3J0KCdjcnlwdG8nKX0gKi9cbmxldCBjcnlwdG9cbnRyeSB7XG4gIGNyeXB0byA9IHJlcXVpcmUoJ25vZGU6Y3J5cHRvJylcbiAgY29uc3QgcG9zc2libGVSZWxldmFudEhhc2hlcyA9IFsnc2hhMjU2JywgJ3NoYTM4NCcsICdzaGE1MTInXVxuICBzdXBwb3J0ZWRIYXNoZXMgPSBjcnlwdG8uZ2V0SGFzaGVzKCkuZmlsdGVyKChoYXNoKSA9PiBwb3NzaWJsZVJlbGV2YW50SGFzaGVzLmluY2x1ZGVzKGhhc2gpKVxuLyogYzggaWdub3JlIG5leHQgMyAqL1xufSBjYXRjaCB7XG5cbn1cblxuZnVuY3Rpb24gcmVzcG9uc2VVUkwgKHJlc3BvbnNlKSB7XG4gIC8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZXNcbiAgLy8gQSByZXNwb25zZSBoYXMgYW4gYXNzb2NpYXRlZCBVUkwuIEl0IGlzIGEgcG9pbnRlciB0byB0aGUgbGFzdCBVUkxcbiAgLy8gaW4gcmVzcG9uc2XigJlzIFVSTCBsaXN0IGFuZCBudWxsIGlmIHJlc3BvbnNl4oCZcyBVUkwgbGlzdCBpcyBlbXB0eS5cbiAgY29uc3QgdXJsTGlzdCA9IHJlc3BvbnNlLnVybExpc3RcbiAgY29uc3QgbGVuZ3RoID0gdXJsTGlzdC5sZW5ndGhcbiAgcmV0dXJuIGxlbmd0aCA9PT0gMCA/IG51bGwgOiB1cmxMaXN0W2xlbmd0aCAtIDFdLnRvU3RyaW5nKClcbn1cblxuLy8gaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtcmVzcG9uc2UtbG9jYXRpb24tdXJsXG5mdW5jdGlvbiByZXNwb25zZUxvY2F0aW9uVVJMIChyZXNwb25zZSwgcmVxdWVzdEZyYWdtZW50KSB7XG4gIC8vIDEuIElmIHJlc3BvbnNl4oCZcyBzdGF0dXMgaXMgbm90IGEgcmVkaXJlY3Qgc3RhdHVzLCB0aGVuIHJldHVybiBudWxsLlxuICBpZiAoIXJlZGlyZWN0U3RhdHVzU2V0LmhhcyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIDIuIExldCBsb2NhdGlvbiBiZSB0aGUgcmVzdWx0IG9mIGV4dHJhY3RpbmcgaGVhZGVyIGxpc3QgdmFsdWVzIGdpdmVuXG4gIC8vIGBMb2NhdGlvbmAgYW5kIHJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdC5cbiAgbGV0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdsb2NhdGlvbicsIHRydWUpXG5cbiAgLy8gMy4gSWYgbG9jYXRpb24gaXMgYSBoZWFkZXIgdmFsdWUsIHRoZW4gc2V0IGxvY2F0aW9uIHRvIHRoZSByZXN1bHQgb2ZcbiAgLy8gICAgcGFyc2luZyBsb2NhdGlvbiB3aXRoIHJlc3BvbnNl4oCZcyBVUkwuXG4gIGlmIChsb2NhdGlvbiAhPT0gbnVsbCAmJiBpc1ZhbGlkSGVhZGVyVmFsdWUobG9jYXRpb24pKSB7XG4gICAgaWYgKCFpc1ZhbGlkRW5jb2RlZFVSTChsb2NhdGlvbikpIHtcbiAgICAgIC8vIFNvbWUgd2Vic2l0ZXMgcmVzcG9uZCBsb2NhdGlvbiBoZWFkZXIgaW4gVVRGLTggZm9ybSB3aXRob3V0IGVuY29kaW5nIHRoZW0gYXMgQVNDSUlcbiAgICAgIC8vIGFuZCBtYWpvciBicm93c2VycyByZWRpcmVjdCB0aGVtIHRvIGNvcnJlY3RseSBVVEYtOCBlbmNvZGVkIGFkZHJlc3Nlcy5cbiAgICAgIC8vIEhlcmUsIHdlIGhhbmRsZSB0aGF0IGJlaGF2aW9yIGluIHRoZSBzYW1lIHdheS5cbiAgICAgIGxvY2F0aW9uID0gbm9ybWFsaXplQmluYXJ5U3RyaW5nVG9VdGY4KGxvY2F0aW9uKVxuICAgIH1cbiAgICBsb2NhdGlvbiA9IG5ldyBVUkwobG9jYXRpb24sIHJlc3BvbnNlVVJMKHJlc3BvbnNlKSlcbiAgfVxuXG4gIC8vIDQuIElmIGxvY2F0aW9uIGlzIGEgVVJMIHdob3NlIGZyYWdtZW50IGlzIG51bGwsIHRoZW4gc2V0IGxvY2F0aW9u4oCZc1xuICAvLyBmcmFnbWVudCB0byByZXF1ZXN0RnJhZ21lbnQuXG4gIGlmIChsb2NhdGlvbiAmJiAhbG9jYXRpb24uaGFzaCkge1xuICAgIGxvY2F0aW9uLmhhc2ggPSByZXF1ZXN0RnJhZ21lbnRcbiAgfVxuXG4gIC8vIDUuIFJldHVybiBsb2NhdGlvbi5cbiAgcmV0dXJuIGxvY2F0aW9uXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMTczOCNzZWN0aW9uLTIuMlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbmNvZGVkVVJMICh1cmwpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB1cmwubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBjb2RlID0gdXJsLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPiAweDdFIHx8IC8vIE5vbi1VUy1BU0NJSSArIERFTFxuICAgICAgY29kZSA8IDB4MjAgLy8gQ29udHJvbCBjaGFyYWN0ZXJzIE5VTCAtIFVTXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBJZiBzdHJpbmcgY29udGFpbnMgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGFzc3VtZXMgaXQncyBVVEYtOCBlbmNvZGVkIGFuZCBkZWNvZGVzIGl0LlxuICogU2luY2UgVVRGLTggaXMgYSBzdXBlcnNldCBvZiBBU0NJSSwgdGhpcyB3aWxsIHdvcmsgZm9yIEFTQ0lJIHN0cmluZ3MgYXMgd2VsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQmluYXJ5U3RyaW5nVG9VdGY4ICh2YWx1ZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWUsICdiaW5hcnknKS50b1N0cmluZygndXRmOCcpXG59XG5cbi8qKiBAcmV0dXJucyB7VVJMfSAqL1xuZnVuY3Rpb24gcmVxdWVzdEN1cnJlbnRVUkwgKHJlcXVlc3QpIHtcbiAgcmV0dXJuIHJlcXVlc3QudXJsTGlzdFtyZXF1ZXN0LnVybExpc3QubGVuZ3RoIC0gMV1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdEJhZFBvcnQgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHVybCBiZSByZXF1ZXN04oCZcyBjdXJyZW50IFVSTC5cbiAgY29uc3QgdXJsID0gcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdClcblxuICAvLyAyLiBJZiB1cmzigJlzIHNjaGVtZSBpcyBhbiBIVFRQKFMpIHNjaGVtZSBhbmQgdXJs4oCZcyBwb3J0IGlzIGEgYmFkIHBvcnQsXG4gIC8vIHRoZW4gcmV0dXJuIGJsb2NrZWQuXG4gIGlmICh1cmxJc0h0dHBIdHRwc1NjaGVtZSh1cmwpICYmIGJhZFBvcnRzU2V0Lmhhcyh1cmwucG9ydCkpIHtcbiAgICByZXR1cm4gJ2Jsb2NrZWQnXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gYWxsb3dlZC5cbiAgcmV0dXJuICdhbGxvd2VkJ1xufVxuXG5mdW5jdGlvbiBpc0Vycm9yTGlrZSAob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBFcnJvciB8fCAoXG4gICAgb2JqZWN0Py5jb25zdHJ1Y3Rvcj8ubmFtZSA9PT0gJ0Vycm9yJyB8fFxuICAgIG9iamVjdD8uY29uc3RydWN0b3I/Lm5hbWUgPT09ICdET01FeGNlcHRpb24nXG4gIClcbn1cblxuLy8gQ2hlY2sgd2hldGhlciB8c3RhdHVzVGV4dHwgaXMgYSBCeXRlU3RyaW5nIGFuZFxuLy8gbWF0Y2hlcyB0aGUgUmVhc29uLVBocmFzZSB0b2tlbiBwcm9kdWN0aW9uLlxuLy8gUkZDIDI2MTY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyNjE2XG4vLyBSRkMgNzIzMDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzBcbi8vIFwicmVhc29uLXBocmFzZSA9ICooIEhUQUIgLyBTUCAvIFZDSEFSIC8gb2JzLXRleHQgKVwiXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi85NC4wLjQ2MDQuMS90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9jb3JlL2ZldGNoL3Jlc3BvbnNlLmNjI0wxMTZcbmZ1bmN0aW9uIGlzVmFsaWRSZWFzb25QaHJhc2UgKHN0YXR1c1RleHQpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0dXNUZXh0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgYyA9IHN0YXR1c1RleHQuY2hhckNvZGVBdChpKVxuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIChcbiAgICAgICAgICBjID09PSAweDA5IHx8IC8vIEhUQUJcbiAgICAgICAgICAoYyA+PSAweDIwICYmIGMgPD0gMHg3ZSkgfHwgLy8gU1AgLyBWQ0hBUlxuICAgICAgICAgIChjID49IDB4ODAgJiYgYyA8PSAweGZmKVxuICAgICAgICApIC8vIG9icy10ZXh0XG4gICAgICApXG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNoZWFkZXItbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmNvbnN0IGlzVmFsaWRIZWFkZXJOYW1lID0gaXNWYWxpZEhUVFBUb2tlblxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci12YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBvdGVudGlhbFZhbHVlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRIZWFkZXJWYWx1ZSAocG90ZW50aWFsVmFsdWUpIHtcbiAgLy8gLSBIYXMgbm8gbGVhZGluZyBvciB0cmFpbGluZyBIVFRQIHRhYiBvciBzcGFjZSBieXRlcy5cbiAgLy8gLSBDb250YWlucyBubyAweDAwIChOVUwpIG9yIEhUVFAgbmV3bGluZSBieXRlcy5cbiAgcmV0dXJuIChcbiAgICBwb3RlbnRpYWxWYWx1ZVswXSA9PT0gJ1xcdCcgfHxcbiAgICBwb3RlbnRpYWxWYWx1ZVswXSA9PT0gJyAnIHx8XG4gICAgcG90ZW50aWFsVmFsdWVbcG90ZW50aWFsVmFsdWUubGVuZ3RoIC0gMV0gPT09ICdcXHQnIHx8XG4gICAgcG90ZW50aWFsVmFsdWVbcG90ZW50aWFsVmFsdWUubGVuZ3RoIC0gMV0gPT09ICcgJyB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXG4nKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXHInKSB8fFxuICAgIHBvdGVudGlhbFZhbHVlLmluY2x1ZGVzKCdcXDAnKVxuICApID09PSBmYWxzZVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jc2V0LXJlcXVlc3RzLXJlZmVycmVyLXBvbGljeS1vbi1yZWRpcmVjdFxuZnVuY3Rpb24gc2V0UmVxdWVzdFJlZmVycmVyUG9saWN5T25SZWRpcmVjdCAocmVxdWVzdCwgYWN0dWFsUmVzcG9uc2UpIHtcbiAgLy8gIEdpdmVuIGEgcmVxdWVzdCByZXF1ZXN0IGFuZCBhIHJlc3BvbnNlIGFjdHVhbFJlc3BvbnNlLCB0aGlzIGFsZ29yaXRobVxuICAvLyAgdXBkYXRlcyByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgYWNjb3JkaW5nIHRvIHRoZSBSZWZlcnJlci1Qb2xpY3lcbiAgLy8gIGhlYWRlciAoaWYgYW55KSBpbiBhY3R1YWxSZXNwb25zZS5cblxuICAvLyAxLiBMZXQgcG9saWN5IGJlIHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIMKnIDguMSBQYXJzZSBhIHJlZmVycmVyIHBvbGljeVxuICAvLyBmcm9tIGEgUmVmZXJyZXItUG9saWN5IGhlYWRlciBvbiBhY3R1YWxSZXNwb25zZS5cblxuICAvLyA4LjEgUGFyc2UgYSByZWZlcnJlciBwb2xpY3kgZnJvbSBhIFJlZmVycmVyLVBvbGljeSBoZWFkZXJcbiAgLy8gMS4gTGV0IHBvbGljeS10b2tlbnMgYmUgdGhlIHJlc3VsdCBvZiBleHRyYWN0aW5nIGhlYWRlciBsaXN0IHZhbHVlcyBnaXZlbiBgUmVmZXJyZXItUG9saWN5YCBhbmQgcmVzcG9uc2XigJlzIGhlYWRlciBsaXN0LlxuICBjb25zdCB7IGhlYWRlcnNMaXN0IH0gPSBhY3R1YWxSZXNwb25zZVxuICAvLyAyLiBMZXQgcG9saWN5IGJlIHRoZSBlbXB0eSBzdHJpbmcuXG4gIC8vIDMuIEZvciBlYWNoIHRva2VuIGluIHBvbGljeS10b2tlbnMsIGlmIHRva2VuIGlzIGEgcmVmZXJyZXIgcG9saWN5IGFuZCB0b2tlbiBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgdGhlbiBzZXQgcG9saWN5IHRvIHRva2VuLlxuICAvLyA0LiBSZXR1cm4gcG9saWN5LlxuICBjb25zdCBwb2xpY3lIZWFkZXIgPSAoaGVhZGVyc0xpc3QuZ2V0KCdyZWZlcnJlci1wb2xpY3knLCB0cnVlKSA/PyAnJykuc3BsaXQoJywnKVxuXG4gIC8vIE5vdGU6IEFzIHRoZSByZWZlcnJlci1wb2xpY3kgY2FuIGNvbnRhaW4gbXVsdGlwbGUgcG9saWNpZXNcbiAgLy8gc2VwYXJhdGVkIGJ5IGNvbW1hLCB3ZSBuZWVkIHRvIGxvb3AgdGhyb3VnaCBhbGwgb2YgdGhlbVxuICAvLyBhbmQgcGljayB0aGUgZmlyc3QgdmFsaWQgb25lLlxuICAvLyBSZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZWZlcnJlci1Qb2xpY3kjc3BlY2lmeV9hX2ZhbGxiYWNrX3BvbGljeVxuICBsZXQgcG9saWN5ID0gJydcbiAgaWYgKHBvbGljeUhlYWRlci5sZW5ndGggPiAwKSB7XG4gICAgLy8gVGhlIHJpZ2h0LW1vc3QgcG9saWN5IHRha2VzIHByZWNlZGVuY2UuXG4gICAgLy8gVGhlIGxlZnQtbW9zdCBwb2xpY3kgaXMgdGhlIGZhbGxiYWNrLlxuICAgIGZvciAobGV0IGkgPSBwb2xpY3lIZWFkZXIubGVuZ3RoOyBpICE9PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHRva2VuID0gcG9saWN5SGVhZGVyW2kgLSAxXS50cmltKClcbiAgICAgIGlmIChyZWZlcnJlclBvbGljeVRva2Vucy5oYXModG9rZW4pKSB7XG4gICAgICAgIHBvbGljeSA9IHRva2VuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMi4gSWYgcG9saWN5IGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCB0aGVuIHNldCByZXF1ZXN04oCZcyByZWZlcnJlciBwb2xpY3kgdG8gcG9saWN5LlxuICBpZiAocG9saWN5ICE9PSAnJykge1xuICAgIHJlcXVlc3QucmVmZXJyZXJQb2xpY3kgPSBwb2xpY3lcbiAgfVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY3Jvc3Mtb3JpZ2luLXJlc291cmNlLXBvbGljeS1jaGVja1xuZnVuY3Rpb24gY3Jvc3NPcmlnaW5SZXNvdXJjZVBvbGljeUNoZWNrICgpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gJ2FsbG93ZWQnXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWNvcnMtY2hlY2tcbmZ1bmN0aW9uIGNvcnNDaGVjayAoKSB7XG4gIC8vIFRPRE9cbiAgcmV0dXJuICdzdWNjZXNzJ1xufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC10YW8tY2hlY2tcbmZ1bmN0aW9uIFRBT0NoZWNrICgpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gJ3N1Y2Nlc3MnXG59XG5cbmZ1bmN0aW9uIGFwcGVuZEZldGNoTWV0YWRhdGEgKGh0dHBSZXF1ZXN0KSB7XG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtZGVzdC1oZWFkZXJcbiAgLy8gIFRPRE9cblxuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLW1vZGUtaGVhZGVyXG5cbiAgLy8gIDEuIEFzc2VydDogcuKAmXMgdXJsIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLlxuICAvLyAgVE9ET1xuXG4gIC8vICAyLiBMZXQgaGVhZGVyIGJlIGEgU3RydWN0dXJlZCBIZWFkZXIgd2hvc2UgdmFsdWUgaXMgYSB0b2tlbi5cbiAgbGV0IGhlYWRlciA9IG51bGxcblxuICAvLyAgMy4gU2V0IGhlYWRlcuKAmXMgdmFsdWUgdG8gcuKAmXMgbW9kZS5cbiAgaGVhZGVyID0gaHR0cFJlcXVlc3QubW9kZVxuXG4gIC8vICA0LiBTZXQgYSBzdHJ1Y3R1cmVkIGZpZWxkIHZhbHVlIGBTZWMtRmV0Y2gtTW9kZWAvaGVhZGVyIGluIHLigJlzIGhlYWRlciBsaXN0LlxuICBodHRwUmVxdWVzdC5oZWFkZXJzTGlzdC5zZXQoJ3NlYy1mZXRjaC1tb2RlJywgaGVhZGVyLCB0cnVlKVxuXG4gIC8vICBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLWZldGNoLW1ldGFkYXRhLyNzZWMtZmV0Y2gtc2l0ZS1oZWFkZXJcbiAgLy8gIFRPRE9cblxuICAvLyAgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1mZXRjaC1tZXRhZGF0YS8jc2VjLWZldGNoLXVzZXItaGVhZGVyXG4gIC8vICBUT0RPXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNhcHBlbmQtYS1yZXF1ZXN0LW9yaWdpbi1oZWFkZXJcbmZ1bmN0aW9uIGFwcGVuZFJlcXVlc3RPcmlnaW5IZWFkZXIgKHJlcXVlc3QpIHtcbiAgLy8gMS4gTGV0IHNlcmlhbGl6ZWRPcmlnaW4gYmUgdGhlIHJlc3VsdCBvZiBieXRlLXNlcmlhbGl6aW5nIGEgcmVxdWVzdCBvcmlnaW5cbiAgLy8gICAgd2l0aCByZXF1ZXN0LlxuICAvLyBUT0RPOiBpbXBsZW1lbnQgXCJieXRlLXNlcmlhbGl6aW5nIGEgcmVxdWVzdCBvcmlnaW5cIlxuICBsZXQgc2VyaWFsaXplZE9yaWdpbiA9IHJlcXVlc3Qub3JpZ2luXG5cbiAgLy8gLSBcIidjbGllbnQnIGlzIGNoYW5nZWQgdG8gYW4gb3JpZ2luIGR1cmluZyBmZXRjaGluZy5cIlxuICAvLyAgIFRoaXMgZG9lc24ndCBoYXBwZW4gaW4gdW5kaWNpIChpbiBtb3N0IGNhc2VzKSBiZWNhdXNlIHVuZGljaSwgYnkgZGVmYXVsdCxcbiAgLy8gICBoYXMgbm8gY29uY2VwdCBvZiBvcmlnaW4uXG4gIC8vIC0gcmVxdWVzdC5vcmlnaW4gY2FuIGFsc28gYmUgc2V0IHRvIHJlcXVlc3QuY2xpZW50Lm9yaWdpbiAoY2xpZW50IGJlaW5nXG4gIC8vICAgYW4gZW52aXJvbm1lbnQgc2V0dGluZ3Mgb2JqZWN0KSwgd2hpY2ggaXMgdW5kZWZpbmVkIHdpdGhvdXQgdXNpbmdcbiAgLy8gICBzZXRHbG9iYWxPcmlnaW4uXG4gIGlmIChzZXJpYWxpemVkT3JpZ2luID09PSAnY2xpZW50JyB8fCBzZXJpYWxpemVkT3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIElmIHJlcXVlc3TigJlzIHJlc3BvbnNlIHRhaW50aW5nIGlzIFwiY29yc1wiIG9yIHJlcXVlc3TigJlzIG1vZGUgaXMgXCJ3ZWJzb2NrZXRcIixcbiAgLy8gICAgdGhlbiBhcHBlbmQgKGBPcmlnaW5gLCBzZXJpYWxpemVkT3JpZ2luKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gMy4gT3RoZXJ3aXNlLCBpZiByZXF1ZXN04oCZcyBtZXRob2QgaXMgbmVpdGhlciBgR0VUYCBub3IgYEhFQURgLCB0aGVuOlxuICBpZiAocmVxdWVzdC5yZXNwb25zZVRhaW50aW5nID09PSAnY29ycycgfHwgcmVxdWVzdC5tb2RlID09PSAnd2Vic29ja2V0Jykge1xuICAgIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdvcmlnaW4nLCBzZXJpYWxpemVkT3JpZ2luLCB0cnVlKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QubWV0aG9kICE9PSAnR0VUJyAmJiByZXF1ZXN0Lm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgLy8gMS4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZmVycmVyIHBvbGljeTpcbiAgICBzd2l0Y2ggKHJlcXVlc3QucmVmZXJyZXJQb2xpY3kpIHtcbiAgICAgIGNhc2UgJ25vLXJlZmVycmVyJzpcbiAgICAgICAgLy8gU2V0IHNlcmlhbGl6ZWRPcmlnaW4gdG8gYG51bGxgLlxuICAgICAgICBzZXJpYWxpemVkT3JpZ2luID0gbnVsbFxuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnOlxuICAgICAgY2FzZSAnc3RyaWN0LW9yaWdpbic6XG4gICAgICBjYXNlICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJzpcbiAgICAgICAgLy8gSWYgcmVxdWVzdOKAmXMgb3JpZ2luIGlzIGEgdHVwbGUgb3JpZ2luLCBpdHMgc2NoZW1lIGlzIFwiaHR0cHNcIiwgYW5kXG4gICAgICAgIC8vIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZcyBzY2hlbWUgaXMgbm90IFwiaHR0cHNcIiwgdGhlbiBzZXRcbiAgICAgICAgLy8gc2VyaWFsaXplZE9yaWdpbiB0byBgbnVsbGAuXG4gICAgICAgIGlmIChyZXF1ZXN0Lm9yaWdpbiAmJiB1cmxIYXNIdHRwc1NjaGVtZShyZXF1ZXN0Lm9yaWdpbikgJiYgIXVybEhhc0h0dHBzU2NoZW1lKHJlcXVlc3RDdXJyZW50VVJMKHJlcXVlc3QpKSkge1xuICAgICAgICAgIHNlcmlhbGl6ZWRPcmlnaW4gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NhbWUtb3JpZ2luJzpcbiAgICAgICAgLy8gSWYgcmVxdWVzdOKAmXMgb3JpZ2luIGlzIG5vdCBzYW1lIG9yaWdpbiB3aXRoIHJlcXVlc3TigJlzIGN1cnJlbnQgVVJM4oCZc1xuICAgICAgICAvLyBvcmlnaW4sIHRoZW4gc2V0IHNlcmlhbGl6ZWRPcmlnaW4gdG8gYG51bGxgLlxuICAgICAgICBpZiAoIXNhbWVPcmlnaW4ocmVxdWVzdCwgcmVxdWVzdEN1cnJlbnRVUkwocmVxdWVzdCkpKSB7XG4gICAgICAgICAgc2VyaWFsaXplZE9yaWdpbiA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9XG5cbiAgICAvLyAyLiBBcHBlbmQgKGBPcmlnaW5gLCBzZXJpYWxpemVkT3JpZ2luKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnb3JpZ2luJywgc2VyaWFsaXplZE9yaWdpbiwgdHJ1ZSlcbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vaHItdGltZS8jZGZuLWNvYXJzZW4tdGltZVxuZnVuY3Rpb24gY29hcnNlblRpbWUgKHRpbWVzdGFtcCwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpIHtcbiAgLy8gVE9ET1xuICByZXR1cm4gdGltZXN0YW1wXG59XG5cbi8vIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjbGFtcC1hbmQtY29hcnNlbi1jb25uZWN0aW9uLXRpbWluZy1pbmZvXG5mdW5jdGlvbiBjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbyAoY29ubmVjdGlvblRpbWluZ0luZm8sIGRlZmF1bHRTdGFydFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSB7XG4gIGlmICghY29ubmVjdGlvblRpbWluZ0luZm8/LnN0YXJ0VGltZSB8fCBjb25uZWN0aW9uVGltaW5nSW5mby5zdGFydFRpbWUgPCBkZWZhdWx0U3RhcnRUaW1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRvbWFpbkxvb2t1cFN0YXJ0VGltZTogZGVmYXVsdFN0YXJ0VGltZSxcbiAgICAgIGRvbWFpbkxvb2t1cEVuZFRpbWU6IGRlZmF1bHRTdGFydFRpbWUsXG4gICAgICBjb25uZWN0aW9uU3RhcnRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgY29ubmVjdGlvbkVuZFRpbWU6IGRlZmF1bHRTdGFydFRpbWUsXG4gICAgICBzZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lOiBkZWZhdWx0U3RhcnRUaW1lLFxuICAgICAgQUxQTk5lZ290aWF0ZWRQcm90b2NvbDogY29ubmVjdGlvblRpbWluZ0luZm8/LkFMUE5OZWdvdGlhdGVkUHJvdG9jb2xcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRvbWFpbkxvb2t1cFN0YXJ0VGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uZG9tYWluTG9va3VwU3RhcnRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgZG9tYWluTG9va3VwRW5kVGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uZG9tYWluTG9va3VwRW5kVGltZSwgY3Jvc3NPcmlnaW5Jc29sYXRlZENhcGFiaWxpdHkpLFxuICAgIGNvbm5lY3Rpb25TdGFydFRpbWU6IGNvYXJzZW5UaW1lKGNvbm5lY3Rpb25UaW1pbmdJbmZvLmNvbm5lY3Rpb25TdGFydFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSxcbiAgICBjb25uZWN0aW9uRW5kVGltZTogY29hcnNlblRpbWUoY29ubmVjdGlvblRpbWluZ0luZm8uY29ubmVjdGlvbkVuZFRpbWUsIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KSxcbiAgICBzZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lOiBjb2Fyc2VuVGltZShjb25uZWN0aW9uVGltaW5nSW5mby5zZWN1cmVDb25uZWN0aW9uU3RhcnRUaW1lLCBjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSksXG4gICAgQUxQTk5lZ290aWF0ZWRQcm90b2NvbDogY29ubmVjdGlvblRpbWluZ0luZm8uQUxQTk5lZ290aWF0ZWRQcm90b2NvbFxuICB9XG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9oci10aW1lLyNkZm4tY29hcnNlbmVkLXNoYXJlZC1jdXJyZW50LXRpbWVcbmZ1bmN0aW9uIGNvYXJzZW5lZFNoYXJlZEN1cnJlbnRUaW1lIChjcm9zc09yaWdpbklzb2xhdGVkQ2FwYWJpbGl0eSkge1xuICByZXR1cm4gY29hcnNlblRpbWUocGVyZm9ybWFuY2Uubm93KCksIGNyb3NzT3JpZ2luSXNvbGF0ZWRDYXBhYmlsaXR5KVxufVxuXG4vLyBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY3JlYXRlLWFuLW9wYXF1ZS10aW1pbmctaW5mb1xuZnVuY3Rpb24gY3JlYXRlT3BhcXVlVGltaW5nSW5mbyAodGltaW5nSW5mbykge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0VGltZTogdGltaW5nSW5mby5zdGFydFRpbWUgPz8gMCxcbiAgICByZWRpcmVjdFN0YXJ0VGltZTogMCxcbiAgICByZWRpcmVjdEVuZFRpbWU6IDAsXG4gICAgcG9zdFJlZGlyZWN0U3RhcnRUaW1lOiB0aW1pbmdJbmZvLnN0YXJ0VGltZSA/PyAwLFxuICAgIGZpbmFsU2VydmljZVdvcmtlclN0YXJ0VGltZTogMCxcbiAgICBmaW5hbE5ldHdvcmtSZXNwb25zZVN0YXJ0VGltZTogMCxcbiAgICBmaW5hbE5ldHdvcmtSZXF1ZXN0U3RhcnRUaW1lOiAwLFxuICAgIGVuZFRpbWU6IDAsXG4gICAgZW5jb2RlZEJvZHlTaXplOiAwLFxuICAgIGRlY29kZWRCb2R5U2l6ZTogMCxcbiAgICBmaW5hbENvbm5lY3Rpb25UaW1pbmdJbmZvOiBudWxsXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvb3JpZ2luLmh0bWwjcG9saWN5LWNvbnRhaW5lclxuZnVuY3Rpb24gbWFrZVBvbGljeUNvbnRhaW5lciAoKSB7XG4gIC8vIE5vdGU6IHRoZSBmZXRjaCBzcGVjIGRvZXNuJ3QgbWFrZSB1c2Ugb2YgZW1iZWRkZXIgcG9saWN5IG9yIENTUCBsaXN0XG4gIHJldHVybiB7XG4gICAgcmVmZXJyZXJQb2xpY3k6ICdzdHJpY3Qtb3JpZ2luLXdoZW4tY3Jvc3Mtb3JpZ2luJ1xuICB9XG59XG5cbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI2Nsb25lLWEtcG9saWN5LWNvbnRhaW5lclxuZnVuY3Rpb24gY2xvbmVQb2xpY3lDb250YWluZXIgKHBvbGljeUNvbnRhaW5lcikge1xuICByZXR1cm4ge1xuICAgIHJlZmVycmVyUG9saWN5OiBwb2xpY3lDb250YWluZXIucmVmZXJyZXJQb2xpY3lcbiAgfVxufVxuXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXBwc2VjLXJlZmVycmVyLXBvbGljeS8jZGV0ZXJtaW5lLXJlcXVlc3RzLXJlZmVycmVyXG5mdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0c1JlZmVycmVyIChyZXF1ZXN0KSB7XG4gIC8vIDEuIExldCBwb2xpY3kgYmUgcmVxdWVzdCdzIHJlZmVycmVyIHBvbGljeS5cbiAgY29uc3QgcG9saWN5ID0gcmVxdWVzdC5yZWZlcnJlclBvbGljeVxuXG4gIC8vIE5vdGU6IHBvbGljeSBjYW5ub3QgKHNob3VsZG4ndCkgYmUgbnVsbCBvciBhbiBlbXB0eSBzdHJpbmcuXG4gIGFzc2VydChwb2xpY3kpXG5cbiAgLy8gMi4gTGV0IGVudmlyb25tZW50IGJlIHJlcXVlc3TigJlzIGNsaWVudC5cblxuICBsZXQgcmVmZXJyZXJTb3VyY2UgPSBudWxsXG5cbiAgLy8gMy4gU3dpdGNoIG9uIHJlcXVlc3TigJlzIHJlZmVycmVyOlxuICBpZiAocmVxdWVzdC5yZWZlcnJlciA9PT0gJ2NsaWVudCcpIHtcbiAgICAvLyBOb3RlOiBub2RlIGlzbid0IGEgYnJvd3NlciBhbmQgZG9lc24ndCBpbXBsZW1lbnQgZG9jdW1lbnQvaWZyYW1lcyxcbiAgICAvLyBzbyB3ZSBieXBhc3MgdGhpcyBzdGVwIGFuZCByZXBsYWNlIGl0IHdpdGggb3VyIG93bi5cblxuICAgIGNvbnN0IGdsb2JhbE9yaWdpbiA9IGdldEdsb2JhbE9yaWdpbigpXG5cbiAgICBpZiAoIWdsb2JhbE9yaWdpbiB8fCBnbG9iYWxPcmlnaW4ub3JpZ2luID09PSAnbnVsbCcpIHtcbiAgICAgIHJldHVybiAnbm8tcmVmZXJyZXInXG4gICAgfVxuXG4gICAgLy8gbm90ZTogd2UgbmVlZCB0byBjbG9uZSBpdCBhcyBpdCdzIG11dGF0ZWRcbiAgICByZWZlcnJlclNvdXJjZSA9IG5ldyBVUkwoZ2xvYmFsT3JpZ2luKVxuICB9IGVsc2UgaWYgKHJlcXVlc3QucmVmZXJyZXIgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAvLyBMZXQgcmVmZXJyZXJTb3VyY2UgYmUgcmVxdWVzdOKAmXMgcmVmZXJyZXIuXG4gICAgcmVmZXJyZXJTb3VyY2UgPSByZXF1ZXN0LnJlZmVycmVyXG4gIH1cblxuICAvLyA0LiBMZXQgcmVxdWVzdOKAmXMgcmVmZXJyZXJVUkwgYmUgdGhlIHJlc3VsdCBvZiBzdHJpcHBpbmcgcmVmZXJyZXJTb3VyY2UgZm9yXG4gIC8vICAgIHVzZSBhcyBhIHJlZmVycmVyLlxuICBsZXQgcmVmZXJyZXJVUkwgPSBzdHJpcFVSTEZvclJlZmVycmVyKHJlZmVycmVyU291cmNlKVxuXG4gIC8vIDUuIExldCByZWZlcnJlck9yaWdpbiBiZSB0aGUgcmVzdWx0IG9mIHN0cmlwcGluZyByZWZlcnJlclNvdXJjZSBmb3IgdXNlIGFzXG4gIC8vICAgIGEgcmVmZXJyZXIsIHdpdGggdGhlIG9yaWdpbi1vbmx5IGZsYWcgc2V0IHRvIHRydWUuXG4gIGNvbnN0IHJlZmVycmVyT3JpZ2luID0gc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcblxuICAvLyA2LiBJZiB0aGUgcmVzdWx0IG9mIHNlcmlhbGl6aW5nIHJlZmVycmVyVVJMIGlzIGEgc3RyaW5nIHdob3NlIGxlbmd0aCBpc1xuICAvLyAgICBncmVhdGVyIHRoYW4gNDA5Niwgc2V0IHJlZmVycmVyVVJMIHRvIHJlZmVycmVyT3JpZ2luLlxuICBpZiAocmVmZXJyZXJVUkwudG9TdHJpbmcoKS5sZW5ndGggPiA0MDk2KSB7XG4gICAgcmVmZXJyZXJVUkwgPSByZWZlcnJlck9yaWdpblxuICB9XG5cbiAgY29uc3QgYXJlU2FtZU9yaWdpbiA9IHNhbWVPcmlnaW4ocmVxdWVzdCwgcmVmZXJyZXJVUkwpXG4gIGNvbnN0IGlzTm9uUG90ZW50aWFsbHlUcnVzdFdvcnRoeSA9IGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiZcbiAgICAhaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5KHJlcXVlc3QudXJsKVxuXG4gIC8vIDguIEV4ZWN1dGUgdGhlIHN3aXRjaCBzdGF0ZW1lbnRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHZhbHVlIG9mIHBvbGljeTpcbiAgc3dpdGNoIChwb2xpY3kpIHtcbiAgICBjYXNlICdvcmlnaW4nOiByZXR1cm4gcmVmZXJyZXJPcmlnaW4gIT0gbnVsbCA/IHJlZmVycmVyT3JpZ2luIDogc3RyaXBVUkxGb3JSZWZlcnJlcihyZWZlcnJlclNvdXJjZSwgdHJ1ZSlcbiAgICBjYXNlICd1bnNhZmUtdXJsJzogcmV0dXJuIHJlZmVycmVyVVJMXG4gICAgY2FzZSAnc2FtZS1vcmlnaW4nOlxuICAgICAgcmV0dXJuIGFyZVNhbWVPcmlnaW4gPyByZWZlcnJlck9yaWdpbiA6ICduby1yZWZlcnJlcidcbiAgICBjYXNlICdvcmlnaW4td2hlbi1jcm9zcy1vcmlnaW4nOlxuICAgICAgcmV0dXJuIGFyZVNhbWVPcmlnaW4gPyByZWZlcnJlclVSTCA6IHJlZmVycmVyT3JpZ2luXG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbi13aGVuLWNyb3NzLW9yaWdpbic6IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRVUkwgPSByZXF1ZXN0Q3VycmVudFVSTChyZXF1ZXN0KVxuXG4gICAgICAvLyAxLiBJZiB0aGUgb3JpZ2luIG9mIHJlZmVycmVyVVJMIGFuZCB0aGUgb3JpZ2luIG9mIHJlcXVlc3TigJlzIGN1cnJlbnRcbiAgICAgIC8vICAgIFVSTCBhcmUgdGhlIHNhbWUsIHRoZW4gcmV0dXJuIHJlZmVycmVyVVJMLlxuICAgICAgaWYgKHNhbWVPcmlnaW4ocmVmZXJyZXJVUkwsIGN1cnJlbnRVUkwpKSB7XG4gICAgICAgIHJldHVybiByZWZlcnJlclVSTFxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmQgcmVxdWVzdOKAmXNcbiAgICAgIC8vICAgIGN1cnJlbnQgVVJMIGlzIG5vdCBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCwgdGhlbiByZXR1cm4gbm9cbiAgICAgIC8vICAgIHJlZmVycmVyLlxuICAgICAgaWYgKGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShyZWZlcnJlclVSTCkgJiYgIWlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeShjdXJyZW50VVJMKSkge1xuICAgICAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICAgICAgfVxuXG4gICAgICAvLyAzLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW4uXG4gICAgICByZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICB9XG4gICAgY2FzZSAnc3RyaWN0LW9yaWdpbic6IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIC8qKlxuICAgICAgICAgKiAxLiBJZiByZWZlcnJlclVSTCBpcyBhIHBvdGVudGlhbGx5IHRydXN0d29ydGh5IFVSTCBhbmRcbiAgICAgICAgICogcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLFxuICAgICAgICAgKiB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgICAgICAgICogMi4gUmV0dXJuIHJlZmVycmVyT3JpZ2luXG4gICAgICAgICovXG4gICAgY2FzZSAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvKipcbiAgICAgICAqIDEuIElmIHJlZmVycmVyVVJMIGlzIGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMIGFuZFxuICAgICAgICogcmVxdWVzdOKAmXMgY3VycmVudCBVUkwgaXMgbm90IGEgcG90ZW50aWFsbHkgdHJ1c3R3b3J0aHkgVVJMLFxuICAgICAgICogdGhlbiByZXR1cm4gbm8gcmVmZXJyZXIuXG4gICAgICAgKiAyLiBSZXR1cm4gcmVmZXJyZXJPcmlnaW5cbiAgICAgICovXG5cbiAgICBkZWZhdWx0OiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICByZXR1cm4gaXNOb25Qb3RlbnRpYWxseVRydXN0V29ydGh5ID8gJ25vLXJlZmVycmVyJyA6IHJlZmVycmVyT3JpZ2luXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtcmVmZXJyZXItcG9saWN5LyNzdHJpcC11cmxcbiAqIEBwYXJhbSB7VVJMfSB1cmxcbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IG9yaWdpbk9ubHlcbiAqL1xuZnVuY3Rpb24gc3RyaXBVUkxGb3JSZWZlcnJlciAodXJsLCBvcmlnaW5Pbmx5KSB7XG4gIC8vIDEuIEFzc2VydDogdXJsIGlzIGEgVVJMLlxuICBhc3NlcnQodXJsIGluc3RhbmNlb2YgVVJMKVxuXG4gIHVybCA9IG5ldyBVUkwodXJsKVxuXG4gIC8vIDIuIElmIHVybOKAmXMgc2NoZW1lIGlzIGEgbG9jYWwgc2NoZW1lLCB0aGVuIHJldHVybiBubyByZWZlcnJlci5cbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6JyB8fCB1cmwucHJvdG9jb2wgPT09ICdhYm91dDonIHx8IHVybC5wcm90b2NvbCA9PT0gJ2JsYW5rOicpIHtcbiAgICByZXR1cm4gJ25vLXJlZmVycmVyJ1xuICB9XG5cbiAgLy8gMy4gU2V0IHVybOKAmXMgdXNlcm5hbWUgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgdXJsLnVzZXJuYW1lID0gJydcblxuICAvLyA0LiBTZXQgdXJs4oCZcyBwYXNzd29yZCB0byB0aGUgZW1wdHkgc3RyaW5nLlxuICB1cmwucGFzc3dvcmQgPSAnJ1xuXG4gIC8vIDUuIFNldCB1cmzigJlzIGZyYWdtZW50IHRvIG51bGwuXG4gIHVybC5oYXNoID0gJydcblxuICAvLyA2LiBJZiB0aGUgb3JpZ2luLW9ubHkgZmxhZyBpcyB0cnVlLCB0aGVuOlxuICBpZiAob3JpZ2luT25seSkge1xuICAgIC8vIDEuIFNldCB1cmzigJlzIHBhdGggdG8gwqsgdGhlIGVtcHR5IHN0cmluZyDCuy5cbiAgICB1cmwucGF0aG5hbWUgPSAnJ1xuXG4gICAgLy8gMi4gU2V0IHVybOKAmXMgcXVlcnkgdG8gbnVsbC5cbiAgICB1cmwuc2VhcmNoID0gJydcbiAgfVxuXG4gIC8vIDcuIFJldHVybiB1cmwuXG4gIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gaXNVUkxQb3RlbnRpYWxseVRydXN0d29ydGh5ICh1cmwpIHtcbiAgaWYgKCEodXJsIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gSWYgY2hpbGQgb2YgYWJvdXQsIHJldHVybiB0cnVlXG4gIGlmICh1cmwuaHJlZiA9PT0gJ2Fib3V0OmJsYW5rJyB8fCB1cmwuaHJlZiA9PT0gJ2Fib3V0OnNyY2RvYycpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gSWYgc2NoZW1lIGlzIGRhdGEsIHJldHVybiB0cnVlXG4gIGlmICh1cmwucHJvdG9jb2wgPT09ICdkYXRhOicpIHJldHVybiB0cnVlXG5cbiAgLy8gSWYgZmlsZSwgcmV0dXJuIHRydWVcbiAgaWYgKHVybC5wcm90b2NvbCA9PT0gJ2ZpbGU6JykgcmV0dXJuIHRydWVcblxuICByZXR1cm4gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5KHVybC5vcmlnaW4pXG5cbiAgZnVuY3Rpb24gaXNPcmlnaW5Qb3RlbnRpYWxseVRydXN0d29ydGh5IChvcmlnaW4pIHtcbiAgICAvLyBJZiBvcmlnaW4gaXMgZXhwbGljaXRseSBudWxsLCByZXR1cm4gZmFsc2VcbiAgICBpZiAob3JpZ2luID09IG51bGwgfHwgb3JpZ2luID09PSAnbnVsbCcpIHJldHVybiBmYWxzZVxuXG4gICAgY29uc3Qgb3JpZ2luQXNVUkwgPSBuZXcgVVJMKG9yaWdpbilcblxuICAgIC8vIElmIHNlY3VyZSwgcmV0dXJuIHRydWVcbiAgICBpZiAob3JpZ2luQXNVUkwucHJvdG9jb2wgPT09ICdodHRwczonIHx8IG9yaWdpbkFzVVJMLnByb3RvY29sID09PSAnd3NzOicpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgbG9jYWxob3N0IG9yIHZhcmlhbnRzLCByZXR1cm4gdHJ1ZVxuICAgIGlmICgvXjEyNyg/OlxcLlswLTldKyl7MCwyfVxcLlswLTldKyR8XlxcWyg/OjAqOikqPzo/MCoxXFxdJC8udGVzdChvcmlnaW5Bc1VSTC5ob3N0bmFtZSkgfHxcbiAgICAgKG9yaWdpbkFzVVJMLmhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fCBvcmlnaW5Bc1VSTC5ob3N0bmFtZS5pbmNsdWRlcygnbG9jYWxob3N0LicpKSB8fFxuICAgICAob3JpZ2luQXNVUkwuaG9zdG5hbWUuZW5kc1dpdGgoJy5sb2NhbGhvc3QnKSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG90aGVyLCByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI2RvZXMtcmVzcG9uc2UtbWF0Y2gtbWV0YWRhdGFsaXN0XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFMaXN0XG4gKi9cbmZ1bmN0aW9uIGJ5dGVzTWF0Y2ggKGJ5dGVzLCBtZXRhZGF0YUxpc3QpIHtcbiAgLy8gSWYgbm9kZSBpcyBub3QgYnVpbHQgd2l0aCBPcGVuU1NMIHN1cHBvcnQsIHdlIGNhbm5vdCBjaGVja1xuICAvLyBhIHJlcXVlc3QncyBpbnRlZ3JpdHksIHNvIGFsbG93IGl0IGJ5IGRlZmF1bHQgKHRoZSBzcGVjIHdpbGxcbiAgLy8gYWxsb3cgcmVxdWVzdHMgaWYgYW4gaW52YWxpZCBoYXNoIGlzIGdpdmVuLCBhcyBwcmVjZWRlbmNlKS5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBvbmx5IGlmIG5vZGUgaXMgYnVpbHQgd2l0aCAtLXdpdGhvdXQtc3NsICovXG4gIGlmIChjcnlwdG8gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAxLiBMZXQgcGFyc2VkTWV0YWRhdGEgYmUgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIG1ldGFkYXRhTGlzdC5cbiAgY29uc3QgcGFyc2VkTWV0YWRhdGEgPSBwYXJzZU1ldGFkYXRhKG1ldGFkYXRhTGlzdClcblxuICAvLyAyLiBJZiBwYXJzZWRNZXRhZGF0YSBpcyBubyBtZXRhZGF0YSwgcmV0dXJuIHRydWUuXG4gIGlmIChwYXJzZWRNZXRhZGF0YSA9PT0gJ25vIG1ldGFkYXRhJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyAzLiBJZiByZXNwb25zZSBpcyBub3QgZWxpZ2libGUgZm9yIGludGVncml0eSB2YWxpZGF0aW9uLCByZXR1cm4gZmFsc2UuXG4gIC8vIFRPRE9cblxuICAvLyA0LiBJZiBwYXJzZWRNZXRhZGF0YSBpcyB0aGUgZW1wdHkgc2V0LCByZXR1cm4gdHJ1ZS5cbiAgaWYgKHBhcnNlZE1ldGFkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyA1LiBMZXQgbWV0YWRhdGEgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nIHRoZSBzdHJvbmdlc3RcbiAgLy8gICAgbWV0YWRhdGEgZnJvbSBwYXJzZWRNZXRhZGF0YS5cbiAgY29uc3Qgc3Ryb25nZXN0ID0gZ2V0U3Ryb25nZXN0TWV0YWRhdGEocGFyc2VkTWV0YWRhdGEpXG4gIGNvbnN0IG1ldGFkYXRhID0gZmlsdGVyTWV0YWRhdGFMaXN0QnlBbGdvcml0aG0ocGFyc2VkTWV0YWRhdGEsIHN0cm9uZ2VzdClcblxuICAvLyA2LiBGb3IgZWFjaCBpdGVtIGluIG1ldGFkYXRhOlxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgbWV0YWRhdGEpIHtcbiAgICAvLyAxLiBMZXQgYWxnb3JpdGhtIGJlIHRoZSBhbGcgY29tcG9uZW50IG9mIGl0ZW0uXG4gICAgY29uc3QgYWxnb3JpdGhtID0gaXRlbS5hbGdvXG5cbiAgICAvLyAyLiBMZXQgZXhwZWN0ZWRWYWx1ZSBiZSB0aGUgdmFsIGNvbXBvbmVudCBvZiBpdGVtLlxuICAgIGNvbnN0IGV4cGVjdGVkVmFsdWUgPSBpdGVtLmhhc2hcblxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2ViLXBsYXRmb3JtLXRlc3RzL3dwdC9jb21taXQvZTRjNWNjN2E1ZTQ4MDkzMjIwNTI4ZGZkZDFjNDAxMmRjMzgzN2EwZVxuICAgIC8vIFwiYmUgbGliZXJhbCB3aXRoIHBhZGRpbmdcIi4gVGhpcyBpcyBhbm5veWluZywgYW5kIGl0J3Mgbm90IGV2ZW4gaW4gdGhlIHNwZWMuXG5cbiAgICAvLyAzLiBMZXQgYWN0dWFsVmFsdWUgYmUgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBhbGdvcml0aG0gdG8gYnl0ZXMuXG4gICAgbGV0IGFjdHVhbFZhbHVlID0gY3J5cHRvLmNyZWF0ZUhhc2goYWxnb3JpdGhtKS51cGRhdGUoYnl0ZXMpLmRpZ2VzdCgnYmFzZTY0JylcblxuICAgIGlmIChhY3R1YWxWYWx1ZVthY3R1YWxWYWx1ZS5sZW5ndGggLSAxXSA9PT0gJz0nKSB7XG4gICAgICBpZiAoYWN0dWFsVmFsdWVbYWN0dWFsVmFsdWUubGVuZ3RoIC0gMl0gPT09ICc9Jykge1xuICAgICAgICBhY3R1YWxWYWx1ZSA9IGFjdHVhbFZhbHVlLnNsaWNlKDAsIC0yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0dWFsVmFsdWUgPSBhY3R1YWxWYWx1ZS5zbGljZSgwLCAtMSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA0LiBJZiBhY3R1YWxWYWx1ZSBpcyBhIGNhc2Utc2Vuc2l0aXZlIG1hdGNoIGZvciBleHBlY3RlZFZhbHVlLFxuICAgIC8vICAgIHJldHVybiB0cnVlLlxuICAgIGlmIChjb21wYXJlQmFzZTY0TWl4ZWQoYWN0dWFsVmFsdWUsIGV4cGVjdGVkVmFsdWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIDcuIFJldHVybiBmYWxzZS5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhcHBzZWMtc3VicmVzb3VyY2UtaW50ZWdyaXR5LyNncmFtbWFyZGVmLWhhc2gtd2l0aC1vcHRpb25zXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvQ1NQMi8jc291cmNlLWxpc3Qtc3ludGF4XG4vLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNTIzNCNhcHBlbmRpeC1CLjFcbmNvbnN0IHBhcnNlSGFzaFdpdGhPcHRpb25zID0gLyg/PGFsZ28+c2hhMjU2fHNoYTM4NHxzaGE1MTIpLSgoPzxoYXNoPltBLVphLXowLTkrL10rfFtBLVphLXowLTlfLV0rKT17MCwyfSg/Olxcc3wkKSggK1shLX5dKik/KT8vaVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy1zdWJyZXNvdXJjZS1pbnRlZ3JpdHkvI3BhcnNlLW1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gcGFyc2VNZXRhZGF0YSAobWV0YWRhdGEpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSB0aGUgZW1wdHkgc2V0LlxuICAvKiogQHR5cGUge3sgYWxnbzogc3RyaW5nLCBoYXNoOiBzdHJpbmcgfVtdfSAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuXG4gIC8vIDIuIExldCBlbXB0eSBiZSBlcXVhbCB0byB0cnVlLlxuICBsZXQgZW1wdHkgPSB0cnVlXG5cbiAgLy8gMy4gRm9yIGVhY2ggdG9rZW4gcmV0dXJuZWQgYnkgc3BsaXR0aW5nIG1ldGFkYXRhIG9uIHNwYWNlczpcbiAgZm9yIChjb25zdCB0b2tlbiBvZiBtZXRhZGF0YS5zcGxpdCgnICcpKSB7XG4gICAgLy8gMS4gU2V0IGVtcHR5IHRvIGZhbHNlLlxuICAgIGVtcHR5ID0gZmFsc2VcblxuICAgIC8vIDIuIFBhcnNlIHRva2VuIGFzIGEgaGFzaC13aXRoLW9wdGlvbnMuXG4gICAgY29uc3QgcGFyc2VkVG9rZW4gPSBwYXJzZUhhc2hXaXRoT3B0aW9ucy5leGVjKHRva2VuKVxuXG4gICAgLy8gMy4gSWYgdG9rZW4gZG9lcyBub3QgcGFyc2UsIGNvbnRpbnVlIHRvIHRoZSBuZXh0IHRva2VuLlxuICAgIGlmIChcbiAgICAgIHBhcnNlZFRva2VuID09PSBudWxsIHx8XG4gICAgICBwYXJzZWRUb2tlbi5ncm91cHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgcGFyc2VkVG9rZW4uZ3JvdXBzLmFsZ28gPT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgLy8gTm90ZTogQ2hyb21pdW0gYmxvY2tzIHRoZSByZXF1ZXN0IGF0IHRoaXMgcG9pbnQsIGJ1dCBGaXJlZm94XG4gICAgICAvLyBnaXZlcyBhIHdhcm5pbmcgdGhhdCBhbiBpbnZhbGlkIGludGVncml0eSB3YXMgZ2l2ZW4uIFRoZVxuICAgICAgLy8gY29ycmVjdCBiZWhhdmlvciBpcyB0byBpZ25vcmUgdGhlc2UsIGFuZCBzdWJzZXF1ZW50bHkgbm90XG4gICAgICAvLyBjaGVjayB0aGUgaW50ZWdyaXR5IG9mIHRoZSByZXNvdXJjZS5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gNC4gTGV0IGFsZ29yaXRobSBiZSB0aGUgaGFzaC1hbGdvIGNvbXBvbmVudCBvZiB0b2tlbi5cbiAgICBjb25zdCBhbGdvcml0aG0gPSBwYXJzZWRUb2tlbi5ncm91cHMuYWxnby50b0xvd2VyQ2FzZSgpXG5cbiAgICAvLyA1LiBJZiBhbGdvcml0aG0gaXMgYSBoYXNoIGZ1bmN0aW9uIHJlY29nbml6ZWQgYnkgdGhlIHVzZXJcbiAgICAvLyAgICBhZ2VudCwgYWRkIHRoZSBwYXJzZWQgdG9rZW4gdG8gcmVzdWx0LlxuICAgIGlmIChzdXBwb3J0ZWRIYXNoZXMuaW5jbHVkZXMoYWxnb3JpdGhtKSkge1xuICAgICAgcmVzdWx0LnB1c2gocGFyc2VkVG9rZW4uZ3JvdXBzKVxuICAgIH1cbiAgfVxuXG4gIC8vIDQuIFJldHVybiBubyBtZXRhZGF0YSBpZiBlbXB0eSBpcyB0cnVlLCBvdGhlcndpc2UgcmV0dXJuIHJlc3VsdC5cbiAgaWYgKGVtcHR5ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuICdubyBtZXRhZGF0YSdcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3sgYWxnbzogJ3NoYTI1NicgfCAnc2hhMzg0JyB8ICdzaGE1MTInIH1bXX0gbWV0YWRhdGFMaXN0XG4gKi9cbmZ1bmN0aW9uIGdldFN0cm9uZ2VzdE1ldGFkYXRhIChtZXRhZGF0YUxpc3QpIHtcbiAgLy8gTGV0IGFsZ29yaXRobSBiZSB0aGUgYWxnbyBjb21wb25lbnQgb2YgdGhlIGZpcnN0IGl0ZW0gaW4gbWV0YWRhdGFMaXN0LlxuICAvLyBDYW4gYmUgc2hhMjU2XG4gIGxldCBhbGdvcml0aG0gPSBtZXRhZGF0YUxpc3RbMF0uYWxnb1xuICAvLyBJZiB0aGUgYWxnb3JpdGhtIGlzIHNoYTUxMiwgdGhlbiBpdCBpcyB0aGUgc3Ryb25nZXN0XG4gIC8vIGFuZCB3ZSBjYW4gcmV0dXJuIGltbWVkaWF0ZWx5XG4gIGlmIChhbGdvcml0aG1bM10gPT09ICc1Jykge1xuICAgIHJldHVybiBhbGdvcml0aG1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgbWV0YWRhdGFMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YUxpc3RbaV1cbiAgICAvLyBJZiB0aGUgYWxnb3JpdGhtIGlzIHNoYTUxMiwgdGhlbiBpdCBpcyB0aGUgc3Ryb25nZXN0XG4gICAgLy8gYW5kIHdlIGNhbiBicmVhayB0aGUgbG9vcCBpbW1lZGlhdGVseVxuICAgIGlmIChtZXRhZGF0YS5hbGdvWzNdID09PSAnNScpIHtcbiAgICAgIGFsZ29yaXRobSA9ICdzaGE1MTInXG4gICAgICBicmVha1xuICAgIC8vIElmIHRoZSBhbGdvcml0aG0gaXMgc2hhMzg0LCB0aGVuIGEgcG90ZW50aWFsIHNoYTI1NiBvciBzaGEzODQgaXMgaWdub3JlZFxuICAgIH0gZWxzZSBpZiAoYWxnb3JpdGhtWzNdID09PSAnMycpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgLy8gYWxnb3JpdGhtIGlzIHNoYTI1NiwgY2hlY2sgaWYgYWxnb3JpdGhtIGlzIHNoYTM4NCBhbmQgaWYgc28sIHNldCBpdCBhc1xuICAgIC8vIHRoZSBzdHJvbmdlc3RcbiAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLmFsZ29bM10gPT09ICczJykge1xuICAgICAgYWxnb3JpdGhtID0gJ3NoYTM4NCdcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFsZ29yaXRobVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJNZXRhZGF0YUxpc3RCeUFsZ29yaXRobSAobWV0YWRhdGFMaXN0LCBhbGdvcml0aG0pIHtcbiAgaWYgKG1ldGFkYXRhTGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbWV0YWRhdGFMaXN0XG4gIH1cblxuICBsZXQgcG9zID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFkYXRhTGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGlmIChtZXRhZGF0YUxpc3RbaV0uYWxnbyA9PT0gYWxnb3JpdGhtKSB7XG4gICAgICBtZXRhZGF0YUxpc3RbcG9zKytdID0gbWV0YWRhdGFMaXN0W2ldXG4gICAgfVxuICB9XG5cbiAgbWV0YWRhdGFMaXN0Lmxlbmd0aCA9IHBvc1xuXG4gIHJldHVybiBtZXRhZGF0YUxpc3Rcbn1cblxuLyoqXG4gKiBDb21wYXJlcyB0d28gYmFzZTY0IHN0cmluZ3MsIGFsbG93aW5nIGZvciBiYXNlNjR1cmxcbiAqIGluIHRoZSBzZWNvbmQgc3RyaW5nLlxuICpcbiogQHBhcmFtIHtzdHJpbmd9IGFjdHVhbFZhbHVlIGFsd2F5cyBiYXNlNjRcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFZhbHVlIGJhc2U2NCBvciBiYXNlNjR1cmxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb21wYXJlQmFzZTY0TWl4ZWQgKGFjdHVhbFZhbHVlLCBleHBlY3RlZFZhbHVlKSB7XG4gIGlmIChhY3R1YWxWYWx1ZS5sZW5ndGggIT09IGV4cGVjdGVkVmFsdWUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3R1YWxWYWx1ZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhY3R1YWxWYWx1ZVtpXSAhPT0gZXhwZWN0ZWRWYWx1ZVtpXSkge1xuICAgICAgaWYgKFxuICAgICAgICAoYWN0dWFsVmFsdWVbaV0gPT09ICcrJyAmJiBleHBlY3RlZFZhbHVlW2ldID09PSAnLScpIHx8XG4gICAgICAgIChhY3R1YWxWYWx1ZVtpXSA9PT0gJy8nICYmIGV4cGVjdGVkVmFsdWVbaV0gPT09ICdfJylcbiAgICAgICkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmFwcHNlYy11cGdyYWRlLWluc2VjdXJlLXJlcXVlc3RzLyN1cGdyYWRlLXJlcXVlc3RcbmZ1bmN0aW9uIHRyeVVwZ3JhZGVSZXF1ZXN0VG9BUG90ZW50aWFsbHlUcnVzdHdvcnRoeVVSTCAocmVxdWVzdCkge1xuICAvLyBUT0RPXG59XG5cbi8qKlxuICogQGxpbmsge2h0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL29yaWdpbi5odG1sI3NhbWUtb3JpZ2lufVxuICogQHBhcmFtIHtVUkx9IEFcbiAqIEBwYXJhbSB7VVJMfSBCXG4gKi9cbmZ1bmN0aW9uIHNhbWVPcmlnaW4gKEEsIEIpIHtcbiAgLy8gMS4gSWYgQSBhbmQgQiBhcmUgdGhlIHNhbWUgb3BhcXVlIG9yaWdpbiwgdGhlbiByZXR1cm4gdHJ1ZS5cbiAgaWYgKEEub3JpZ2luID09PSBCLm9yaWdpbiAmJiBBLm9yaWdpbiA9PT0gJ251bGwnKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIDIuIElmIEEgYW5kIEIgYXJlIGJvdGggdHVwbGUgb3JpZ2lucyBhbmQgdGhlaXIgc2NoZW1lcyxcbiAgLy8gICAgaG9zdHMsIGFuZCBwb3J0IGFyZSBpZGVudGljYWwsIHRoZW4gcmV0dXJuIHRydWUuXG4gIGlmIChBLnByb3RvY29sID09PSBCLnByb3RvY29sICYmIEEuaG9zdG5hbWUgPT09IEIuaG9zdG5hbWUgJiYgQS5wb3J0ID09PSBCLnBvcnQpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gMy4gUmV0dXJuIGZhbHNlLlxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRQcm9taXNlICgpIHtcbiAgbGV0IHJlc1xuICBsZXQgcmVqXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzID0gcmVzb2x2ZVxuICAgIHJlaiA9IHJlamVjdFxuICB9KVxuXG4gIHJldHVybiB7IHByb21pc2UsIHJlc29sdmU6IHJlcywgcmVqZWN0OiByZWogfVxufVxuXG5mdW5jdGlvbiBpc0Fib3J0ZWQgKGZldGNoUGFyYW1zKSB7XG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAnYWJvcnRlZCdcbn1cblxuZnVuY3Rpb24gaXNDYW5jZWxsZWQgKGZldGNoUGFyYW1zKSB7XG4gIHJldHVybiBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAnYWJvcnRlZCcgfHxcbiAgICBmZXRjaFBhcmFtcy5jb250cm9sbGVyLnN0YXRlID09PSAndGVybWluYXRlZCdcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LW1ldGhvZC1ub3JtYWxpemVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2RcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kIChtZXRob2QpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZWRNZXRob2RSZWNvcmRzQmFzZVttZXRob2QudG9Mb3dlckNhc2UoKV0gPz8gbWV0aG9kXG59XG5cbi8vIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNzZXJpYWxpemUtYS1qYXZhc2NyaXB0LXZhbHVlLXRvLWEtanNvbi1zdHJpbmdcbmZ1bmN0aW9uIHNlcmlhbGl6ZUphdmFzY3JpcHRWYWx1ZVRvSlNPTlN0cmluZyAodmFsdWUpIHtcbiAgLy8gMS4gTGV0IHJlc3VsdCBiZSA/IENhbGwoJUpTT04uc3RyaW5naWZ5JSwgdW5kZWZpbmVkLCDCqyB2YWx1ZSDCuykuXG4gIGNvbnN0IHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuXG4gIC8vIDIuIElmIHJlc3VsdCBpcyB1bmRlZmluZWQsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1ZhbHVlIGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZScpXG4gIH1cblxuICAvLyAzLiBBc3NlcnQ6IHJlc3VsdCBpcyBhIHN0cmluZy5cbiAgYXNzZXJ0KHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKVxuXG4gIC8vIDQuIFJldHVybiByZXN1bHQuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy0lMjVpdGVyYXRvcnByb3RvdHlwZSUyNS1vYmplY3RcbmNvbnN0IGVzSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT2JqZWN0LmdldFByb3RvdHlwZU9mKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzeW1ib2x9IGtJbnRlcm5hbEl0ZXJhdG9yXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gW2tleUluZGV4XVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IFt2YWx1ZUluZGV4XVxuICovXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvciAobmFtZSwga0ludGVybmFsSXRlcmF0b3IsIGtleUluZGV4ID0gMCwgdmFsdWVJbmRleCA9IDEpIHtcbiAgY2xhc3MgRmFzdEl0ZXJhYmxlSXRlcmF0b3Ige1xuICAgIC8qKiBAdHlwZSB7YW55fSAqL1xuICAgICN0YXJnZXRcbiAgICAvKiogQHR5cGUgeydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSAqL1xuICAgICNraW5kXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgI2luZGV4XG5cbiAgICAvKipcbiAgICAgKiBAc2VlIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWRlZmF1bHQtaXRlcmF0b3Itb2JqZWN0XG4gICAgICogQHBhcmFtIHt1bmtub3dufSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSBraW5kXG4gICAgICovXG4gICAgY29uc3RydWN0b3IgKHRhcmdldCwga2luZCkge1xuICAgICAgdGhpcy4jdGFyZ2V0ID0gdGFyZ2V0XG4gICAgICB0aGlzLiNraW5kID0ga2luZFxuICAgICAgdGhpcy4jaW5kZXggPSAwXG4gICAgfVxuXG4gICAgbmV4dCAoKSB7XG4gICAgICAvLyAxLiBMZXQgaW50ZXJmYWNlIGJlIHRoZSBpbnRlcmZhY2UgZm9yIHdoaWNoIHRoZSBpdGVyYXRvciBwcm90b3R5cGUgb2JqZWN0IGV4aXN0cy5cbiAgICAgIC8vIDIuIExldCB0aGlzVmFsdWUgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAvLyAzLiBMZXQgb2JqZWN0IGJlID8gVG9PYmplY3QodGhpc1ZhbHVlKS5cbiAgICAgIC8vIDQuIElmIG9iamVjdCBpcyBhIHBsYXRmb3JtIG9iamVjdCwgdGhlbiBwZXJmb3JtIGEgc2VjdXJpdHlcbiAgICAgIC8vICAgIGNoZWNrLCBwYXNzaW5nOlxuICAgICAgLy8gNS4gSWYgb2JqZWN0IGlzIG5vdCBhIGRlZmF1bHQgaXRlcmF0b3Igb2JqZWN0IGZvciBpbnRlcmZhY2UsXG4gICAgICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgICAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JyB8fCB0aGlzID09PSBudWxsIHx8ICEoI3RhcmdldCBpbiB0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAnbmV4dCcgY2FsbGVkIG9uIGFuIG9iamVjdCB0aGF0IGRvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgJHtuYW1lfSBJdGVyYXRvci5gXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgLy8gNi4gTGV0IGluZGV4IGJlIG9iamVjdOKAmXMgaW5kZXguXG4gICAgICAvLyA3LiBMZXQga2luZCBiZSBvYmplY3TigJlzIGtpbmQuXG4gICAgICAvLyA4LiBMZXQgdmFsdWVzIGJlIG9iamVjdOKAmXMgdGFyZ2V0J3MgdmFsdWUgcGFpcnMgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNpbmRleFxuICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy4jdGFyZ2V0W2tJbnRlcm5hbEl0ZXJhdG9yXVxuXG4gICAgICAvLyA5LiBMZXQgbGVuIGJlIHRoZSBsZW5ndGggb2YgdmFsdWVzLlxuICAgICAgY29uc3QgbGVuID0gdmFsdWVzLmxlbmd0aFxuXG4gICAgICAvLyAxMC4gSWYgaW5kZXggaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGxlbiwgdGhlbiByZXR1cm5cbiAgICAgIC8vICAgICBDcmVhdGVJdGVyUmVzdWx0T2JqZWN0KHVuZGVmaW5lZCwgdHJ1ZSkuXG4gICAgICBpZiAoaW5kZXggPj0gbGVuKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gMTEuIExldCBwYWlyIGJlIHRoZSBlbnRyeSBpbiB2YWx1ZXMgYXQgaW5kZXggaW5kZXguXG4gICAgICBjb25zdCB7IFtrZXlJbmRleF06IGtleSwgW3ZhbHVlSW5kZXhdOiB2YWx1ZSB9ID0gdmFsdWVzW2luZGV4XVxuXG4gICAgICAvLyAxMi4gU2V0IG9iamVjdOKAmXMgaW5kZXggdG8gaW5kZXggKyAxLlxuICAgICAgdGhpcy4jaW5kZXggPSBpbmRleCArIDFcblxuICAgICAgLy8gMTMuIFJldHVybiB0aGUgaXRlcmF0b3IgcmVzdWx0IGZvciBwYWlyIGFuZCBraW5kLlxuXG4gICAgICAvLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2l0ZXJhdG9yLXJlc3VsdFxuXG4gICAgICAvLyAxLiBMZXQgcmVzdWx0IGJlIGEgdmFsdWUgZGV0ZXJtaW5lZCBieSB0aGUgdmFsdWUgb2Yga2luZDpcbiAgICAgIGxldCByZXN1bHRcbiAgICAgIHN3aXRjaCAodGhpcy4ja2luZCkge1xuICAgICAgICBjYXNlICdrZXknOlxuICAgICAgICAgIC8vIDEuIExldCBpZGxLZXkgYmUgcGFpcuKAmXMga2V5LlxuICAgICAgICAgIC8vIDIuIExldCBrZXkgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbEtleSB0byBhblxuICAgICAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gMy4gcmVzdWx0IGlzIGtleS5cbiAgICAgICAgICByZXN1bHQgPSBrZXlcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgLy8gMS4gTGV0IGlkbFZhbHVlIGJlIHBhaXLigJlzIHZhbHVlLlxuICAgICAgICAgIC8vIDIuIExldCB2YWx1ZSBiZSB0aGUgcmVzdWx0IG9mIGNvbnZlcnRpbmcgaWRsVmFsdWUgdG9cbiAgICAgICAgICAvLyAgICBhbiBFQ01BU2NyaXB0IHZhbHVlLlxuICAgICAgICAgIC8vIDMuIHJlc3VsdCBpcyB2YWx1ZS5cbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2tleSt2YWx1ZSc6XG4gICAgICAgICAgLy8gMS4gTGV0IGlkbEtleSBiZSBwYWly4oCZcyBrZXkuXG4gICAgICAgICAgLy8gMi4gTGV0IGlkbFZhbHVlIGJlIHBhaXLigJlzIHZhbHVlLlxuICAgICAgICAgIC8vIDMuIExldCBrZXkgYmUgdGhlIHJlc3VsdCBvZiBjb252ZXJ0aW5nIGlkbEtleSB0byBhblxuICAgICAgICAgIC8vICAgIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gNC4gTGV0IHZhbHVlIGJlIHRoZSByZXN1bHQgb2YgY29udmVydGluZyBpZGxWYWx1ZSB0b1xuICAgICAgICAgIC8vICAgIGFuIEVDTUFTY3JpcHQgdmFsdWUuXG4gICAgICAgICAgLy8gNS4gTGV0IGFycmF5IGJlICEgQXJyYXlDcmVhdGUoMikuXG4gICAgICAgICAgLy8gNi4gQ2FsbCAhIENyZWF0ZURhdGFQcm9wZXJ0eShhcnJheSwgXCIwXCIsIGtleSkuXG4gICAgICAgICAgLy8gNy4gQ2FsbCAhIENyZWF0ZURhdGFQcm9wZXJ0eShhcnJheSwgXCIxXCIsIHZhbHVlKS5cbiAgICAgICAgICAvLyA4LiByZXN1bHQgaXMgYXJyYXkuXG4gICAgICAgICAgcmVzdWx0ID0gW2tleSwgdmFsdWVdXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgLy8gMi4gUmV0dXJuIENyZWF0ZUl0ZXJSZXN1bHRPYmplY3QocmVzdWx0LCBmYWxzZSkuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZGZuLWl0ZXJhdG9yLXByb3RvdHlwZS1vYmplY3RcbiAgLy8gQHRzLWlnbm9yZVxuICBkZWxldGUgRmFzdEl0ZXJhYmxlSXRlcmF0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yXG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKEZhc3RJdGVyYWJsZUl0ZXJhdG9yLnByb3RvdHlwZSwgZXNJdGVyYXRvclByb3RvdHlwZSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGYXN0SXRlcmFibGVJdGVyYXRvci5wcm90b3R5cGUsIHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogYCR7bmFtZX0gSXRlcmF0b3JgXG4gICAgfSxcbiAgICBuZXh0OiB7IHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfVxuICB9KVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3Vua25vd259IHRhcmdldFxuICAgKiBAcGFyYW0geydrZXknIHwgJ3ZhbHVlJyB8ICdrZXkrdmFsdWUnfSBraW5kXG4gICAqIEByZXR1cm5zIHtJdGVyYWJsZUl0ZXJhdG9yPGFueT59XG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2luZCkge1xuICAgIHJldHVybiBuZXcgRmFzdEl0ZXJhYmxlSXRlcmF0b3IodGFyZ2V0LCBraW5kKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2Rmbi1pdGVyYXRvci1wcm90b3R5cGUtb2JqZWN0XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIHRoZSBpbnN0YW5jZVxuICogQHBhcmFtIHthbnl9IG9iamVjdCBjbGFzc1xuICogQHBhcmFtIHtzeW1ib2x9IGtJbnRlcm5hbEl0ZXJhdG9yXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gW2tleUluZGV4XVxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IFt2YWx1ZUluZGV4XVxuICovXG5mdW5jdGlvbiBpdGVyYXRvck1peGluIChuYW1lLCBvYmplY3QsIGtJbnRlcm5hbEl0ZXJhdG9yLCBrZXlJbmRleCA9IDAsIHZhbHVlSW5kZXggPSAxKSB7XG4gIGNvbnN0IG1ha2VJdGVyYXRvciA9IGNyZWF0ZUl0ZXJhdG9yKG5hbWUsIGtJbnRlcm5hbEl0ZXJhdG9yLCBrZXlJbmRleCwgdmFsdWVJbmRleClcblxuICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgIGtleXM6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzICgpIHtcbiAgICAgICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgb2JqZWN0KVxuICAgICAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKHRoaXMsICdrZXknKVxuICAgICAgfVxuICAgIH0sXG4gICAgdmFsdWVzOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzICgpIHtcbiAgICAgICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgb2JqZWN0KVxuICAgICAgICByZXR1cm4gbWFrZUl0ZXJhdG9yKHRoaXMsICd2YWx1ZScpXG4gICAgICB9XG4gICAgfSxcbiAgICBlbnRyaWVzOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZW50cmllcyAoKSB7XG4gICAgICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIG9iamVjdClcbiAgICAgICAgcmV0dXJuIG1ha2VJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJylcbiAgICAgIH1cbiAgICB9LFxuICAgIGZvckVhY2g6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoIChjYWxsYmFja2ZuLCB0aGlzQXJnID0gZ2xvYmFsVGhpcykge1xuICAgICAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBvYmplY3QpXG4gICAgICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgYCR7bmFtZX0uZm9yRWFjaGApXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2tmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZvckVhY2gnIG9uICcke25hbWV9JzogcGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0Z1bmN0aW9uJy5gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgeyAwOiBrZXksIDE6IHZhbHVlIH0gb2YgbWFrZUl0ZXJhdG9yKHRoaXMsICdrZXkrdmFsdWUnKSkge1xuICAgICAgICAgIGNhbGxiYWNrZm4uY2FsbCh0aGlzQXJnLCB2YWx1ZSwga2V5LCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG9iamVjdC5wcm90b3R5cGUsIHtcbiAgICAuLi5wcm9wZXJ0aWVzLFxuICAgIFtTeW1ib2wuaXRlcmF0b3JdOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IHByb3BlcnRpZXMuZW50cmllcy52YWx1ZVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5LWZ1bGx5LXJlYWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZnVsbHlSZWFkQm9keSAoYm9keSwgcHJvY2Vzc0JvZHksIHByb2Nlc3NCb2R5RXJyb3IpIHtcbiAgLy8gMS4gSWYgdGFza0Rlc3RpbmF0aW9uIGlzIG51bGwsIHRoZW4gc2V0IHRhc2tEZXN0aW5hdGlvbiB0b1xuICAvLyAgICB0aGUgcmVzdWx0IG9mIHN0YXJ0aW5nIGEgbmV3IHBhcmFsbGVsIHF1ZXVlLlxuXG4gIC8vIDIuIExldCBzdWNjZXNzU3RlcHMgZ2l2ZW4gYSBieXRlIHNlcXVlbmNlIGJ5dGVzIGJlIHRvIHF1ZXVlIGFcbiAgLy8gICAgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc0JvZHkgZ2l2ZW4gYnl0ZXMsIHdpdGggdGFza0Rlc3RpbmF0aW9uLlxuICBjb25zdCBzdWNjZXNzU3RlcHMgPSBwcm9jZXNzQm9keVxuXG4gIC8vIDMuIExldCBlcnJvclN0ZXBzIGJlIHRvIHF1ZXVlIGEgZmV0Y2ggdGFzayB0byBydW4gcHJvY2Vzc0JvZHlFcnJvcixcbiAgLy8gICAgd2l0aCB0YXNrRGVzdGluYXRpb24uXG4gIGNvbnN0IGVycm9yU3RlcHMgPSBwcm9jZXNzQm9keUVycm9yXG5cbiAgLy8gNC4gTGV0IHJlYWRlciBiZSB0aGUgcmVzdWx0IG9mIGdldHRpbmcgYSByZWFkZXIgZm9yIGJvZHnigJlzIHN0cmVhbS5cbiAgLy8gICAgSWYgdGhhdCB0aHJldyBhbiBleGNlcHRpb24sIHRoZW4gcnVuIGVycm9yU3RlcHMgd2l0aCB0aGF0XG4gIC8vICAgIGV4Y2VwdGlvbiBhbmQgcmV0dXJuLlxuICBsZXQgcmVhZGVyXG5cbiAgdHJ5IHtcbiAgICByZWFkZXIgPSBib2R5LnN0cmVhbS5nZXRSZWFkZXIoKVxuICB9IGNhdGNoIChlKSB7XG4gICAgZXJyb3JTdGVwcyhlKVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gNS4gUmVhZCBhbGwgYnl0ZXMgZnJvbSByZWFkZXIsIGdpdmVuIHN1Y2Nlc3NTdGVwcyBhbmQgZXJyb3JTdGVwcy5cbiAgdHJ5IHtcbiAgICBzdWNjZXNzU3RlcHMoYXdhaXQgcmVhZEFsbEJ5dGVzKHJlYWRlcikpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlcnJvclN0ZXBzKGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNSZWFkYWJsZVN0cmVhbUxpa2UgKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0gfHwgKFxuICAgIHN0cmVhbVtTeW1ib2wudG9TdHJpbmdUYWddID09PSAnUmVhZGFibGVTdHJlYW0nICYmXG4gICAgdHlwZW9mIHN0cmVhbS50ZWUgPT09ICdmdW5jdGlvbidcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFVpbnQ4QXJyYXk+fSBjb250cm9sbGVyXG4gKi9cbmZ1bmN0aW9uIHJlYWRhYmxlU3RyZWFtQ2xvc2UgKGNvbnRyb2xsZXIpIHtcbiAgdHJ5IHtcbiAgICBjb250cm9sbGVyLmNsb3NlKClcbiAgICBjb250cm9sbGVyLmJ5b2JSZXF1ZXN0Py5yZXNwb25kKDApXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIFRPRE86IGFkZCBjb21tZW50IGV4cGxhaW5pbmcgd2h5IHRoaXMgZXJyb3Igb2NjdXJzLlxuICAgIGlmICghZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ0NvbnRyb2xsZXIgaXMgYWxyZWFkeSBjbG9zZWQnKSAmJiAhZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ1JlYWRhYmxlU3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkJykpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBpbnZhbGlkSXNvbW9ycGhpY0VuY29kZVZhbHVlUmVnZXggPSAvW15cXHgwMC1cXHhGRl0vIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vaW5mcmEuc3BlYy53aGF0d2cub3JnLyNpc29tb3JwaGljLWVuY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKi9cbmZ1bmN0aW9uIGlzb21vcnBoaWNFbmNvZGUgKGlucHV0KSB7XG4gIC8vIDEuIEFzc2VydDogaW5wdXQgY29udGFpbnMgbm8gY29kZSBwb2ludHMgZ3JlYXRlciB0aGFuIFUrMDBGRi5cbiAgYXNzZXJ0KCFpbnZhbGlkSXNvbW9ycGhpY0VuY29kZVZhbHVlUmVnZXgudGVzdChpbnB1dCkpXG5cbiAgLy8gMi4gUmV0dXJuIGEgYnl0ZSBzZXF1ZW5jZSB3aG9zZSBsZW5ndGggaXMgZXF1YWwgdG8gaW5wdXTigJlzIGNvZGVcbiAgLy8gICAgcG9pbnQgbGVuZ3RoIGFuZCB3aG9zZSBieXRlcyBoYXZlIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgLy8gICAgdmFsdWVzIG9mIGlucHV04oCZcyBjb2RlIHBvaW50cywgaW4gdGhlIHNhbWUgb3JkZXJcbiAgcmV0dXJuIGlucHV0XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3N0cmVhbXMuc3BlYy53aGF0d2cub3JnLyNyZWFkYWJsZXN0cmVhbWRlZmF1bHRyZWFkZXItcmVhZC1hbGwtYnl0ZXNcbiAqIEBzZWUgaHR0cHM6Ly9zdHJlYW1zLnNwZWMud2hhdHdnLm9yZy8jcmVhZC1sb29wXG4gKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcn0gcmVhZGVyXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlYWRBbGxCeXRlcyAocmVhZGVyKSB7XG4gIGNvbnN0IGJ5dGVzID0gW11cbiAgbGV0IGJ5dGVMZW5ndGggPSAwXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiBjaHVuayB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKVxuXG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIC8vIDEuIENhbGwgc3VjY2Vzc1N0ZXBzIHdpdGggYnl0ZXMuXG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChieXRlcywgYnl0ZUxlbmd0aClcbiAgICB9XG5cbiAgICAvLyAxLiBJZiBjaHVuayBpcyBub3QgYSBVaW50OEFycmF5IG9iamVjdCwgY2FsbCBmYWlsdXJlU3RlcHNcbiAgICAvLyAgICB3aXRoIGEgVHlwZUVycm9yIGFuZCBhYm9ydCB0aGVzZSBzdGVwcy5cbiAgICBpZiAoIWlzVWludDhBcnJheShjaHVuaykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlY2VpdmVkIG5vbi1VaW50OEFycmF5IGNodW5rJylcbiAgICB9XG5cbiAgICAvLyAyLiBBcHBlbmQgdGhlIGJ5dGVzIHJlcHJlc2VudGVkIGJ5IGNodW5rIHRvIGJ5dGVzLlxuICAgIGJ5dGVzLnB1c2goY2h1bmspXG4gICAgYnl0ZUxlbmd0aCArPSBjaHVuay5sZW5ndGhcblxuICAgIC8vIDMuIFJlYWQtbG9vcCBnaXZlbiByZWFkZXIsIGJ5dGVzLCBzdWNjZXNzU3RlcHMsIGFuZCBmYWlsdXJlU3RlcHMuXG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNpcy1sb2NhbFxuICogQHBhcmFtIHtVUkx9IHVybFxuICovXG5mdW5jdGlvbiB1cmxJc0xvY2FsICh1cmwpIHtcbiAgYXNzZXJ0KCdwcm90b2NvbCcgaW4gdXJsKSAvLyBlbnN1cmUgaXQncyBhIHVybCBvYmplY3RcblxuICBjb25zdCBwcm90b2NvbCA9IHVybC5wcm90b2NvbFxuXG4gIHJldHVybiBwcm90b2NvbCA9PT0gJ2Fib3V0OicgfHwgcHJvdG9jb2wgPT09ICdibG9iOicgfHwgcHJvdG9jb2wgPT09ICdkYXRhOidcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xVUkx9IHVybFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHVybEhhc0h0dHBzU2NoZW1lICh1cmwpIHtcbiAgcmV0dXJuIChcbiAgICAoXG4gICAgICB0eXBlb2YgdXJsID09PSAnc3RyaW5nJyAmJlxuICAgICAgdXJsWzVdID09PSAnOicgJiZcbiAgICAgIHVybFswXSA9PT0gJ2gnICYmXG4gICAgICB1cmxbMV0gPT09ICd0JyAmJlxuICAgICAgdXJsWzJdID09PSAndCcgJiZcbiAgICAgIHVybFszXSA9PT0gJ3AnICYmXG4gICAgICB1cmxbNF0gPT09ICdzJ1xuICAgICkgfHxcbiAgICB1cmwucHJvdG9jb2wgPT09ICdodHRwczonXG4gIClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNodHRwLXNjaGVtZVxuICogQHBhcmFtIHtVUkx9IHVybFxuICovXG5mdW5jdGlvbiB1cmxJc0h0dHBIdHRwc1NjaGVtZSAodXJsKSB7XG4gIGFzc2VydCgncHJvdG9jb2wnIGluIHVybCkgLy8gZW5zdXJlIGl0J3MgYSB1cmwgb2JqZWN0XG5cbiAgY29uc3QgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2xcblxuICByZXR1cm4gcHJvdG9jb2wgPT09ICdodHRwOicgfHwgcHJvdG9jb2wgPT09ICdodHRwczonXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jc2ltcGxlLXJhbmdlLWhlYWRlci12YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsbG93V2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiBzaW1wbGVSYW5nZUhlYWRlclZhbHVlICh2YWx1ZSwgYWxsb3dXaGl0ZXNwYWNlKSB7XG4gIC8vIDEuIExldCBkYXRhIGJlIHRoZSBpc29tb3JwaGljIGRlY29kaW5nIG9mIHZhbHVlLlxuICAvLyBOb3RlOiBpc29tb3JwaGljIGRlY29kaW5nIHRha2VzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgKGllLiBhIFVpbnQ4QXJyYXkpIGFuZCB0dXJucyBpdCBpbnRvIGEgc3RyaW5nLFxuICAvLyBub3RoaW5nIG1vcmUuIFdlIG9idmlvdXNseSBkb24ndCBuZWVkIHRvIGRvIHRoYXQgaWYgdmFsdWUgaXMgYSBzdHJpbmcgYWxyZWFkeS5cbiAgY29uc3QgZGF0YSA9IHZhbHVlXG5cbiAgLy8gMi4gSWYgZGF0YSBkb2VzIG5vdCBzdGFydCB3aXRoIFwiYnl0ZXNcIiwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKCFkYXRhLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAzLiBMZXQgcG9zaXRpb24gYmUgYSBwb3NpdGlvbiB2YXJpYWJsZSBmb3IgZGF0YSwgaW5pdGlhbGx5IHBvaW50aW5nIGF0IHRoZSA1dGggY29kZSBwb2ludCBvZiBkYXRhLlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDUgfVxuXG4gIC8vIDQuIElmIGFsbG93V2hpdGVzcGFjZSBpcyB0cnVlLCBjb2xsZWN0IGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmUgSFRUUCB0YWIgb3Igc3BhY2UsXG4gIC8vICAgIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgaWYgKGFsbG93V2hpdGVzcGFjZSkge1xuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJyAnLFxuICAgICAgZGF0YSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICB9XG5cbiAgLy8gNS4gSWYgdGhlIGNvZGUgcG9pbnQgYXQgcG9zaXRpb24gd2l0aGluIGRhdGEgaXMgbm90IFUrMDAzRCAoPSksIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChkYXRhLmNoYXJDb2RlQXQocG9zaXRpb24ucG9zaXRpb24pICE9PSAweDNEKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNi4gQWR2YW5jZSBwb3NpdGlvbiBieSAxLlxuICBwb3NpdGlvbi5wb3NpdGlvbisrXG5cbiAgLy8gNy4gSWYgYWxsb3dXaGl0ZXNwYWNlIGlzIHRydWUsIGNvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQIHRhYiBvciBzcGFjZSwgZnJvbVxuICAvLyAgICBkYXRhIGdpdmVuIHBvc2l0aW9uLlxuICBpZiAoYWxsb3dXaGl0ZXNwYWNlKSB7XG4gICAgY29sbGVjdEFTZXF1ZW5jZU9mQ29kZVBvaW50cyhcbiAgICAgIChjaGFyKSA9PiBjaGFyID09PSAnXFx0JyB8fCBjaGFyID09PSAnICcsXG4gICAgICBkYXRhLFxuICAgICAgcG9zaXRpb25cbiAgICApXG4gIH1cblxuICAvLyA4LiBMZXQgcmFuZ2VTdGFydCBiZSB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBBU0NJSSBkaWdpdHMsXG4gIC8vICAgIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgY29uc3QgcmFuZ2VTdGFydCA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgKGNoYXIpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgICAgcmV0dXJuIGNvZGUgPj0gMHgzMCAmJiBjb2RlIDw9IDB4MzlcbiAgICB9LFxuICAgIGRhdGEsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDkuIExldCByYW5nZVN0YXJ0VmFsdWUgYmUgcmFuZ2VTdGFydCwgaW50ZXJwcmV0ZWQgYXMgZGVjaW1hbCBudW1iZXIsIGlmIHJhbmdlU3RhcnQgaXMgbm90IHRoZVxuICAvLyAgICBlbXB0eSBzdHJpbmc7IG90aGVyd2lzZSBudWxsLlxuICBjb25zdCByYW5nZVN0YXJ0VmFsdWUgPSByYW5nZVN0YXJ0Lmxlbmd0aCA/IE51bWJlcihyYW5nZVN0YXJ0KSA6IG51bGxcblxuICAvLyAxMC4gSWYgYWxsb3dXaGl0ZXNwYWNlIGlzIHRydWUsIGNvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQIHRhYiBvciBzcGFjZSxcbiAgLy8gICAgIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgaWYgKGFsbG93V2hpdGVzcGFjZSkge1xuICAgIGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciA9PT0gJ1xcdCcgfHwgY2hhciA9PT0gJyAnLFxuICAgICAgZGF0YSxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuICB9XG5cbiAgLy8gMTEuIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBkYXRhIGlzIG5vdCBVKzAwMkQgKC0pLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAoZGF0YS5jaGFyQ29kZUF0KHBvc2l0aW9uLnBvc2l0aW9uKSAhPT0gMHgyRCkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDEyLiBBZHZhbmNlIHBvc2l0aW9uIGJ5IDEuXG4gIHBvc2l0aW9uLnBvc2l0aW9uKytcblxuICAvLyAxMy4gSWYgYWxsb3dXaGl0ZXNwYWNlIGlzIHRydWUsIGNvbGxlY3QgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBIVFRQIHRhYlxuICAvLyAgICAgb3Igc3BhY2UsIGZyb20gZGF0YSBnaXZlbiBwb3NpdGlvbi5cbiAgLy8gTm90ZSBmcm9tIEtoYWZyYTogaXRzIHRoZSBzYW1lIHN0ZXAgYXMgaW4gIzggYWdhaW4gbG9sXG4gIGlmIChhbGxvd1doaXRlc3BhY2UpIHtcbiAgICBjb2xsZWN0QVNlcXVlbmNlT2ZDb2RlUG9pbnRzKFxuICAgICAgKGNoYXIpID0+IGNoYXIgPT09ICdcXHQnIHx8IGNoYXIgPT09ICcgJyxcbiAgICAgIGRhdGEsXG4gICAgICBwb3NpdGlvblxuICAgIClcbiAgfVxuXG4gIC8vIDE0LiBMZXQgcmFuZ2VFbmQgYmUgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGEgc2VxdWVuY2Ugb2YgY29kZSBwb2ludHMgdGhhdCBhcmVcbiAgLy8gICAgIEFTQ0lJIGRpZ2l0cywgZnJvbSBkYXRhIGdpdmVuIHBvc2l0aW9uLlxuICAvLyBOb3RlIGZyb20gS2hhZnJhOiB5b3Ugd291bGRuJ3QgZ3Vlc3MgaXQsIGJ1dCB0aGlzIGlzIGFsc28gdGhlIHNhbWUgc3RlcCBhcyAjOFxuICBjb25zdCByYW5nZUVuZCA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgKGNoYXIpID0+IHtcbiAgICAgIGNvbnN0IGNvZGUgPSBjaGFyLmNoYXJDb2RlQXQoMClcblxuICAgICAgcmV0dXJuIGNvZGUgPj0gMHgzMCAmJiBjb2RlIDw9IDB4MzlcbiAgICB9LFxuICAgIGRhdGEsXG4gICAgcG9zaXRpb25cbiAgKVxuXG4gIC8vIDE1LiBMZXQgcmFuZ2VFbmRWYWx1ZSBiZSByYW5nZUVuZCwgaW50ZXJwcmV0ZWQgYXMgZGVjaW1hbCBudW1iZXIsIGlmIHJhbmdlRW5kXG4gIC8vICAgICBpcyBub3QgdGhlIGVtcHR5IHN0cmluZzsgb3RoZXJ3aXNlIG51bGwuXG4gIC8vIE5vdGUgZnJvbSBLaGFmcmE6IFRIRSBTQU1FIFNURVAsIEFHQUlOISEhXG4gIC8vIE5vdGU6IHdoeSBpbnRlcnByZXQgYXMgYSBkZWNpbWFsIGlmIHdlIG9ubHkgY29sbGVjdCBhc2NpaSBkaWdpdHM/XG4gIGNvbnN0IHJhbmdlRW5kVmFsdWUgPSByYW5nZUVuZC5sZW5ndGggPyBOdW1iZXIocmFuZ2VFbmQpIDogbnVsbFxuXG4gIC8vIDE2LiBJZiBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGRhdGEsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMTcuIElmIHJhbmdlRW5kVmFsdWUgYW5kIHJhbmdlU3RhcnRWYWx1ZSBhcmUgbnVsbCwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKHJhbmdlRW5kVmFsdWUgPT09IG51bGwgJiYgcmFuZ2VTdGFydFZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gMTguIElmIHJhbmdlU3RhcnRWYWx1ZSBhbmQgcmFuZ2VFbmRWYWx1ZSBhcmUgbnVtYmVycywgYW5kIHJhbmdlU3RhcnRWYWx1ZSBpc1xuICAvLyAgICAgZ3JlYXRlciB0aGFuIHJhbmdlRW5kVmFsdWUsIHRoZW4gcmV0dXJuIGZhaWx1cmUuXG4gIC8vIE5vdGU6IC4uLiB3aGVuIGNhbiB0aGV5IG5vdCBiZSBudW1iZXJzP1xuICBpZiAocmFuZ2VTdGFydFZhbHVlID4gcmFuZ2VFbmRWYWx1ZSkge1xuICAgIHJldHVybiAnZmFpbHVyZSdcbiAgfVxuXG4gIC8vIDE5LiBSZXR1cm4gKHJhbmdlU3RhcnRWYWx1ZSwgcmFuZ2VFbmRWYWx1ZSkuXG4gIHJldHVybiB7IHJhbmdlU3RhcnRWYWx1ZSwgcmFuZ2VFbmRWYWx1ZSB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jYnVpbGQtYS1jb250ZW50LXJhbmdlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFuZ2VTdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IHJhbmdlRW5kXG4gKiBAcGFyYW0ge251bWJlcn0gZnVsbExlbmd0aFxuICovXG5mdW5jdGlvbiBidWlsZENvbnRlbnRSYW5nZSAocmFuZ2VTdGFydCwgcmFuZ2VFbmQsIGZ1bGxMZW5ndGgpIHtcbiAgLy8gMS4gTGV0IGNvbnRlbnRSYW5nZSBiZSBgYnl0ZXMgYC5cbiAgbGV0IGNvbnRlbnRSYW5nZSA9ICdieXRlcyAnXG5cbiAgLy8gMi4gQXBwZW5kIHJhbmdlU3RhcnQsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCwgdG8gY29udGVudFJhbmdlLlxuICBjb250ZW50UmFuZ2UgKz0gaXNvbW9ycGhpY0VuY29kZShgJHtyYW5nZVN0YXJ0fWApXG5cbiAgLy8gMy4gQXBwZW5kIDB4MkQgKC0pIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9ICctJ1xuXG4gIC8vIDQuIEFwcGVuZCByYW5nZUVuZCwgc2VyaWFsaXplZCBhbmQgaXNvbW9ycGhpYyBlbmNvZGVkIHRvIGNvbnRlbnRSYW5nZS5cbiAgY29udGVudFJhbmdlICs9IGlzb21vcnBoaWNFbmNvZGUoYCR7cmFuZ2VFbmR9YClcblxuICAvLyA1LiBBcHBlbmQgMHgyRiAoLykgdG8gY29udGVudFJhbmdlLlxuICBjb250ZW50UmFuZ2UgKz0gJy8nXG5cbiAgLy8gNi4gQXBwZW5kIGZ1bGxMZW5ndGgsIHNlcmlhbGl6ZWQgYW5kIGlzb21vcnBoaWMgZW5jb2RlZCB0byBjb250ZW50UmFuZ2UuXG4gIGNvbnRlbnRSYW5nZSArPSBpc29tb3JwaGljRW5jb2RlKGAke2Z1bGxMZW5ndGh9YClcblxuICAvLyA3LiBSZXR1cm4gY29udGVudFJhbmdlLlxuICByZXR1cm4gY29udGVudFJhbmdlXG59XG5cbi8vIEEgU3RyZWFtLCB3aGljaCBwaXBlcyB0aGUgcmVzcG9uc2UgdG8gemxpYi5jcmVhdGVJbmZsYXRlKCkgb3Jcbi8vIHpsaWIuY3JlYXRlSW5mbGF0ZVJhdygpIGRlcGVuZGluZyBvbiB0aGUgZmlyc3QgYnl0ZSBvZiB0aGUgQnVmZmVyLlxuLy8gSWYgdGhlIGxvd2VyIGJ5dGUgb2YgdGhlIGZpcnN0IGJ5dGUgaXMgMHgwOCwgdGhlbiB0aGUgc3RyZWFtIGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhIHpsaWIgc3RyZWFtLCBvdGhlcndpc2UgaXQncyBpbnRlcnByZXRlZCBhcyBhXG4vLyByYXcgZGVmbGF0ZSBzdHJlYW0uXG5jbGFzcyBJbmZsYXRlU3RyZWFtIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgI3psaWJPcHRpb25zXG5cbiAgLyoqIEBwYXJhbSB7emxpYi5abGliT3B0aW9uc30gW3psaWJPcHRpb25zXSAqL1xuICBjb25zdHJ1Y3RvciAoemxpYk9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy4jemxpYk9wdGlvbnMgPSB6bGliT3B0aW9uc1xuICB9XG5cbiAgX3RyYW5zZm9ybSAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5faW5mbGF0ZVN0cmVhbSkge1xuICAgICAgaWYgKGNodW5rLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbSA9IChjaHVua1swXSAmIDB4MEYpID09PSAweDA4XG4gICAgICAgID8gemxpYi5jcmVhdGVJbmZsYXRlKHRoaXMuI3psaWJPcHRpb25zKVxuICAgICAgICA6IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh0aGlzLiN6bGliT3B0aW9ucylcblxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbS5vbignZGF0YScsIHRoaXMucHVzaC5iaW5kKHRoaXMpKVxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbS5vbignZW5kJywgKCkgPT4gdGhpcy5wdXNoKG51bGwpKVxuICAgICAgdGhpcy5faW5mbGF0ZVN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB0aGlzLmRlc3Ryb3koZXJyKSlcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlU3RyZWFtLndyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spXG4gIH1cblxuICBfZmluYWwgKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX2luZmxhdGVTdHJlYW0pIHtcbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0uZW5kKClcbiAgICAgIHRoaXMuX2luZmxhdGVTdHJlYW0gPSBudWxsXG4gICAgfVxuICAgIGNhbGxiYWNrKClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7emxpYi5abGliT3B0aW9uc30gW3psaWJPcHRpb25zXVxuICogQHJldHVybnMge0luZmxhdGVTdHJlYW19XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZmxhdGUgKHpsaWJPcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZVN0cmVhbSh6bGliT3B0aW9ucylcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWhlYWRlci1leHRyYWN0LW1pbWUtdHlwZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaGVhZGVycycpLkhlYWRlcnNMaXN0fSBoZWFkZXJzXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RNaW1lVHlwZSAoaGVhZGVycykge1xuICAvLyAxLiBMZXQgY2hhcnNldCBiZSBudWxsLlxuICBsZXQgY2hhcnNldCA9IG51bGxcblxuICAvLyAyLiBMZXQgZXNzZW5jZSBiZSBudWxsLlxuICBsZXQgZXNzZW5jZSA9IG51bGxcblxuICAvLyAzLiBMZXQgbWltZVR5cGUgYmUgbnVsbC5cbiAgbGV0IG1pbWVUeXBlID0gbnVsbFxuXG4gIC8vIDQuIExldCB2YWx1ZXMgYmUgdGhlIHJlc3VsdCBvZiBnZXR0aW5nLCBkZWNvZGluZywgYW5kIHNwbGl0dGluZyBgQ29udGVudC1UeXBlYCBmcm9tIGhlYWRlcnMuXG4gIGNvbnN0IHZhbHVlcyA9IGdldERlY29kZVNwbGl0KCdjb250ZW50LXR5cGUnLCBoZWFkZXJzKVxuXG4gIC8vIDUuIElmIHZhbHVlcyBpcyBudWxsLCB0aGVuIHJldHVybiBmYWlsdXJlLlxuICBpZiAodmFsdWVzID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdmYWlsdXJlJ1xuICB9XG5cbiAgLy8gNi4gRm9yIGVhY2ggdmFsdWUgb2YgdmFsdWVzOlxuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIC8vIDYuMS4gTGV0IHRlbXBvcmFyeU1pbWVUeXBlIGJlIHRoZSByZXN1bHQgb2YgcGFyc2luZyB2YWx1ZS5cbiAgICBjb25zdCB0ZW1wb3JhcnlNaW1lVHlwZSA9IHBhcnNlTUlNRVR5cGUodmFsdWUpXG5cbiAgICAvLyA2LjIuIElmIHRlbXBvcmFyeU1pbWVUeXBlIGlzIGZhaWx1cmUgb3IgaXRzIGVzc2VuY2UgaXMgXCIqLypcIiwgdGhlbiBjb250aW51ZS5cbiAgICBpZiAodGVtcG9yYXJ5TWltZVR5cGUgPT09ICdmYWlsdXJlJyB8fCB0ZW1wb3JhcnlNaW1lVHlwZS5lc3NlbmNlID09PSAnKi8qJykge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICAvLyA2LjMuIFNldCBtaW1lVHlwZSB0byB0ZW1wb3JhcnlNaW1lVHlwZS5cbiAgICBtaW1lVHlwZSA9IHRlbXBvcmFyeU1pbWVUeXBlXG5cbiAgICAvLyA2LjQuIElmIG1pbWVUeXBl4oCZcyBlc3NlbmNlIGlzIG5vdCBlc3NlbmNlLCB0aGVuOlxuICAgIGlmIChtaW1lVHlwZS5lc3NlbmNlICE9PSBlc3NlbmNlKSB7XG4gICAgICAvLyA2LjQuMS4gU2V0IGNoYXJzZXQgdG8gbnVsbC5cbiAgICAgIGNoYXJzZXQgPSBudWxsXG5cbiAgICAgIC8vIDYuNC4yLiBJZiBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1tcImNoYXJzZXRcIl0gZXhpc3RzLCB0aGVuIHNldCBjaGFyc2V0IHRvXG4gICAgICAvLyAgICAgICAgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdLlxuICAgICAgaWYgKG1pbWVUeXBlLnBhcmFtZXRlcnMuaGFzKCdjaGFyc2V0JykpIHtcbiAgICAgICAgY2hhcnNldCA9IG1pbWVUeXBlLnBhcmFtZXRlcnMuZ2V0KCdjaGFyc2V0JylcbiAgICAgIH1cblxuICAgICAgLy8gNi40LjMuIFNldCBlc3NlbmNlIHRvIG1pbWVUeXBl4oCZcyBlc3NlbmNlLlxuICAgICAgZXNzZW5jZSA9IG1pbWVUeXBlLmVzc2VuY2VcbiAgICB9IGVsc2UgaWYgKCFtaW1lVHlwZS5wYXJhbWV0ZXJzLmhhcygnY2hhcnNldCcpICYmIGNoYXJzZXQgIT09IG51bGwpIHtcbiAgICAgIC8vIDYuNS4gT3RoZXJ3aXNlLCBpZiBtaW1lVHlwZeKAmXMgcGFyYW1ldGVyc1tcImNoYXJzZXRcIl0gZG9lcyBub3QgZXhpc3QsIGFuZFxuICAgICAgLy8gICAgICBjaGFyc2V0IGlzIG5vbi1udWxsLCBzZXQgbWltZVR5cGXigJlzIHBhcmFtZXRlcnNbXCJjaGFyc2V0XCJdIHRvIGNoYXJzZXQuXG4gICAgICBtaW1lVHlwZS5wYXJhbWV0ZXJzLnNldCgnY2hhcnNldCcsIGNoYXJzZXQpXG4gICAgfVxuICB9XG5cbiAgLy8gNy4gSWYgbWltZVR5cGUgaXMgbnVsbCwgdGhlbiByZXR1cm4gZmFpbHVyZS5cbiAgaWYgKG1pbWVUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyA4LiBSZXR1cm4gbWltZVR5cGUuXG4gIHJldHVybiBtaW1lVHlwZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlci12YWx1ZS1nZXQtZGVjb2RlLWFuZC1zcGxpdFxuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2V0dGluZ0RlY29kaW5nU3BsaXR0aW5nICh2YWx1ZSkge1xuICAvLyAxLiBMZXQgaW5wdXQgYmUgdGhlIHJlc3VsdCBvZiBpc29tb3JwaGljIGRlY29kaW5nIHZhbHVlLlxuICBjb25zdCBpbnB1dCA9IHZhbHVlXG5cbiAgLy8gMi4gTGV0IHBvc2l0aW9uIGJlIGEgcG9zaXRpb24gdmFyaWFibGUgZm9yIGlucHV0LCBpbml0aWFsbHkgcG9pbnRpbmcgYXQgdGhlIHN0YXJ0IG9mIGlucHV0LlxuICBjb25zdCBwb3NpdGlvbiA9IHsgcG9zaXRpb246IDAgfVxuXG4gIC8vIDMuIExldCB2YWx1ZXMgYmUgYSBsaXN0IG9mIHN0cmluZ3MsIGluaXRpYWxseSBlbXB0eS5cbiAgY29uc3QgdmFsdWVzID0gW11cblxuICAvLyA0LiBMZXQgdGVtcG9yYXJ5VmFsdWUgYmUgdGhlIGVtcHR5IHN0cmluZy5cbiAgbGV0IHRlbXBvcmFyeVZhbHVlID0gJydcblxuICAvLyA1LiBXaGlsZSBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0OlxuICB3aGlsZSAocG9zaXRpb24ucG9zaXRpb24gPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAvLyA1LjEuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGNvbGxlY3RpbmcgYSBzZXF1ZW5jZSBvZiBjb2RlIHBvaW50cyB0aGF0IGFyZSBub3QgVSswMDIyIChcIilcbiAgICAvLyAgICAgIG9yIFUrMDAyQyAoLCkgZnJvbSBpbnB1dCwgZ2l2ZW4gcG9zaXRpb24sIHRvIHRlbXBvcmFyeVZhbHVlLlxuICAgIHRlbXBvcmFyeVZhbHVlICs9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHMoXG4gICAgICAoY2hhcikgPT4gY2hhciAhPT0gJ1wiJyAmJiBjaGFyICE9PSAnLCcsXG4gICAgICBpbnB1dCxcbiAgICAgIHBvc2l0aW9uXG4gICAgKVxuXG4gICAgLy8gNS4yLiBJZiBwb3NpdGlvbiBpcyBub3QgcGFzdCB0aGUgZW5kIG9mIGlucHV0LCB0aGVuOlxuICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgLy8gNS4yLjEuIElmIHRoZSBjb2RlIHBvaW50IGF0IHBvc2l0aW9uIHdpdGhpbiBpbnB1dCBpcyBVKzAwMjIgKFwiKSwgdGhlbjpcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvc2l0aW9uLnBvc2l0aW9uKSA9PT0gMHgyMikge1xuICAgICAgICAvLyA1LjIuMS4xLiBBcHBlbmQgdGhlIHJlc3VsdCBvZiBjb2xsZWN0aW5nIGFuIEhUVFAgcXVvdGVkIHN0cmluZyBmcm9tIGlucHV0LCBnaXZlbiBwb3NpdGlvbiwgdG8gdGVtcG9yYXJ5VmFsdWUuXG4gICAgICAgIHRlbXBvcmFyeVZhbHVlICs9IGNvbGxlY3RBbkhUVFBRdW90ZWRTdHJpbmcoXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgKVxuXG4gICAgICAgIC8vIDUuMi4xLjIuIElmIHBvc2l0aW9uIGlzIG5vdCBwYXN0IHRoZSBlbmQgb2YgaW5wdXQsIHRoZW4gY29udGludWUuXG4gICAgICAgIGlmIChwb3NpdGlvbi5wb3NpdGlvbiA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIDUuMi4yLiBPdGhlcndpc2U6XG5cbiAgICAgICAgLy8gNS4yLjIuMS4gQXNzZXJ0OiB0aGUgY29kZSBwb2ludCBhdCBwb3NpdGlvbiB3aXRoaW4gaW5wdXQgaXMgVSswMDJDICgsKS5cbiAgICAgICAgYXNzZXJ0KGlucHV0LmNoYXJDb2RlQXQocG9zaXRpb24ucG9zaXRpb24pID09PSAweDJDKVxuXG4gICAgICAgIC8vIDUuMi4yLjIuIEFkdmFuY2UgcG9zaXRpb24gYnkgMS5cbiAgICAgICAgcG9zaXRpb24ucG9zaXRpb24rK1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIDUuMy4gUmVtb3ZlIGFsbCBIVFRQIHRhYiBvciBzcGFjZSBmcm9tIHRoZSBzdGFydCBhbmQgZW5kIG9mIHRlbXBvcmFyeVZhbHVlLlxuICAgIHRlbXBvcmFyeVZhbHVlID0gcmVtb3ZlQ2hhcnModGVtcG9yYXJ5VmFsdWUsIHRydWUsIHRydWUsIChjaGFyKSA9PiBjaGFyID09PSAweDkgfHwgY2hhciA9PT0gMHgyMClcblxuICAgIC8vIDUuNC4gQXBwZW5kIHRlbXBvcmFyeVZhbHVlIHRvIHZhbHVlcy5cbiAgICB2YWx1ZXMucHVzaCh0ZW1wb3JhcnlWYWx1ZSlcblxuICAgIC8vIDUuNi4gU2V0IHRlbXBvcmFyeVZhbHVlIHRvIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgdGVtcG9yYXJ5VmFsdWUgPSAnJ1xuICB9XG5cbiAgLy8gNi4gUmV0dXJuIHZhbHVlcy5cbiAgcmV0dXJuIHZhbHVlc1xufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtaGVhZGVyLWxpc3QtZ2V0LWRlY29kZS1zcGxpdFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbG93ZXJjYXNlIGhlYWRlciBuYW1lXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9oZWFkZXJzJykuSGVhZGVyc0xpc3R9IGxpc3RcbiAqL1xuZnVuY3Rpb24gZ2V0RGVjb2RlU3BsaXQgKG5hbWUsIGxpc3QpIHtcbiAgLy8gMS4gTGV0IHZhbHVlIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBuYW1lIGZyb20gbGlzdC5cbiAgY29uc3QgdmFsdWUgPSBsaXN0LmdldChuYW1lLCB0cnVlKVxuXG4gIC8vIDIuIElmIHZhbHVlIGlzIG51bGwsIHRoZW4gcmV0dXJuIG51bGwuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBnZXR0aW5nLCBkZWNvZGluZywgYW5kIHNwbGl0dGluZyB2YWx1ZS5cbiAgcmV0dXJuIGdldHRpbmdEZWNvZGluZ1NwbGl0dGluZyh2YWx1ZSlcbn1cblxuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9lbmNvZGluZy5zcGVjLndoYXR3Zy5vcmcvI3V0Zi04LWRlY29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlclxuICovXG5mdW5jdGlvbiB1dGY4RGVjb2RlQnl0ZXMgKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gMS4gTGV0IGJ1ZmZlciBiZSB0aGUgcmVzdWx0IG9mIHBlZWtpbmcgdGhyZWUgYnl0ZXMgZnJvbVxuICAvLyAgICBpb1F1ZXVlLCBjb252ZXJ0ZWQgdG8gYSBieXRlIHNlcXVlbmNlLlxuXG4gIC8vIDIuIElmIGJ1ZmZlciBpcyAweEVGIDB4QkIgMHhCRiwgdGhlbiByZWFkIHRocmVlXG4gIC8vICAgIGJ5dGVzIGZyb20gaW9RdWV1ZS4gKERvIG5vdGhpbmcgd2l0aCB0aG9zZSBieXRlcy4pXG4gIGlmIChidWZmZXJbMF0gPT09IDB4RUYgJiYgYnVmZmVyWzFdID09PSAweEJCICYmIGJ1ZmZlclsyXSA9PT0gMHhCRikge1xuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheSgzKVxuICB9XG5cbiAgLy8gMy4gUHJvY2VzcyBhIHF1ZXVlIHdpdGggYW4gaW5zdGFuY2Ugb2YgVVRGLTjigJlzXG4gIC8vICAgIGRlY29kZXIsIGlvUXVldWUsIG91dHB1dCwgYW5kIFwicmVwbGFjZW1lbnRcIi5cbiAgY29uc3Qgb3V0cHV0ID0gdGV4dERlY29kZXIuZGVjb2RlKGJ1ZmZlcilcblxuICAvLyA0LiBSZXR1cm4gb3V0cHV0LlxuICByZXR1cm4gb3V0cHV0XG59XG5cbmNsYXNzIEVudmlyb25tZW50U2V0dGluZ3NPYmplY3RCYXNlIHtcbiAgZ2V0IGJhc2VVcmwgKCkge1xuICAgIHJldHVybiBnZXRHbG9iYWxPcmlnaW4oKVxuICB9XG5cbiAgZ2V0IG9yaWdpbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZVVybD8ub3JpZ2luXG4gIH1cblxuICBwb2xpY3lDb250YWluZXIgPSBtYWtlUG9saWN5Q29udGFpbmVyKClcbn1cblxuY2xhc3MgRW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCB7XG4gIHNldHRpbmdzT2JqZWN0ID0gbmV3IEVudmlyb25tZW50U2V0dGluZ3NPYmplY3RCYXNlKClcbn1cblxuY29uc3QgZW52aXJvbm1lbnRTZXR0aW5nc09iamVjdCA9IG5ldyBFbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0KClcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzQWJvcnRlZCxcbiAgaXNDYW5jZWxsZWQsXG4gIGlzVmFsaWRFbmNvZGVkVVJMLFxuICBjcmVhdGVEZWZlcnJlZFByb21pc2UsXG4gIFJlYWRhYmxlU3RyZWFtRnJvbSxcbiAgdHJ5VXBncmFkZVJlcXVlc3RUb0FQb3RlbnRpYWxseVRydXN0d29ydGh5VVJMLFxuICBjbGFtcEFuZENvYXJzZW5Db25uZWN0aW9uVGltaW5nSW5mbyxcbiAgY29hcnNlbmVkU2hhcmVkQ3VycmVudFRpbWUsXG4gIGRldGVybWluZVJlcXVlc3RzUmVmZXJyZXIsXG4gIG1ha2VQb2xpY3lDb250YWluZXIsXG4gIGNsb25lUG9saWN5Q29udGFpbmVyLFxuICBhcHBlbmRGZXRjaE1ldGFkYXRhLFxuICBhcHBlbmRSZXF1ZXN0T3JpZ2luSGVhZGVyLFxuICBUQU9DaGVjayxcbiAgY29yc0NoZWNrLFxuICBjcm9zc09yaWdpblJlc291cmNlUG9saWN5Q2hlY2ssXG4gIGNyZWF0ZU9wYXF1ZVRpbWluZ0luZm8sXG4gIHNldFJlcXVlc3RSZWZlcnJlclBvbGljeU9uUmVkaXJlY3QsXG4gIGlzVmFsaWRIVFRQVG9rZW4sXG4gIHJlcXVlc3RCYWRQb3J0LFxuICByZXF1ZXN0Q3VycmVudFVSTCxcbiAgcmVzcG9uc2VVUkwsXG4gIHJlc3BvbnNlTG9jYXRpb25VUkwsXG4gIGlzQmxvYkxpa2UsXG4gIGlzVVJMUG90ZW50aWFsbHlUcnVzdHdvcnRoeSxcbiAgaXNWYWxpZFJlYXNvblBocmFzZSxcbiAgc2FtZU9yaWdpbixcbiAgbm9ybWFsaXplTWV0aG9kLFxuICBzZXJpYWxpemVKYXZhc2NyaXB0VmFsdWVUb0pTT05TdHJpbmcsXG4gIGl0ZXJhdG9yTWl4aW4sXG4gIGNyZWF0ZUl0ZXJhdG9yLFxuICBpc1ZhbGlkSGVhZGVyTmFtZSxcbiAgaXNWYWxpZEhlYWRlclZhbHVlLFxuICBpc0Vycm9yTGlrZSxcbiAgZnVsbHlSZWFkQm9keSxcbiAgYnl0ZXNNYXRjaCxcbiAgaXNSZWFkYWJsZVN0cmVhbUxpa2UsXG4gIHJlYWRhYmxlU3RyZWFtQ2xvc2UsXG4gIGlzb21vcnBoaWNFbmNvZGUsXG4gIHVybElzTG9jYWwsXG4gIHVybEhhc0h0dHBzU2NoZW1lLFxuICB1cmxJc0h0dHBIdHRwc1NjaGVtZSxcbiAgcmVhZEFsbEJ5dGVzLFxuICBzaW1wbGVSYW5nZUhlYWRlclZhbHVlLFxuICBidWlsZENvbnRlbnRSYW5nZSxcbiAgcGFyc2VNZXRhZGF0YSxcbiAgY3JlYXRlSW5mbGF0ZSxcbiAgZXh0cmFjdE1pbWVUeXBlLFxuICBnZXREZWNvZGVTcGxpdCxcbiAgdXRmOERlY29kZUJ5dGVzLFxuICBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fetch/webidl.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fetch/webidl.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { types, inspect } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { markAsUncloneable } = __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\")\nconst { toUSVString } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\n/** @type {import('../../../types/webidl').Webidl} */\nconst webidl = {}\nwebidl.converters = {}\nwebidl.util = {}\nwebidl.errors = {}\n\nwebidl.errors.exception = function (message) {\n  return new TypeError(`${message.header}: ${message.message}`)\n}\n\nwebidl.errors.conversionFailed = function (context) {\n  const plural = context.types.length === 1 ? '' : ' one of'\n  const message =\n    `${context.argument} could not be converted to` +\n    `${plural}: ${context.types.join(', ')}.`\n\n  return webidl.errors.exception({\n    header: context.prefix,\n    message\n  })\n}\n\nwebidl.errors.invalidArgument = function (context) {\n  return webidl.errors.exception({\n    header: context.prefix,\n    message: `\"${context.value}\" is an invalid ${context.type}.`\n  })\n}\n\n// https://webidl.spec.whatwg.org/#implements\nwebidl.brandCheck = function (V, I, opts) {\n  if (opts?.strict !== false) {\n    if (!(V instanceof I)) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  } else {\n    if (V?.[Symbol.toStringTag] !== I.prototype[Symbol.toStringTag]) {\n      const err = new TypeError('Illegal invocation')\n      err.code = 'ERR_INVALID_THIS' // node compat.\n      throw err\n    }\n  }\n}\n\nwebidl.argumentLengthCheck = function ({ length }, min, ctx) {\n  if (length < min) {\n    throw webidl.errors.exception({\n      message: `${min} argument${min !== 1 ? 's' : ''} required, ` +\n               `but${length ? ' only' : ''} ${length} found.`,\n      header: ctx\n    })\n  }\n}\n\nwebidl.illegalConstructor = function () {\n  throw webidl.errors.exception({\n    header: 'TypeError',\n    message: 'Illegal constructor'\n  })\n}\n\n// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values\nwebidl.util.Type = function (V) {\n  switch (typeof V) {\n    case 'undefined': return 'Undefined'\n    case 'boolean': return 'Boolean'\n    case 'string': return 'String'\n    case 'symbol': return 'Symbol'\n    case 'number': return 'Number'\n    case 'bigint': return 'BigInt'\n    case 'function':\n    case 'object': {\n      if (V === null) {\n        return 'Null'\n      }\n\n      return 'Object'\n    }\n  }\n}\n\nwebidl.util.markAsUncloneable = markAsUncloneable || (() => {})\n// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint\nwebidl.util.ConvertToInt = function (V, bitLength, signedness, opts) {\n  let upperBound\n  let lowerBound\n\n  // 1. If bitLength is 64, then:\n  if (bitLength === 64) {\n    // 1. Let upperBound be 2^53 − 1.\n    upperBound = Math.pow(2, 53) - 1\n\n    // 2. If signedness is \"unsigned\", then let lowerBound be 0.\n    if (signedness === 'unsigned') {\n      lowerBound = 0\n    } else {\n      // 3. Otherwise let lowerBound be −2^53 + 1.\n      lowerBound = Math.pow(-2, 53) + 1\n    }\n  } else if (signedness === 'unsigned') {\n    // 2. Otherwise, if signedness is \"unsigned\", then:\n\n    // 1. Let lowerBound be 0.\n    lowerBound = 0\n\n    // 2. Let upperBound be 2^bitLength − 1.\n    upperBound = Math.pow(2, bitLength) - 1\n  } else {\n    // 3. Otherwise:\n\n    // 1. Let lowerBound be -2^bitLength − 1.\n    lowerBound = Math.pow(-2, bitLength) - 1\n\n    // 2. Let upperBound be 2^bitLength − 1 − 1.\n    upperBound = Math.pow(2, bitLength - 1) - 1\n  }\n\n  // 4. Let x be ? ToNumber(V).\n  let x = Number(V)\n\n  // 5. If x is −0, then set x to +0.\n  if (x === 0) {\n    x = 0\n  }\n\n  // 6. If the conversion is to an IDL type associated\n  //    with the [EnforceRange] extended attribute, then:\n  if (opts?.enforceRange === true) {\n    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.\n    if (\n      Number.isNaN(x) ||\n      x === Number.POSITIVE_INFINITY ||\n      x === Number.NEGATIVE_INFINITY\n    ) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Could not convert ${webidl.util.Stringify(V)} to an integer.`\n      })\n    }\n\n    // 2. Set x to IntegerPart(x).\n    x = webidl.util.IntegerPart(x)\n\n    // 3. If x < lowerBound or x > upperBound, then\n    //    throw a TypeError.\n    if (x < lowerBound || x > upperBound) {\n      throw webidl.errors.exception({\n        header: 'Integer conversion',\n        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`\n      })\n    }\n\n    // 4. Return x.\n    return x\n  }\n\n  // 7. If x is not NaN and the conversion is to an IDL\n  //    type associated with the [Clamp] extended\n  //    attribute, then:\n  if (!Number.isNaN(x) && opts?.clamp === true) {\n    // 1. Set x to min(max(x, lowerBound), upperBound).\n    x = Math.min(Math.max(x, lowerBound), upperBound)\n\n    // 2. Round x to the nearest integer, choosing the\n    //    even integer if it lies halfway between two,\n    //    and choosing +0 rather than −0.\n    if (Math.floor(x) % 2 === 0) {\n      x = Math.floor(x)\n    } else {\n      x = Math.ceil(x)\n    }\n\n    // 3. Return x.\n    return x\n  }\n\n  // 8. If x is NaN, +0, +∞, or −∞, then return +0.\n  if (\n    Number.isNaN(x) ||\n    (x === 0 && Object.is(0, x)) ||\n    x === Number.POSITIVE_INFINITY ||\n    x === Number.NEGATIVE_INFINITY\n  ) {\n    return 0\n  }\n\n  // 9. Set x to IntegerPart(x).\n  x = webidl.util.IntegerPart(x)\n\n  // 10. Set x to x modulo 2^bitLength.\n  x = x % Math.pow(2, bitLength)\n\n  // 11. If signedness is \"signed\" and x ≥ 2^bitLength − 1,\n  //    then return x − 2^bitLength.\n  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {\n    return x - Math.pow(2, bitLength)\n  }\n\n  // 12. Otherwise, return x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart\nwebidl.util.IntegerPart = function (n) {\n  // 1. Let r be floor(abs(n)).\n  const r = Math.floor(Math.abs(n))\n\n  // 2. If n < 0, then return -1 × r.\n  if (n < 0) {\n    return -1 * r\n  }\n\n  // 3. Otherwise, return r.\n  return r\n}\n\nwebidl.util.Stringify = function (V) {\n  const type = webidl.util.Type(V)\n\n  switch (type) {\n    case 'Symbol':\n      return `Symbol(${V.description})`\n    case 'Object':\n      return inspect(V)\n    case 'String':\n      return `\"${V}\"`\n    default:\n      return `${V}`\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-sequence\nwebidl.sequenceConverter = function (converter) {\n  return (V, prefix, argument, Iterable) => {\n    // 1. If Type(V) is not Object, throw a TypeError.\n    if (webidl.util.Type(V) !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (${webidl.util.Stringify(V)}) is not iterable.`\n      })\n    }\n\n    // 2. Let method be ? GetMethod(V, @@iterator).\n    /** @type {Generator} */\n    const method = typeof Iterable === 'function' ? Iterable() : V?.[Symbol.iterator]?.()\n    const seq = []\n    let index = 0\n\n    // 3. If method is undefined, throw a TypeError.\n    if (\n      method === undefined ||\n      typeof method.next !== 'function'\n    ) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} is not iterable.`\n      })\n    }\n\n    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable\n    while (true) {\n      const { done, value } = method.next()\n\n      if (done) {\n        break\n      }\n\n      seq.push(converter(value, prefix, `${argument}[${index++}]`))\n    }\n\n    return seq\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-to-record\nwebidl.recordConverter = function (keyConverter, valueConverter) {\n  return (O, prefix, argument) => {\n    // 1. If Type(O) is not Object, throw a TypeError.\n    if (webidl.util.Type(O) !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `${argument} (\"${webidl.util.Type(O)}\") is not an Object.`\n      })\n    }\n\n    // 2. Let result be a new empty instance of record<K, V>.\n    const result = {}\n\n    if (!types.isProxy(O)) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const keys = [...Object.getOwnPropertyNames(O), ...Object.getOwnPropertySymbols(O)]\n\n      for (const key of keys) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n\n      // 5. Return result.\n      return result\n    }\n\n    // 3. Let keys be ? O.[[OwnPropertyKeys]]().\n    const keys = Reflect.ownKeys(O)\n\n    // 4. For each key of keys.\n    for (const key of keys) {\n      // 1. Let desc be ? O.[[GetOwnProperty]](key).\n      const desc = Reflect.getOwnPropertyDescriptor(O, key)\n\n      // 2. If desc is not undefined and desc.[[Enumerable]] is true:\n      if (desc?.enumerable) {\n        // 1. Let typedKey be key converted to an IDL value of type K.\n        const typedKey = keyConverter(key, prefix, argument)\n\n        // 2. Let value be ? Get(O, key).\n        // 3. Let typedValue be value converted to an IDL value of type V.\n        const typedValue = valueConverter(O[key], prefix, argument)\n\n        // 4. Set result[typedKey] to typedValue.\n        result[typedKey] = typedValue\n      }\n    }\n\n    // 5. Return result.\n    return result\n  }\n}\n\nwebidl.interfaceConverter = function (i) {\n  return (V, prefix, argument, opts) => {\n    if (opts?.strict !== false && !(V instanceof i)) {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${argument} (\"${webidl.util.Stringify(V)}\") to be an instance of ${i.name}.`\n      })\n    }\n\n    return V\n  }\n}\n\nwebidl.dictionaryConverter = function (converters) {\n  return (dictionary, prefix, argument) => {\n    const type = webidl.util.Type(dictionary)\n    const dict = {}\n\n    if (type === 'Null' || type === 'Undefined') {\n      return dict\n    } else if (type !== 'Object') {\n      throw webidl.errors.exception({\n        header: prefix,\n        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`\n      })\n    }\n\n    for (const options of converters) {\n      const { key, defaultValue, required, converter } = options\n\n      if (required === true) {\n        if (!Object.hasOwn(dictionary, key)) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `Missing required key \"${key}\".`\n          })\n        }\n      }\n\n      let value = dictionary[key]\n      const hasDefault = Object.hasOwn(options, 'defaultValue')\n\n      // Only use defaultValue if value is undefined and\n      // a defaultValue options was provided.\n      if (hasDefault && value !== null) {\n        value ??= defaultValue()\n      }\n\n      // A key can be optional and have no default value.\n      // When this happens, do not perform a conversion,\n      // and do not assign the key a value.\n      if (required || hasDefault || value !== undefined) {\n        value = converter(value, prefix, `${argument}.${key}`)\n\n        if (\n          options.allowedValues &&\n          !options.allowedValues.includes(value)\n        ) {\n          throw webidl.errors.exception({\n            header: prefix,\n            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`\n          })\n        }\n\n        dict[key] = value\n      }\n    }\n\n    return dict\n  }\n}\n\nwebidl.nullableConverter = function (converter) {\n  return (V, prefix, argument) => {\n    if (V === null) {\n      return V\n    }\n\n    return converter(V, prefix, argument)\n  }\n}\n\n// https://webidl.spec.whatwg.org/#es-DOMString\nwebidl.converters.DOMString = function (V, prefix, argument, opts) {\n  // 1. If V is null and the conversion is to an IDL type\n  //    associated with the [LegacyNullToEmptyString]\n  //    extended attribute, then return the DOMString value\n  //    that represents the empty string.\n  if (V === null && opts?.legacyNullToEmptyString) {\n    return ''\n  }\n\n  // 2. Let x be ? ToString(V).\n  if (typeof V === 'symbol') {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${argument} is a symbol, which cannot be converted to a DOMString.`\n    })\n  }\n\n  // 3. Return the IDL DOMString value that represents the\n  //    same sequence of code units as the one the\n  //    ECMAScript String value x represents.\n  return String(V)\n}\n\n// https://webidl.spec.whatwg.org/#es-ByteString\nwebidl.converters.ByteString = function (V, prefix, argument) {\n  // 1. Let x be ? ToString(V).\n  // Note: DOMString converter perform ? ToString(V)\n  const x = webidl.converters.DOMString(V, prefix, argument)\n\n  // 2. If the value of any element of x is greater than\n  //    255, then throw a TypeError.\n  for (let index = 0; index < x.length; index++) {\n    if (x.charCodeAt(index) > 255) {\n      throw new TypeError(\n        'Cannot convert argument to a ByteString because the character at ' +\n        `index ${index} has a value of ${x.charCodeAt(index)} which is greater than 255.`\n      )\n    }\n  }\n\n  // 3. Return an IDL ByteString value whose length is the\n  //    length of x, and where the value of each element is\n  //    the value of the corresponding element of x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-USVString\n// TODO: rewrite this so we can control the errors thrown\nwebidl.converters.USVString = toUSVString\n\n// https://webidl.spec.whatwg.org/#es-boolean\nwebidl.converters.boolean = function (V) {\n  // 1. Let x be the result of computing ToBoolean(V).\n  const x = Boolean(V)\n\n  // 2. Return the IDL boolean value that is the one that represents\n  //    the same truth value as the ECMAScript Boolean value x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-any\nwebidl.converters.any = function (V) {\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#es-long-long\nwebidl.converters['long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"signed\").\n  const x = webidl.util.ConvertToInt(V, 64, 'signed', undefined, prefix, argument)\n\n  // 2. Return the IDL long long value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long-long\nwebidl.converters['unsigned long long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 64, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 64, 'unsigned', undefined, prefix, argument)\n\n  // 2. Return the IDL unsigned long long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-long\nwebidl.converters['unsigned long'] = function (V, prefix, argument) {\n  // 1. Let x be ? ConvertToInt(V, 32, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 32, 'unsigned', undefined, prefix, argument)\n\n  // 2. Return the IDL unsigned long value that\n  //    represents the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#es-unsigned-short\nwebidl.converters['unsigned short'] = function (V, prefix, argument, opts) {\n  // 1. Let x be ? ConvertToInt(V, 16, \"unsigned\").\n  const x = webidl.util.ConvertToInt(V, 16, 'unsigned', opts, prefix, argument)\n\n  // 2. Return the IDL unsigned short value that represents\n  //    the same numeric value as x.\n  return x\n}\n\n// https://webidl.spec.whatwg.org/#idl-ArrayBuffer\nwebidl.converters.ArrayBuffer = function (V, prefix, argument, opts) {\n  // 1. If Type(V) is not Object, or V does not have an\n  //    [[ArrayBufferData]] internal slot, then throw a\n  //    TypeError.\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances\n  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isAnyArrayBuffer(V)\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${argument} (\"${webidl.util.Stringify(V)}\")`,\n      types: ['ArrayBuffer']\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V) is true, then throw a\n  //    TypeError.\n  if (V.resizable || V.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 4. Return the IDL ArrayBuffer value that is a\n  //    reference to the same object as V.\n  return V\n}\n\nwebidl.converters.TypedArray = function (V, T, prefix, name, opts) {\n  // 1. Let T be the IDL type V is being converted to.\n\n  // 2. If Type(V) is not Object, or V does not have a\n  //    [[TypedArrayName]] internal slot with a value\n  //    equal to T’s name, then throw a TypeError.\n  if (\n    webidl.util.Type(V) !== 'Object' ||\n    !types.isTypedArray(V) ||\n    V.constructor.name !== T.name\n  ) {\n    throw webidl.errors.conversionFailed({\n      prefix,\n      argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n      types: [T.name]\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 4. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 5. Return the IDL value of type T that is a reference\n  //    to the same object as V.\n  return V\n}\n\nwebidl.converters.DataView = function (V, prefix, name, opts) {\n  // 1. If Type(V) is not Object, or V does not have a\n  //    [[DataView]] internal slot, then throw a TypeError.\n  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {\n    throw webidl.errors.exception({\n      header: prefix,\n      message: `${name} is not a DataView.`\n    })\n  }\n\n  // 2. If the conversion is not to an IDL type associated\n  //    with the [AllowShared] extended attribute, and\n  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,\n  //    then throw a TypeError.\n  if (opts?.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'SharedArrayBuffer is not allowed.'\n    })\n  }\n\n  // 3. If the conversion is not to an IDL type associated\n  //    with the [AllowResizable] extended attribute, and\n  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is\n  //    true, then throw a TypeError.\n  if (V.buffer.resizable || V.buffer.growable) {\n    throw webidl.errors.exception({\n      header: 'ArrayBuffer',\n      message: 'Received a resizable ArrayBuffer.'\n    })\n  }\n\n  // 4. Return the IDL DataView value that is a reference\n  //    to the same object as V.\n  return V\n}\n\n// https://webidl.spec.whatwg.org/#BufferSource\nwebidl.converters.BufferSource = function (V, prefix, name, opts) {\n  if (types.isAnyArrayBuffer(V)) {\n    return webidl.converters.ArrayBuffer(V, prefix, name, { ...opts, allowShared: false })\n  }\n\n  if (types.isTypedArray(V)) {\n    return webidl.converters.TypedArray(V, V.constructor, prefix, name, { ...opts, allowShared: false })\n  }\n\n  if (types.isDataView(V)) {\n    return webidl.converters.DataView(V, prefix, name, { ...opts, allowShared: false })\n  }\n\n  throw webidl.errors.conversionFailed({\n    prefix,\n    argument: `${name} (\"${webidl.util.Stringify(V)}\")`,\n    types: ['BufferSource']\n  })\n}\n\nwebidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(\n  webidl.converters.ByteString\n)\n\nwebidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(\n  webidl.converters['sequence<ByteString>']\n)\n\nwebidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(\n  webidl.converters.ByteString,\n  webidl.converters.ByteString\n)\n\nmodule.exports = {\n  webidl\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmV0Y2gvd2ViaWRsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsaUJBQWlCLEVBQUUsbUJBQU8sQ0FBQyw0QkFBVztBQUM5QyxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsZ0RBQXFCO0FBQzNELFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMscUVBQWlCOztBQUVqRCxXQUFXLHdDQUF3QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQixlQUFlLElBQUksZ0JBQWdCO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sa0JBQWtCO0FBQ3pCLE9BQU8sT0FBTyxJQUFJLHlCQUF5Qjs7QUFFM0M7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixjQUFjLGtCQUFrQixhQUFhO0FBQzlELEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSyxVQUFVLHNCQUFzQjtBQUN2RCxxQkFBcUIsdUJBQXVCLEVBQUUsUUFBUTtBQUN0RDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFF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QUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDZCQUE2QjtBQUN6Rjs7QUFFQTtBQUNBLDBFQUEwRSw2QkFBNkI7QUFDdkc7O0FBRUE7QUFDQSx5REFBeUQsNkJBQTZCO0FBQ3RGOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTSxJQUFJLHlCQUF5QjtBQUNwRDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZldGNoXFx3ZWJpZGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgdHlwZXMsIGluc3BlY3QgfSA9IHJlcXVpcmUoJ25vZGU6dXRpbCcpXG5jb25zdCB7IG1hcmtBc1VuY2xvbmVhYmxlIH0gPSByZXF1aXJlKCdub2RlOndvcmtlcl90aHJlYWRzJylcbmNvbnN0IHsgdG9VU1ZTdHJpbmcgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuLi8uLi8uLi90eXBlcy93ZWJpZGwnKS5XZWJpZGx9ICovXG5jb25zdCB3ZWJpZGwgPSB7fVxud2ViaWRsLmNvbnZlcnRlcnMgPSB7fVxud2ViaWRsLnV0aWwgPSB7fVxud2ViaWRsLmVycm9ycyA9IHt9XG5cbndlYmlkbC5lcnJvcnMuZXhjZXB0aW9uID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYCR7bWVzc2FnZS5oZWFkZXJ9OiAke21lc3NhZ2UubWVzc2FnZX1gKVxufVxuXG53ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICBjb25zdCBwbHVyYWwgPSBjb250ZXh0LnR5cGVzLmxlbmd0aCA9PT0gMSA/ICcnIDogJyBvbmUgb2YnXG4gIGNvbnN0IG1lc3NhZ2UgPVxuICAgIGAke2NvbnRleHQuYXJndW1lbnR9IGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG9gICtcbiAgICBgJHtwbHVyYWx9OiAke2NvbnRleHQudHlwZXMuam9pbignLCAnKX0uYFxuXG4gIHJldHVybiB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiBjb250ZXh0LnByZWZpeCxcbiAgICBtZXNzYWdlXG4gIH0pXG59XG5cbndlYmlkbC5lcnJvcnMuaW52YWxpZEFyZ3VtZW50ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgcmV0dXJuIHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICBoZWFkZXI6IGNvbnRleHQucHJlZml4LFxuICAgIG1lc3NhZ2U6IGBcIiR7Y29udGV4dC52YWx1ZX1cIiBpcyBhbiBpbnZhbGlkICR7Y29udGV4dC50eXBlfS5gXG4gIH0pXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jaW1wbGVtZW50c1xud2ViaWRsLmJyYW5kQ2hlY2sgPSBmdW5jdGlvbiAoViwgSSwgb3B0cykge1xuICBpZiAob3B0cz8uc3RyaWN0ICE9PSBmYWxzZSkge1xuICAgIGlmICghKFYgaW5zdGFuY2VvZiBJKSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBpbnZvY2F0aW9uJylcbiAgICAgIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX1RISVMnIC8vIG5vZGUgY29tcGF0LlxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChWPy5bU3ltYm9sLnRvU3RyaW5nVGFnXSAhPT0gSS5wcm90b3R5cGVbU3ltYm9sLnRvU3RyaW5nVGFnXSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IFR5cGVFcnJvcignSWxsZWdhbCBpbnZvY2F0aW9uJylcbiAgICAgIGVyci5jb2RlID0gJ0VSUl9JTlZBTElEX1RISVMnIC8vIG5vZGUgY29tcGF0LlxuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbndlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrID0gZnVuY3Rpb24gKHsgbGVuZ3RoIH0sIG1pbiwgY3R4KSB7XG4gIGlmIChsZW5ndGggPCBtaW4pIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBtZXNzYWdlOiBgJHttaW59IGFyZ3VtZW50JHttaW4gIT09IDEgPyAncycgOiAnJ30gcmVxdWlyZWQsIGAgK1xuICAgICAgICAgICAgICAgYGJ1dCR7bGVuZ3RoID8gJyBvbmx5JyA6ICcnfSAke2xlbmd0aH0gZm91bmQuYCxcbiAgICAgIGhlYWRlcjogY3R4XG4gICAgfSlcbiAgfVxufVxuXG53ZWJpZGwuaWxsZWdhbENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgaGVhZGVyOiAnVHlwZUVycm9yJyxcbiAgICBtZXNzYWdlOiAnSWxsZWdhbCBjb25zdHJ1Y3RvcidcbiAgfSlcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1lY21hc2NyaXB0LWRhdGEtdHlwZXMtYW5kLXZhbHVlc1xud2ViaWRsLnV0aWwuVHlwZSA9IGZ1bmN0aW9uIChWKSB7XG4gIHN3aXRjaCAodHlwZW9mIFYpIHtcbiAgICBjYXNlICd1bmRlZmluZWQnOiByZXR1cm4gJ1VuZGVmaW5lZCdcbiAgICBjYXNlICdib29sZWFuJzogcmV0dXJuICdCb29sZWFuJ1xuICAgIGNhc2UgJ3N0cmluZyc6IHJldHVybiAnU3RyaW5nJ1xuICAgIGNhc2UgJ3N5bWJvbCc6IHJldHVybiAnU3ltYm9sJ1xuICAgIGNhc2UgJ251bWJlcic6IHJldHVybiAnTnVtYmVyJ1xuICAgIGNhc2UgJ2JpZ2ludCc6IHJldHVybiAnQmlnSW50J1xuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICBpZiAoViA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ051bGwnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnT2JqZWN0J1xuICAgIH1cbiAgfVxufVxuXG53ZWJpZGwudXRpbC5tYXJrQXNVbmNsb25lYWJsZSA9IG1hcmtBc1VuY2xvbmVhYmxlIHx8ICgoKSA9PiB7fSlcbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jYWJzdHJhY3Qtb3BkZWYtY29udmVydHRvaW50XG53ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQgPSBmdW5jdGlvbiAoViwgYml0TGVuZ3RoLCBzaWduZWRuZXNzLCBvcHRzKSB7XG4gIGxldCB1cHBlckJvdW5kXG4gIGxldCBsb3dlckJvdW5kXG5cbiAgLy8gMS4gSWYgYml0TGVuZ3RoIGlzIDY0LCB0aGVuOlxuICBpZiAoYml0TGVuZ3RoID09PSA2NCkge1xuICAgIC8vIDEuIExldCB1cHBlckJvdW5kIGJlIDJeNTMg4oiSIDEuXG4gICAgdXBwZXJCb3VuZCA9IE1hdGgucG93KDIsIDUzKSAtIDFcblxuICAgIC8vIDIuIElmIHNpZ25lZG5lc3MgaXMgXCJ1bnNpZ25lZFwiLCB0aGVuIGxldCBsb3dlckJvdW5kIGJlIDAuXG4gICAgaWYgKHNpZ25lZG5lc3MgPT09ICd1bnNpZ25lZCcpIHtcbiAgICAgIGxvd2VyQm91bmQgPSAwXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIDMuIE90aGVyd2lzZSBsZXQgbG93ZXJCb3VuZCBiZSDiiJIyXjUzICsgMS5cbiAgICAgIGxvd2VyQm91bmQgPSBNYXRoLnBvdygtMiwgNTMpICsgMVxuICAgIH1cbiAgfSBlbHNlIGlmIChzaWduZWRuZXNzID09PSAndW5zaWduZWQnKSB7XG4gICAgLy8gMi4gT3RoZXJ3aXNlLCBpZiBzaWduZWRuZXNzIGlzIFwidW5zaWduZWRcIiwgdGhlbjpcblxuICAgIC8vIDEuIExldCBsb3dlckJvdW5kIGJlIDAuXG4gICAgbG93ZXJCb3VuZCA9IDBcblxuICAgIC8vIDIuIExldCB1cHBlckJvdW5kIGJlIDJeYml0TGVuZ3RoIOKIkiAxLlxuICAgIHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpIC0gMVxuICB9IGVsc2Uge1xuICAgIC8vIDMuIE90aGVyd2lzZTpcblxuICAgIC8vIDEuIExldCBsb3dlckJvdW5kIGJlIC0yXmJpdExlbmd0aCDiiJIgMS5cbiAgICBsb3dlckJvdW5kID0gTWF0aC5wb3coLTIsIGJpdExlbmd0aCkgLSAxXG5cbiAgICAvLyAyLiBMZXQgdXBwZXJCb3VuZCBiZSAyXmJpdExlbmd0aCDiiJIgMSDiiJIgMS5cbiAgICB1cHBlckJvdW5kID0gTWF0aC5wb3coMiwgYml0TGVuZ3RoIC0gMSkgLSAxXG4gIH1cblxuICAvLyA0LiBMZXQgeCBiZSA/IFRvTnVtYmVyKFYpLlxuICBsZXQgeCA9IE51bWJlcihWKVxuXG4gIC8vIDUuIElmIHggaXMg4oiSMCwgdGhlbiBzZXQgeCB0byArMC5cbiAgaWYgKHggPT09IDApIHtcbiAgICB4ID0gMFxuICB9XG5cbiAgLy8gNi4gSWYgdGhlIGNvbnZlcnNpb24gaXMgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbRW5mb3JjZVJhbmdlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIHRoZW46XG4gIGlmIChvcHRzPy5lbmZvcmNlUmFuZ2UgPT09IHRydWUpIHtcbiAgICAvLyAxLiBJZiB4IGlzIE5hTiwgK+KIniwgb3Ig4oiS4oieLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChcbiAgICAgIE51bWJlci5pc05hTih4KSB8fFxuICAgICAgeCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8XG4gICAgICB4ID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICApIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiAnSW50ZWdlciBjb252ZXJzaW9uJyxcbiAgICAgICAgbWVzc2FnZTogYENvdWxkIG5vdCBjb252ZXJ0ICR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfSB0byBhbiBpbnRlZ2VyLmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gU2V0IHggdG8gSW50ZWdlclBhcnQoeCkuXG4gICAgeCA9IHdlYmlkbC51dGlsLkludGVnZXJQYXJ0KHgpXG5cbiAgICAvLyAzLiBJZiB4IDwgbG93ZXJCb3VuZCBvciB4ID4gdXBwZXJCb3VuZCwgdGhlblxuICAgIC8vICAgIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xuICAgICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgICBoZWFkZXI6ICdJbnRlZ2VyIGNvbnZlcnNpb24nLFxuICAgICAgICBtZXNzYWdlOiBgVmFsdWUgbXVzdCBiZSBiZXR3ZWVuICR7bG93ZXJCb3VuZH0tJHt1cHBlckJvdW5kfSwgZ290ICR7eH0uYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyA0LiBSZXR1cm4geC5cbiAgICByZXR1cm4geFxuICB9XG5cbiAgLy8gNy4gSWYgeCBpcyBub3QgTmFOIGFuZCB0aGUgY29udmVyc2lvbiBpcyB0byBhbiBJRExcbiAgLy8gICAgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIFtDbGFtcF0gZXh0ZW5kZWRcbiAgLy8gICAgYXR0cmlidXRlLCB0aGVuOlxuICBpZiAoIU51bWJlci5pc05hTih4KSAmJiBvcHRzPy5jbGFtcCA9PT0gdHJ1ZSkge1xuICAgIC8vIDEuIFNldCB4IHRvIG1pbihtYXgoeCwgbG93ZXJCb3VuZCksIHVwcGVyQm91bmQpLlxuICAgIHggPSBNYXRoLm1pbihNYXRoLm1heCh4LCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZClcblxuICAgIC8vIDIuIFJvdW5kIHggdG8gdGhlIG5lYXJlc3QgaW50ZWdlciwgY2hvb3NpbmcgdGhlXG4gICAgLy8gICAgZXZlbiBpbnRlZ2VyIGlmIGl0IGxpZXMgaGFsZndheSBiZXR3ZWVuIHR3byxcbiAgICAvLyAgICBhbmQgY2hvb3NpbmcgKzAgcmF0aGVyIHRoYW4g4oiSMC5cbiAgICBpZiAoTWF0aC5mbG9vcih4KSAlIDIgPT09IDApIHtcbiAgICAgIHggPSBNYXRoLmZsb29yKHgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBNYXRoLmNlaWwoeClcbiAgICB9XG5cbiAgICAvLyAzLiBSZXR1cm4geC5cbiAgICByZXR1cm4geFxuICB9XG5cbiAgLy8gOC4gSWYgeCBpcyBOYU4sICswLCAr4oieLCBvciDiiJLiiJ4sIHRoZW4gcmV0dXJuICswLlxuICBpZiAoXG4gICAgTnVtYmVyLmlzTmFOKHgpIHx8XG4gICAgKHggPT09IDAgJiYgT2JqZWN0LmlzKDAsIHgpKSB8fFxuICAgIHggPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB8fFxuICAgIHggPT09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICApIHtcbiAgICByZXR1cm4gMFxuICB9XG5cbiAgLy8gOS4gU2V0IHggdG8gSW50ZWdlclBhcnQoeCkuXG4gIHggPSB3ZWJpZGwudXRpbC5JbnRlZ2VyUGFydCh4KVxuXG4gIC8vIDEwLiBTZXQgeCB0byB4IG1vZHVsbyAyXmJpdExlbmd0aC5cbiAgeCA9IHggJSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpXG5cbiAgLy8gMTEuIElmIHNpZ25lZG5lc3MgaXMgXCJzaWduZWRcIiBhbmQgeCDiiaUgMl5iaXRMZW5ndGgg4oiSIDEsXG4gIC8vICAgIHRoZW4gcmV0dXJuIHgg4oiSIDJeYml0TGVuZ3RoLlxuICBpZiAoc2lnbmVkbmVzcyA9PT0gJ3NpZ25lZCcgJiYgeCA+PSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpIC0gMSkge1xuICAgIHJldHVybiB4IC0gTWF0aC5wb3coMiwgYml0TGVuZ3RoKVxuICB9XG5cbiAgLy8gMTIuIE90aGVyd2lzZSwgcmV0dXJuIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jYWJzdHJhY3Qtb3BkZWYtaW50ZWdlcnBhcnRcbndlYmlkbC51dGlsLkludGVnZXJQYXJ0ID0gZnVuY3Rpb24gKG4pIHtcbiAgLy8gMS4gTGV0IHIgYmUgZmxvb3IoYWJzKG4pKS5cbiAgY29uc3QgciA9IE1hdGguZmxvb3IoTWF0aC5hYnMobikpXG5cbiAgLy8gMi4gSWYgbiA8IDAsIHRoZW4gcmV0dXJuIC0xIMOXIHIuXG4gIGlmIChuIDwgMCkge1xuICAgIHJldHVybiAtMSAqIHJcbiAgfVxuXG4gIC8vIDMuIE90aGVyd2lzZSwgcmV0dXJuIHIuXG4gIHJldHVybiByXG59XG5cbndlYmlkbC51dGlsLlN0cmluZ2lmeSA9IGZ1bmN0aW9uIChWKSB7XG4gIGNvbnN0IHR5cGUgPSB3ZWJpZGwudXRpbC5UeXBlKFYpXG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnU3ltYm9sJzpcbiAgICAgIHJldHVybiBgU3ltYm9sKCR7Vi5kZXNjcmlwdGlvbn0pYFxuICAgIGNhc2UgJ09iamVjdCc6XG4gICAgICByZXR1cm4gaW5zcGVjdChWKVxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgICByZXR1cm4gYFwiJHtWfVwiYFxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYCR7Vn1gXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1zZXF1ZW5jZVxud2ViaWRsLnNlcXVlbmNlQ29udmVydGVyID0gZnVuY3Rpb24gKGNvbnZlcnRlcikge1xuICByZXR1cm4gKFYsIHByZWZpeCwgYXJndW1lbnQsIEl0ZXJhYmxlKSA9PiB7XG4gICAgLy8gMS4gSWYgVHlwZShWKSBpcyBub3QgT2JqZWN0LCB0aHJvdyBhIFR5cGVFcnJvci5cbiAgICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSAoJHt3ZWJpZGwudXRpbC5TdHJpbmdpZnkoVil9KSBpcyBub3QgaXRlcmFibGUuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyAyLiBMZXQgbWV0aG9kIGJlID8gR2V0TWV0aG9kKFYsIEBAaXRlcmF0b3IpLlxuICAgIC8qKiBAdHlwZSB7R2VuZXJhdG9yfSAqL1xuICAgIGNvbnN0IG1ldGhvZCA9IHR5cGVvZiBJdGVyYWJsZSA9PT0gJ2Z1bmN0aW9uJyA/IEl0ZXJhYmxlKCkgOiBWPy5bU3ltYm9sLml0ZXJhdG9yXT8uKClcbiAgICBjb25zdCBzZXEgPSBbXVxuICAgIGxldCBpbmRleCA9IDBcblxuICAgIC8vIDMuIElmIG1ldGhvZCBpcyB1bmRlZmluZWQsIHRocm93IGEgVHlwZUVycm9yLlxuICAgIGlmIChcbiAgICAgIG1ldGhvZCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0eXBlb2YgbWV0aG9kLm5leHQgIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGAke2FyZ3VtZW50fSBpcyBub3QgaXRlcmFibGUuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2NyZWF0ZS1zZXF1ZW5jZS1mcm9tLWl0ZXJhYmxlXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IG1ldGhvZC5uZXh0KClcblxuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgc2VxLnB1c2goY29udmVydGVyKHZhbHVlLCBwcmVmaXgsIGAke2FyZ3VtZW50fVske2luZGV4Kyt9XWApKVxuICAgIH1cblxuICAgIHJldHVybiBzZXFcbiAgfVxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXRvLXJlY29yZFxud2ViaWRsLnJlY29yZENvbnZlcnRlciA9IGZ1bmN0aW9uIChrZXlDb252ZXJ0ZXIsIHZhbHVlQ29udmVydGVyKSB7XG4gIHJldHVybiAoTywgcHJlZml4LCBhcmd1bWVudCkgPT4ge1xuICAgIC8vIDEuIElmIFR5cGUoTykgaXMgbm90IE9iamVjdCwgdGhyb3cgYSBUeXBlRXJyb3IuXG4gICAgaWYgKHdlYmlkbC51dGlsLlR5cGUoTykgIT09ICdPYmplY3QnKSB7XG4gICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgIGhlYWRlcjogcHJlZml4LFxuICAgICAgICBtZXNzYWdlOiBgJHthcmd1bWVudH0gKFwiJHt3ZWJpZGwudXRpbC5UeXBlKE8pfVwiKSBpcyBub3QgYW4gT2JqZWN0LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gMi4gTGV0IHJlc3VsdCBiZSBhIG5ldyBlbXB0eSBpbnN0YW5jZSBvZiByZWNvcmQ8SywgVj4uXG4gICAgY29uc3QgcmVzdWx0ID0ge31cblxuICAgIGlmICghdHlwZXMuaXNQcm94eShPKSkge1xuICAgICAgLy8gMS4gTGV0IGRlc2MgYmUgPyBPLltbR2V0T3duUHJvcGVydHldXShrZXkpLlxuICAgICAgY29uc3Qga2V5cyA9IFsuLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKSwgLi4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhPKV1cblxuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICAvLyAxLiBMZXQgdHlwZWRLZXkgYmUga2V5IGNvbnZlcnRlZCB0byBhbiBJREwgdmFsdWUgb2YgdHlwZSBLLlxuICAgICAgICBjb25zdCB0eXBlZEtleSA9IGtleUNvbnZlcnRlcihrZXksIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgICAgICAgLy8gMi4gTGV0IHZhbHVlIGJlID8gR2V0KE8sIGtleSkuXG4gICAgICAgIC8vIDMuIExldCB0eXBlZFZhbHVlIGJlIHZhbHVlIGNvbnZlcnRlZCB0byBhbiBJREwgdmFsdWUgb2YgdHlwZSBWLlxuICAgICAgICBjb25zdCB0eXBlZFZhbHVlID0gdmFsdWVDb252ZXJ0ZXIoT1trZXldLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gICAgICAgIC8vIDQuIFNldCByZXN1bHRbdHlwZWRLZXldIHRvIHR5cGVkVmFsdWUuXG4gICAgICAgIHJlc3VsdFt0eXBlZEtleV0gPSB0eXBlZFZhbHVlXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIFJldHVybiByZXN1bHQuXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgLy8gMy4gTGV0IGtleXMgYmUgPyBPLltbT3duUHJvcGVydHlLZXlzXV0oKS5cbiAgICBjb25zdCBrZXlzID0gUmVmbGVjdC5vd25LZXlzKE8pXG5cbiAgICAvLyA0LiBGb3IgZWFjaCBrZXkgb2Yga2V5cy5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAvLyAxLiBMZXQgZGVzYyBiZSA/IE8uW1tHZXRPd25Qcm9wZXJ0eV1dKGtleSkuXG4gICAgICBjb25zdCBkZXNjID0gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywga2V5KVxuXG4gICAgICAvLyAyLiBJZiBkZXNjIGlzIG5vdCB1bmRlZmluZWQgYW5kIGRlc2MuW1tFbnVtZXJhYmxlXV0gaXMgdHJ1ZTpcbiAgICAgIGlmIChkZXNjPy5lbnVtZXJhYmxlKSB7XG4gICAgICAgIC8vIDEuIExldCB0eXBlZEtleSBiZSBrZXkgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIEsuXG4gICAgICAgIGNvbnN0IHR5cGVkS2V5ID0ga2V5Q29udmVydGVyKGtleSwgcHJlZml4LCBhcmd1bWVudClcblxuICAgICAgICAvLyAyLiBMZXQgdmFsdWUgYmUgPyBHZXQoTywga2V5KS5cbiAgICAgICAgLy8gMy4gTGV0IHR5cGVkVmFsdWUgYmUgdmFsdWUgY29udmVydGVkIHRvIGFuIElETCB2YWx1ZSBvZiB0eXBlIFYuXG4gICAgICAgIGNvbnN0IHR5cGVkVmFsdWUgPSB2YWx1ZUNvbnZlcnRlcihPW2tleV0sIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgICAgICAgLy8gNC4gU2V0IHJlc3VsdFt0eXBlZEtleV0gdG8gdHlwZWRWYWx1ZS5cbiAgICAgICAgcmVzdWx0W3R5cGVkS2V5XSA9IHR5cGVkVmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyA1LiBSZXR1cm4gcmVzdWx0LlxuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG53ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyID0gZnVuY3Rpb24gKGkpIHtcbiAgcmV0dXJuIChWLCBwcmVmaXgsIGFyZ3VtZW50LCBvcHRzKSA9PiB7XG4gICAgaWYgKG9wdHM/LnN0cmljdCAhPT0gZmFsc2UgJiYgIShWIGluc3RhbmNlb2YgaSkpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAke2FyZ3VtZW50fSAoXCIke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX1cIikgdG8gYmUgYW4gaW5zdGFuY2Ugb2YgJHtpLm5hbWV9LmBcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFZcbiAgfVxufVxuXG53ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXJzKSB7XG4gIHJldHVybiAoZGljdGlvbmFyeSwgcHJlZml4LCBhcmd1bWVudCkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSB3ZWJpZGwudXRpbC5UeXBlKGRpY3Rpb25hcnkpXG4gICAgY29uc3QgZGljdCA9IHt9XG5cbiAgICBpZiAodHlwZSA9PT0gJ051bGwnIHx8IHR5cGUgPT09ICdVbmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZGljdFxuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gJ09iamVjdCcpIHtcbiAgICAgIHRocm93IHdlYmlkbC5lcnJvcnMuZXhjZXB0aW9uKHtcbiAgICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICAgIG1lc3NhZ2U6IGBFeHBlY3RlZCAke2RpY3Rpb25hcnl9IHRvIGJlIG9uZSBvZjogTnVsbCwgVW5kZWZpbmVkLCBPYmplY3QuYFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2YgY29udmVydGVycykge1xuICAgICAgY29uc3QgeyBrZXksIGRlZmF1bHRWYWx1ZSwgcmVxdWlyZWQsIGNvbnZlcnRlciB9ID0gb3B0aW9uc1xuXG4gICAgICBpZiAocmVxdWlyZWQgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKGRpY3Rpb25hcnksIGtleSkpIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBNaXNzaW5nIHJlcXVpcmVkIGtleSBcIiR7a2V5fVwiLmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCB2YWx1ZSA9IGRpY3Rpb25hcnlba2V5XVxuICAgICAgY29uc3QgaGFzRGVmYXVsdCA9IE9iamVjdC5oYXNPd24ob3B0aW9ucywgJ2RlZmF1bHRWYWx1ZScpXG5cbiAgICAgIC8vIE9ubHkgdXNlIGRlZmF1bHRWYWx1ZSBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgYW5kXG4gICAgICAvLyBhIGRlZmF1bHRWYWx1ZSBvcHRpb25zIHdhcyBwcm92aWRlZC5cbiAgICAgIGlmIChoYXNEZWZhdWx0ICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHZhbHVlID8/PSBkZWZhdWx0VmFsdWUoKVxuICAgICAgfVxuXG4gICAgICAvLyBBIGtleSBjYW4gYmUgb3B0aW9uYWwgYW5kIGhhdmUgbm8gZGVmYXVsdCB2YWx1ZS5cbiAgICAgIC8vIFdoZW4gdGhpcyBoYXBwZW5zLCBkbyBub3QgcGVyZm9ybSBhIGNvbnZlcnNpb24sXG4gICAgICAvLyBhbmQgZG8gbm90IGFzc2lnbiB0aGUga2V5IGEgdmFsdWUuXG4gICAgICBpZiAocmVxdWlyZWQgfHwgaGFzRGVmYXVsdCB8fCB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlID0gY29udmVydGVyKHZhbHVlLCBwcmVmaXgsIGAke2FyZ3VtZW50fS4ke2tleX1gKVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBvcHRpb25zLmFsbG93ZWRWYWx1ZXMgJiZcbiAgICAgICAgICAhb3B0aW9ucy5hbGxvd2VkVmFsdWVzLmluY2x1ZGVzKHZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICAgICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGAke3ZhbHVlfSBpcyBub3QgYW4gYWNjZXB0ZWQgdHlwZS4gRXhwZWN0ZWQgb25lIG9mICR7b3B0aW9ucy5hbGxvd2VkVmFsdWVzLmpvaW4oJywgJyl9LmBcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZGljdFtrZXldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGljdFxuICB9XG59XG5cbndlYmlkbC5udWxsYWJsZUNvbnZlcnRlciA9IGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcbiAgcmV0dXJuIChWLCBwcmVmaXgsIGFyZ3VtZW50KSA9PiB7XG4gICAgaWYgKFYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBWXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnZlcnRlcihWLCBwcmVmaXgsIGFyZ3VtZW50KVxuICB9XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtRE9NU3RyaW5nXG53ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCwgb3B0cykge1xuICAvLyAxLiBJZiBWIGlzIG51bGwgYW5kIHRoZSBjb252ZXJzaW9uIGlzIHRvIGFuIElETCB0eXBlXG4gIC8vICAgIGFzc29jaWF0ZWQgd2l0aCB0aGUgW0xlZ2FjeU51bGxUb0VtcHR5U3RyaW5nXVxuICAvLyAgICBleHRlbmRlZCBhdHRyaWJ1dGUsIHRoZW4gcmV0dXJuIHRoZSBET01TdHJpbmcgdmFsdWVcbiAgLy8gICAgdGhhdCByZXByZXNlbnRzIHRoZSBlbXB0eSBzdHJpbmcuXG4gIGlmIChWID09PSBudWxsICYmIG9wdHM/LmxlZ2FjeU51bGxUb0VtcHR5U3RyaW5nKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyAyLiBMZXQgeCBiZSA/IFRvU3RyaW5nKFYpLlxuICBpZiAodHlwZW9mIFYgPT09ICdzeW1ib2wnKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiBwcmVmaXgsXG4gICAgICBtZXNzYWdlOiBgJHthcmd1bWVudH0gaXMgYSBzeW1ib2wsIHdoaWNoIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG8gYSBET01TdHJpbmcuYFxuICAgIH0pXG4gIH1cblxuICAvLyAzLiBSZXR1cm4gdGhlIElETCBET01TdHJpbmcgdmFsdWUgdGhhdCByZXByZXNlbnRzIHRoZVxuICAvLyAgICBzYW1lIHNlcXVlbmNlIG9mIGNvZGUgdW5pdHMgYXMgdGhlIG9uZSB0aGVcbiAgLy8gICAgRUNNQVNjcmlwdCBTdHJpbmcgdmFsdWUgeCByZXByZXNlbnRzLlxuICByZXR1cm4gU3RyaW5nKFYpXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtQnl0ZVN0cmluZ1xud2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIGFyZ3VtZW50KSB7XG4gIC8vIDEuIExldCB4IGJlID8gVG9TdHJpbmcoVikuXG4gIC8vIE5vdGU6IERPTVN0cmluZyBjb252ZXJ0ZXIgcGVyZm9ybSA/IFRvU3RyaW5nKFYpXG4gIGNvbnN0IHggPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoViwgcHJlZml4LCBhcmd1bWVudClcblxuICAvLyAyLiBJZiB0aGUgdmFsdWUgb2YgYW55IGVsZW1lbnQgb2YgeCBpcyBncmVhdGVyIHRoYW5cbiAgLy8gICAgMjU1LCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgeC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAoeC5jaGFyQ29kZUF0KGluZGV4KSA+IDI1NSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IHRvIGEgQnl0ZVN0cmluZyBiZWNhdXNlIHRoZSBjaGFyYWN0ZXIgYXQgJyArXG4gICAgICAgIGBpbmRleCAke2luZGV4fSBoYXMgYSB2YWx1ZSBvZiAke3guY2hhckNvZGVBdChpbmRleCl9IHdoaWNoIGlzIGdyZWF0ZXIgdGhhbiAyNTUuYFxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIDMuIFJldHVybiBhbiBJREwgQnl0ZVN0cmluZyB2YWx1ZSB3aG9zZSBsZW5ndGggaXMgdGhlXG4gIC8vICAgIGxlbmd0aCBvZiB4LCBhbmQgd2hlcmUgdGhlIHZhbHVlIG9mIGVhY2ggZWxlbWVudCBpc1xuICAvLyAgICB0aGUgdmFsdWUgb2YgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBvZiB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLVVTVlN0cmluZ1xuLy8gVE9ETzogcmV3cml0ZSB0aGlzIHNvIHdlIGNhbiBjb250cm9sIHRoZSBlcnJvcnMgdGhyb3duXG53ZWJpZGwuY29udmVydGVycy5VU1ZTdHJpbmcgPSB0b1VTVlN0cmluZ1xuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLWJvb2xlYW5cbndlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4gPSBmdW5jdGlvbiAoVikge1xuICAvLyAxLiBMZXQgeCBiZSB0aGUgcmVzdWx0IG9mIGNvbXB1dGluZyBUb0Jvb2xlYW4oVikuXG4gIGNvbnN0IHggPSBCb29sZWFuKFYpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgYm9vbGVhbiB2YWx1ZSB0aGF0IGlzIHRoZSBvbmUgdGhhdCByZXByZXNlbnRzXG4gIC8vICAgIHRoZSBzYW1lIHRydXRoIHZhbHVlIGFzIHRoZSBFQ01BU2NyaXB0IEJvb2xlYW4gdmFsdWUgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy1hbnlcbndlYmlkbC5jb252ZXJ0ZXJzLmFueSA9IGZ1bmN0aW9uIChWKSB7XG4gIHJldHVybiBWXG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtbG9uZy1sb25nXG53ZWJpZGwuY29udmVydGVyc1snbG9uZyBsb25nJ10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCA2NCwgXCJzaWduZWRcIikuXG4gIGNvbnN0IHggPSB3ZWJpZGwudXRpbC5Db252ZXJ0VG9JbnQoViwgNjQsICdzaWduZWQnLCB1bmRlZmluZWQsIHByZWZpeCwgYXJndW1lbnQpXG5cbiAgLy8gMi4gUmV0dXJuIHRoZSBJREwgbG9uZyBsb25nIHZhbHVlIHRoYXQgcmVwcmVzZW50c1xuICAvLyAgICB0aGUgc2FtZSBudW1lcmljIHZhbHVlIGFzIHguXG4gIHJldHVybiB4XG59XG5cbi8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jZXMtdW5zaWduZWQtbG9uZy1sb25nXG53ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCA2NCwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCA2NCwgJ3Vuc2lnbmVkJywgdW5kZWZpbmVkLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIHVuc2lnbmVkIGxvbmcgbG9uZyB2YWx1ZSB0aGF0XG4gIC8vICAgIHJlcHJlc2VudHMgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2VzLXVuc2lnbmVkLWxvbmdcbndlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCkge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCAzMiwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCAzMiwgJ3Vuc2lnbmVkJywgdW5kZWZpbmVkLCBwcmVmaXgsIGFyZ3VtZW50KVxuXG4gIC8vIDIuIFJldHVybiB0aGUgSURMIHVuc2lnbmVkIGxvbmcgdmFsdWUgdGhhdFxuICAvLyAgICByZXByZXNlbnRzIHRoZSBzYW1lIG51bWVyaWMgdmFsdWUgYXMgeC5cbiAgcmV0dXJuIHhcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNlcy11bnNpZ25lZC1zaG9ydFxud2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10gPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCwgb3B0cykge1xuICAvLyAxLiBMZXQgeCBiZSA/IENvbnZlcnRUb0ludChWLCAxNiwgXCJ1bnNpZ25lZFwiKS5cbiAgY29uc3QgeCA9IHdlYmlkbC51dGlsLkNvbnZlcnRUb0ludChWLCAxNiwgJ3Vuc2lnbmVkJywgb3B0cywgcHJlZml4LCBhcmd1bWVudClcblxuICAvLyAyLiBSZXR1cm4gdGhlIElETCB1bnNpZ25lZCBzaG9ydCB2YWx1ZSB0aGF0IHJlcHJlc2VudHNcbiAgLy8gICAgdGhlIHNhbWUgbnVtZXJpYyB2YWx1ZSBhcyB4LlxuICByZXR1cm4geFxufVxuXG4vLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2lkbC1BcnJheUJ1ZmZlclxud2ViaWRsLmNvbnZlcnRlcnMuQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoViwgcHJlZml4LCBhcmd1bWVudCwgb3B0cykge1xuICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhblxuICAvLyAgICBbW0FycmF5QnVmZmVyRGF0YV1dIGludGVybmFsIHNsb3QsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIC8vIHNlZTogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1hcnJheWJ1ZmZlci1pbnN0YW5jZXNcbiAgLy8gc2VlOiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLXNoYXJlZGFycmF5YnVmZmVyLWluc3RhbmNlc1xuICBpZiAoXG4gICAgd2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gJ09iamVjdCcgfHxcbiAgICAhdHlwZXMuaXNBbnlBcnJheUJ1ZmZlcihWKVxuICApIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4LFxuICAgICAgYXJndW1lbnQ6IGAke2FyZ3VtZW50fSAoXCIke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX1cIilgLFxuICAgICAgdHlwZXM6IFsnQXJyYXlCdWZmZXInXVxuICAgIH0pXG4gIH1cblxuICAvLyAyLiBJZiB0aGUgY29udmVyc2lvbiBpcyBub3QgdG8gYW4gSURMIHR5cGUgYXNzb2NpYXRlZFxuICAvLyAgICB3aXRoIHRoZSBbQWxsb3dTaGFyZWRdIGV4dGVuZGVkIGF0dHJpYnV0ZSwgYW5kXG4gIC8vICAgIElzU2hhcmVkQXJyYXlCdWZmZXIoVikgaXMgdHJ1ZSwgdGhlbiB0aHJvdyBhXG4gIC8vICAgIFR5cGVFcnJvci5cbiAgaWYgKG9wdHM/LmFsbG93U2hhcmVkID09PSBmYWxzZSAmJiB0eXBlcy5pc1NoYXJlZEFycmF5QnVmZmVyKFYpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1NoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhbGxvd2VkLidcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93UmVzaXphYmxlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1Jlc2l6YWJsZUFycmF5QnVmZmVyKFYpIGlzIHRydWUsIHRoZW4gdGhyb3cgYVxuICAvLyAgICBUeXBlRXJyb3IuXG4gIGlmIChWLnJlc2l6YWJsZSB8fCBWLmdyb3dhYmxlKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1JlY2VpdmVkIGEgcmVzaXphYmxlIEFycmF5QnVmZmVyLidcbiAgICB9KVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIHRoZSBJREwgQXJyYXlCdWZmZXIgdmFsdWUgdGhhdCBpcyBhXG4gIC8vICAgIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBvYmplY3QgYXMgVi5cbiAgcmV0dXJuIFZcbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChWLCBULCBwcmVmaXgsIG5hbWUsIG9wdHMpIHtcbiAgLy8gMS4gTGV0IFQgYmUgdGhlIElETCB0eXBlIFYgaXMgYmVpbmcgY29udmVydGVkIHRvLlxuXG4gIC8vIDIuIElmIFR5cGUoVikgaXMgbm90IE9iamVjdCwgb3IgViBkb2VzIG5vdCBoYXZlIGFcbiAgLy8gICAgW1tUeXBlZEFycmF5TmFtZV1dIGludGVybmFsIHNsb3Qgd2l0aCBhIHZhbHVlXG4gIC8vICAgIGVxdWFsIHRvIFTigJlzIG5hbWUsIHRoZW4gdGhyb3cgYSBUeXBlRXJyb3IuXG4gIGlmIChcbiAgICB3ZWJpZGwudXRpbC5UeXBlKFYpICE9PSAnT2JqZWN0JyB8fFxuICAgICF0eXBlcy5pc1R5cGVkQXJyYXkoVikgfHxcbiAgICBWLmNvbnN0cnVjdG9yLm5hbWUgIT09IFQubmFtZVxuICApIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmNvbnZlcnNpb25GYWlsZWQoe1xuICAgICAgcHJlZml4LFxuICAgICAgYXJndW1lbnQ6IGAke25hbWV9IChcIiR7d2ViaWRsLnV0aWwuU3RyaW5naWZ5KFYpfVwiKWAsXG4gICAgICB0eXBlczogW1QubmFtZV1cbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93U2hhcmVkXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1NoYXJlZEFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpc1xuICAvLyAgICB0cnVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAob3B0cz8uYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVi5idWZmZXIpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1NoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhbGxvd2VkLidcbiAgICB9KVxuICB9XG5cbiAgLy8gNC4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93UmVzaXphYmxlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1Jlc2l6YWJsZUFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpc1xuICAvLyAgICB0cnVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoVi5idWZmZXIucmVzaXphYmxlIHx8IFYuYnVmZmVyLmdyb3dhYmxlKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1JlY2VpdmVkIGEgcmVzaXphYmxlIEFycmF5QnVmZmVyLidcbiAgICB9KVxuICB9XG5cbiAgLy8gNS4gUmV0dXJuIHRoZSBJREwgdmFsdWUgb2YgdHlwZSBUIHRoYXQgaXMgYSByZWZlcmVuY2VcbiAgLy8gICAgdG8gdGhlIHNhbWUgb2JqZWN0IGFzIFYuXG4gIHJldHVybiBWXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLkRhdGFWaWV3ID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgbmFtZSwgb3B0cykge1xuICAvLyAxLiBJZiBUeXBlKFYpIGlzIG5vdCBPYmplY3QsIG9yIFYgZG9lcyBub3QgaGF2ZSBhXG4gIC8vICAgIFtbRGF0YVZpZXddXSBpbnRlcm5hbCBzbG90LCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSAhPT0gJ09iamVjdCcgfHwgIXR5cGVzLmlzRGF0YVZpZXcoVikpIHtcbiAgICB0aHJvdyB3ZWJpZGwuZXJyb3JzLmV4Y2VwdGlvbih7XG4gICAgICBoZWFkZXI6IHByZWZpeCxcbiAgICAgIG1lc3NhZ2U6IGAke25hbWV9IGlzIG5vdCBhIERhdGFWaWV3LmBcbiAgICB9KVxuICB9XG5cbiAgLy8gMi4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93U2hhcmVkXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1NoYXJlZEFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpcyB0cnVlLFxuICAvLyAgICB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAob3B0cz8uYWxsb3dTaGFyZWQgPT09IGZhbHNlICYmIHR5cGVzLmlzU2hhcmVkQXJyYXlCdWZmZXIoVi5idWZmZXIpKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1NoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhbGxvd2VkLidcbiAgICB9KVxuICB9XG5cbiAgLy8gMy4gSWYgdGhlIGNvbnZlcnNpb24gaXMgbm90IHRvIGFuIElETCB0eXBlIGFzc29jaWF0ZWRcbiAgLy8gICAgd2l0aCB0aGUgW0FsbG93UmVzaXphYmxlXSBleHRlbmRlZCBhdHRyaWJ1dGUsIGFuZFxuICAvLyAgICBJc1Jlc2l6YWJsZUFycmF5QnVmZmVyKFYuW1tWaWV3ZWRBcnJheUJ1ZmZlcl1dKSBpc1xuICAvLyAgICB0cnVlLCB0aGVuIHRocm93IGEgVHlwZUVycm9yLlxuICBpZiAoVi5idWZmZXIucmVzaXphYmxlIHx8IFYuYnVmZmVyLmdyb3dhYmxlKSB7XG4gICAgdGhyb3cgd2ViaWRsLmVycm9ycy5leGNlcHRpb24oe1xuICAgICAgaGVhZGVyOiAnQXJyYXlCdWZmZXInLFxuICAgICAgbWVzc2FnZTogJ1JlY2VpdmVkIGEgcmVzaXphYmxlIEFycmF5QnVmZmVyLidcbiAgICB9KVxuICB9XG5cbiAgLy8gNC4gUmV0dXJuIHRoZSBJREwgRGF0YVZpZXcgdmFsdWUgdGhhdCBpcyBhIHJlZmVyZW5jZVxuICAvLyAgICB0byB0aGUgc2FtZSBvYmplY3QgYXMgVi5cbiAgcmV0dXJuIFZcbn1cblxuLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNCdWZmZXJTb3VyY2VcbndlYmlkbC5jb252ZXJ0ZXJzLkJ1ZmZlclNvdXJjZSA9IGZ1bmN0aW9uIChWLCBwcmVmaXgsIG5hbWUsIG9wdHMpIHtcbiAgaWYgKHR5cGVzLmlzQW55QXJyYXlCdWZmZXIoVikpIHtcbiAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQXJyYXlCdWZmZXIoViwgcHJlZml4LCBuYW1lLCB7IC4uLm9wdHMsIGFsbG93U2hhcmVkOiBmYWxzZSB9KVxuICB9XG5cbiAgaWYgKHR5cGVzLmlzVHlwZWRBcnJheShWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5UeXBlZEFycmF5KFYsIFYuY29uc3RydWN0b3IsIHByZWZpeCwgbmFtZSwgeyAuLi5vcHRzLCBhbGxvd1NoYXJlZDogZmFsc2UgfSlcbiAgfVxuXG4gIGlmICh0eXBlcy5pc0RhdGFWaWV3KFYpKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkRhdGFWaWV3KFYsIHByZWZpeCwgbmFtZSwgeyAuLi5vcHRzLCBhbGxvd1NoYXJlZDogZmFsc2UgfSlcbiAgfVxuXG4gIHRocm93IHdlYmlkbC5lcnJvcnMuY29udmVyc2lvbkZhaWxlZCh7XG4gICAgcHJlZml4LFxuICAgIGFyZ3VtZW50OiBgJHtuYW1lfSAoXCIke3dlYmlkbC51dGlsLlN0cmluZ2lmeShWKX1cIilgLFxuICAgIHR5cGVzOiBbJ0J1ZmZlclNvdXJjZSddXG4gIH0pXG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxCeXRlU3RyaW5nPiddID0gd2ViaWRsLnNlcXVlbmNlQ29udmVydGVyKFxuICB3ZWJpZGwuY29udmVydGVycy5CeXRlU3RyaW5nXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxzZXF1ZW5jZTxCeXRlU3RyaW5nPj4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPEJ5dGVTdHJpbmc+J11cbilcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3JlY29yZDxCeXRlU3RyaW5nLCBCeXRlU3RyaW5nPiddID0gd2ViaWRsLnJlY29yZENvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZyxcbiAgd2ViaWRsLmNvbnZlcnRlcnMuQnl0ZVN0cmluZ1xuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd2ViaWRsXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fileapi/encoding.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/encoding.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/**\n * @see https://encoding.spec.whatwg.org/#concept-encoding-get\n * @param {string|undefined} label\n */\nfunction getEncoding (label) {\n  if (!label) {\n    return 'failure'\n  }\n\n  // 1. Remove any leading and trailing ASCII whitespace from label.\n  // 2. If label is an ASCII case-insensitive match for any of the\n  //    labels listed in the table below, then return the\n  //    corresponding encoding; otherwise return failure.\n  switch (label.trim().toLowerCase()) {\n    case 'unicode-1-1-utf-8':\n    case 'unicode11utf8':\n    case 'unicode20utf8':\n    case 'utf-8':\n    case 'utf8':\n    case 'x-unicode20utf8':\n      return 'UTF-8'\n    case '866':\n    case 'cp866':\n    case 'csibm866':\n    case 'ibm866':\n      return 'IBM866'\n    case 'csisolatin2':\n    case 'iso-8859-2':\n    case 'iso-ir-101':\n    case 'iso8859-2':\n    case 'iso88592':\n    case 'iso_8859-2':\n    case 'iso_8859-2:1987':\n    case 'l2':\n    case 'latin2':\n      return 'ISO-8859-2'\n    case 'csisolatin3':\n    case 'iso-8859-3':\n    case 'iso-ir-109':\n    case 'iso8859-3':\n    case 'iso88593':\n    case 'iso_8859-3':\n    case 'iso_8859-3:1988':\n    case 'l3':\n    case 'latin3':\n      return 'ISO-8859-3'\n    case 'csisolatin4':\n    case 'iso-8859-4':\n    case 'iso-ir-110':\n    case 'iso8859-4':\n    case 'iso88594':\n    case 'iso_8859-4':\n    case 'iso_8859-4:1988':\n    case 'l4':\n    case 'latin4':\n      return 'ISO-8859-4'\n    case 'csisolatincyrillic':\n    case 'cyrillic':\n    case 'iso-8859-5':\n    case 'iso-ir-144':\n    case 'iso8859-5':\n    case 'iso88595':\n    case 'iso_8859-5':\n    case 'iso_8859-5:1988':\n      return 'ISO-8859-5'\n    case 'arabic':\n    case 'asmo-708':\n    case 'csiso88596e':\n    case 'csiso88596i':\n    case 'csisolatinarabic':\n    case 'ecma-114':\n    case 'iso-8859-6':\n    case 'iso-8859-6-e':\n    case 'iso-8859-6-i':\n    case 'iso-ir-127':\n    case 'iso8859-6':\n    case 'iso88596':\n    case 'iso_8859-6':\n    case 'iso_8859-6:1987':\n      return 'ISO-8859-6'\n    case 'csisolatingreek':\n    case 'ecma-118':\n    case 'elot_928':\n    case 'greek':\n    case 'greek8':\n    case 'iso-8859-7':\n    case 'iso-ir-126':\n    case 'iso8859-7':\n    case 'iso88597':\n    case 'iso_8859-7':\n    case 'iso_8859-7:1987':\n    case 'sun_eu_greek':\n      return 'ISO-8859-7'\n    case 'csiso88598e':\n    case 'csisolatinhebrew':\n    case 'hebrew':\n    case 'iso-8859-8':\n    case 'iso-8859-8-e':\n    case 'iso-ir-138':\n    case 'iso8859-8':\n    case 'iso88598':\n    case 'iso_8859-8':\n    case 'iso_8859-8:1988':\n    case 'visual':\n      return 'ISO-8859-8'\n    case 'csiso88598i':\n    case 'iso-8859-8-i':\n    case 'logical':\n      return 'ISO-8859-8-I'\n    case 'csisolatin6':\n    case 'iso-8859-10':\n    case 'iso-ir-157':\n    case 'iso8859-10':\n    case 'iso885910':\n    case 'l6':\n    case 'latin6':\n      return 'ISO-8859-10'\n    case 'iso-8859-13':\n    case 'iso8859-13':\n    case 'iso885913':\n      return 'ISO-8859-13'\n    case 'iso-8859-14':\n    case 'iso8859-14':\n    case 'iso885914':\n      return 'ISO-8859-14'\n    case 'csisolatin9':\n    case 'iso-8859-15':\n    case 'iso8859-15':\n    case 'iso885915':\n    case 'iso_8859-15':\n    case 'l9':\n      return 'ISO-8859-15'\n    case 'iso-8859-16':\n      return 'ISO-8859-16'\n    case 'cskoi8r':\n    case 'koi':\n    case 'koi8':\n    case 'koi8-r':\n    case 'koi8_r':\n      return 'KOI8-R'\n    case 'koi8-ru':\n    case 'koi8-u':\n      return 'KOI8-U'\n    case 'csmacintosh':\n    case 'mac':\n    case 'macintosh':\n    case 'x-mac-roman':\n      return 'macintosh'\n    case 'iso-8859-11':\n    case 'iso8859-11':\n    case 'iso885911':\n    case 'tis-620':\n    case 'windows-874':\n      return 'windows-874'\n    case 'cp1250':\n    case 'windows-1250':\n    case 'x-cp1250':\n      return 'windows-1250'\n    case 'cp1251':\n    case 'windows-1251':\n    case 'x-cp1251':\n      return 'windows-1251'\n    case 'ansi_x3.4-1968':\n    case 'ascii':\n    case 'cp1252':\n    case 'cp819':\n    case 'csisolatin1':\n    case 'ibm819':\n    case 'iso-8859-1':\n    case 'iso-ir-100':\n    case 'iso8859-1':\n    case 'iso88591':\n    case 'iso_8859-1':\n    case 'iso_8859-1:1987':\n    case 'l1':\n    case 'latin1':\n    case 'us-ascii':\n    case 'windows-1252':\n    case 'x-cp1252':\n      return 'windows-1252'\n    case 'cp1253':\n    case 'windows-1253':\n    case 'x-cp1253':\n      return 'windows-1253'\n    case 'cp1254':\n    case 'csisolatin5':\n    case 'iso-8859-9':\n    case 'iso-ir-148':\n    case 'iso8859-9':\n    case 'iso88599':\n    case 'iso_8859-9':\n    case 'iso_8859-9:1989':\n    case 'l5':\n    case 'latin5':\n    case 'windows-1254':\n    case 'x-cp1254':\n      return 'windows-1254'\n    case 'cp1255':\n    case 'windows-1255':\n    case 'x-cp1255':\n      return 'windows-1255'\n    case 'cp1256':\n    case 'windows-1256':\n    case 'x-cp1256':\n      return 'windows-1256'\n    case 'cp1257':\n    case 'windows-1257':\n    case 'x-cp1257':\n      return 'windows-1257'\n    case 'cp1258':\n    case 'windows-1258':\n    case 'x-cp1258':\n      return 'windows-1258'\n    case 'x-mac-cyrillic':\n    case 'x-mac-ukrainian':\n      return 'x-mac-cyrillic'\n    case 'chinese':\n    case 'csgb2312':\n    case 'csiso58gb231280':\n    case 'gb2312':\n    case 'gb_2312':\n    case 'gb_2312-80':\n    case 'gbk':\n    case 'iso-ir-58':\n    case 'x-gbk':\n      return 'GBK'\n    case 'gb18030':\n      return 'gb18030'\n    case 'big5':\n    case 'big5-hkscs':\n    case 'cn-big5':\n    case 'csbig5':\n    case 'x-x-big5':\n      return 'Big5'\n    case 'cseucpkdfmtjapanese':\n    case 'euc-jp':\n    case 'x-euc-jp':\n      return 'EUC-JP'\n    case 'csiso2022jp':\n    case 'iso-2022-jp':\n      return 'ISO-2022-JP'\n    case 'csshiftjis':\n    case 'ms932':\n    case 'ms_kanji':\n    case 'shift-jis':\n    case 'shift_jis':\n    case 'sjis':\n    case 'windows-31j':\n    case 'x-sjis':\n      return 'Shift_JIS'\n    case 'cseuckr':\n    case 'csksc56011987':\n    case 'euc-kr':\n    case 'iso-ir-149':\n    case 'korean':\n    case 'ks_c_5601-1987':\n    case 'ks_c_5601-1989':\n    case 'ksc5601':\n    case 'ksc_5601':\n    case 'windows-949':\n      return 'EUC-KR'\n    case 'csiso2022kr':\n    case 'hz-gb-2312':\n    case 'iso-2022-cn':\n    case 'iso-2022-cn-ext':\n    case 'iso-2022-kr':\n    case 'replacement':\n      return 'replacement'\n    case 'unicodefffe':\n    case 'utf-16be':\n      return 'UTF-16BE'\n    case 'csunicode':\n    case 'iso-10646-ucs-2':\n    case 'ucs-2':\n    case 'unicode':\n    case 'unicodefeff':\n    case 'utf-16':\n    case 'utf-16le':\n      return 'UTF-16LE'\n    case 'x-user-defined':\n      return 'x-user-defined'\n    default: return 'failure'\n  }\n}\n\nmodule.exports = {\n  getEncoding\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9lbmNvZGluZy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmlsZWFwaVxcZW5jb2RpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogQHNlZSBodHRwczovL2VuY29kaW5nLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1lbmNvZGluZy1nZXRcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gbGFiZWxcbiAqL1xuZnVuY3Rpb24gZ2V0RW5jb2RpbmcgKGxhYmVsKSB7XG4gIGlmICghbGFiZWwpIHtcbiAgICByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cblxuICAvLyAxLiBSZW1vdmUgYW55IGxlYWRpbmcgYW5kIHRyYWlsaW5nIEFTQ0lJIHdoaXRlc3BhY2UgZnJvbSBsYWJlbC5cbiAgLy8gMi4gSWYgbGFiZWwgaXMgYW4gQVNDSUkgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaCBmb3IgYW55IG9mIHRoZVxuICAvLyAgICBsYWJlbHMgbGlzdGVkIGluIHRoZSB0YWJsZSBiZWxvdywgdGhlbiByZXR1cm4gdGhlXG4gIC8vICAgIGNvcnJlc3BvbmRpbmcgZW5jb2Rpbmc7IG90aGVyd2lzZSByZXR1cm4gZmFpbHVyZS5cbiAgc3dpdGNoIChsYWJlbC50cmltKCkudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ3VuaWNvZGUtMS0xLXV0Zi04JzpcbiAgICBjYXNlICd1bmljb2RlMTF1dGY4JzpcbiAgICBjYXNlICd1bmljb2RlMjB1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAneC11bmljb2RlMjB1dGY4JzpcbiAgICAgIHJldHVybiAnVVRGLTgnXG4gICAgY2FzZSAnODY2JzpcbiAgICBjYXNlICdjcDg2Nic6XG4gICAgY2FzZSAnY3NpYm04NjYnOlxuICAgIGNhc2UgJ2libTg2Nic6XG4gICAgICByZXR1cm4gJ0lCTTg2NidcbiAgICBjYXNlICdjc2lzb2xhdGluMic6XG4gICAgY2FzZSAnaXNvLTg4NTktMic6XG4gICAgY2FzZSAnaXNvLWlyLTEwMSc6XG4gICAgY2FzZSAnaXNvODg1OS0yJzpcbiAgICBjYXNlICdpc284ODU5Mic6XG4gICAgY2FzZSAnaXNvXzg4NTktMic6XG4gICAgY2FzZSAnaXNvXzg4NTktMjoxOTg3JzpcbiAgICBjYXNlICdsMic6XG4gICAgY2FzZSAnbGF0aW4yJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMidcbiAgICBjYXNlICdjc2lzb2xhdGluMyc6XG4gICAgY2FzZSAnaXNvLTg4NTktMyc6XG4gICAgY2FzZSAnaXNvLWlyLTEwOSc6XG4gICAgY2FzZSAnaXNvODg1OS0zJzpcbiAgICBjYXNlICdpc284ODU5Myc6XG4gICAgY2FzZSAnaXNvXzg4NTktMyc6XG4gICAgY2FzZSAnaXNvXzg4NTktMzoxOTg4JzpcbiAgICBjYXNlICdsMyc6XG4gICAgY2FzZSAnbGF0aW4zJzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMydcbiAgICBjYXNlICdjc2lzb2xhdGluNCc6XG4gICAgY2FzZSAnaXNvLTg4NTktNCc6XG4gICAgY2FzZSAnaXNvLWlyLTExMCc6XG4gICAgY2FzZSAnaXNvODg1OS00JzpcbiAgICBjYXNlICdpc284ODU5NCc6XG4gICAgY2FzZSAnaXNvXzg4NTktNCc6XG4gICAgY2FzZSAnaXNvXzg4NTktNDoxOTg4JzpcbiAgICBjYXNlICdsNCc6XG4gICAgY2FzZSAnbGF0aW40JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktNCdcbiAgICBjYXNlICdjc2lzb2xhdGluY3lyaWxsaWMnOlxuICAgIGNhc2UgJ2N5cmlsbGljJzpcbiAgICBjYXNlICdpc28tODg1OS01JzpcbiAgICBjYXNlICdpc28taXItMTQ0JzpcbiAgICBjYXNlICdpc284ODU5LTUnOlxuICAgIGNhc2UgJ2lzbzg4NTk1JzpcbiAgICBjYXNlICdpc29fODg1OS01JzpcbiAgICBjYXNlICdpc29fODg1OS01OjE5ODgnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS01J1xuICAgIGNhc2UgJ2FyYWJpYyc6XG4gICAgY2FzZSAnYXNtby03MDgnOlxuICAgIGNhc2UgJ2NzaXNvODg1OTZlJzpcbiAgICBjYXNlICdjc2lzbzg4NTk2aSc6XG4gICAgY2FzZSAnY3Npc29sYXRpbmFyYWJpYyc6XG4gICAgY2FzZSAnZWNtYS0xMTQnOlxuICAgIGNhc2UgJ2lzby04ODU5LTYnOlxuICAgIGNhc2UgJ2lzby04ODU5LTYtZSc6XG4gICAgY2FzZSAnaXNvLTg4NTktNi1pJzpcbiAgICBjYXNlICdpc28taXItMTI3JzpcbiAgICBjYXNlICdpc284ODU5LTYnOlxuICAgIGNhc2UgJ2lzbzg4NTk2JzpcbiAgICBjYXNlICdpc29fODg1OS02JzpcbiAgICBjYXNlICdpc29fODg1OS02OjE5ODcnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS02J1xuICAgIGNhc2UgJ2NzaXNvbGF0aW5ncmVlayc6XG4gICAgY2FzZSAnZWNtYS0xMTgnOlxuICAgIGNhc2UgJ2Vsb3RfOTI4JzpcbiAgICBjYXNlICdncmVlayc6XG4gICAgY2FzZSAnZ3JlZWs4JzpcbiAgICBjYXNlICdpc28tODg1OS03JzpcbiAgICBjYXNlICdpc28taXItMTI2JzpcbiAgICBjYXNlICdpc284ODU5LTcnOlxuICAgIGNhc2UgJ2lzbzg4NTk3JzpcbiAgICBjYXNlICdpc29fODg1OS03JzpcbiAgICBjYXNlICdpc29fODg1OS03OjE5ODcnOlxuICAgIGNhc2UgJ3N1bl9ldV9ncmVlayc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTcnXG4gICAgY2FzZSAnY3Npc284ODU5OGUnOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW5oZWJyZXcnOlxuICAgIGNhc2UgJ2hlYnJldyc6XG4gICAgY2FzZSAnaXNvLTg4NTktOCc6XG4gICAgY2FzZSAnaXNvLTg4NTktOC1lJzpcbiAgICBjYXNlICdpc28taXItMTM4JzpcbiAgICBjYXNlICdpc284ODU5LTgnOlxuICAgIGNhc2UgJ2lzbzg4NTk4JzpcbiAgICBjYXNlICdpc29fODg1OS04JzpcbiAgICBjYXNlICdpc29fODg1OS04OjE5ODgnOlxuICAgIGNhc2UgJ3Zpc3VhbCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTgnXG4gICAgY2FzZSAnY3Npc284ODU5OGknOlxuICAgIGNhc2UgJ2lzby04ODU5LTgtaSc6XG4gICAgY2FzZSAnbG9naWNhbCc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTgtSSdcbiAgICBjYXNlICdjc2lzb2xhdGluNic6XG4gICAgY2FzZSAnaXNvLTg4NTktMTAnOlxuICAgIGNhc2UgJ2lzby1pci0xNTcnOlxuICAgIGNhc2UgJ2lzbzg4NTktMTAnOlxuICAgIGNhc2UgJ2lzbzg4NTkxMCc6XG4gICAgY2FzZSAnbDYnOlxuICAgIGNhc2UgJ2xhdGluNic6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTEwJ1xuICAgIGNhc2UgJ2lzby04ODU5LTEzJzpcbiAgICBjYXNlICdpc284ODU5LTEzJzpcbiAgICBjYXNlICdpc284ODU5MTMnOlxuICAgICAgcmV0dXJuICdJU08tODg1OS0xMydcbiAgICBjYXNlICdpc28tODg1OS0xNCc6XG4gICAgY2FzZSAnaXNvODg1OS0xNCc6XG4gICAgY2FzZSAnaXNvODg1OTE0JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTQnXG4gICAgY2FzZSAnY3Npc29sYXRpbjknOlxuICAgIGNhc2UgJ2lzby04ODU5LTE1JzpcbiAgICBjYXNlICdpc284ODU5LTE1JzpcbiAgICBjYXNlICdpc284ODU5MTUnOlxuICAgIGNhc2UgJ2lzb184ODU5LTE1JzpcbiAgICBjYXNlICdsOSc6XG4gICAgICByZXR1cm4gJ0lTTy04ODU5LTE1J1xuICAgIGNhc2UgJ2lzby04ODU5LTE2JzpcbiAgICAgIHJldHVybiAnSVNPLTg4NTktMTYnXG4gICAgY2FzZSAnY3Nrb2k4cic6XG4gICAgY2FzZSAna29pJzpcbiAgICBjYXNlICdrb2k4JzpcbiAgICBjYXNlICdrb2k4LXInOlxuICAgIGNhc2UgJ2tvaThfcic6XG4gICAgICByZXR1cm4gJ0tPSTgtUidcbiAgICBjYXNlICdrb2k4LXJ1JzpcbiAgICBjYXNlICdrb2k4LXUnOlxuICAgICAgcmV0dXJuICdLT0k4LVUnXG4gICAgY2FzZSAnY3NtYWNpbnRvc2gnOlxuICAgIGNhc2UgJ21hYyc6XG4gICAgY2FzZSAnbWFjaW50b3NoJzpcbiAgICBjYXNlICd4LW1hYy1yb21hbic6XG4gICAgICByZXR1cm4gJ21hY2ludG9zaCdcbiAgICBjYXNlICdpc28tODg1OS0xMSc6XG4gICAgY2FzZSAnaXNvODg1OS0xMSc6XG4gICAgY2FzZSAnaXNvODg1OTExJzpcbiAgICBjYXNlICd0aXMtNjIwJzpcbiAgICBjYXNlICd3aW5kb3dzLTg3NCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtODc0J1xuICAgIGNhc2UgJ2NwMTI1MCc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUwJzpcbiAgICBjYXNlICd4LWNwMTI1MCc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MCdcbiAgICBjYXNlICdjcDEyNTEnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1MSc6XG4gICAgY2FzZSAneC1jcDEyNTEnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTEnXG4gICAgY2FzZSAnYW5zaV94My40LTE5NjgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdjcDEyNTInOlxuICAgIGNhc2UgJ2NwODE5JzpcbiAgICBjYXNlICdjc2lzb2xhdGluMSc6XG4gICAgY2FzZSAnaWJtODE5JzpcbiAgICBjYXNlICdpc28tODg1OS0xJzpcbiAgICBjYXNlICdpc28taXItMTAwJzpcbiAgICBjYXNlICdpc284ODU5LTEnOlxuICAgIGNhc2UgJ2lzbzg4NTkxJzpcbiAgICBjYXNlICdpc29fODg1OS0xJzpcbiAgICBjYXNlICdpc29fODg1OS0xOjE5ODcnOlxuICAgIGNhc2UgJ2wxJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ3VzLWFzY2lpJzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTInOlxuICAgIGNhc2UgJ3gtY3AxMjUyJzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjUyJ1xuICAgIGNhc2UgJ2NwMTI1Myc6XG4gICAgY2FzZSAnd2luZG93cy0xMjUzJzpcbiAgICBjYXNlICd4LWNwMTI1Myc6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1MydcbiAgICBjYXNlICdjcDEyNTQnOlxuICAgIGNhc2UgJ2NzaXNvbGF0aW41JzpcbiAgICBjYXNlICdpc28tODg1OS05JzpcbiAgICBjYXNlICdpc28taXItMTQ4JzpcbiAgICBjYXNlICdpc284ODU5LTknOlxuICAgIGNhc2UgJ2lzbzg4NTk5JzpcbiAgICBjYXNlICdpc29fODg1OS05JzpcbiAgICBjYXNlICdpc29fODg1OS05OjE5ODknOlxuICAgIGNhc2UgJ2w1JzpcbiAgICBjYXNlICdsYXRpbjUnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1NCc6XG4gICAgY2FzZSAneC1jcDEyNTQnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTQnXG4gICAgY2FzZSAnY3AxMjU1JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTUnOlxuICAgIGNhc2UgJ3gtY3AxMjU1JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU1J1xuICAgIGNhc2UgJ2NwMTI1Nic6XG4gICAgY2FzZSAnd2luZG93cy0xMjU2JzpcbiAgICBjYXNlICd4LWNwMTI1Nic6XG4gICAgICByZXR1cm4gJ3dpbmRvd3MtMTI1NidcbiAgICBjYXNlICdjcDEyNTcnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMTI1Nyc6XG4gICAgY2FzZSAneC1jcDEyNTcnOlxuICAgICAgcmV0dXJuICd3aW5kb3dzLTEyNTcnXG4gICAgY2FzZSAnY3AxMjU4JzpcbiAgICBjYXNlICd3aW5kb3dzLTEyNTgnOlxuICAgIGNhc2UgJ3gtY3AxMjU4JzpcbiAgICAgIHJldHVybiAnd2luZG93cy0xMjU4J1xuICAgIGNhc2UgJ3gtbWFjLWN5cmlsbGljJzpcbiAgICBjYXNlICd4LW1hYy11a3JhaW5pYW4nOlxuICAgICAgcmV0dXJuICd4LW1hYy1jeXJpbGxpYydcbiAgICBjYXNlICdjaGluZXNlJzpcbiAgICBjYXNlICdjc2diMjMxMic6XG4gICAgY2FzZSAnY3Npc281OGdiMjMxMjgwJzpcbiAgICBjYXNlICdnYjIzMTInOlxuICAgIGNhc2UgJ2diXzIzMTInOlxuICAgIGNhc2UgJ2diXzIzMTItODAnOlxuICAgIGNhc2UgJ2diayc6XG4gICAgY2FzZSAnaXNvLWlyLTU4JzpcbiAgICBjYXNlICd4LWdiayc6XG4gICAgICByZXR1cm4gJ0dCSydcbiAgICBjYXNlICdnYjE4MDMwJzpcbiAgICAgIHJldHVybiAnZ2IxODAzMCdcbiAgICBjYXNlICdiaWc1JzpcbiAgICBjYXNlICdiaWc1LWhrc2NzJzpcbiAgICBjYXNlICdjbi1iaWc1JzpcbiAgICBjYXNlICdjc2JpZzUnOlxuICAgIGNhc2UgJ3gteC1iaWc1JzpcbiAgICAgIHJldHVybiAnQmlnNSdcbiAgICBjYXNlICdjc2V1Y3BrZGZtdGphcGFuZXNlJzpcbiAgICBjYXNlICdldWMtanAnOlxuICAgIGNhc2UgJ3gtZXVjLWpwJzpcbiAgICAgIHJldHVybiAnRVVDLUpQJ1xuICAgIGNhc2UgJ2NzaXNvMjAyMmpwJzpcbiAgICBjYXNlICdpc28tMjAyMi1qcCc6XG4gICAgICByZXR1cm4gJ0lTTy0yMDIyLUpQJ1xuICAgIGNhc2UgJ2Nzc2hpZnRqaXMnOlxuICAgIGNhc2UgJ21zOTMyJzpcbiAgICBjYXNlICdtc19rYW5qaSc6XG4gICAgY2FzZSAnc2hpZnQtamlzJzpcbiAgICBjYXNlICdzaGlmdF9qaXMnOlxuICAgIGNhc2UgJ3NqaXMnOlxuICAgIGNhc2UgJ3dpbmRvd3MtMzFqJzpcbiAgICBjYXNlICd4LXNqaXMnOlxuICAgICAgcmV0dXJuICdTaGlmdF9KSVMnXG4gICAgY2FzZSAnY3NldWNrcic6XG4gICAgY2FzZSAnY3Nrc2M1NjAxMTk4Nyc6XG4gICAgY2FzZSAnZXVjLWtyJzpcbiAgICBjYXNlICdpc28taXItMTQ5JzpcbiAgICBjYXNlICdrb3JlYW4nOlxuICAgIGNhc2UgJ2tzX2NfNTYwMS0xOTg3JzpcbiAgICBjYXNlICdrc19jXzU2MDEtMTk4OSc6XG4gICAgY2FzZSAna3NjNTYwMSc6XG4gICAgY2FzZSAna3NjXzU2MDEnOlxuICAgIGNhc2UgJ3dpbmRvd3MtOTQ5JzpcbiAgICAgIHJldHVybiAnRVVDLUtSJ1xuICAgIGNhc2UgJ2NzaXNvMjAyMmtyJzpcbiAgICBjYXNlICdoei1nYi0yMzEyJzpcbiAgICBjYXNlICdpc28tMjAyMi1jbic6XG4gICAgY2FzZSAnaXNvLTIwMjItY24tZXh0JzpcbiAgICBjYXNlICdpc28tMjAyMi1rcic6XG4gICAgY2FzZSAncmVwbGFjZW1lbnQnOlxuICAgICAgcmV0dXJuICdyZXBsYWNlbWVudCdcbiAgICBjYXNlICd1bmljb2RlZmZmZSc6XG4gICAgY2FzZSAndXRmLTE2YmUnOlxuICAgICAgcmV0dXJuICdVVEYtMTZCRSdcbiAgICBjYXNlICdjc3VuaWNvZGUnOlxuICAgIGNhc2UgJ2lzby0xMDY0Ni11Y3MtMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3VuaWNvZGUnOlxuICAgIGNhc2UgJ3VuaWNvZGVmZWZmJzpcbiAgICBjYXNlICd1dGYtMTYnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiAnVVRGLTE2TEUnXG4gICAgY2FzZSAneC11c2VyLWRlZmluZWQnOlxuICAgICAgcmV0dXJuICd4LXVzZXItZGVmaW5lZCdcbiAgICBkZWZhdWx0OiByZXR1cm4gJ2ZhaWx1cmUnXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldEVuY29kaW5nXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fileapi/encoding.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fileapi/filereader.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/filereader.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  staticPropertyDescriptors,\n  readOperation,\n  fireAProgressEvent\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/fileapi/util.js\")\nconst {\n  kState,\n  kError,\n  kResult,\n  kEvents,\n  kAborted\n} = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/fileapi/symbols.js\")\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\n\nclass FileReader extends EventTarget {\n  constructor () {\n    super()\n\n    this[kState] = 'empty'\n    this[kResult] = null\n    this[kError] = null\n    this[kEvents] = {\n      loadend: null,\n      error: null,\n      abort: null,\n      load: null,\n      progress: null,\n      loadstart: null\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer\n   * @param {import('buffer').Blob} blob\n   */\n  readAsArrayBuffer (blob) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsArrayBuffer')\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    // The readAsArrayBuffer(blob) method, when invoked,\n    // must initiate a read operation for blob with ArrayBuffer.\n    readOperation(this, blob, 'ArrayBuffer')\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#readAsBinaryString\n   * @param {import('buffer').Blob} blob\n   */\n  readAsBinaryString (blob) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsBinaryString')\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    // The readAsBinaryString(blob) method, when invoked,\n    // must initiate a read operation for blob with BinaryString.\n    readOperation(this, blob, 'BinaryString')\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#readAsDataText\n   * @param {import('buffer').Blob} blob\n   * @param {string?} encoding\n   */\n  readAsText (blob, encoding = undefined) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsText')\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    if (encoding !== undefined) {\n      encoding = webidl.converters.DOMString(encoding, 'FileReader.readAsText', 'encoding')\n    }\n\n    // The readAsText(blob, encoding) method, when invoked,\n    // must initiate a read operation for blob with Text and encoding.\n    readOperation(this, blob, 'Text', encoding)\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL\n   * @param {import('buffer').Blob} blob\n   */\n  readAsDataURL (blob) {\n    webidl.brandCheck(this, FileReader)\n\n    webidl.argumentLengthCheck(arguments, 1, 'FileReader.readAsDataURL')\n\n    blob = webidl.converters.Blob(blob, { strict: false })\n\n    // The readAsDataURL(blob) method, when invoked, must\n    // initiate a read operation for blob with DataURL.\n    readOperation(this, blob, 'DataURL')\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dfn-abort\n   */\n  abort () {\n    // 1. If this's state is \"empty\" or if this's state is\n    //    \"done\" set this's result to null and terminate\n    //    this algorithm.\n    if (this[kState] === 'empty' || this[kState] === 'done') {\n      this[kResult] = null\n      return\n    }\n\n    // 2. If this's state is \"loading\" set this's state to\n    //    \"done\" and set this's result to null.\n    if (this[kState] === 'loading') {\n      this[kState] = 'done'\n      this[kResult] = null\n    }\n\n    // 3. If there are any tasks from this on the file reading\n    //    task source in an affiliated task queue, then remove\n    //    those tasks from that task queue.\n    this[kAborted] = true\n\n    // 4. Terminate the algorithm for the read method being processed.\n    // TODO\n\n    // 5. Fire a progress event called abort at this.\n    fireAProgressEvent('abort', this)\n\n    // 6. If this's state is not \"loading\", fire a progress\n    //    event called loadend at this.\n    if (this[kState] !== 'loading') {\n      fireAProgressEvent('loadend', this)\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate\n   */\n  get readyState () {\n    webidl.brandCheck(this, FileReader)\n\n    switch (this[kState]) {\n      case 'empty': return this.EMPTY\n      case 'loading': return this.LOADING\n      case 'done': return this.DONE\n    }\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-result\n   */\n  get result () {\n    webidl.brandCheck(this, FileReader)\n\n    // The result attribute’s getter, when invoked, must return\n    // this's result.\n    return this[kResult]\n  }\n\n  /**\n   * @see https://w3c.github.io/FileAPI/#dom-filereader-error\n   */\n  get error () {\n    webidl.brandCheck(this, FileReader)\n\n    // The error attribute’s getter, when invoked, must return\n    // this's error.\n    return this[kError]\n  }\n\n  get onloadend () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].loadend\n  }\n\n  set onloadend (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].loadend) {\n      this.removeEventListener('loadend', this[kEvents].loadend)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].loadend = fn\n      this.addEventListener('loadend', fn)\n    } else {\n      this[kEvents].loadend = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].error) {\n      this.removeEventListener('error', this[kEvents].error)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this[kEvents].error = null\n    }\n  }\n\n  get onloadstart () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].loadstart\n  }\n\n  set onloadstart (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].loadstart) {\n      this.removeEventListener('loadstart', this[kEvents].loadstart)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].loadstart = fn\n      this.addEventListener('loadstart', fn)\n    } else {\n      this[kEvents].loadstart = null\n    }\n  }\n\n  get onprogress () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].progress\n  }\n\n  set onprogress (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].progress) {\n      this.removeEventListener('progress', this[kEvents].progress)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].progress = fn\n      this.addEventListener('progress', fn)\n    } else {\n      this[kEvents].progress = null\n    }\n  }\n\n  get onload () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].load\n  }\n\n  set onload (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].load) {\n      this.removeEventListener('load', this[kEvents].load)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].load = fn\n      this.addEventListener('load', fn)\n    } else {\n      this[kEvents].load = null\n    }\n  }\n\n  get onabort () {\n    webidl.brandCheck(this, FileReader)\n\n    return this[kEvents].abort\n  }\n\n  set onabort (fn) {\n    webidl.brandCheck(this, FileReader)\n\n    if (this[kEvents].abort) {\n      this.removeEventListener('abort', this[kEvents].abort)\n    }\n\n    if (typeof fn === 'function') {\n      this[kEvents].abort = fn\n      this.addEventListener('abort', fn)\n    } else {\n      this[kEvents].abort = null\n    }\n  }\n}\n\n// https://w3c.github.io/FileAPI/#dom-filereader-empty\nFileReader.EMPTY = FileReader.prototype.EMPTY = 0\n// https://w3c.github.io/FileAPI/#dom-filereader-loading\nFileReader.LOADING = FileReader.prototype.LOADING = 1\n// https://w3c.github.io/FileAPI/#dom-filereader-done\nFileReader.DONE = FileReader.prototype.DONE = 2\n\nObject.defineProperties(FileReader.prototype, {\n  EMPTY: staticPropertyDescriptors,\n  LOADING: staticPropertyDescriptors,\n  DONE: staticPropertyDescriptors,\n  readAsArrayBuffer: kEnumerableProperty,\n  readAsBinaryString: kEnumerableProperty,\n  readAsText: kEnumerableProperty,\n  readAsDataURL: kEnumerableProperty,\n  abort: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  result: kEnumerableProperty,\n  error: kEnumerableProperty,\n  onloadstart: kEnumerableProperty,\n  onprogress: kEnumerableProperty,\n  onload: kEnumerableProperty,\n  onabort: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onloadend: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'FileReader',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(FileReader, {\n  EMPTY: staticPropertyDescriptors,\n  LOADING: staticPropertyDescriptors,\n  DONE: staticPropertyDescriptors\n})\n\nmodule.exports = {\n  FileReader\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9maWxlcmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsbUVBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMseUVBQVc7QUFDdkIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDNUMsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLHFFQUFpQjs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQyxlQUFlOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBDQUEwQyxlQUFlOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwwQ0FBMEMsZUFBZTs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDLGVBQWU7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZpbGVhcGlcXGZpbGVyZWFkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgcmVhZE9wZXJhdGlvbixcbiAgZmlyZUFQcm9ncmVzc0V2ZW50XG59ID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHtcbiAga1N0YXRlLFxuICBrRXJyb3IsXG4gIGtSZXN1bHQsXG4gIGtFdmVudHMsXG4gIGtBYm9ydGVkXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgd2ViaWRsIH0gPSByZXF1aXJlKCcuLi9mZXRjaC93ZWJpZGwnKVxuY29uc3QgeyBrRW51bWVyYWJsZVByb3BlcnR5IH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL3V0aWwnKVxuXG5jbGFzcyBGaWxlUmVhZGVyIGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgdGhpc1trU3RhdGVdID0gJ2VtcHR5J1xuICAgIHRoaXNba1Jlc3VsdF0gPSBudWxsXG4gICAgdGhpc1trRXJyb3JdID0gbnVsbFxuICAgIHRoaXNba0V2ZW50c10gPSB7XG4gICAgICBsb2FkZW5kOiBudWxsLFxuICAgICAgZXJyb3I6IG51bGwsXG4gICAgICBhYm9ydDogbnVsbCxcbiAgICAgIGxvYWQ6IG51bGwsXG4gICAgICBwcm9ncmVzczogbnVsbCxcbiAgICAgIGxvYWRzdGFydDogbnVsbFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkZm4tcmVhZEFzQXJyYXlCdWZmZXJcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAgICovXG4gIHJlYWRBc0FycmF5QnVmZmVyIChibG9iKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0ZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXInKVxuXG4gICAgYmxvYiA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoYmxvYiwgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgICAvLyBUaGUgcmVhZEFzQXJyYXlCdWZmZXIoYmxvYikgbWV0aG9kLCB3aGVuIGludm9rZWQsXG4gICAgLy8gbXVzdCBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggQXJyYXlCdWZmZXIuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnQXJyYXlCdWZmZXInKVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI3JlYWRBc0JpbmFyeVN0cmluZ1xuICAgKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICAgKi9cbiAgcmVhZEFzQmluYXJ5U3RyaW5nIChibG9iKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgJ0ZpbGVSZWFkZXIucmVhZEFzQmluYXJ5U3RyaW5nJylcblxuICAgIGJsb2IgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKGJsb2IsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gICAgLy8gVGhlIHJlYWRBc0JpbmFyeVN0cmluZyhibG9iKSBtZXRob2QsIHdoZW4gaW52b2tlZCxcbiAgICAvLyBtdXN0IGluaXRpYXRlIGEgcmVhZCBvcGVyYXRpb24gZm9yIGJsb2Igd2l0aCBCaW5hcnlTdHJpbmcuXG4gICAgcmVhZE9wZXJhdGlvbih0aGlzLCBibG9iLCAnQmluYXJ5U3RyaW5nJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNyZWFkQXNEYXRhVGV4dFxuICAgKiBAcGFyYW0ge2ltcG9ydCgnYnVmZmVyJykuQmxvYn0gYmxvYlxuICAgKiBAcGFyYW0ge3N0cmluZz99IGVuY29kaW5nXG4gICAqL1xuICByZWFkQXNUZXh0IChibG9iLCBlbmNvZGluZyA9IHVuZGVmaW5lZCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdGaWxlUmVhZGVyLnJlYWRBc1RleHQnKVxuXG4gICAgYmxvYiA9IHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoYmxvYiwgeyBzdHJpY3Q6IGZhbHNlIH0pXG5cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5jb2RpbmcgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoZW5jb2RpbmcsICdGaWxlUmVhZGVyLnJlYWRBc1RleHQnLCAnZW5jb2RpbmcnKVxuICAgIH1cblxuICAgIC8vIFRoZSByZWFkQXNUZXh0KGJsb2IsIGVuY29kaW5nKSBtZXRob2QsIHdoZW4gaW52b2tlZCxcbiAgICAvLyBtdXN0IGluaXRpYXRlIGEgcmVhZCBvcGVyYXRpb24gZm9yIGJsb2Igd2l0aCBUZXh0IGFuZCBlbmNvZGluZy5cbiAgICByZWFkT3BlcmF0aW9uKHRoaXMsIGJsb2IsICdUZXh0JywgZW5jb2RpbmcpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZGZuLXJlYWRBc0RhdGFVUkxcbiAgICogQHBhcmFtIHtpbXBvcnQoJ2J1ZmZlcicpLkJsb2J9IGJsb2JcbiAgICovXG4gIHJlYWRBc0RhdGFVUkwgKGJsb2IpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgd2ViaWRsLmFyZ3VtZW50TGVuZ3RoQ2hlY2soYXJndW1lbnRzLCAxLCAnRmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMJylcblxuICAgIGJsb2IgPSB3ZWJpZGwuY29udmVydGVycy5CbG9iKGJsb2IsIHsgc3RyaWN0OiBmYWxzZSB9KVxuXG4gICAgLy8gVGhlIHJlYWRBc0RhdGFVUkwoYmxvYikgbWV0aG9kLCB3aGVuIGludm9rZWQsIG11c3RcbiAgICAvLyBpbml0aWF0ZSBhIHJlYWQgb3BlcmF0aW9uIGZvciBibG9iIHdpdGggRGF0YVVSTC5cbiAgICByZWFkT3BlcmF0aW9uKHRoaXMsIGJsb2IsICdEYXRhVVJMJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkZm4tYWJvcnRcbiAgICovXG4gIGFib3J0ICgpIHtcbiAgICAvLyAxLiBJZiB0aGlzJ3Mgc3RhdGUgaXMgXCJlbXB0eVwiIG9yIGlmIHRoaXMncyBzdGF0ZSBpc1xuICAgIC8vICAgIFwiZG9uZVwiIHNldCB0aGlzJ3MgcmVzdWx0IHRvIG51bGwgYW5kIHRlcm1pbmF0ZVxuICAgIC8vICAgIHRoaXMgYWxnb3JpdGhtLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0gPT09ICdlbXB0eScgfHwgdGhpc1trU3RhdGVdID09PSAnZG9uZScpIHtcbiAgICAgIHRoaXNba1Jlc3VsdF0gPSBudWxsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAyLiBJZiB0aGlzJ3Mgc3RhdGUgaXMgXCJsb2FkaW5nXCIgc2V0IHRoaXMncyBzdGF0ZSB0b1xuICAgIC8vICAgIFwiZG9uZVwiIGFuZCBzZXQgdGhpcydzIHJlc3VsdCB0byBudWxsLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0gPT09ICdsb2FkaW5nJykge1xuICAgICAgdGhpc1trU3RhdGVdID0gJ2RvbmUnXG4gICAgICB0aGlzW2tSZXN1bHRdID0gbnVsbFxuICAgIH1cblxuICAgIC8vIDMuIElmIHRoZXJlIGFyZSBhbnkgdGFza3MgZnJvbSB0aGlzIG9uIHRoZSBmaWxlIHJlYWRpbmdcbiAgICAvLyAgICB0YXNrIHNvdXJjZSBpbiBhbiBhZmZpbGlhdGVkIHRhc2sgcXVldWUsIHRoZW4gcmVtb3ZlXG4gICAgLy8gICAgdGhvc2UgdGFza3MgZnJvbSB0aGF0IHRhc2sgcXVldWUuXG4gICAgdGhpc1trQWJvcnRlZF0gPSB0cnVlXG5cbiAgICAvLyA0LiBUZXJtaW5hdGUgdGhlIGFsZ29yaXRobSBmb3IgdGhlIHJlYWQgbWV0aG9kIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAvLyBUT0RPXG5cbiAgICAvLyA1LiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGFib3J0IGF0IHRoaXMuXG4gICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdhYm9ydCcsIHRoaXMpXG5cbiAgICAvLyA2LiBJZiB0aGlzJ3Mgc3RhdGUgaXMgbm90IFwibG9hZGluZ1wiLCBmaXJlIGEgcHJvZ3Jlc3NcbiAgICAvLyAgICBldmVudCBjYWxsZWQgbG9hZGVuZCBhdCB0aGlzLlxuICAgIGlmICh0aGlzW2tTdGF0ZV0gIT09ICdsb2FkaW5nJykge1xuICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2FkZW5kJywgdGhpcylcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItcmVhZHlzdGF0ZVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBzd2l0Y2ggKHRoaXNba1N0YXRlXSkge1xuICAgICAgY2FzZSAnZW1wdHknOiByZXR1cm4gdGhpcy5FTVBUWVxuICAgICAgY2FzZSAnbG9hZGluZyc6IHJldHVybiB0aGlzLkxPQURJTkdcbiAgICAgIGNhc2UgJ2RvbmUnOiByZXR1cm4gdGhpcy5ET05FXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLXJlc3VsdFxuICAgKi9cbiAgZ2V0IHJlc3VsdCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIC8vIFRoZSByZXN1bHQgYXR0cmlidXRl4oCZcyBnZXR0ZXIsIHdoZW4gaW52b2tlZCwgbXVzdCByZXR1cm5cbiAgICAvLyB0aGlzJ3MgcmVzdWx0LlxuICAgIHJldHVybiB0aGlzW2tSZXN1bHRdXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItZXJyb3JcbiAgICovXG4gIGdldCBlcnJvciAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIC8vIFRoZSBlcnJvciBhdHRyaWJ1dGXigJlzIGdldHRlciwgd2hlbiBpbnZva2VkLCBtdXN0IHJldHVyblxuICAgIC8vIHRoaXMncyBlcnJvci5cbiAgICByZXR1cm4gdGhpc1trRXJyb3JdXG4gIH1cblxuICBnZXQgb25sb2FkZW5kICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10ubG9hZGVuZFxuICB9XG5cbiAgc2V0IG9ubG9hZGVuZCAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10ubG9hZGVuZCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZW5kJywgdGhpc1trRXZlbnRzXS5sb2FkZW5kKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10ubG9hZGVuZCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2FkZW5kID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmVycm9yICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10uZXJyb3JcbiAgfVxuXG4gIHNldCBvbmVycm9yIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5lcnJvcikge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXNba0V2ZW50c10uZXJyb3IpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5lcnJvciA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0V2ZW50c10uZXJyb3IgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9ubG9hZHN0YXJ0ICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgcmV0dXJuIHRoaXNba0V2ZW50c10ubG9hZHN0YXJ0XG4gIH1cblxuICBzZXQgb25sb2Fkc3RhcnQgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmxvYWRzdGFydCkge1xuICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCB0aGlzW2tFdmVudHNdLmxvYWRzdGFydClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWRzdGFydCA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWRzdGFydCA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25wcm9ncmVzcyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIHJldHVybiB0aGlzW2tFdmVudHNdLnByb2dyZXNzXG4gIH1cblxuICBzZXQgb25wcm9ncmVzcyAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBGaWxlUmVhZGVyKVxuXG4gICAgaWYgKHRoaXNba0V2ZW50c10ucHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzW2tFdmVudHNdLnByb2dyZXNzKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNba0V2ZW50c10ucHJvZ3Jlc3MgPSBmblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLnByb2dyZXNzID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmxvYWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5sb2FkXG4gIH1cblxuICBzZXQgb25sb2FkIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICBpZiAodGhpc1trRXZlbnRzXS5sb2FkKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzW2tFdmVudHNdLmxvYWQpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1trRXZlbnRzXS5sb2FkID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZuKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmxvYWQgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uYWJvcnQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpXG5cbiAgICByZXR1cm4gdGhpc1trRXZlbnRzXS5hYm9ydFxuICB9XG5cbiAgc2V0IG9uYWJvcnQgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRmlsZVJlYWRlcilcblxuICAgIGlmICh0aGlzW2tFdmVudHNdLmFib3J0KSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpc1trRXZlbnRzXS5hYm9ydClcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2tFdmVudHNdLmFib3J0ID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1trRXZlbnRzXS5hYm9ydCA9IG51bGxcbiAgICB9XG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2RvbS1maWxlcmVhZGVyLWVtcHR5XG5GaWxlUmVhZGVyLkVNUFRZID0gRmlsZVJlYWRlci5wcm90b3R5cGUuRU1QVFkgPSAwXG4vLyBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jZG9tLWZpbGVyZWFkZXItbG9hZGluZ1xuRmlsZVJlYWRlci5MT0FESU5HID0gRmlsZVJlYWRlci5wcm90b3R5cGUuTE9BRElORyA9IDFcbi8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNkb20tZmlsZXJlYWRlci1kb25lXG5GaWxlUmVhZGVyLkRPTkUgPSBGaWxlUmVhZGVyLnByb3RvdHlwZS5ET05FID0gMlxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGaWxlUmVhZGVyLnByb3RvdHlwZSwge1xuICBFTVBUWTogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgTE9BRElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgRE9ORTogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgcmVhZEFzQXJyYXlCdWZmZXI6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWRBc0JpbmFyeVN0cmluZzoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZEFzVGV4dDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZEFzRGF0YVVSTDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYWJvcnQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlYWR5U3RhdGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHJlc3VsdDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubG9hZHN0YXJ0OiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbnByb2dyZXNzOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBvbmxvYWQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uYWJvcnQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9uZXJyb3I6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubG9hZGVuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0ZpbGVSZWFkZXInLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmlsZVJlYWRlciwge1xuICBFTVBUWTogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgTE9BRElORzogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgRE9ORTogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9yc1xufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZpbGVSZWFkZXJcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fileapi/filereader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fileapi/progressevent.js":
/*!**************************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/progressevent.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\n\nconst kState = Symbol('ProgressEvent state')\n\n/**\n * @see https://xhr.spec.whatwg.org/#progressevent\n */\nclass ProgressEvent extends Event {\n  constructor (type, eventInitDict = {}) {\n    type = webidl.converters.DOMString(type, 'ProgressEvent constructor', 'type')\n    eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {})\n\n    super(type, eventInitDict)\n\n    this[kState] = {\n      lengthComputable: eventInitDict.lengthComputable,\n      loaded: eventInitDict.loaded,\n      total: eventInitDict.total\n    }\n  }\n\n  get lengthComputable () {\n    webidl.brandCheck(this, ProgressEvent)\n\n    return this[kState].lengthComputable\n  }\n\n  get loaded () {\n    webidl.brandCheck(this, ProgressEvent)\n\n    return this[kState].loaded\n  }\n\n  get total () {\n    webidl.brandCheck(this, ProgressEvent)\n\n    return this[kState].total\n  }\n}\n\nwebidl.converters.ProgressEventInit = webidl.dictionaryConverter([\n  {\n    key: 'lengthComputable',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'loaded',\n    converter: webidl.converters['unsigned long long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'total',\n    converter: webidl.converters['unsigned long long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'bubbles',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'cancelable',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'composed',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n])\n\nmodule.exports = {\n  ProgressEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9wcm9ncmVzc2V2ZW50LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsNEVBQWlCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLDJFQUEyRTs7QUFFM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcZmlsZWFwaVxccHJvZ3Jlc3NldmVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB3ZWJpZGwgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3dlYmlkbCcpXG5cbmNvbnN0IGtTdGF0ZSA9IFN5bWJvbCgnUHJvZ3Jlc3NFdmVudCBzdGF0ZScpXG5cbi8qKlxuICogQHNlZSBodHRwczovL3hoci5zcGVjLndoYXR3Zy5vcmcvI3Byb2dyZXNzZXZlbnRcbiAqL1xuY2xhc3MgUHJvZ3Jlc3NFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSwgJ1Byb2dyZXNzRXZlbnQgY29uc3RydWN0b3InLCAndHlwZScpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlByb2dyZXNzRXZlbnRJbml0KGV2ZW50SW5pdERpY3QgPz8ge30pXG5cbiAgICBzdXBlcih0eXBlLCBldmVudEluaXREaWN0KVxuXG4gICAgdGhpc1trU3RhdGVdID0ge1xuICAgICAgbGVuZ3RoQ29tcHV0YWJsZTogZXZlbnRJbml0RGljdC5sZW5ndGhDb21wdXRhYmxlLFxuICAgICAgbG9hZGVkOiBldmVudEluaXREaWN0LmxvYWRlZCxcbiAgICAgIHRvdGFsOiBldmVudEluaXREaWN0LnRvdGFsXG4gICAgfVxuICB9XG5cbiAgZ2V0IGxlbmd0aENvbXB1dGFibGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxlbmd0aENvbXB1dGFibGVcbiAgfVxuXG4gIGdldCBsb2FkZWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFByb2dyZXNzRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpc1trU3RhdGVdLmxvYWRlZFxuICB9XG5cbiAgZ2V0IHRvdGFsICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBQcm9ncmVzc0V2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXNba1N0YXRlXS50b3RhbFxuICB9XG59XG5cbndlYmlkbC5jb252ZXJ0ZXJzLlByb2dyZXNzRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICB7XG4gICAga2V5OiAnbGVuZ3RoQ29tcHV0YWJsZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2xvYWRlZCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICd0b3RhbCcsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgbG9uZyBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdidWJibGVzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY2FuY2VsYWJsZScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvbXBvc2VkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9XG5dKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUHJvZ3Jlc3NFdmVudFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fileapi/progressevent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fileapi/symbols.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/symbols.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kState: Symbol('FileReader state'),\n  kResult: Symbol('FileReader result'),\n  kError: Symbol('FileReader error'),\n  kLastProgressEventFired: Symbol('FileReader last progress event fired timestamp'),\n  kEvents: Symbol('FileReader events'),\n  kAborted: Symbol('FileReader aborted')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS9zeW1ib2xzLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFxmaWxlYXBpXFxzeW1ib2xzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAga1N0YXRlOiBTeW1ib2woJ0ZpbGVSZWFkZXIgc3RhdGUnKSxcbiAga1Jlc3VsdDogU3ltYm9sKCdGaWxlUmVhZGVyIHJlc3VsdCcpLFxuICBrRXJyb3I6IFN5bWJvbCgnRmlsZVJlYWRlciBlcnJvcicpLFxuICBrTGFzdFByb2dyZXNzRXZlbnRGaXJlZDogU3ltYm9sKCdGaWxlUmVhZGVyIGxhc3QgcHJvZ3Jlc3MgZXZlbnQgZmlyZWQgdGltZXN0YW1wJyksXG4gIGtFdmVudHM6IFN5bWJvbCgnRmlsZVJlYWRlciBldmVudHMnKSxcbiAga0Fib3J0ZWQ6IFN5bWJvbCgnRmlsZVJlYWRlciBhYm9ydGVkJylcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fileapi/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/fileapi/util.js":
/*!*****************************************************!*\
  !*** ./node_modules/undici/lib/web/fileapi/util.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst {\n  kState,\n  kError,\n  kResult,\n  kAborted,\n  kLastProgressEventFired\n} = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/fileapi/symbols.js\")\nconst { ProgressEvent } = __webpack_require__(/*! ./progressevent */ \"(rsc)/./node_modules/undici/lib/web/fileapi/progressevent.js\")\nconst { getEncoding } = __webpack_require__(/*! ./encoding */ \"(rsc)/./node_modules/undici/lib/web/fileapi/encoding.js\")\nconst { serializeAMimeType, parseMIMEType } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\")\nconst { btoa } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\n\n/** @type {PropertyDescriptor} */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#readOperation\n * @param {import('./filereader').FileReader} fr\n * @param {import('buffer').Blob} blob\n * @param {string} type\n * @param {string?} encodingName\n */\nfunction readOperation (fr, blob, type, encodingName) {\n  // 1. If fr’s state is \"loading\", throw an InvalidStateError\n  //    DOMException.\n  if (fr[kState] === 'loading') {\n    throw new DOMException('Invalid state', 'InvalidStateError')\n  }\n\n  // 2. Set fr’s state to \"loading\".\n  fr[kState] = 'loading'\n\n  // 3. Set fr’s result to null.\n  fr[kResult] = null\n\n  // 4. Set fr’s error to null.\n  fr[kError] = null\n\n  // 5. Let stream be the result of calling get stream on blob.\n  /** @type {import('stream/web').ReadableStream} */\n  const stream = blob.stream()\n\n  // 6. Let reader be the result of getting a reader from stream.\n  const reader = stream.getReader()\n\n  // 7. Let bytes be an empty byte sequence.\n  /** @type {Uint8Array[]} */\n  const bytes = []\n\n  // 8. Let chunkPromise be the result of reading a chunk from\n  //    stream with reader.\n  let chunkPromise = reader.read()\n\n  // 9. Let isFirstChunk be true.\n  let isFirstChunk = true\n\n  // 10. In parallel, while true:\n  // Note: \"In parallel\" just means non-blocking\n  // Note 2: readOperation itself cannot be async as double\n  // reading the body would then reject the promise, instead\n  // of throwing an error.\n  ;(async () => {\n    while (!fr[kAborted]) {\n      // 1. Wait for chunkPromise to be fulfilled or rejected.\n      try {\n        const { done, value } = await chunkPromise\n\n        // 2. If chunkPromise is fulfilled, and isFirstChunk is\n        //    true, queue a task to fire a progress event called\n        //    loadstart at fr.\n        if (isFirstChunk && !fr[kAborted]) {\n          queueMicrotask(() => {\n            fireAProgressEvent('loadstart', fr)\n          })\n        }\n\n        // 3. Set isFirstChunk to false.\n        isFirstChunk = false\n\n        // 4. If chunkPromise is fulfilled with an object whose\n        //    done property is false and whose value property is\n        //    a Uint8Array object, run these steps:\n        if (!done && types.isUint8Array(value)) {\n          // 1. Let bs be the byte sequence represented by the\n          //    Uint8Array object.\n\n          // 2. Append bs to bytes.\n          bytes.push(value)\n\n          // 3. If roughly 50ms have passed since these steps\n          //    were last invoked, queue a task to fire a\n          //    progress event called progress at fr.\n          if (\n            (\n              fr[kLastProgressEventFired] === undefined ||\n              Date.now() - fr[kLastProgressEventFired] >= 50\n            ) &&\n            !fr[kAborted]\n          ) {\n            fr[kLastProgressEventFired] = Date.now()\n            queueMicrotask(() => {\n              fireAProgressEvent('progress', fr)\n            })\n          }\n\n          // 4. Set chunkPromise to the result of reading a\n          //    chunk from stream with reader.\n          chunkPromise = reader.read()\n        } else if (done) {\n          // 5. Otherwise, if chunkPromise is fulfilled with an\n          //    object whose done property is true, queue a task\n          //    to run the following steps and abort this algorithm:\n          queueMicrotask(() => {\n            // 1. Set fr’s state to \"done\".\n            fr[kState] = 'done'\n\n            // 2. Let result be the result of package data given\n            //    bytes, type, blob’s type, and encodingName.\n            try {\n              const result = packageData(bytes, type, blob.type, encodingName)\n\n              // 4. Else:\n\n              if (fr[kAborted]) {\n                return\n              }\n\n              // 1. Set fr’s result to result.\n              fr[kResult] = result\n\n              // 2. Fire a progress event called load at the fr.\n              fireAProgressEvent('load', fr)\n            } catch (error) {\n              // 3. If package data threw an exception error:\n\n              // 1. Set fr’s error to error.\n              fr[kError] = error\n\n              // 2. Fire a progress event called error at fr.\n              fireAProgressEvent('error', fr)\n            }\n\n            // 5. If fr’s state is not \"loading\", fire a progress\n            //    event called loadend at the fr.\n            if (fr[kState] !== 'loading') {\n              fireAProgressEvent('loadend', fr)\n            }\n          })\n\n          break\n        }\n      } catch (error) {\n        if (fr[kAborted]) {\n          return\n        }\n\n        // 6. Otherwise, if chunkPromise is rejected with an\n        //    error error, queue a task to run the following\n        //    steps and abort this algorithm:\n        queueMicrotask(() => {\n          // 1. Set fr’s state to \"done\".\n          fr[kState] = 'done'\n\n          // 2. Set fr’s error to error.\n          fr[kError] = error\n\n          // 3. Fire a progress event called error at fr.\n          fireAProgressEvent('error', fr)\n\n          // 4. If fr’s state is not \"loading\", fire a progress\n          //    event called loadend at fr.\n          if (fr[kState] !== 'loading') {\n            fireAProgressEvent('loadend', fr)\n          }\n        })\n\n        break\n      }\n    }\n  })()\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#fire-a-progress-event\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e The name of the event\n * @param {import('./filereader').FileReader} reader\n */\nfunction fireAProgressEvent (e, reader) {\n  // The progress event e does not bubble. e.bubbles must be false\n  // The progress event e is NOT cancelable. e.cancelable must be false\n  const event = new ProgressEvent(e, {\n    bubbles: false,\n    cancelable: false\n  })\n\n  reader.dispatchEvent(event)\n}\n\n/**\n * @see https://w3c.github.io/FileAPI/#blob-package-data\n * @param {Uint8Array[]} bytes\n * @param {string} type\n * @param {string?} mimeType\n * @param {string?} encodingName\n */\nfunction packageData (bytes, type, mimeType, encodingName) {\n  // 1. A Blob has an associated package data algorithm, given\n  //    bytes, a type, a optional mimeType, and a optional\n  //    encodingName, which switches on type and runs the\n  //    associated steps:\n\n  switch (type) {\n    case 'DataURL': {\n      // 1. Return bytes as a DataURL [RFC2397] subject to\n      //    the considerations below:\n      //  * Use mimeType as part of the Data URL if it is\n      //    available in keeping with the Data URL\n      //    specification [RFC2397].\n      //  * If mimeType is not available return a Data URL\n      //    without a media-type. [RFC2397].\n\n      // https://datatracker.ietf.org/doc/html/rfc2397#section-3\n      // dataurl    := \"data:\" [ mediatype ] [ \";base64\" ] \",\" data\n      // mediatype  := [ type \"/\" subtype ] *( \";\" parameter )\n      // data       := *urlchar\n      // parameter  := attribute \"=\" value\n      let dataURL = 'data:'\n\n      const parsed = parseMIMEType(mimeType || 'application/octet-stream')\n\n      if (parsed !== 'failure') {\n        dataURL += serializeAMimeType(parsed)\n      }\n\n      dataURL += ';base64,'\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        dataURL += btoa(decoder.write(chunk))\n      }\n\n      dataURL += btoa(decoder.end())\n\n      return dataURL\n    }\n    case 'Text': {\n      // 1. Let encoding be failure\n      let encoding = 'failure'\n\n      // 2. If the encodingName is present, set encoding to the\n      //    result of getting an encoding from encodingName.\n      if (encodingName) {\n        encoding = getEncoding(encodingName)\n      }\n\n      // 3. If encoding is failure, and mimeType is present:\n      if (encoding === 'failure' && mimeType) {\n        // 1. Let type be the result of parse a MIME type\n        //    given mimeType.\n        const type = parseMIMEType(mimeType)\n\n        // 2. If type is not failure, set encoding to the result\n        //    of getting an encoding from type’s parameters[\"charset\"].\n        if (type !== 'failure') {\n          encoding = getEncoding(type.parameters.get('charset'))\n        }\n      }\n\n      // 4. If encoding is failure, then set encoding to UTF-8.\n      if (encoding === 'failure') {\n        encoding = 'UTF-8'\n      }\n\n      // 5. Decode bytes using fallback encoding encoding, and\n      //    return the result.\n      return decode(bytes, encoding)\n    }\n    case 'ArrayBuffer': {\n      // Return a new ArrayBuffer whose contents are bytes.\n      const sequence = combineByteSequences(bytes)\n\n      return sequence.buffer\n    }\n    case 'BinaryString': {\n      // Return bytes as a binary string, in which every byte\n      //  is represented by a code unit of equal value [0..255].\n      let binaryString = ''\n\n      const decoder = new StringDecoder('latin1')\n\n      for (const chunk of bytes) {\n        binaryString += decoder.write(chunk)\n      }\n\n      binaryString += decoder.end()\n\n      return binaryString\n    }\n  }\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#decode\n * @param {Uint8Array[]} ioQueue\n * @param {string} encoding\n */\nfunction decode (ioQueue, encoding) {\n  const bytes = combineByteSequences(ioQueue)\n\n  // 1. Let BOMEncoding be the result of BOM sniffing ioQueue.\n  const BOMEncoding = BOMSniffing(bytes)\n\n  let slice = 0\n\n  // 2. If BOMEncoding is non-null:\n  if (BOMEncoding !== null) {\n    // 1. Set encoding to BOMEncoding.\n    encoding = BOMEncoding\n\n    // 2. Read three bytes from ioQueue, if BOMEncoding is\n    //    UTF-8; otherwise read two bytes.\n    //    (Do nothing with those bytes.)\n    slice = BOMEncoding === 'UTF-8' ? 3 : 2\n  }\n\n  // 3. Process a queue with an instance of encoding’s\n  //    decoder, ioQueue, output, and \"replacement\".\n\n  // 4. Return output.\n\n  const sliced = bytes.slice(slice)\n  return new TextDecoder(encoding).decode(sliced)\n}\n\n/**\n * @see https://encoding.spec.whatwg.org/#bom-sniff\n * @param {Uint8Array} ioQueue\n */\nfunction BOMSniffing (ioQueue) {\n  // 1. Let BOM be the result of peeking 3 bytes from ioQueue,\n  //    converted to a byte sequence.\n  const [a, b, c] = ioQueue\n\n  // 2. For each of the rows in the table below, starting with\n  //    the first one and going down, if BOM starts with the\n  //    bytes given in the first column, then return the\n  //    encoding given in the cell in the second column of that\n  //    row. Otherwise, return null.\n  if (a === 0xEF && b === 0xBB && c === 0xBF) {\n    return 'UTF-8'\n  } else if (a === 0xFE && b === 0xFF) {\n    return 'UTF-16BE'\n  } else if (a === 0xFF && b === 0xFE) {\n    return 'UTF-16LE'\n  }\n\n  return null\n}\n\n/**\n * @param {Uint8Array[]} sequences\n */\nfunction combineByteSequences (sequences) {\n  const size = sequences.reduce((a, b) => {\n    return a + b.byteLength\n  }, 0)\n\n  let offset = 0\n\n  return sequences.reduce((a, b) => {\n    a.set(b, offset)\n    offset += b.byteLength\n    return a\n  }, new Uint8Array(size))\n}\n\nmodule.exports = {\n  staticPropertyDescriptors,\n  readOperation,\n  fireAProgressEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvZmlsZWFwaS91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHlFQUFXO0FBQ3ZCLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxxRkFBaUI7QUFDbkQsUUFBUSxjQUFjLEVBQUUsbUJBQU8sQ0FBQywyRUFBWTtBQUM1QyxRQUFRLG9DQUFvQyxFQUFFLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ3pFLFFBQVEsUUFBUSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDckMsUUFBUSxnQkFBZ0IsRUFBRSxtQkFBTyxDQUFDLHNDQUFnQjtBQUNsRCxRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLGdDQUFhOztBQUV0QyxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1DQUFtQztBQUM5QyxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGFBQWEsY0FBYztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFjOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsbUNBQW1DO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRDtBQUNqRCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXGZpbGVhcGlcXHV0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHtcbiAga1N0YXRlLFxuICBrRXJyb3IsXG4gIGtSZXN1bHQsXG4gIGtBYm9ydGVkLFxuICBrTGFzdFByb2dyZXNzRXZlbnRGaXJlZFxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IFByb2dyZXNzRXZlbnQgfSA9IHJlcXVpcmUoJy4vcHJvZ3Jlc3NldmVudCcpXG5jb25zdCB7IGdldEVuY29kaW5nIH0gPSByZXF1aXJlKCcuL2VuY29kaW5nJylcbmNvbnN0IHsgc2VyaWFsaXplQU1pbWVUeXBlLCBwYXJzZU1JTUVUeXBlIH0gPSByZXF1aXJlKCcuLi9mZXRjaC9kYXRhLXVybCcpXG5jb25zdCB7IHR5cGVzIH0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgeyBTdHJpbmdEZWNvZGVyIH0gPSByZXF1aXJlKCdzdHJpbmdfZGVjb2RlcicpXG5jb25zdCB7IGJ0b2EgfSA9IHJlcXVpcmUoJ25vZGU6YnVmZmVyJylcblxuLyoqIEB0eXBlIHtQcm9wZXJ0eURlc2NyaXB0b3J9ICovXG5jb25zdCBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9GaWxlQVBJLyNyZWFkT3BlcmF0aW9uXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9maWxlcmVhZGVyJykuRmlsZVJlYWRlcn0gZnJcbiAqIEBwYXJhbSB7aW1wb3J0KCdidWZmZXInKS5CbG9ifSBibG9iXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmc/fSBlbmNvZGluZ05hbWVcbiAqL1xuZnVuY3Rpb24gcmVhZE9wZXJhdGlvbiAoZnIsIGJsb2IsIHR5cGUsIGVuY29kaW5nTmFtZSkge1xuICAvLyAxLiBJZiBmcuKAmXMgc3RhdGUgaXMgXCJsb2FkaW5nXCIsIHRocm93IGFuIEludmFsaWRTdGF0ZUVycm9yXG4gIC8vICAgIERPTUV4Y2VwdGlvbi5cbiAgaWYgKGZyW2tTdGF0ZV0gPT09ICdsb2FkaW5nJykge1xuICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0ludmFsaWQgc3RhdGUnLCAnSW52YWxpZFN0YXRlRXJyb3InKVxuICB9XG5cbiAgLy8gMi4gU2V0IGZy4oCZcyBzdGF0ZSB0byBcImxvYWRpbmdcIi5cbiAgZnJba1N0YXRlXSA9ICdsb2FkaW5nJ1xuXG4gIC8vIDMuIFNldCBmcuKAmXMgcmVzdWx0IHRvIG51bGwuXG4gIGZyW2tSZXN1bHRdID0gbnVsbFxuXG4gIC8vIDQuIFNldCBmcuKAmXMgZXJyb3IgdG8gbnVsbC5cbiAgZnJba0Vycm9yXSA9IG51bGxcblxuICAvLyA1LiBMZXQgc3RyZWFtIGJlIHRoZSByZXN1bHQgb2YgY2FsbGluZyBnZXQgc3RyZWFtIG9uIGJsb2IuXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCdzdHJlYW0vd2ViJykuUmVhZGFibGVTdHJlYW19ICovXG4gIGNvbnN0IHN0cmVhbSA9IGJsb2Iuc3RyZWFtKClcblxuICAvLyA2LiBMZXQgcmVhZGVyIGJlIHRoZSByZXN1bHQgb2YgZ2V0dGluZyBhIHJlYWRlciBmcm9tIHN0cmVhbS5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpXG5cbiAgLy8gNy4gTGV0IGJ5dGVzIGJlIGFuIGVtcHR5IGJ5dGUgc2VxdWVuY2UuXG4gIC8qKiBAdHlwZSB7VWludDhBcnJheVtdfSAqL1xuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgLy8gOC4gTGV0IGNodW5rUHJvbWlzZSBiZSB0aGUgcmVzdWx0IG9mIHJlYWRpbmcgYSBjaHVuayBmcm9tXG4gIC8vICAgIHN0cmVhbSB3aXRoIHJlYWRlci5cbiAgbGV0IGNodW5rUHJvbWlzZSA9IHJlYWRlci5yZWFkKClcblxuICAvLyA5LiBMZXQgaXNGaXJzdENodW5rIGJlIHRydWUuXG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlXG5cbiAgLy8gMTAuIEluIHBhcmFsbGVsLCB3aGlsZSB0cnVlOlxuICAvLyBOb3RlOiBcIkluIHBhcmFsbGVsXCIganVzdCBtZWFucyBub24tYmxvY2tpbmdcbiAgLy8gTm90ZSAyOiByZWFkT3BlcmF0aW9uIGl0c2VsZiBjYW5ub3QgYmUgYXN5bmMgYXMgZG91YmxlXG4gIC8vIHJlYWRpbmcgdGhlIGJvZHkgd291bGQgdGhlbiByZWplY3QgdGhlIHByb21pc2UsIGluc3RlYWRcbiAgLy8gb2YgdGhyb3dpbmcgYW4gZXJyb3IuXG4gIDsoYXN5bmMgKCkgPT4ge1xuICAgIHdoaWxlICghZnJba0Fib3J0ZWRdKSB7XG4gICAgICAvLyAxLiBXYWl0IGZvciBjaHVua1Byb21pc2UgdG8gYmUgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgY2h1bmtQcm9taXNlXG5cbiAgICAgICAgLy8gMi4gSWYgY2h1bmtQcm9taXNlIGlzIGZ1bGZpbGxlZCwgYW5kIGlzRmlyc3RDaHVuayBpc1xuICAgICAgICAvLyAgICB0cnVlLCBxdWV1ZSBhIHRhc2sgdG8gZmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZFxuICAgICAgICAvLyAgICBsb2Fkc3RhcnQgYXQgZnIuXG4gICAgICAgIGlmIChpc0ZpcnN0Q2h1bmsgJiYgIWZyW2tBYm9ydGVkXSkge1xuICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZHN0YXJ0JywgZnIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIFNldCBpc0ZpcnN0Q2h1bmsgdG8gZmFsc2UuXG4gICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlXG5cbiAgICAgICAgLy8gNC4gSWYgY2h1bmtQcm9taXNlIGlzIGZ1bGZpbGxlZCB3aXRoIGFuIG9iamVjdCB3aG9zZVxuICAgICAgICAvLyAgICBkb25lIHByb3BlcnR5IGlzIGZhbHNlIGFuZCB3aG9zZSB2YWx1ZSBwcm9wZXJ0eSBpc1xuICAgICAgICAvLyAgICBhIFVpbnQ4QXJyYXkgb2JqZWN0LCBydW4gdGhlc2Ugc3RlcHM6XG4gICAgICAgIGlmICghZG9uZSAmJiB0eXBlcy5pc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgLy8gMS4gTGV0IGJzIGJlIHRoZSBieXRlIHNlcXVlbmNlIHJlcHJlc2VudGVkIGJ5IHRoZVxuICAgICAgICAgIC8vICAgIFVpbnQ4QXJyYXkgb2JqZWN0LlxuXG4gICAgICAgICAgLy8gMi4gQXBwZW5kIGJzIHRvIGJ5dGVzLlxuICAgICAgICAgIGJ5dGVzLnB1c2godmFsdWUpXG5cbiAgICAgICAgICAvLyAzLiBJZiByb3VnaGx5IDUwbXMgaGF2ZSBwYXNzZWQgc2luY2UgdGhlc2Ugc3RlcHNcbiAgICAgICAgICAvLyAgICB3ZXJlIGxhc3QgaW52b2tlZCwgcXVldWUgYSB0YXNrIHRvIGZpcmUgYVxuICAgICAgICAgIC8vICAgIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBwcm9ncmVzcyBhdCBmci5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoXG4gICAgICAgICAgICAgIGZyW2tMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgIERhdGUubm93KCkgLSBmcltrTGFzdFByb2dyZXNzRXZlbnRGaXJlZF0gPj0gNTBcbiAgICAgICAgICAgICkgJiZcbiAgICAgICAgICAgICFmcltrQWJvcnRlZF1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGZyW2tMYXN0UHJvZ3Jlc3NFdmVudEZpcmVkXSA9IERhdGUubm93KClcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdwcm9ncmVzcycsIGZyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyA0LiBTZXQgY2h1bmtQcm9taXNlIHRvIHRoZSByZXN1bHQgb2YgcmVhZGluZyBhXG4gICAgICAgICAgLy8gICAgY2h1bmsgZnJvbSBzdHJlYW0gd2l0aCByZWFkZXIuXG4gICAgICAgICAgY2h1bmtQcm9taXNlID0gcmVhZGVyLnJlYWQoKVxuICAgICAgICB9IGVsc2UgaWYgKGRvbmUpIHtcbiAgICAgICAgICAvLyA1LiBPdGhlcndpc2UsIGlmIGNodW5rUHJvbWlzZSBpcyBmdWxmaWxsZWQgd2l0aCBhblxuICAgICAgICAgIC8vICAgIG9iamVjdCB3aG9zZSBkb25lIHByb3BlcnR5IGlzIHRydWUsIHF1ZXVlIGEgdGFza1xuICAgICAgICAgIC8vICAgIHRvIHJ1biB0aGUgZm9sbG93aW5nIHN0ZXBzIGFuZCBhYm9ydCB0aGlzIGFsZ29yaXRobTpcbiAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIHN0YXRlIHRvIFwiZG9uZVwiLlxuICAgICAgICAgICAgZnJba1N0YXRlXSA9ICdkb25lJ1xuXG4gICAgICAgICAgICAvLyAyLiBMZXQgcmVzdWx0IGJlIHRoZSByZXN1bHQgb2YgcGFja2FnZSBkYXRhIGdpdmVuXG4gICAgICAgICAgICAvLyAgICBieXRlcywgdHlwZSwgYmxvYuKAmXMgdHlwZSwgYW5kIGVuY29kaW5nTmFtZS5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhY2thZ2VEYXRhKGJ5dGVzLCB0eXBlLCBibG9iLnR5cGUsIGVuY29kaW5nTmFtZSlcblxuICAgICAgICAgICAgICAvLyA0LiBFbHNlOlxuXG4gICAgICAgICAgICAgIGlmIChmcltrQWJvcnRlZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIDEuIFNldCBmcuKAmXMgcmVzdWx0IHRvIHJlc3VsdC5cbiAgICAgICAgICAgICAgZnJba1Jlc3VsdF0gPSByZXN1bHRcblxuICAgICAgICAgICAgICAvLyAyLiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGxvYWQgYXQgdGhlIGZyLlxuICAgICAgICAgICAgICBmaXJlQVByb2dyZXNzRXZlbnQoJ2xvYWQnLCBmcilcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIDMuIElmIHBhY2thZ2UgZGF0YSB0aHJldyBhbiBleGNlcHRpb24gZXJyb3I6XG5cbiAgICAgICAgICAgICAgLy8gMS4gU2V0IGZy4oCZcyBlcnJvciB0byBlcnJvci5cbiAgICAgICAgICAgICAgZnJba0Vycm9yXSA9IGVycm9yXG5cbiAgICAgICAgICAgICAgLy8gMi4gRmlyZSBhIHByb2dyZXNzIGV2ZW50IGNhbGxlZCBlcnJvciBhdCBmci5cbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdlcnJvcicsIGZyKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyA1LiBJZiBmcuKAmXMgc3RhdGUgaXMgbm90IFwibG9hZGluZ1wiLCBmaXJlIGEgcHJvZ3Jlc3NcbiAgICAgICAgICAgIC8vICAgIGV2ZW50IGNhbGxlZCBsb2FkZW5kIGF0IHRoZSBmci5cbiAgICAgICAgICAgIGlmIChmcltrU3RhdGVdICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgICAgZmlyZUFQcm9ncmVzc0V2ZW50KCdsb2FkZW5kJywgZnIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChmcltrQWJvcnRlZF0pIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDYuIE90aGVyd2lzZSwgaWYgY2h1bmtQcm9taXNlIGlzIHJlamVjdGVkIHdpdGggYW5cbiAgICAgICAgLy8gICAgZXJyb3IgZXJyb3IsIHF1ZXVlIGEgdGFzayB0byBydW4gdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyAgICBzdGVwcyBhbmQgYWJvcnQgdGhpcyBhbGdvcml0aG06XG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAvLyAxLiBTZXQgZnLigJlzIHN0YXRlIHRvIFwiZG9uZVwiLlxuICAgICAgICAgIGZyW2tTdGF0ZV0gPSAnZG9uZSdcblxuICAgICAgICAgIC8vIDIuIFNldCBmcuKAmXMgZXJyb3IgdG8gZXJyb3IuXG4gICAgICAgICAgZnJba0Vycm9yXSA9IGVycm9yXG5cbiAgICAgICAgICAvLyAzLiBGaXJlIGEgcHJvZ3Jlc3MgZXZlbnQgY2FsbGVkIGVycm9yIGF0IGZyLlxuICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnZXJyb3InLCBmcilcblxuICAgICAgICAgIC8vIDQuIElmIGZy4oCZcyBzdGF0ZSBpcyBub3QgXCJsb2FkaW5nXCIsIGZpcmUgYSBwcm9ncmVzc1xuICAgICAgICAgIC8vICAgIGV2ZW50IGNhbGxlZCBsb2FkZW5kIGF0IGZyLlxuICAgICAgICAgIGlmIChmcltrU3RhdGVdICE9PSAnbG9hZGluZycpIHtcbiAgICAgICAgICAgIGZpcmVBUHJvZ3Jlc3NFdmVudCgnbG9hZGVuZCcsIGZyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfSkoKVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL0ZpbGVBUEkvI2ZpcmUtYS1wcm9ncmVzcy1ldmVudFxuICogQHNlZSBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtZXZlbnQtZmlyZVxuICogQHBhcmFtIHtzdHJpbmd9IGUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9maWxlcmVhZGVyJykuRmlsZVJlYWRlcn0gcmVhZGVyXG4gKi9cbmZ1bmN0aW9uIGZpcmVBUHJvZ3Jlc3NFdmVudCAoZSwgcmVhZGVyKSB7XG4gIC8vIFRoZSBwcm9ncmVzcyBldmVudCBlIGRvZXMgbm90IGJ1YmJsZS4gZS5idWJibGVzIG11c3QgYmUgZmFsc2VcbiAgLy8gVGhlIHByb2dyZXNzIGV2ZW50IGUgaXMgTk9UIGNhbmNlbGFibGUuIGUuY2FuY2VsYWJsZSBtdXN0IGJlIGZhbHNlXG4gIGNvbnN0IGV2ZW50ID0gbmV3IFByb2dyZXNzRXZlbnQoZSwge1xuICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgIGNhbmNlbGFibGU6IGZhbHNlXG4gIH0pXG5cbiAgcmVhZGVyLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3czYy5naXRodWIuaW8vRmlsZUFQSS8jYmxvYi1wYWNrYWdlLWRhdGFcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBieXRlc1xuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nP30gbWltZVR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nP30gZW5jb2RpbmdOYW1lXG4gKi9cbmZ1bmN0aW9uIHBhY2thZ2VEYXRhIChieXRlcywgdHlwZSwgbWltZVR5cGUsIGVuY29kaW5nTmFtZSkge1xuICAvLyAxLiBBIEJsb2IgaGFzIGFuIGFzc29jaWF0ZWQgcGFja2FnZSBkYXRhIGFsZ29yaXRobSwgZ2l2ZW5cbiAgLy8gICAgYnl0ZXMsIGEgdHlwZSwgYSBvcHRpb25hbCBtaW1lVHlwZSwgYW5kIGEgb3B0aW9uYWxcbiAgLy8gICAgZW5jb2RpbmdOYW1lLCB3aGljaCBzd2l0Y2hlcyBvbiB0eXBlIGFuZCBydW5zIHRoZVxuICAvLyAgICBhc3NvY2lhdGVkIHN0ZXBzOlxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ0RhdGFVUkwnOiB7XG4gICAgICAvLyAxLiBSZXR1cm4gYnl0ZXMgYXMgYSBEYXRhVVJMIFtSRkMyMzk3XSBzdWJqZWN0IHRvXG4gICAgICAvLyAgICB0aGUgY29uc2lkZXJhdGlvbnMgYmVsb3c6XG4gICAgICAvLyAgKiBVc2UgbWltZVR5cGUgYXMgcGFydCBvZiB0aGUgRGF0YSBVUkwgaWYgaXQgaXNcbiAgICAgIC8vICAgIGF2YWlsYWJsZSBpbiBrZWVwaW5nIHdpdGggdGhlIERhdGEgVVJMXG4gICAgICAvLyAgICBzcGVjaWZpY2F0aW9uIFtSRkMyMzk3XS5cbiAgICAgIC8vICAqIElmIG1pbWVUeXBlIGlzIG5vdCBhdmFpbGFibGUgcmV0dXJuIGEgRGF0YSBVUkxcbiAgICAgIC8vICAgIHdpdGhvdXQgYSBtZWRpYS10eXBlLiBbUkZDMjM5N10uXG5cbiAgICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMjM5NyNzZWN0aW9uLTNcbiAgICAgIC8vIGRhdGF1cmwgICAgOj0gXCJkYXRhOlwiIFsgbWVkaWF0eXBlIF0gWyBcIjtiYXNlNjRcIiBdIFwiLFwiIGRhdGFcbiAgICAgIC8vIG1lZGlhdHlwZSAgOj0gWyB0eXBlIFwiL1wiIHN1YnR5cGUgXSAqKCBcIjtcIiBwYXJhbWV0ZXIgKVxuICAgICAgLy8gZGF0YSAgICAgICA6PSAqdXJsY2hhclxuICAgICAgLy8gcGFyYW1ldGVyICA6PSBhdHRyaWJ1dGUgXCI9XCIgdmFsdWVcbiAgICAgIGxldCBkYXRhVVJMID0gJ2RhdGE6J1xuXG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlIHx8ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKVxuXG4gICAgICBpZiAocGFyc2VkICE9PSAnZmFpbHVyZScpIHtcbiAgICAgICAgZGF0YVVSTCArPSBzZXJpYWxpemVBTWltZVR5cGUocGFyc2VkKVxuICAgICAgfVxuXG4gICAgICBkYXRhVVJMICs9ICc7YmFzZTY0LCdcblxuICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKCdsYXRpbjEnKVxuXG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGJ5dGVzKSB7XG4gICAgICAgIGRhdGFVUkwgKz0gYnRvYShkZWNvZGVyLndyaXRlKGNodW5rKSlcbiAgICAgIH1cblxuICAgICAgZGF0YVVSTCArPSBidG9hKGRlY29kZXIuZW5kKCkpXG5cbiAgICAgIHJldHVybiBkYXRhVVJMXG4gICAgfVxuICAgIGNhc2UgJ1RleHQnOiB7XG4gICAgICAvLyAxLiBMZXQgZW5jb2RpbmcgYmUgZmFpbHVyZVxuICAgICAgbGV0IGVuY29kaW5nID0gJ2ZhaWx1cmUnXG5cbiAgICAgIC8vIDIuIElmIHRoZSBlbmNvZGluZ05hbWUgaXMgcHJlc2VudCwgc2V0IGVuY29kaW5nIHRvIHRoZVxuICAgICAgLy8gICAgcmVzdWx0IG9mIGdldHRpbmcgYW4gZW5jb2RpbmcgZnJvbSBlbmNvZGluZ05hbWUuXG4gICAgICBpZiAoZW5jb2RpbmdOYW1lKSB7XG4gICAgICAgIGVuY29kaW5nID0gZ2V0RW5jb2RpbmcoZW5jb2RpbmdOYW1lKVxuICAgICAgfVxuXG4gICAgICAvLyAzLiBJZiBlbmNvZGluZyBpcyBmYWlsdXJlLCBhbmQgbWltZVR5cGUgaXMgcHJlc2VudDpcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2ZhaWx1cmUnICYmIG1pbWVUeXBlKSB7XG4gICAgICAgIC8vIDEuIExldCB0eXBlIGJlIHRoZSByZXN1bHQgb2YgcGFyc2UgYSBNSU1FIHR5cGVcbiAgICAgICAgLy8gICAgZ2l2ZW4gbWltZVR5cGUuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJzZU1JTUVUeXBlKG1pbWVUeXBlKVxuXG4gICAgICAgIC8vIDIuIElmIHR5cGUgaXMgbm90IGZhaWx1cmUsIHNldCBlbmNvZGluZyB0byB0aGUgcmVzdWx0XG4gICAgICAgIC8vICAgIG9mIGdldHRpbmcgYW4gZW5jb2RpbmcgZnJvbSB0eXBl4oCZcyBwYXJhbWV0ZXJzW1wiY2hhcnNldFwiXS5cbiAgICAgICAgaWYgKHR5cGUgIT09ICdmYWlsdXJlJykge1xuICAgICAgICAgIGVuY29kaW5nID0gZ2V0RW5jb2RpbmcodHlwZS5wYXJhbWV0ZXJzLmdldCgnY2hhcnNldCcpKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDQuIElmIGVuY29kaW5nIGlzIGZhaWx1cmUsIHRoZW4gc2V0IGVuY29kaW5nIHRvIFVURi04LlxuICAgICAgaWYgKGVuY29kaW5nID09PSAnZmFpbHVyZScpIHtcbiAgICAgICAgZW5jb2RpbmcgPSAnVVRGLTgnXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIERlY29kZSBieXRlcyB1c2luZyBmYWxsYmFjayBlbmNvZGluZyBlbmNvZGluZywgYW5kXG4gICAgICAvLyAgICByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgIHJldHVybiBkZWNvZGUoYnl0ZXMsIGVuY29kaW5nKVxuICAgIH1cbiAgICBjYXNlICdBcnJheUJ1ZmZlcic6IHtcbiAgICAgIC8vIFJldHVybiBhIG5ldyBBcnJheUJ1ZmZlciB3aG9zZSBjb250ZW50cyBhcmUgYnl0ZXMuXG4gICAgICBjb25zdCBzZXF1ZW5jZSA9IGNvbWJpbmVCeXRlU2VxdWVuY2VzKGJ5dGVzKVxuXG4gICAgICByZXR1cm4gc2VxdWVuY2UuYnVmZmVyXG4gICAgfVxuICAgIGNhc2UgJ0JpbmFyeVN0cmluZyc6IHtcbiAgICAgIC8vIFJldHVybiBieXRlcyBhcyBhIGJpbmFyeSBzdHJpbmcsIGluIHdoaWNoIGV2ZXJ5IGJ5dGVcbiAgICAgIC8vICBpcyByZXByZXNlbnRlZCBieSBhIGNvZGUgdW5pdCBvZiBlcXVhbCB2YWx1ZSBbMC4uMjU1XS5cbiAgICAgIGxldCBiaW5hcnlTdHJpbmcgPSAnJ1xuXG4gICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoJ2xhdGluMScpXG5cbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgYnl0ZXMpIHtcbiAgICAgICAgYmluYXJ5U3RyaW5nICs9IGRlY29kZXIud3JpdGUoY2h1bmspXG4gICAgICB9XG5cbiAgICAgIGJpbmFyeVN0cmluZyArPSBkZWNvZGVyLmVuZCgpXG5cbiAgICAgIHJldHVybiBiaW5hcnlTdHJpbmdcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNkZWNvZGVcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBpb1F1ZXVlXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqL1xuZnVuY3Rpb24gZGVjb2RlIChpb1F1ZXVlLCBlbmNvZGluZykge1xuICBjb25zdCBieXRlcyA9IGNvbWJpbmVCeXRlU2VxdWVuY2VzKGlvUXVldWUpXG5cbiAgLy8gMS4gTGV0IEJPTUVuY29kaW5nIGJlIHRoZSByZXN1bHQgb2YgQk9NIHNuaWZmaW5nIGlvUXVldWUuXG4gIGNvbnN0IEJPTUVuY29kaW5nID0gQk9NU25pZmZpbmcoYnl0ZXMpXG5cbiAgbGV0IHNsaWNlID0gMFxuXG4gIC8vIDIuIElmIEJPTUVuY29kaW5nIGlzIG5vbi1udWxsOlxuICBpZiAoQk9NRW5jb2RpbmcgIT09IG51bGwpIHtcbiAgICAvLyAxLiBTZXQgZW5jb2RpbmcgdG8gQk9NRW5jb2RpbmcuXG4gICAgZW5jb2RpbmcgPSBCT01FbmNvZGluZ1xuXG4gICAgLy8gMi4gUmVhZCB0aHJlZSBieXRlcyBmcm9tIGlvUXVldWUsIGlmIEJPTUVuY29kaW5nIGlzXG4gICAgLy8gICAgVVRGLTg7IG90aGVyd2lzZSByZWFkIHR3byBieXRlcy5cbiAgICAvLyAgICAoRG8gbm90aGluZyB3aXRoIHRob3NlIGJ5dGVzLilcbiAgICBzbGljZSA9IEJPTUVuY29kaW5nID09PSAnVVRGLTgnID8gMyA6IDJcbiAgfVxuXG4gIC8vIDMuIFByb2Nlc3MgYSBxdWV1ZSB3aXRoIGFuIGluc3RhbmNlIG9mIGVuY29kaW5n4oCZc1xuICAvLyAgICBkZWNvZGVyLCBpb1F1ZXVlLCBvdXRwdXQsIGFuZCBcInJlcGxhY2VtZW50XCIuXG5cbiAgLy8gNC4gUmV0dXJuIG91dHB1dC5cblxuICBjb25zdCBzbGljZWQgPSBieXRlcy5zbGljZShzbGljZSlcbiAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZykuZGVjb2RlKHNsaWNlZClcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnLyNib20tc25pZmZcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gaW9RdWV1ZVxuICovXG5mdW5jdGlvbiBCT01TbmlmZmluZyAoaW9RdWV1ZSkge1xuICAvLyAxLiBMZXQgQk9NIGJlIHRoZSByZXN1bHQgb2YgcGVla2luZyAzIGJ5dGVzIGZyb20gaW9RdWV1ZSxcbiAgLy8gICAgY29udmVydGVkIHRvIGEgYnl0ZSBzZXF1ZW5jZS5cbiAgY29uc3QgW2EsIGIsIGNdID0gaW9RdWV1ZVxuXG4gIC8vIDIuIEZvciBlYWNoIG9mIHRoZSByb3dzIGluIHRoZSB0YWJsZSBiZWxvdywgc3RhcnRpbmcgd2l0aFxuICAvLyAgICB0aGUgZmlyc3Qgb25lIGFuZCBnb2luZyBkb3duLCBpZiBCT00gc3RhcnRzIHdpdGggdGhlXG4gIC8vICAgIGJ5dGVzIGdpdmVuIGluIHRoZSBmaXJzdCBjb2x1bW4sIHRoZW4gcmV0dXJuIHRoZVxuICAvLyAgICBlbmNvZGluZyBnaXZlbiBpbiB0aGUgY2VsbCBpbiB0aGUgc2Vjb25kIGNvbHVtbiBvZiB0aGF0XG4gIC8vICAgIHJvdy4gT3RoZXJ3aXNlLCByZXR1cm4gbnVsbC5cbiAgaWYgKGEgPT09IDB4RUYgJiYgYiA9PT0gMHhCQiAmJiBjID09PSAweEJGKSB7XG4gICAgcmV0dXJuICdVVEYtOCdcbiAgfSBlbHNlIGlmIChhID09PSAweEZFICYmIGIgPT09IDB4RkYpIHtcbiAgICByZXR1cm4gJ1VURi0xNkJFJ1xuICB9IGVsc2UgaWYgKGEgPT09IDB4RkYgJiYgYiA9PT0gMHhGRSkge1xuICAgIHJldHVybiAnVVRGLTE2TEUnXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheVtdfSBzZXF1ZW5jZXNcbiAqL1xuZnVuY3Rpb24gY29tYmluZUJ5dGVTZXF1ZW5jZXMgKHNlcXVlbmNlcykge1xuICBjb25zdCBzaXplID0gc2VxdWVuY2VzLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgIHJldHVybiBhICsgYi5ieXRlTGVuZ3RoXG4gIH0sIDApXG5cbiAgbGV0IG9mZnNldCA9IDBcblxuICByZXR1cm4gc2VxdWVuY2VzLnJlZHVjZSgoYSwgYikgPT4ge1xuICAgIGEuc2V0KGIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYi5ieXRlTGVuZ3RoXG4gICAgcmV0dXJuIGFcbiAgfSwgbmV3IFVpbnQ4QXJyYXkoc2l6ZSkpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICByZWFkT3BlcmF0aW9uLFxuICBmaXJlQVByb2dyZXNzRXZlbnRcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/fileapi/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/connection.js":
/*!*************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/connection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { uid, states, sentCloseFrameState, emptyBuffer, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst {\n  kReadyState,\n  kSentClose,\n  kByteParser,\n  kReceivedClose,\n  kResponse\n} = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/websocket/symbols.js\")\nconst { fireEvent, failWebsocketConnection, isClosing, isClosed, isEstablished, parseExtensions } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst { CloseEvent } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { makeRequest } = __webpack_require__(/*! ../fetch/request */ \"(rsc)/./node_modules/undici/lib/web/fetch/request.js\")\nconst { fetching } = __webpack_require__(/*! ../fetch/index */ \"(rsc)/./node_modules/undici/lib/web/fetch/index.js\")\nconst { Headers, getHeadersList } = __webpack_require__(/*! ../fetch/headers */ \"(rsc)/./node_modules/undici/lib/web/fetch/headers.js\")\nconst { getDecodeSplit } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\n\n/** @type {import('crypto')} */\nlet crypto\ntry {\n  crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n/* c8 ignore next 3 */\n} catch {\n\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n * @param {(response: any, extensions: string[] | undefined) => void} onEstablish\n * @param {Partial<import('../../types/websocket').WebSocketInit>} options\n */\nfunction establishWebSocketConnection (url, protocols, client, ws, onEstablish, options) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    client,\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  })\n\n  // Note: undici extension, allow setting custom headers.\n  if (options.headers) {\n    const headersList = getHeadersList(new Headers(options.headers))\n\n    request.headersList = headersList\n  }\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = crypto.randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13')\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  const permessageDeflate = 'permessage-deflate; client_max_window_bits'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  request.headersList.append('sec-websocket-extensions', permessageDeflate)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: options.dispatcher,\n    processResponse (response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.')\n        return\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = crypto.createHash('sha1').update(keyValue + uid).digest('base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n      let extensions\n\n      if (secExtension !== null) {\n        extensions = parseExtensions(secExtension)\n\n        if (!extensions.has('permessage-deflate')) {\n          failWebsocketConnection(ws, 'Sec-WebSocket-Extensions header does not match.')\n          return\n        }\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null) {\n        const requestProtocols = getDecodeSplit('sec-websocket-protocol', request.headersList)\n\n        // The client can request that the server use a specific subprotocol by\n        // including the |Sec-WebSocket-Protocol| field in its handshake.  If it\n        // is specified, the server needs to include the same field and one of\n        // the selected subprotocol values in its response for the connection to\n        // be established.\n        if (!requestProtocols.includes(secProtocol)) {\n          failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.')\n          return\n        }\n      }\n\n      response.socket.on('data', onSocketData)\n      response.socket.on('close', onSocketClose)\n      response.socket.on('error', onSocketError)\n\n      if (channels.open.hasSubscribers) {\n        channels.open.publish({\n          address: response.socket.address(),\n          protocol: secProtocol,\n          extensions: secExtension\n        })\n      }\n\n      onEstablish(response, extensions)\n    }\n  })\n\n  return controller\n}\n\nfunction closeWebSocketConnection (ws, code, reason, reasonByteLength) {\n  if (isClosing(ws) || isClosed(ws)) {\n    // If this's ready state is CLOSING (2) or CLOSED (3)\n    // Do nothing.\n  } else if (!isEstablished(ws)) {\n    // If the WebSocket connection is not yet established\n    // Fail the WebSocket connection and set this's ready state\n    // to CLOSING (2).\n    failWebsocketConnection(ws, 'Connection was closed before it was established.')\n    ws[kReadyState] = states.CLOSING\n  } else if (ws[kSentClose] === sentCloseFrameState.NOT_SENT) {\n    // If the WebSocket closing handshake has not yet been started\n    // Start the WebSocket closing handshake and set this's ready\n    // state to CLOSING (2).\n    // - If neither code nor reason is present, the WebSocket Close\n    //   message must not have a body.\n    // - If code is present, then the status code to use in the\n    //   WebSocket Close message must be the integer given by code.\n    // - If reason is also present, then reasonBytes must be\n    //   provided in the Close message after the status code.\n\n    ws[kSentClose] = sentCloseFrameState.PROCESSING\n\n    const frame = new WebsocketFrameSend()\n\n    // If neither code nor reason is present, the WebSocket Close\n    // message must not have a body.\n\n    // If code is present, then the status code to use in the\n    // WebSocket Close message must be the integer given by code.\n    if (code !== undefined && reason === undefined) {\n      frame.frameData = Buffer.allocUnsafe(2)\n      frame.frameData.writeUInt16BE(code, 0)\n    } else if (code !== undefined && reason !== undefined) {\n      // If reason is also present, then reasonBytes must be\n      // provided in the Close message after the status code.\n      frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)\n      frame.frameData.writeUInt16BE(code, 0)\n      // the body MAY contain UTF-8-encoded data with value /reason/\n      frame.frameData.write(reason, 2, 'utf-8')\n    } else {\n      frame.frameData = emptyBuffer\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = ws[kResponse].socket\n\n    socket.write(frame.createFrame(opcodes.CLOSE))\n\n    ws[kSentClose] = sentCloseFrameState.SENT\n\n    // Upon either sending or receiving a Close control frame, it is said\n    // that _The WebSocket Closing Handshake is Started_ and that the\n    // WebSocket connection is in the CLOSING state.\n    ws[kReadyState] = states.CLOSING\n  } else {\n    // Otherwise\n    // Set this's ready state to CLOSING (2).\n    ws[kReadyState] = states.CLOSING\n  }\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData (chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause()\n  }\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose () {\n  const { ws } = this\n  const { [kResponse]: response } = ws\n\n  response.socket.off('data', onSocketData)\n  response.socket.off('close', onSocketClose)\n  response.socket.off('error', onSocketError)\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] === sentCloseFrameState.SENT && ws[kReceivedClose]\n\n  let code = 1005\n  let reason = ''\n\n  const result = ws[kByteParser].closingInfo\n\n  if (result && !result.error) {\n    code = result.code ?? 1005\n    reason = result.reason\n  } else if (!ws[kReceivedClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  // TODO: process.nextTick\n  fireEvent('close', ws, (type, init) => new CloseEvent(type, init), {\n    wasClean, code, reason\n  })\n\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    })\n  }\n}\n\nfunction onSocketError (error) {\n  const { ws } = this\n\n  ws[kReadyState] = states.CLOSING\n\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error)\n  }\n\n  this.destroy()\n}\n\nmodule.exports = {\n  establishWebSocketConnection,\n  closeWebSocketConnection\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2Nvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSx5REFBeUQsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFXO0FBQ3ZCLFFBQVEsMEZBQTBGLEVBQUUsbUJBQU8sQ0FBQyxxRUFBUTtBQUNwSCxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLG1GQUF3QjtBQUNyRCxRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHlFQUFVO0FBQ3pDLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsOEVBQWtCO0FBQ2xELFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsMEVBQWdCO0FBQzdDLFFBQVEsMEJBQTBCLEVBQUUsbUJBQU8sQ0FBQyw4RUFBa0I7QUFDOUQsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLHdFQUFlO0FBQ2xELFFBQVEscUJBQXFCLEVBQUUsbUJBQU8sQ0FBQyx1RUFBUzs7QUFFaEQsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxnQ0FBYTtBQUNoQztBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlDQUFpQztBQUM1QyxXQUFXLDJEQUEyRDtBQUN0RSxXQUFXLHdEQUF3RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsZUFBZSx5QkFBeUI7QUFDeEM7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmLFVBQVUsd0JBQXdCOztBQUVsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFVBQVUsS0FBSzs7QUFFZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcY29ubmVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyB1aWQsIHN0YXRlcywgc2VudENsb3NlRnJhbWVTdGF0ZSwgZW1wdHlCdWZmZXIsIG9wY29kZXMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHtcbiAga1JlYWR5U3RhdGUsXG4gIGtTZW50Q2xvc2UsXG4gIGtCeXRlUGFyc2VyLFxuICBrUmVjZWl2ZWRDbG9zZSxcbiAga1Jlc3BvbnNlXG59ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgZmlyZUV2ZW50LCBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbiwgaXNDbG9zaW5nLCBpc0Nsb3NlZCwgaXNFc3RhYmxpc2hlZCwgcGFyc2VFeHRlbnNpb25zIH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuY29uc3QgeyBjaGFubmVscyB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9kaWFnbm9zdGljcycpXG5jb25zdCB7IENsb3NlRXZlbnQgfSA9IHJlcXVpcmUoJy4vZXZlbnRzJylcbmNvbnN0IHsgbWFrZVJlcXVlc3QgfSA9IHJlcXVpcmUoJy4uL2ZldGNoL3JlcXVlc3QnKVxuY29uc3QgeyBmZXRjaGluZyB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaW5kZXgnKVxuY29uc3QgeyBIZWFkZXJzLCBnZXRIZWFkZXJzTGlzdCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvaGVhZGVycycpXG5jb25zdCB7IGdldERlY29kZVNwbGl0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcbmNvbnN0IHsgV2Vic29ja2V0RnJhbWVTZW5kIH0gPSByZXF1aXJlKCcuL2ZyYW1lJylcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2NyeXB0bycpfSAqL1xubGV0IGNyeXB0b1xudHJ5IHtcbiAgY3J5cHRvID0gcmVxdWlyZSgnbm9kZTpjcnlwdG8nKVxuLyogYzggaWdub3JlIG5leHQgMyAqL1xufSBjYXRjaCB7XG5cbn1cblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtd2Vic29ja2V0LWVzdGFibGlzaFxuICogQHBhcmFtIHtVUkx9IHVybFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHByb3RvY29sc1xuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHBhcmFtIHsocmVzcG9uc2U6IGFueSwgZXh0ZW5zaW9uczogc3RyaW5nW10gfCB1bmRlZmluZWQpID0+IHZvaWR9IG9uRXN0YWJsaXNoXG4gKiBAcGFyYW0ge1BhcnRpYWw8aW1wb3J0KCcuLi8uLi90eXBlcy93ZWJzb2NrZXQnKS5XZWJTb2NrZXRJbml0Pn0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uICh1cmwsIHByb3RvY29scywgY2xpZW50LCB3cywgb25Fc3RhYmxpc2gsIG9wdGlvbnMpIHtcbiAgLy8gMS4gTGV0IHJlcXVlc3RVUkwgYmUgYSBjb3B5IG9mIHVybCwgd2l0aCBpdHMgc2NoZW1lIHNldCB0byBcImh0dHBcIiwgaWYgdXJs4oCZc1xuICAvLyAgICBzY2hlbWUgaXMgXCJ3c1wiLCBhbmQgdG8gXCJodHRwc1wiIG90aGVyd2lzZS5cbiAgY29uc3QgcmVxdWVzdFVSTCA9IHVybFxuXG4gIHJlcXVlc3RVUkwucHJvdG9jb2wgPSB1cmwucHJvdG9jb2wgPT09ICd3czonID8gJ2h0dHA6JyA6ICdodHRwczonXG5cbiAgLy8gMi4gTGV0IHJlcXVlc3QgYmUgYSBuZXcgcmVxdWVzdCwgd2hvc2UgVVJMIGlzIHJlcXVlc3RVUkwsIGNsaWVudCBpcyBjbGllbnQsXG4gIC8vICAgIHNlcnZpY2Utd29ya2VycyBtb2RlIGlzIFwibm9uZVwiLCByZWZlcnJlciBpcyBcIm5vLXJlZmVycmVyXCIsIG1vZGUgaXNcbiAgLy8gICAgXCJ3ZWJzb2NrZXRcIiwgY3JlZGVudGlhbHMgbW9kZSBpcyBcImluY2x1ZGVcIiwgY2FjaGUgbW9kZSBpcyBcIm5vLXN0b3JlXCIgLFxuICAvLyAgICBhbmQgcmVkaXJlY3QgbW9kZSBpcyBcImVycm9yXCIuXG4gIGNvbnN0IHJlcXVlc3QgPSBtYWtlUmVxdWVzdCh7XG4gICAgdXJsTGlzdDogW3JlcXVlc3RVUkxdLFxuICAgIGNsaWVudCxcbiAgICBzZXJ2aWNlV29ya2VyczogJ25vbmUnLFxuICAgIHJlZmVycmVyOiAnbm8tcmVmZXJyZXInLFxuICAgIG1vZGU6ICd3ZWJzb2NrZXQnLFxuICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgY2FjaGU6ICduby1zdG9yZScsXG4gICAgcmVkaXJlY3Q6ICdlcnJvcidcbiAgfSlcblxuICAvLyBOb3RlOiB1bmRpY2kgZXh0ZW5zaW9uLCBhbGxvdyBzZXR0aW5nIGN1c3RvbSBoZWFkZXJzLlxuICBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyc0xpc3QgPSBnZXRIZWFkZXJzTGlzdChuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpKVxuXG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdCA9IGhlYWRlcnNMaXN0XG4gIH1cblxuICAvLyAzLiBBcHBlbmQgKGBVcGdyYWRlYCwgYHdlYnNvY2tldGApIHRvIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICAvLyA0LiBBcHBlbmQgKGBDb25uZWN0aW9uYCwgYFVwZ3JhZGVgKSB0byByZXF1ZXN04oCZcyBoZWFkZXIgbGlzdC5cbiAgLy8gTm90ZTogYm90aCBvZiB0aGVzZSBhcmUgaGFuZGxlZCBieSB1bmRpY2kgY3VycmVudGx5LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL3VuZGljaS9ibG9iLzY4YzI2OWM0MTQ0YzQ0NmYzZjEyMjA5NTEzMzhkYWVmNGE2YjVlYzQvbGliL2NsaWVudC5qcyNMMTM5N1xuXG4gIC8vIDUuIExldCBrZXlWYWx1ZSBiZSBhIG5vbmNlIGNvbnNpc3Rpbmcgb2YgYSByYW5kb21seSBzZWxlY3RlZFxuICAvLyAgICAxNi1ieXRlIHZhbHVlIHRoYXQgaGFzIGJlZW4gZm9yZ2l2aW5nLWJhc2U2NC1lbmNvZGVkIGFuZFxuICAvLyAgICBpc29tb3JwaGljIGVuY29kZWQuXG4gIGNvbnN0IGtleVZhbHVlID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0JylcblxuICAvLyA2LiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LUtleWAsIGtleVZhbHVlKSB0byByZXF1ZXN04oCZc1xuICAvLyAgICBoZWFkZXIgbGlzdC5cbiAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQta2V5Jywga2V5VmFsdWUpXG5cbiAgLy8gNy4gQXBwZW5kIChgU2VjLVdlYlNvY2tldC1WZXJzaW9uYCwgYDEzYCkgdG8gcmVxdWVzdOKAmXNcbiAgLy8gICAgaGVhZGVyIGxpc3QuXG4gIHJlcXVlc3QuaGVhZGVyc0xpc3QuYXBwZW5kKCdzZWMtd2Vic29ja2V0LXZlcnNpb24nLCAnMTMnKVxuXG4gIC8vIDguIEZvciBlYWNoIHByb3RvY29sIGluIHByb3RvY29scywgY29tYmluZVxuICAvLyAgICAoYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgLCBwcm90b2NvbCkgaW4gcmVxdWVzdOKAmXMgaGVhZGVyXG4gIC8vICAgIGxpc3QuXG4gIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgcmVxdWVzdC5oZWFkZXJzTGlzdC5hcHBlbmQoJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnLCBwcm90b2NvbClcbiAgfVxuXG4gIC8vIDkuIExldCBwZXJtZXNzYWdlRGVmbGF0ZSBiZSBhIHVzZXItYWdlbnQgZGVmaW5lZFxuICAvLyAgICBcInBlcm1lc3NhZ2UtZGVmbGF0ZVwiIGV4dGVuc2lvbiBoZWFkZXIgdmFsdWUuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iL2NlNzgyMzRmNWU2NTNhNWQzOTE2ODEzZmY5OTBmMDUzNTEwMjI3YmMvbmV0d2Vyay9wcm90b2NvbC93ZWJzb2NrZXQvV2ViU29ja2V0Q2hhbm5lbC5jcHAjTDI2NzNcbiAgY29uc3QgcGVybWVzc2FnZURlZmxhdGUgPSAncGVybWVzc2FnZS1kZWZsYXRlOyBjbGllbnRfbWF4X3dpbmRvd19iaXRzJ1xuXG4gIC8vIDEwLiBBcHBlbmQgKGBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnNgLCBwZXJtZXNzYWdlRGVmbGF0ZSkgdG9cbiAgLy8gICAgIHJlcXVlc3TigJlzIGhlYWRlciBsaXN0LlxuICByZXF1ZXN0LmhlYWRlcnNMaXN0LmFwcGVuZCgnc2VjLXdlYnNvY2tldC1leHRlbnNpb25zJywgcGVybWVzc2FnZURlZmxhdGUpXG5cbiAgLy8gMTEuIEZldGNoIHJlcXVlc3Qgd2l0aCB1c2VQYXJhbGxlbFF1ZXVlIHNldCB0byB0cnVlLCBhbmRcbiAgLy8gICAgIHByb2Nlc3NSZXNwb25zZSBnaXZlbiByZXNwb25zZSBiZWluZyB0aGVzZSBzdGVwczpcbiAgY29uc3QgY29udHJvbGxlciA9IGZldGNoaW5nKHtcbiAgICByZXF1ZXN0LFxuICAgIHVzZVBhcmFsbGVsUXVldWU6IHRydWUsXG4gICAgZGlzcGF0Y2hlcjogb3B0aW9ucy5kaXNwYXRjaGVyLFxuICAgIHByb2Nlc3NSZXNwb25zZSAocmVzcG9uc2UpIHtcbiAgICAgIC8vIDEuIElmIHJlc3BvbnNlIGlzIGEgbmV0d29yayBlcnJvciBvciBpdHMgc3RhdHVzIGlzIG5vdCAxMDEsXG4gICAgICAvLyAgICBmYWlsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgICAgIGlmIChyZXNwb25zZS50eXBlID09PSAnZXJyb3InIHx8IHJlc3BvbnNlLnN0YXR1cyAhPT0gMTAxKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUmVjZWl2ZWQgbmV0d29yayBlcnJvciBvciBub24tMTAxIHN0YXR1cyBjb2RlLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAyLiBJZiBwcm90b2NvbHMgaXMgbm90IHRoZSBlbXB0eSBsaXN0IGFuZCBleHRyYWN0aW5nIGhlYWRlclxuICAgICAgLy8gICAgbGlzdCB2YWx1ZXMgZ2l2ZW4gYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGFuZCByZXNwb25zZeKAmXNcbiAgICAgIC8vICAgIGhlYWRlciBsaXN0IHJlc3VsdHMgaW4gbnVsbCwgZmFpbHVyZSwgb3IgdGhlIGVtcHR5IGJ5dGVcbiAgICAgIC8vICAgIHNlcXVlbmNlLCB0aGVuIGZhaWwgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICAgICAgaWYgKHByb3RvY29scy5sZW5ndGggIT09IDAgJiYgIXJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnU2VjLVdlYlNvY2tldC1Qcm90b2NvbCcpKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnU2VydmVyIGRpZCBub3QgcmVzcG9uZCB3aXRoIHNlbnQgcHJvdG9jb2xzLicpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyAzLiBGb2xsb3cgdGhlIHJlcXVpcmVtZW50cyBzdGF0ZWQgc3RlcCAyIHRvIHN0ZXAgNiwgaW5jbHVzaXZlLFxuICAgICAgLy8gICAgb2YgdGhlIGxhc3Qgc2V0IG9mIHN0ZXBzIGluIHNlY3Rpb24gNC4xIG9mIFRoZSBXZWJTb2NrZXRcbiAgICAgIC8vICAgIFByb3RvY29sIHRvIHZhbGlkYXRlIHJlc3BvbnNlLiBUaGlzIGVpdGhlciByZXN1bHRzIGluIGZhaWxcbiAgICAgIC8vICAgIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBvciB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgICAgIC8vICAgIGVzdGFibGlzaGVkLlxuXG4gICAgICAvLyAyLiBJZiB0aGUgcmVzcG9uc2UgbGFja3MgYW4gfFVwZ3JhZGV8IGhlYWRlciBmaWVsZCBvciB0aGUgfFVwZ3JhZGV8XG4gICAgICAvLyAgICBoZWFkZXIgZmllbGQgY29udGFpbnMgYSB2YWx1ZSB0aGF0IGlzIG5vdCBhbiBBU0NJSSBjYXNlLVxuICAgICAgLy8gICAgaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIHRoZSB2YWx1ZSBcIndlYnNvY2tldFwiLCB0aGUgY2xpZW50IE1VU1RcbiAgICAgIC8vICAgIF9GYWlsIHRoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbl8uXG4gICAgICBpZiAocmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdVcGdyYWRlJyk/LnRvTG93ZXJDYXNlKCkgIT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnU2VydmVyIGRpZCBub3Qgc2V0IFVwZ3JhZGUgaGVhZGVyIHRvIFwid2Vic29ja2V0XCIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDMuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhIHxDb25uZWN0aW9ufCBoZWFkZXIgZmllbGQgb3IgdGhlXG4gICAgICAvLyAgICB8Q29ubmVjdGlvbnwgaGVhZGVyIGZpZWxkIGRvZXNuJ3QgY29udGFpbiBhIHRva2VuIHRoYXQgaXMgYW5cbiAgICAgIC8vICAgIEFTQ0lJIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2ggZm9yIHRoZSB2YWx1ZSBcIlVwZ3JhZGVcIiwgdGhlIGNsaWVudFxuICAgICAgLy8gICAgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnNMaXN0LmdldCgnQ29ubmVjdGlvbicpPy50b0xvd2VyQ2FzZSgpICE9PSAndXBncmFkZScpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdTZXJ2ZXIgZGlkIG5vdCBzZXQgQ29ubmVjdGlvbiBoZWFkZXIgdG8gXCJ1cGdyYWRlXCIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDQuIElmIHRoZSByZXNwb25zZSBsYWNrcyBhIHxTZWMtV2ViU29ja2V0LUFjY2VwdHwgaGVhZGVyIGZpZWxkIG9yXG4gICAgICAvLyAgICB0aGUgfFNlYy1XZWJTb2NrZXQtQWNjZXB0fCBjb250YWlucyBhIHZhbHVlIG90aGVyIHRoYW4gdGhlXG4gICAgICAvLyAgICBiYXNlNjQtZW5jb2RlZCBTSEEtMSBvZiB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgfFNlYy1XZWJTb2NrZXQtXG4gICAgICAvLyAgICBLZXl8IChhcyBhIHN0cmluZywgbm90IGJhc2U2NC1kZWNvZGVkKSB3aXRoIHRoZSBzdHJpbmcgXCIyNThFQUZBNS1cbiAgICAgIC8vICAgIEU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMVwiIGJ1dCBpZ25vcmluZyBhbnkgbGVhZGluZyBhbmRcbiAgICAgIC8vICAgIHRyYWlsaW5nIHdoaXRlc3BhY2UsIHRoZSBjbGllbnQgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyAgICBDb25uZWN0aW9uXy5cbiAgICAgIGNvbnN0IHNlY1dTQWNjZXB0ID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LUFjY2VwdCcpXG4gICAgICBjb25zdCBkaWdlc3QgPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShrZXlWYWx1ZSArIHVpZCkuZGlnZXN0KCdiYXNlNjQnKVxuICAgICAgaWYgKHNlY1dTQWNjZXB0ICE9PSBkaWdlc3QpIHtcbiAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24od3MsICdJbmNvcnJlY3QgaGFzaCByZWNlaXZlZCBpbiBTZWMtV2ViU29ja2V0LUFjY2VwdCBoZWFkZXIuJylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIDUuIElmIHRoZSByZXNwb25zZSBpbmNsdWRlcyBhIHxTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnN8IGhlYWRlclxuICAgICAgLy8gICAgZmllbGQgYW5kIHRoaXMgaGVhZGVyIGZpZWxkIGluZGljYXRlcyB0aGUgdXNlIG9mIGFuIGV4dGVuc2lvblxuICAgICAgLy8gICAgdGhhdCB3YXMgbm90IHByZXNlbnQgaW4gdGhlIGNsaWVudCdzIGhhbmRzaGFrZSAodGhlIHNlcnZlciBoYXNcbiAgICAgIC8vICAgIGluZGljYXRlZCBhbiBleHRlbnNpb24gbm90IHJlcXVlc3RlZCBieSB0aGUgY2xpZW50KSwgdGhlIGNsaWVudFxuICAgICAgLy8gICAgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLiAgKFRoZSBwYXJzaW5nIG9mIHRoaXNcbiAgICAgIC8vICAgIGhlYWRlciBmaWVsZCB0byBkZXRlcm1pbmUgd2hpY2ggZXh0ZW5zaW9ucyBhcmUgcmVxdWVzdGVkIGlzXG4gICAgICAvLyAgICBkaXNjdXNzZWQgaW4gU2VjdGlvbiA5LjEuKVxuICAgICAgY29uc3Qgc2VjRXh0ZW5zaW9uID0gcmVzcG9uc2UuaGVhZGVyc0xpc3QuZ2V0KCdTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnKVxuICAgICAgbGV0IGV4dGVuc2lvbnNcblxuICAgICAgaWYgKHNlY0V4dGVuc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICBleHRlbnNpb25zID0gcGFyc2VFeHRlbnNpb25zKHNlY0V4dGVuc2lvbilcblxuICAgICAgICBpZiAoIWV4dGVuc2lvbnMuaGFzKCdwZXJtZXNzYWdlLWRlZmxhdGUnKSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlciBkb2VzIG5vdCBtYXRjaC4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIDYuIElmIHRoZSByZXNwb25zZSBpbmNsdWRlcyBhIHxTZWMtV2ViU29ja2V0LVByb3RvY29sfCBoZWFkZXIgZmllbGRcbiAgICAgIC8vICAgIGFuZCB0aGlzIGhlYWRlciBmaWVsZCBpbmRpY2F0ZXMgdGhlIHVzZSBvZiBhIHN1YnByb3RvY29sIHRoYXQgd2FzXG4gICAgICAvLyAgICBub3QgcHJlc2VudCBpbiB0aGUgY2xpZW50J3MgaGFuZHNoYWtlICh0aGUgc2VydmVyIGhhcyBpbmRpY2F0ZWQgYVxuICAgICAgLy8gICAgc3VicHJvdG9jb2wgbm90IHJlcXVlc3RlZCBieSB0aGUgY2xpZW50KSwgdGhlIGNsaWVudCBNVVNUIF9GYWlsXG4gICAgICAvLyAgICB0aGUgV2ViU29ja2V0IENvbm5lY3Rpb25fLlxuICAgICAgY29uc3Qgc2VjUHJvdG9jb2wgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ1NlYy1XZWJTb2NrZXQtUHJvdG9jb2wnKVxuXG4gICAgICBpZiAoc2VjUHJvdG9jb2wgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdFByb3RvY29scyA9IGdldERlY29kZVNwbGl0KCdzZWMtd2Vic29ja2V0LXByb3RvY29sJywgcmVxdWVzdC5oZWFkZXJzTGlzdClcblxuICAgICAgICAvLyBUaGUgY2xpZW50IGNhbiByZXF1ZXN0IHRoYXQgdGhlIHNlcnZlciB1c2UgYSBzcGVjaWZpYyBzdWJwcm90b2NvbCBieVxuICAgICAgICAvLyBpbmNsdWRpbmcgdGhlIHxTZWMtV2ViU29ja2V0LVByb3RvY29sfCBmaWVsZCBpbiBpdHMgaGFuZHNoYWtlLiAgSWYgaXRcbiAgICAgICAgLy8gaXMgc3BlY2lmaWVkLCB0aGUgc2VydmVyIG5lZWRzIHRvIGluY2x1ZGUgdGhlIHNhbWUgZmllbGQgYW5kIG9uZSBvZlxuICAgICAgICAvLyB0aGUgc2VsZWN0ZWQgc3VicHJvdG9jb2wgdmFsdWVzIGluIGl0cyByZXNwb25zZSBmb3IgdGhlIGNvbm5lY3Rpb24gdG9cbiAgICAgICAgLy8gYmUgZXN0YWJsaXNoZWQuXG4gICAgICAgIGlmICghcmVxdWVzdFByb3RvY29scy5pbmNsdWRlcyhzZWNQcm90b2NvbCkpIHtcbiAgICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ1Byb3RvY29sIHdhcyBub3Qgc2V0IGluIHRoZSBvcGVuaW5nIGhhbmRzaGFrZS4nKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3BvbnNlLnNvY2tldC5vbignZGF0YScsIG9uU29ja2V0RGF0YSlcbiAgICAgIHJlc3BvbnNlLnNvY2tldC5vbignY2xvc2UnLCBvblNvY2tldENsb3NlKVxuICAgICAgcmVzcG9uc2Uuc29ja2V0Lm9uKCdlcnJvcicsIG9uU29ja2V0RXJyb3IpXG5cbiAgICAgIGlmIChjaGFubmVscy5vcGVuLmhhc1N1YnNjcmliZXJzKSB7XG4gICAgICAgIGNoYW5uZWxzLm9wZW4ucHVibGlzaCh7XG4gICAgICAgICAgYWRkcmVzczogcmVzcG9uc2Uuc29ja2V0LmFkZHJlc3MoKSxcbiAgICAgICAgICBwcm90b2NvbDogc2VjUHJvdG9jb2wsXG4gICAgICAgICAgZXh0ZW5zaW9uczogc2VjRXh0ZW5zaW9uXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIG9uRXN0YWJsaXNoKHJlc3BvbnNlLCBleHRlbnNpb25zKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gY29udHJvbGxlclxufVxuXG5mdW5jdGlvbiBjbG9zZVdlYlNvY2tldENvbm5lY3Rpb24gKHdzLCBjb2RlLCByZWFzb24sIHJlYXNvbkJ5dGVMZW5ndGgpIHtcbiAgaWYgKGlzQ2xvc2luZyh3cykgfHwgaXNDbG9zZWQod3MpKSB7XG4gICAgLy8gSWYgdGhpcydzIHJlYWR5IHN0YXRlIGlzIENMT1NJTkcgKDIpIG9yIENMT1NFRCAoMylcbiAgICAvLyBEbyBub3RoaW5nLlxuICB9IGVsc2UgaWYgKCFpc0VzdGFibGlzaGVkKHdzKSkge1xuICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBub3QgeWV0IGVzdGFibGlzaGVkXG4gICAgLy8gRmFpbCB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gYW5kIHNldCB0aGlzJ3MgcmVhZHkgc3RhdGVcbiAgICAvLyB0byBDTE9TSU5HICgyKS5cbiAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih3cywgJ0Nvbm5lY3Rpb24gd2FzIGNsb3NlZCBiZWZvcmUgaXQgd2FzIGVzdGFibGlzaGVkLicpXG4gICAgd3Nba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NJTkdcbiAgfSBlbHNlIGlmICh3c1trU2VudENsb3NlXSA9PT0gc2VudENsb3NlRnJhbWVTdGF0ZS5OT1RfU0VOVCkge1xuICAgIC8vIElmIHRoZSBXZWJTb2NrZXQgY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgYmVlbiBzdGFydGVkXG4gICAgLy8gU3RhcnQgdGhlIFdlYlNvY2tldCBjbG9zaW5nIGhhbmRzaGFrZSBhbmQgc2V0IHRoaXMncyByZWFkeVxuICAgIC8vIHN0YXRlIHRvIENMT1NJTkcgKDIpLlxuICAgIC8vIC0gSWYgbmVpdGhlciBjb2RlIG5vciByZWFzb24gaXMgcHJlc2VudCwgdGhlIFdlYlNvY2tldCBDbG9zZVxuICAgIC8vICAgbWVzc2FnZSBtdXN0IG5vdCBoYXZlIGEgYm9keS5cbiAgICAvLyAtIElmIGNvZGUgaXMgcHJlc2VudCwgdGhlbiB0aGUgc3RhdHVzIGNvZGUgdG8gdXNlIGluIHRoZVxuICAgIC8vICAgV2ViU29ja2V0IENsb3NlIG1lc3NhZ2UgbXVzdCBiZSB0aGUgaW50ZWdlciBnaXZlbiBieSBjb2RlLlxuICAgIC8vIC0gSWYgcmVhc29uIGlzIGFsc28gcHJlc2VudCwgdGhlbiByZWFzb25CeXRlcyBtdXN0IGJlXG4gICAgLy8gICBwcm92aWRlZCBpbiB0aGUgQ2xvc2UgbWVzc2FnZSBhZnRlciB0aGUgc3RhdHVzIGNvZGUuXG5cbiAgICB3c1trU2VudENsb3NlXSA9IHNlbnRDbG9zZUZyYW1lU3RhdGUuUFJPQ0VTU0lOR1xuXG4gICAgY29uc3QgZnJhbWUgPSBuZXcgV2Vic29ja2V0RnJhbWVTZW5kKClcblxuICAgIC8vIElmIG5laXRoZXIgY29kZSBub3IgcmVhc29uIGlzIHByZXNlbnQsIHRoZSBXZWJTb2NrZXQgQ2xvc2VcbiAgICAvLyBtZXNzYWdlIG11c3Qgbm90IGhhdmUgYSBib2R5LlxuXG4gICAgLy8gSWYgY29kZSBpcyBwcmVzZW50LCB0aGVuIHRoZSBzdGF0dXMgY29kZSB0byB1c2UgaW4gdGhlXG4gICAgLy8gV2ViU29ja2V0IENsb3NlIG1lc3NhZ2UgbXVzdCBiZSB0aGUgaW50ZWdlciBnaXZlbiBieSBjb2RlLlxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQgJiYgcmVhc29uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKVxuICAgICAgZnJhbWUuZnJhbWVEYXRhLndyaXRlVUludDE2QkUoY29kZSwgMClcbiAgICB9IGVsc2UgaWYgKGNvZGUgIT09IHVuZGVmaW5lZCAmJiByZWFzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSWYgcmVhc29uIGlzIGFsc28gcHJlc2VudCwgdGhlbiByZWFzb25CeXRlcyBtdXN0IGJlXG4gICAgICAvLyBwcm92aWRlZCBpbiB0aGUgQ2xvc2UgbWVzc2FnZSBhZnRlciB0aGUgc3RhdHVzIGNvZGUuXG4gICAgICBmcmFtZS5mcmFtZURhdGEgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIHJlYXNvbkJ5dGVMZW5ndGgpXG4gICAgICBmcmFtZS5mcmFtZURhdGEud3JpdGVVSW50MTZCRShjb2RlLCAwKVxuICAgICAgLy8gdGhlIGJvZHkgTUFZIGNvbnRhaW4gVVRGLTgtZW5jb2RlZCBkYXRhIHdpdGggdmFsdWUgL3JlYXNvbi9cbiAgICAgIGZyYW1lLmZyYW1lRGF0YS53cml0ZShyZWFzb24sIDIsICd1dGYtOCcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZyYW1lLmZyYW1lRGF0YSA9IGVtcHR5QnVmZmVyXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtpbXBvcnQoJ3N0cmVhbScpLkR1cGxleH0gKi9cbiAgICBjb25zdCBzb2NrZXQgPSB3c1trUmVzcG9uc2VdLnNvY2tldFxuXG4gICAgc29ja2V0LndyaXRlKGZyYW1lLmNyZWF0ZUZyYW1lKG9wY29kZXMuQ0xPU0UpKVxuXG4gICAgd3Nba1NlbnRDbG9zZV0gPSBzZW50Q2xvc2VGcmFtZVN0YXRlLlNFTlRcblxuICAgIC8vIFVwb24gZWl0aGVyIHNlbmRpbmcgb3IgcmVjZWl2aW5nIGEgQ2xvc2UgY29udHJvbCBmcmFtZSwgaXQgaXMgc2FpZFxuICAgIC8vIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ2xvc2luZyBIYW5kc2hha2UgaXMgU3RhcnRlZF8gYW5kIHRoYXQgdGhlXG4gICAgLy8gV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgaW4gdGhlIENMT1NJTkcgc3RhdGUuXG4gICAgd3Nba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NJTkdcbiAgfSBlbHNlIHtcbiAgICAvLyBPdGhlcndpc2VcbiAgICAvLyBTZXQgdGhpcydzIHJlYWR5IHN0YXRlIHRvIENMT1NJTkcgKDIpLlxuICAgIHdzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5DTE9TSU5HXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmtcbiAqL1xuZnVuY3Rpb24gb25Tb2NrZXREYXRhIChjaHVuaykge1xuICBpZiAoIXRoaXMud3Nba0J5dGVQYXJzZXJdLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNmZWVkYmFjay1mcm9tLXRoZS1wcm90b2NvbFxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNFxuICovXG5mdW5jdGlvbiBvblNvY2tldENsb3NlICgpIHtcbiAgY29uc3QgeyB3cyB9ID0gdGhpc1xuICBjb25zdCB7IFtrUmVzcG9uc2VdOiByZXNwb25zZSB9ID0gd3NcblxuICByZXNwb25zZS5zb2NrZXQub2ZmKCdkYXRhJywgb25Tb2NrZXREYXRhKVxuICByZXNwb25zZS5zb2NrZXQub2ZmKCdjbG9zZScsIG9uU29ja2V0Q2xvc2UpXG4gIHJlc3BvbnNlLnNvY2tldC5vZmYoJ2Vycm9yJywgb25Tb2NrZXRFcnJvcilcblxuICAvLyBJZiB0aGUgVENQIGNvbm5lY3Rpb24gd2FzIGNsb3NlZCBhZnRlciB0aGVcbiAgLy8gV2ViU29ja2V0IGNsb3NpbmcgaGFuZHNoYWtlIHdhcyBjb21wbGV0ZWQsIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAvLyBpcyBzYWlkIHRvIGhhdmUgYmVlbiBjbG9zZWQgX2NsZWFubHlfLlxuICBjb25zdCB3YXNDbGVhbiA9IHdzW2tTZW50Q2xvc2VdID09PSBzZW50Q2xvc2VGcmFtZVN0YXRlLlNFTlQgJiYgd3Nba1JlY2VpdmVkQ2xvc2VdXG5cbiAgbGV0IGNvZGUgPSAxMDA1XG4gIGxldCByZWFzb24gPSAnJ1xuXG4gIGNvbnN0IHJlc3VsdCA9IHdzW2tCeXRlUGFyc2VyXS5jbG9zaW5nSW5mb1xuXG4gIGlmIChyZXN1bHQgJiYgIXJlc3VsdC5lcnJvcikge1xuICAgIGNvZGUgPSByZXN1bHQuY29kZSA/PyAxMDA1XG4gICAgcmVhc29uID0gcmVzdWx0LnJlYXNvblxuICB9IGVsc2UgaWYgKCF3c1trUmVjZWl2ZWRDbG9zZV0pIHtcbiAgICAvLyBJZiBfVGhlIFdlYlNvY2tldFxuICAgIC8vIENvbm5lY3Rpb24gaXMgQ2xvc2VkXyBhbmQgbm8gQ2xvc2UgY29udHJvbCBmcmFtZSB3YXMgcmVjZWl2ZWQgYnkgdGhlXG4gICAgLy8gZW5kcG9pbnQgKHN1Y2ggYXMgY291bGQgb2NjdXIgaWYgdGhlIHVuZGVybHlpbmcgdHJhbnNwb3J0IGNvbm5lY3Rpb25cbiAgICAvLyBpcyBsb3N0KSwgX1RoZSBXZWJTb2NrZXQgQ29ubmVjdGlvbiBDbG9zZSBDb2RlXyBpcyBjb25zaWRlcmVkIHRvIGJlXG4gICAgLy8gMTAwNi5cbiAgICBjb2RlID0gMTAwNlxuICB9XG5cbiAgLy8gMS4gQ2hhbmdlIHRoZSByZWFkeSBzdGF0ZSB0byBDTE9TRUQgKDMpLlxuICB3c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0VEXG5cbiAgLy8gMi4gSWYgdGhlIHVzZXIgYWdlbnQgd2FzIHJlcXVpcmVkIHRvIGZhaWwgdGhlIFdlYlNvY2tldFxuICAvLyAgICBjb25uZWN0aW9uLCBvciBpZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAvLyAgICBhZnRlciBiZWluZyBmbGFnZ2VkIGFzIGZ1bGwsIGZpcmUgYW4gZXZlbnQgbmFtZWQgZXJyb3JcbiAgLy8gICAgYXQgdGhlIFdlYlNvY2tldCBvYmplY3QuXG4gIC8vIFRPRE9cblxuICAvLyAzLiBGaXJlIGFuIGV2ZW50IG5hbWVkIGNsb3NlIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LFxuICAvLyAgICB1c2luZyBDbG9zZUV2ZW50LCB3aXRoIHRoZSB3YXNDbGVhbiBhdHRyaWJ1dGVcbiAgLy8gICAgaW5pdGlhbGl6ZWQgdG8gdHJ1ZSBpZiB0aGUgY29ubmVjdGlvbiBjbG9zZWQgY2xlYW5seVxuICAvLyAgICBhbmQgZmFsc2Ugb3RoZXJ3aXNlLCB0aGUgY29kZSBhdHRyaWJ1dGUgaW5pdGlhbGl6ZWQgdG9cbiAgLy8gICAgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGNsb3NlIGNvZGUsIGFuZCB0aGUgcmVhc29uXG4gIC8vICAgIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0byB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIFVURi04XG4gIC8vICAgIGRlY29kZSB3aXRob3V0IEJPTSB0byB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gY2xvc2VcbiAgLy8gICAgcmVhc29uLlxuICAvLyBUT0RPOiBwcm9jZXNzLm5leHRUaWNrXG4gIGZpcmVFdmVudCgnY2xvc2UnLCB3cywgKHR5cGUsIGluaXQpID0+IG5ldyBDbG9zZUV2ZW50KHR5cGUsIGluaXQpLCB7XG4gICAgd2FzQ2xlYW4sIGNvZGUsIHJlYXNvblxuICB9KVxuXG4gIGlmIChjaGFubmVscy5jbG9zZS5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLmNsb3NlLnB1Ymxpc2goe1xuICAgICAgd2Vic29ja2V0OiB3cyxcbiAgICAgIGNvZGUsXG4gICAgICByZWFzb25cbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uU29ja2V0RXJyb3IgKGVycm9yKSB7XG4gIGNvbnN0IHsgd3MgfSA9IHRoaXNcblxuICB3c1trUmVhZHlTdGF0ZV0gPSBzdGF0ZXMuQ0xPU0lOR1xuXG4gIGlmIChjaGFubmVscy5zb2NrZXRFcnJvci5oYXNTdWJzY3JpYmVycykge1xuICAgIGNoYW5uZWxzLnNvY2tldEVycm9yLnB1Ymxpc2goZXJyb3IpXG4gIH1cblxuICB0aGlzLmRlc3Ryb3koKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXN0YWJsaXNoV2ViU29ja2V0Q29ubmVjdGlvbixcbiAgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/constants.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// This is a Globally Unique Identifier unique used\n// to validate that the endpoint accepts websocket\n// connections.\n// See https://www.rfc-editor.org/rfc/rfc6455.html#section-1.3\nconst uid = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'\n\n/** @type {PropertyDescriptor} */\nconst staticPropertyDescriptors = {\n  enumerable: true,\n  writable: false,\n  configurable: false\n}\n\nconst states = {\n  CONNECTING: 0,\n  OPEN: 1,\n  CLOSING: 2,\n  CLOSED: 3\n}\n\nconst sentCloseFrameState = {\n  NOT_SENT: 0,\n  PROCESSING: 1,\n  SENT: 2\n}\n\nconst opcodes = {\n  CONTINUATION: 0x0,\n  TEXT: 0x1,\n  BINARY: 0x2,\n  CLOSE: 0x8,\n  PING: 0x9,\n  PONG: 0xA\n}\n\nconst maxUnsigned16Bit = 2 ** 16 - 1 // 65535\n\nconst parserStates = {\n  INFO: 0,\n  PAYLOADLENGTH_16: 2,\n  PAYLOADLENGTH_64: 3,\n  READ_DATA: 4\n}\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\nconst sendHints = {\n  string: 1,\n  typedArray: 2,\n  arrayBuffer: 3,\n  blob: 4\n}\n\nmodule.exports = {\n  uid,\n  sentCloseFrameState,\n  staticPropertyDescriptors,\n  states,\n  opcodes,\n  maxUnsigned16Bit,\n  parserStates,\n  emptyBuffer,\n  sendHints\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXGNvbnN0YW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gVGhpcyBpcyBhIEdsb2JhbGx5IFVuaXF1ZSBJZGVudGlmaWVyIHVuaXF1ZSB1c2VkXG4vLyB0byB2YWxpZGF0ZSB0aGF0IHRoZSBlbmRwb2ludCBhY2NlcHRzIHdlYnNvY2tldFxuLy8gY29ubmVjdGlvbnMuXG4vLyBTZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzY0NTUuaHRtbCNzZWN0aW9uLTEuM1xuY29uc3QgdWlkID0gJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMSdcblxuLyoqIEB0eXBlIHtQcm9wZXJ0eURlc2NyaXB0b3J9ICovXG5jb25zdCBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB3cml0YWJsZTogZmFsc2UsXG4gIGNvbmZpZ3VyYWJsZTogZmFsc2Vcbn1cblxuY29uc3Qgc3RhdGVzID0ge1xuICBDT05ORUNUSU5HOiAwLFxuICBPUEVOOiAxLFxuICBDTE9TSU5HOiAyLFxuICBDTE9TRUQ6IDNcbn1cblxuY29uc3Qgc2VudENsb3NlRnJhbWVTdGF0ZSA9IHtcbiAgTk9UX1NFTlQ6IDAsXG4gIFBST0NFU1NJTkc6IDEsXG4gIFNFTlQ6IDJcbn1cblxuY29uc3Qgb3Bjb2RlcyA9IHtcbiAgQ09OVElOVUFUSU9OOiAweDAsXG4gIFRFWFQ6IDB4MSxcbiAgQklOQVJZOiAweDIsXG4gIENMT1NFOiAweDgsXG4gIFBJTkc6IDB4OSxcbiAgUE9ORzogMHhBXG59XG5cbmNvbnN0IG1heFVuc2lnbmVkMTZCaXQgPSAyICoqIDE2IC0gMSAvLyA2NTUzNVxuXG5jb25zdCBwYXJzZXJTdGF0ZXMgPSB7XG4gIElORk86IDAsXG4gIFBBWUxPQURMRU5HVEhfMTY6IDIsXG4gIFBBWUxPQURMRU5HVEhfNjQ6IDMsXG4gIFJFQURfREFUQTogNFxufVxuXG5jb25zdCBlbXB0eUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKVxuXG5jb25zdCBzZW5kSGludHMgPSB7XG4gIHN0cmluZzogMSxcbiAgdHlwZWRBcnJheTogMixcbiAgYXJyYXlCdWZmZXI6IDMsXG4gIGJsb2I6IDRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHVpZCxcbiAgc2VudENsb3NlRnJhbWVTdGF0ZSxcbiAgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycyxcbiAgc3RhdGVzLFxuICBvcGNvZGVzLFxuICBtYXhVbnNpZ25lZDE2Qml0LFxuICBwYXJzZXJTdGF0ZXMsXG4gIGVtcHR5QnVmZmVyLFxuICBzZW5kSGludHNcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/events.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/events.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { kEnumerableProperty } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { kConstruct } = __webpack_require__(/*! ../../core/symbols */ \"(rsc)/./node_modules/undici/lib/core/symbols.js\")\nconst { MessagePort } = __webpack_require__(/*! node:worker_threads */ \"node:worker_threads\")\n\n/**\n * @see https://html.spec.whatwg.org/multipage/comms.html#messageevent\n */\nclass MessageEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    if (type === kConstruct) {\n      super(arguments[1], arguments[2])\n      webidl.util.markAsUncloneable(this)\n      return\n    }\n\n    const prefix = 'MessageEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.MessageEventInit(eventInitDict, prefix, 'eventInitDict')\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n    webidl.util.markAsUncloneable(this)\n  }\n\n  get data () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.data\n  }\n\n  get origin () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.origin\n  }\n\n  get lastEventId () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.lastEventId\n  }\n\n  get source () {\n    webidl.brandCheck(this, MessageEvent)\n\n    return this.#eventInit.source\n  }\n\n  get ports () {\n    webidl.brandCheck(this, MessageEvent)\n\n    if (!Object.isFrozen(this.#eventInit.ports)) {\n      Object.freeze(this.#eventInit.ports)\n    }\n\n    return this.#eventInit.ports\n  }\n\n  initMessageEvent (\n    type,\n    bubbles = false,\n    cancelable = false,\n    data = null,\n    origin = '',\n    lastEventId = '',\n    source = null,\n    ports = []\n  ) {\n    webidl.brandCheck(this, MessageEvent)\n\n    webidl.argumentLengthCheck(arguments, 1, 'MessageEvent.initMessageEvent')\n\n    return new MessageEvent(type, {\n      bubbles, cancelable, data, origin, lastEventId, source, ports\n    })\n  }\n\n  static createFastMessageEvent (type, init) {\n    const messageEvent = new MessageEvent(kConstruct, type, init)\n    messageEvent.#eventInit = init\n    messageEvent.#eventInit.data ??= null\n    messageEvent.#eventInit.origin ??= ''\n    messageEvent.#eventInit.lastEventId ??= ''\n    messageEvent.#eventInit.source ??= null\n    messageEvent.#eventInit.ports ??= []\n    return messageEvent\n  }\n}\n\nconst { createFastMessageEvent } = MessageEvent\ndelete MessageEvent.createFastMessageEvent\n\n/**\n * @see https://websockets.spec.whatwg.org/#the-closeevent-interface\n */\nclass CloseEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict = {}) {\n    const prefix = 'CloseEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.CloseEventInit(eventInitDict)\n\n    super(type, eventInitDict)\n\n    this.#eventInit = eventInitDict\n    webidl.util.markAsUncloneable(this)\n  }\n\n  get wasClean () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.wasClean\n  }\n\n  get code () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.code\n  }\n\n  get reason () {\n    webidl.brandCheck(this, CloseEvent)\n\n    return this.#eventInit.reason\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/webappapis.html#the-errorevent-interface\nclass ErrorEvent extends Event {\n  #eventInit\n\n  constructor (type, eventInitDict) {\n    const prefix = 'ErrorEvent constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    super(type, eventInitDict)\n    webidl.util.markAsUncloneable(this)\n\n    type = webidl.converters.DOMString(type, prefix, 'type')\n    eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {})\n\n    this.#eventInit = eventInitDict\n  }\n\n  get message () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.message\n  }\n\n  get filename () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.filename\n  }\n\n  get lineno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.lineno\n  }\n\n  get colno () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.colno\n  }\n\n  get error () {\n    webidl.brandCheck(this, ErrorEvent)\n\n    return this.#eventInit.error\n  }\n}\n\nObject.defineProperties(MessageEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'MessageEvent',\n    configurable: true\n  },\n  data: kEnumerableProperty,\n  origin: kEnumerableProperty,\n  lastEventId: kEnumerableProperty,\n  source: kEnumerableProperty,\n  ports: kEnumerableProperty,\n  initMessageEvent: kEnumerableProperty\n})\n\nObject.defineProperties(CloseEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'CloseEvent',\n    configurable: true\n  },\n  reason: kEnumerableProperty,\n  code: kEnumerableProperty,\n  wasClean: kEnumerableProperty\n})\n\nObject.defineProperties(ErrorEvent.prototype, {\n  [Symbol.toStringTag]: {\n    value: 'ErrorEvent',\n    configurable: true\n  },\n  message: kEnumerableProperty,\n  filename: kEnumerableProperty,\n  lineno: kEnumerableProperty,\n  colno: kEnumerableProperty,\n  error: kEnumerableProperty\n})\n\nwebidl.converters.MessagePort = webidl.interfaceConverter(MessagePort)\n\nwebidl.converters['sequence<MessagePort>'] = webidl.sequenceConverter(\n  webidl.converters.MessagePort\n)\n\nconst eventInit = [\n  {\n    key: 'bubbles',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'cancelable',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'composed',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  }\n]\n\nwebidl.converters.MessageEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'data',\n    converter: webidl.converters.any,\n    defaultValue: () => null\n  },\n  {\n    key: 'origin',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'lastEventId',\n    converter: webidl.converters.DOMString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'source',\n    // Node doesn't implement WindowProxy or ServiceWorker, so the only\n    // valid value for source is a MessagePort.\n    converter: webidl.nullableConverter(webidl.converters.MessagePort),\n    defaultValue: () => null\n  },\n  {\n    key: 'ports',\n    converter: webidl.converters['sequence<MessagePort>'],\n    defaultValue: () => new Array(0)\n  }\n])\n\nwebidl.converters.CloseEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'wasClean',\n    converter: webidl.converters.boolean,\n    defaultValue: () => false\n  },\n  {\n    key: 'code',\n    converter: webidl.converters['unsigned short'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'reason',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  }\n])\n\nwebidl.converters.ErrorEventInit = webidl.dictionaryConverter([\n  ...eventInit,\n  {\n    key: 'message',\n    converter: webidl.converters.DOMString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'filename',\n    converter: webidl.converters.USVString,\n    defaultValue: () => ''\n  },\n  {\n    key: 'lineno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'colno',\n    converter: webidl.converters['unsigned long'],\n    defaultValue: () => 0\n  },\n  {\n    key: 'error',\n    converter: webidl.converters.any\n  }\n])\n\nmodule.exports = {\n  MessageEvent,\n  CloseEvent,\n  ErrorEvent,\n  createFastMessageEvent\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2V2ZW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjtBQUM1QyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMscUVBQWlCO0FBQ3pELFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsMkVBQW9CO0FBQ25ELFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsZ0RBQXFCOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSx5QkFBeUI7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdFQUF3RTs7QUFFeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcZXZlbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsga0VudW1lcmFibGVQcm9wZXJ0eSB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS91dGlsJylcbmNvbnN0IHsga0NvbnN0cnVjdCB9ID0gcmVxdWlyZSgnLi4vLi4vY29yZS9zeW1ib2xzJylcbmNvbnN0IHsgTWVzc2FnZVBvcnQgfSA9IHJlcXVpcmUoJ25vZGU6d29ya2VyX3RocmVhZHMnKVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCNtZXNzYWdlZXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIGlmICh0eXBlID09PSBrQ29uc3RydWN0KSB7XG4gICAgICBzdXBlcihhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSlcbiAgICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBwcmVmaXggPSAnTWVzc2FnZUV2ZW50IGNvbnN0cnVjdG9yJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlLCBwcmVmaXgsICd0eXBlJylcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZUV2ZW50SW5pdChldmVudEluaXREaWN0LCBwcmVmaXgsICdldmVudEluaXREaWN0JylcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcbiAgfVxuXG4gIGdldCBkYXRhICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmRhdGFcbiAgfVxuXG4gIGdldCBvcmlnaW4gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQub3JpZ2luXG4gIH1cblxuICBnZXQgbGFzdEV2ZW50SWQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubGFzdEV2ZW50SWRcbiAgfVxuXG4gIGdldCBzb3VyY2UgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQuc291cmNlXG4gIH1cblxuICBnZXQgcG9ydHMgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIE1lc3NhZ2VFdmVudClcblxuICAgIGlmICghT2JqZWN0LmlzRnJvemVuKHRoaXMuI2V2ZW50SW5pdC5wb3J0cykpIHtcbiAgICAgIE9iamVjdC5mcmVlemUodGhpcy4jZXZlbnRJbml0LnBvcnRzKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQucG9ydHNcbiAgfVxuXG4gIGluaXRNZXNzYWdlRXZlbnQgKFxuICAgIHR5cGUsXG4gICAgYnViYmxlcyA9IGZhbHNlLFxuICAgIGNhbmNlbGFibGUgPSBmYWxzZSxcbiAgICBkYXRhID0gbnVsbCxcbiAgICBvcmlnaW4gPSAnJyxcbiAgICBsYXN0RXZlbnRJZCA9ICcnLFxuICAgIHNvdXJjZSA9IG51bGwsXG4gICAgcG9ydHMgPSBbXVxuICApIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBNZXNzYWdlRXZlbnQpXG5cbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsICdNZXNzYWdlRXZlbnQuaW5pdE1lc3NhZ2VFdmVudCcpXG5cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VFdmVudCh0eXBlLCB7XG4gICAgICBidWJibGVzLCBjYW5jZWxhYmxlLCBkYXRhLCBvcmlnaW4sIGxhc3RFdmVudElkLCBzb3VyY2UsIHBvcnRzXG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50ICh0eXBlLCBpbml0KSB7XG4gICAgY29uc3QgbWVzc2FnZUV2ZW50ID0gbmV3IE1lc3NhZ2VFdmVudChrQ29uc3RydWN0LCB0eXBlLCBpbml0KVxuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0ID0gaW5pdFxuICAgIG1lc3NhZ2VFdmVudC4jZXZlbnRJbml0LmRhdGEgPz89IG51bGxcbiAgICBtZXNzYWdlRXZlbnQuI2V2ZW50SW5pdC5vcmlnaW4gPz89ICcnXG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQubGFzdEV2ZW50SWQgPz89ICcnXG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQuc291cmNlID8/PSBudWxsXG4gICAgbWVzc2FnZUV2ZW50LiNldmVudEluaXQucG9ydHMgPz89IFtdXG4gICAgcmV0dXJuIG1lc3NhZ2VFdmVudFxuICB9XG59XG5cbmNvbnN0IHsgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudCB9ID0gTWVzc2FnZUV2ZW50XG5kZWxldGUgTWVzc2FnZUV2ZW50LmNyZWF0ZUZhc3RNZXNzYWdlRXZlbnRcblxuLyoqXG4gKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI3RoZS1jbG9zZWV2ZW50LWludGVyZmFjZVxuICovXG5jbGFzcyBDbG9zZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QgPSB7fSkge1xuICAgIGNvbnN0IHByZWZpeCA9ICdDbG9zZUV2ZW50IGNvbnN0cnVjdG9yJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgdHlwZSA9IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyh0eXBlLCBwcmVmaXgsICd0eXBlJylcbiAgICBldmVudEluaXREaWN0ID0gd2ViaWRsLmNvbnZlcnRlcnMuQ2xvc2VFdmVudEluaXQoZXZlbnRJbml0RGljdClcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcbiAgfVxuXG4gIGdldCB3YXNDbGVhbiAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgQ2xvc2VFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQud2FzQ2xlYW5cbiAgfVxuXG4gIGdldCBjb2RlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5jb2RlXG4gIH1cblxuICBnZXQgcmVhc29uICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBDbG9zZUV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5yZWFzb25cbiAgfVxufVxuXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS93ZWJhcHBhcGlzLmh0bWwjdGhlLWVycm9yZXZlbnQtaW50ZXJmYWNlXG5jbGFzcyBFcnJvckV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAjZXZlbnRJbml0XG5cbiAgY29uc3RydWN0b3IgKHR5cGUsIGV2ZW50SW5pdERpY3QpIHtcbiAgICBjb25zdCBwcmVmaXggPSAnRXJyb3JFdmVudCBjb25zdHJ1Y3RvcidcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIHN1cGVyKHR5cGUsIGV2ZW50SW5pdERpY3QpXG4gICAgd2ViaWRsLnV0aWwubWFya0FzVW5jbG9uZWFibGUodGhpcylcblxuICAgIHR5cGUgPSB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcodHlwZSwgcHJlZml4LCAndHlwZScpXG4gICAgZXZlbnRJbml0RGljdCA9IHdlYmlkbC5jb252ZXJ0ZXJzLkVycm9yRXZlbnRJbml0KGV2ZW50SW5pdERpY3QgPz8ge30pXG5cbiAgICB0aGlzLiNldmVudEluaXQgPSBldmVudEluaXREaWN0XG4gIH1cblxuICBnZXQgbWVzc2FnZSAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubWVzc2FnZVxuICB9XG5cbiAgZ2V0IGZpbGVuYW1lICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBFcnJvckV2ZW50KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V2ZW50SW5pdC5maWxlbmFtZVxuICB9XG5cbiAgZ2V0IGxpbmVubyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgRXJyb3JFdmVudClcblxuICAgIHJldHVybiB0aGlzLiNldmVudEluaXQubGluZW5vXG4gIH1cblxuICBnZXQgY29sbm8gKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmNvbG5vXG4gIH1cblxuICBnZXQgZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIEVycm9yRXZlbnQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRJbml0LmVycm9yXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoTWVzc2FnZUV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnTWVzc2FnZUV2ZW50JyxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSxcbiAgZGF0YToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb3JpZ2luOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBsYXN0RXZlbnRJZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc291cmNlOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBwb3J0czoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgaW5pdE1lc3NhZ2VFdmVudDoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2xvc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHtcbiAgICB2YWx1ZTogJ0Nsb3NlRXZlbnQnLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9LFxuICByZWFzb246IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNvZGU6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIHdhc0NsZWFuOiBrRW51bWVyYWJsZVByb3BlcnR5XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhFcnJvckV2ZW50LnByb3RvdHlwZSwge1xuICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgIHZhbHVlOiAnRXJyb3JFdmVudCcsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0sXG4gIG1lc3NhZ2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGZpbGVuYW1lOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBsaW5lbm86IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIGNvbG5vOiBrRW51bWVyYWJsZVByb3BlcnR5LFxuICBlcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eVxufSlcblxud2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnQgPSB3ZWJpZGwuaW50ZXJmYWNlQ29udmVydGVyKE1lc3NhZ2VQb3J0KVxuXG53ZWJpZGwuY29udmVydGVyc1snc2VxdWVuY2U8TWVzc2FnZVBvcnQ+J10gPSB3ZWJpZGwuc2VxdWVuY2VDb252ZXJ0ZXIoXG4gIHdlYmlkbC5jb252ZXJ0ZXJzLk1lc3NhZ2VQb3J0XG4pXG5cbmNvbnN0IGV2ZW50SW5pdCA9IFtcbiAge1xuICAgIGtleTogJ2J1YmJsZXMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdjYW5jZWxhYmxlJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLmJvb2xlYW4sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBmYWxzZVxuICB9LFxuICB7XG4gICAga2V5OiAnY29tcG9zZWQnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYm9vbGVhbixcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IGZhbHNlXG4gIH1cbl1cblxud2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZUV2ZW50SW5pdCA9IHdlYmlkbC5kaWN0aW9uYXJ5Q29udmVydGVyKFtcbiAgLi4uZXZlbnRJbml0LFxuICB7XG4gICAga2V5OiAnZGF0YScsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnksXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBudWxsXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdvcmlnaW4nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2xhc3RFdmVudElkJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLkRPTVN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdzb3VyY2UnLFxuICAgIC8vIE5vZGUgZG9lc24ndCBpbXBsZW1lbnQgV2luZG93UHJveHkgb3IgU2VydmljZVdvcmtlciwgc28gdGhlIG9ubHlcbiAgICAvLyB2YWxpZCB2YWx1ZSBmb3Igc291cmNlIGlzIGEgTWVzc2FnZVBvcnQuXG4gICAgY29udmVydGVyOiB3ZWJpZGwubnVsbGFibGVDb252ZXJ0ZXIod2ViaWRsLmNvbnZlcnRlcnMuTWVzc2FnZVBvcnQpLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbnVsbFxuICB9LFxuICB7XG4gICAga2V5OiAncG9ydHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPE1lc3NhZ2VQb3J0PiddLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gbmV3IEFycmF5KDApXG4gIH1cbl0pXG5cbndlYmlkbC5jb252ZXJ0ZXJzLkNsb3NlRXZlbnRJbml0ID0gd2ViaWRsLmRpY3Rpb25hcnlDb252ZXJ0ZXIoW1xuICAuLi5ldmVudEluaXQsXG4gIHtcbiAgICBrZXk6ICd3YXNDbGVhbicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5ib29sZWFuLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZmFsc2VcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvZGUnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIHNob3J0J10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdyZWFzb24nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnMuRXJyb3JFdmVudEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIC4uLmV2ZW50SW5pdCxcbiAge1xuICAgIGtleTogJ21lc3NhZ2UnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nLFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gJydcbiAgfSxcbiAge1xuICAgIGtleTogJ2ZpbGVuYW1lJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+ICcnXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdsaW5lbm8nLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ3Vuc2lnbmVkIGxvbmcnXSxcbiAgICBkZWZhdWx0VmFsdWU6ICgpID0+IDBcbiAgfSxcbiAge1xuICAgIGtleTogJ2NvbG5vJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5jb252ZXJ0ZXJzWyd1bnNpZ25lZCBsb25nJ10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiAwXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdlcnJvcicsXG4gICAgY29udmVydGVyOiB3ZWJpZGwuY29udmVydGVycy5hbnlcbiAgfVxuXSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIE1lc3NhZ2VFdmVudCxcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudCxcbiAgY3JlYXRlRmFzdE1lc3NhZ2VFdmVudFxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/events.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/frame.js":
/*!********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/frame.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { maxUnsigned16Bit } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\n\nconst BUFFER_SIZE = 16386\n\n/** @type {import('crypto')} */\nlet crypto\nlet buffer = null\nlet bufIdx = BUFFER_SIZE\n\ntry {\n  crypto = __webpack_require__(/*! node:crypto */ \"node:crypto\")\n/* c8 ignore next 3 */\n} catch {\n  crypto = {\n    // not full compatibility, but minimum.\n    randomFillSync: function randomFillSync (buffer, _offset, _size) {\n      for (let i = 0; i < buffer.length; ++i) {\n        buffer[i] = Math.random() * 255 | 0\n      }\n      return buffer\n    }\n  }\n}\n\nfunction generateMask () {\n  if (bufIdx === BUFFER_SIZE) {\n    bufIdx = 0\n    crypto.randomFillSync((buffer ??= Buffer.allocUnsafe(BUFFER_SIZE)), 0, BUFFER_SIZE)\n  }\n  return [buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++], buffer[bufIdx++]]\n}\n\nclass WebsocketFrameSend {\n  /**\n   * @param {Buffer|undefined} data\n   */\n  constructor (data) {\n    this.frameData = data\n  }\n\n  createFrame (opcode) {\n    const frameData = this.frameData\n    const maskKey = generateMask()\n    const bodyLength = frameData?.byteLength ?? 0\n\n    /** @type {number} */\n    let payloadLength = bodyLength // 0-125\n    let offset = 6\n\n    if (bodyLength > maxUnsigned16Bit) {\n      offset += 8 // payload length is next 8 bytes\n      payloadLength = 127\n    } else if (bodyLength > 125) {\n      offset += 2 // payload length is next 2 bytes\n      payloadLength = 126\n    }\n\n    const buffer = Buffer.allocUnsafe(bodyLength + offset)\n\n    // Clear first 2 bytes, everything else is overwritten\n    buffer[0] = buffer[1] = 0\n    buffer[0] |= 0x80 // FIN\n    buffer[0] = (buffer[0] & 0xF0) + opcode // opcode\n\n    /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */\n    buffer[offset - 4] = maskKey[0]\n    buffer[offset - 3] = maskKey[1]\n    buffer[offset - 2] = maskKey[2]\n    buffer[offset - 1] = maskKey[3]\n\n    buffer[1] = payloadLength\n\n    if (payloadLength === 126) {\n      buffer.writeUInt16BE(bodyLength, 2)\n    } else if (payloadLength === 127) {\n      // Clear extended payload length\n      buffer[2] = buffer[3] = 0\n      buffer.writeUIntBE(bodyLength, 4, 6)\n    }\n\n    buffer[1] |= 0x80 // MASK\n\n    // mask body\n    for (let i = 0; i < bodyLength; ++i) {\n      buffer[offset + i] = frameData[i] ^ maskKey[i & 3]\n    }\n\n    return buffer\n  }\n}\n\nmodule.exports = {\n  WebsocketFrameSend\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L2ZyYW1lLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTs7QUFFbEQ7O0FBRUEsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLGdDQUFhO0FBQ2hDO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFxmcmFtZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBtYXhVbnNpZ25lZDE2Qml0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5cbmNvbnN0IEJVRkZFUl9TSVpFID0gMTYzODZcblxuLyoqIEB0eXBlIHtpbXBvcnQoJ2NyeXB0bycpfSAqL1xubGV0IGNyeXB0b1xubGV0IGJ1ZmZlciA9IG51bGxcbmxldCBidWZJZHggPSBCVUZGRVJfU0laRVxuXG50cnkge1xuICBjcnlwdG8gPSByZXF1aXJlKCdub2RlOmNyeXB0bycpXG4vKiBjOCBpZ25vcmUgbmV4dCAzICovXG59IGNhdGNoIHtcbiAgY3J5cHRvID0ge1xuICAgIC8vIG5vdCBmdWxsIGNvbXBhdGliaWxpdHksIGJ1dCBtaW5pbXVtLlxuICAgIHJhbmRvbUZpbGxTeW5jOiBmdW5jdGlvbiByYW5kb21GaWxsU3luYyAoYnVmZmVyLCBfb2Zmc2V0LCBfc2l6ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYnVmZmVyW2ldID0gTWF0aC5yYW5kb20oKSAqIDI1NSB8IDBcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZmZXJcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVNYXNrICgpIHtcbiAgaWYgKGJ1ZklkeCA9PT0gQlVGRkVSX1NJWkUpIHtcbiAgICBidWZJZHggPSAwXG4gICAgY3J5cHRvLnJhbmRvbUZpbGxTeW5jKChidWZmZXIgPz89IEJ1ZmZlci5hbGxvY1Vuc2FmZShCVUZGRVJfU0laRSkpLCAwLCBCVUZGRVJfU0laRSlcbiAgfVxuICByZXR1cm4gW2J1ZmZlcltidWZJZHgrK10sIGJ1ZmZlcltidWZJZHgrK10sIGJ1ZmZlcltidWZJZHgrK10sIGJ1ZmZlcltidWZJZHgrK11dXG59XG5cbmNsYXNzIFdlYnNvY2tldEZyYW1lU2VuZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0J1ZmZlcnx1bmRlZmluZWR9IGRhdGFcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkYXRhKSB7XG4gICAgdGhpcy5mcmFtZURhdGEgPSBkYXRhXG4gIH1cblxuICBjcmVhdGVGcmFtZSAob3Bjb2RlKSB7XG4gICAgY29uc3QgZnJhbWVEYXRhID0gdGhpcy5mcmFtZURhdGFcbiAgICBjb25zdCBtYXNrS2V5ID0gZ2VuZXJhdGVNYXNrKClcbiAgICBjb25zdCBib2R5TGVuZ3RoID0gZnJhbWVEYXRhPy5ieXRlTGVuZ3RoID8/IDBcblxuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIGxldCBwYXlsb2FkTGVuZ3RoID0gYm9keUxlbmd0aCAvLyAwLTEyNVxuICAgIGxldCBvZmZzZXQgPSA2XG5cbiAgICBpZiAoYm9keUxlbmd0aCA+IG1heFVuc2lnbmVkMTZCaXQpIHtcbiAgICAgIG9mZnNldCArPSA4IC8vIHBheWxvYWQgbGVuZ3RoIGlzIG5leHQgOCBieXRlc1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyN1xuICAgIH0gZWxzZSBpZiAoYm9keUxlbmd0aCA+IDEyNSkge1xuICAgICAgb2Zmc2V0ICs9IDIgLy8gcGF5bG9hZCBsZW5ndGggaXMgbmV4dCAyIGJ5dGVzXG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI2XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGJvZHlMZW5ndGggKyBvZmZzZXQpXG5cbiAgICAvLyBDbGVhciBmaXJzdCAyIGJ5dGVzLCBldmVyeXRoaW5nIGVsc2UgaXMgb3ZlcndyaXR0ZW5cbiAgICBidWZmZXJbMF0gPSBidWZmZXJbMV0gPSAwXG4gICAgYnVmZmVyWzBdIHw9IDB4ODAgLy8gRklOXG4gICAgYnVmZmVyWzBdID0gKGJ1ZmZlclswXSAmIDB4RjApICsgb3Bjb2RlIC8vIG9wY29kZVxuXG4gICAgLyohIHdzLiBNSVQgTGljZW5zZS4gRWluYXIgT3R0byBTdGFuZ3ZpayA8ZWluYXJvc0BnbWFpbC5jb20+ICovXG4gICAgYnVmZmVyW29mZnNldCAtIDRdID0gbWFza0tleVswXVxuICAgIGJ1ZmZlcltvZmZzZXQgLSAzXSA9IG1hc2tLZXlbMV1cbiAgICBidWZmZXJbb2Zmc2V0IC0gMl0gPSBtYXNrS2V5WzJdXG4gICAgYnVmZmVyW29mZnNldCAtIDFdID0gbWFza0tleVszXVxuXG4gICAgYnVmZmVyWzFdID0gcGF5bG9hZExlbmd0aFxuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgYnVmZmVyLndyaXRlVUludDE2QkUoYm9keUxlbmd0aCwgMilcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgLy8gQ2xlYXIgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGhcbiAgICAgIGJ1ZmZlclsyXSA9IGJ1ZmZlclszXSA9IDBcbiAgICAgIGJ1ZmZlci53cml0ZVVJbnRCRShib2R5TGVuZ3RoLCA0LCA2KVxuICAgIH1cblxuICAgIGJ1ZmZlclsxXSB8PSAweDgwIC8vIE1BU0tcblxuICAgIC8vIG1hc2sgYm9keVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYm9keUxlbmd0aDsgKytpKSB7XG4gICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSBmcmFtZURhdGFbaV0gXiBtYXNrS2V5W2kgJiAzXVxuICAgIH1cblxuICAgIHJldHVybiBidWZmZXJcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2Vic29ja2V0RnJhbWVTZW5kXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/frame.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/permessage-deflate.js":
/*!*********************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/permessage-deflate.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { createInflateRaw, Z_DEFAULT_WINDOWBITS } = __webpack_require__(/*! node:zlib */ \"node:zlib\")\nconst { isValidClientWindowBits } = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\n\nconst tail = Buffer.from([0x00, 0x00, 0xff, 0xff])\nconst kBuffer = Symbol('kBuffer')\nconst kLength = Symbol('kLength')\n\nclass PerMessageDeflate {\n  /** @type {import('node:zlib').InflateRaw} */\n  #inflate\n\n  #options = {}\n\n  constructor (extensions) {\n    this.#options.serverNoContextTakeover = extensions.has('server_no_context_takeover')\n    this.#options.serverMaxWindowBits = extensions.get('server_max_window_bits')\n  }\n\n  decompress (chunk, fin, callback) {\n    // An endpoint uses the following algorithm to decompress a message.\n    // 1.  Append 4 octets of 0x00 0x00 0xff 0xff to the tail end of the\n    //     payload of the message.\n    // 2.  Decompress the resulting data using DEFLATE.\n\n    if (!this.#inflate) {\n      let windowBits = Z_DEFAULT_WINDOWBITS\n\n      if (this.#options.serverMaxWindowBits) { // empty values default to Z_DEFAULT_WINDOWBITS\n        if (!isValidClientWindowBits(this.#options.serverMaxWindowBits)) {\n          callback(new Error('Invalid server_max_window_bits'))\n          return\n        }\n\n        windowBits = Number.parseInt(this.#options.serverMaxWindowBits)\n      }\n\n      this.#inflate = createInflateRaw({ windowBits })\n      this.#inflate[kBuffer] = []\n      this.#inflate[kLength] = 0\n\n      this.#inflate.on('data', (data) => {\n        this.#inflate[kBuffer].push(data)\n        this.#inflate[kLength] += data.length\n      })\n\n      this.#inflate.on('error', (err) => {\n        this.#inflate = null\n        callback(err)\n      })\n    }\n\n    this.#inflate.write(chunk)\n    if (fin) {\n      this.#inflate.write(tail)\n    }\n\n    this.#inflate.flush(() => {\n      const full = Buffer.concat(this.#inflate[kBuffer], this.#inflate[kLength])\n\n      this.#inflate[kBuffer].length = 0\n      this.#inflate[kLength] = 0\n\n      callback(null, full)\n    })\n  }\n}\n\nmodule.exports = { PerMessageDeflate }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHlDQUF5QyxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDdEUsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHFFQUFROztBQUVwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGdDQUFnQztBQUM3Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXHBlcm1lc3NhZ2UtZGVmbGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBjcmVhdGVJbmZsYXRlUmF3LCBaX0RFRkFVTFRfV0lORE9XQklUUyB9ID0gcmVxdWlyZSgnbm9kZTp6bGliJylcbmNvbnN0IHsgaXNWYWxpZENsaWVudFdpbmRvd0JpdHMgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbmNvbnN0IHRhaWwgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pXG5jb25zdCBrQnVmZmVyID0gU3ltYm9sKCdrQnVmZmVyJylcbmNvbnN0IGtMZW5ndGggPSBTeW1ib2woJ2tMZW5ndGgnKVxuXG5jbGFzcyBQZXJNZXNzYWdlRGVmbGF0ZSB7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KCdub2RlOnpsaWInKS5JbmZsYXRlUmF3fSAqL1xuICAjaW5mbGF0ZVxuXG4gICNvcHRpb25zID0ge31cblxuICBjb25zdHJ1Y3RvciAoZXh0ZW5zaW9ucykge1xuICAgIHRoaXMuI29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPSBleHRlbnNpb25zLmhhcygnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInKVxuICAgIHRoaXMuI29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cyA9IGV4dGVuc2lvbnMuZ2V0KCdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJylcbiAgfVxuXG4gIGRlY29tcHJlc3MgKGNodW5rLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgLy8gQW4gZW5kcG9pbnQgdXNlcyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobSB0byBkZWNvbXByZXNzIGEgbWVzc2FnZS5cbiAgICAvLyAxLiAgQXBwZW5kIDQgb2N0ZXRzIG9mIDB4MDAgMHgwMCAweGZmIDB4ZmYgdG8gdGhlIHRhaWwgZW5kIG9mIHRoZVxuICAgIC8vICAgICBwYXlsb2FkIG9mIHRoZSBtZXNzYWdlLlxuICAgIC8vIDIuICBEZWNvbXByZXNzIHRoZSByZXN1bHRpbmcgZGF0YSB1c2luZyBERUZMQVRFLlxuXG4gICAgaWYgKCF0aGlzLiNpbmZsYXRlKSB7XG4gICAgICBsZXQgd2luZG93Qml0cyA9IFpfREVGQVVMVF9XSU5ET1dCSVRTXG5cbiAgICAgIGlmICh0aGlzLiNvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHsgLy8gZW1wdHkgdmFsdWVzIGRlZmF1bHQgdG8gWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgaWYgKCFpc1ZhbGlkQ2xpZW50V2luZG93Qml0cyh0aGlzLiNvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpKSB7XG4gICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdJbnZhbGlkIHNlcnZlcl9tYXhfd2luZG93X2JpdHMnKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvd0JpdHMgPSBOdW1iZXIucGFyc2VJbnQodGhpcy4jb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKVxuICAgICAgfVxuXG4gICAgICB0aGlzLiNpbmZsYXRlID0gY3JlYXRlSW5mbGF0ZVJhdyh7IHdpbmRvd0JpdHMgfSlcbiAgICAgIHRoaXMuI2luZmxhdGVba0J1ZmZlcl0gPSBbXVxuICAgICAgdGhpcy4jaW5mbGF0ZVtrTGVuZ3RoXSA9IDBcblxuICAgICAgdGhpcy4jaW5mbGF0ZS5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgIHRoaXMuI2luZmxhdGVba0J1ZmZlcl0ucHVzaChkYXRhKVxuICAgICAgICB0aGlzLiNpbmZsYXRlW2tMZW5ndGhdICs9IGRhdGEubGVuZ3RoXG4gICAgICB9KVxuXG4gICAgICB0aGlzLiNpbmZsYXRlLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgdGhpcy4jaW5mbGF0ZSA9IG51bGxcbiAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLiNpbmZsYXRlLndyaXRlKGNodW5rKVxuICAgIGlmIChmaW4pIHtcbiAgICAgIHRoaXMuI2luZmxhdGUud3JpdGUodGFpbClcbiAgICB9XG5cbiAgICB0aGlzLiNpbmZsYXRlLmZsdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGZ1bGwgPSBCdWZmZXIuY29uY2F0KHRoaXMuI2luZmxhdGVba0J1ZmZlcl0sIHRoaXMuI2luZmxhdGVba0xlbmd0aF0pXG5cbiAgICAgIHRoaXMuI2luZmxhdGVba0J1ZmZlcl0ubGVuZ3RoID0gMFxuICAgICAgdGhpcy4jaW5mbGF0ZVtrTGVuZ3RoXSA9IDBcblxuICAgICAgY2FsbGJhY2sobnVsbCwgZnVsbClcbiAgICB9KVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBQZXJNZXNzYWdlRGVmbGF0ZSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/receiver.js":
/*!***********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/receiver.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! node:stream */ \"node:stream\")\nconst assert = __webpack_require__(/*! node:assert */ \"node:assert\")\nconst { parserStates, opcodes, states, emptyBuffer, sentCloseFrameState } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { kReadyState, kSentClose, kResponse, kReceivedClose } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/websocket/symbols.js\")\nconst { channels } = __webpack_require__(/*! ../../core/diagnostics */ \"(rsc)/./node_modules/undici/lib/core/diagnostics.js\")\nconst {\n  isValidStatusCode,\n  isValidOpcode,\n  failWebsocketConnection,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isTextBinaryFrame,\n  isContinuationFrame\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { closeWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/undici/lib/web/websocket/connection.js\")\nconst { PerMessageDeflate } = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/undici/lib/web/websocket/permessage-deflate.js\")\n\n// This code was influenced by ws released under the MIT license.\n// Copyright (c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n// Copyright (c) 2013 Arnout Kazemier and contributors\n// Copyright (c) 2016 Luigi Pinca and contributors\n\nclass ByteParser extends Writable {\n  #buffers = []\n  #byteOffset = 0\n  #loop = false\n\n  #state = parserStates.INFO\n\n  #info = {}\n  #fragments = []\n\n  /** @type {Map<string, PerMessageDeflate>} */\n  #extensions\n\n  constructor (ws, extensions) {\n    super()\n\n    this.ws = ws\n    this.#extensions = extensions == null ? new Map() : extensions\n\n    if (this.#extensions.has('permessage-deflate')) {\n      this.#extensions.set('permessage-deflate', new PerMessageDeflate(extensions))\n    }\n  }\n\n  /**\n   * @param {Buffer} chunk\n   * @param {() => void} callback\n   */\n  _write (chunk, _, callback) {\n    this.#buffers.push(chunk)\n    this.#byteOffset += chunk.length\n    this.#loop = true\n\n    this.run(callback)\n  }\n\n  /**\n   * Runs whenever a new chunk is received.\n   * Callback is called whenever there are no more chunks buffering,\n   * or not enough bytes are buffered to parse.\n   */\n  run (callback) {\n    while (this.#loop) {\n      if (this.#state === parserStates.INFO) {\n        // If there aren't enough bytes to parse the payload length, etc.\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n        const fin = (buffer[0] & 0x80) !== 0\n        const opcode = buffer[0] & 0x0F\n        const masked = (buffer[1] & 0x80) === 0x80\n\n        const fragmented = !fin && opcode !== opcodes.CONTINUATION\n        const payloadLength = buffer[1] & 0x7F\n\n        const rsv1 = buffer[0] & 0x40\n        const rsv2 = buffer[0] & 0x20\n        const rsv3 = buffer[0] & 0x10\n\n        if (!isValidOpcode(opcode)) {\n          failWebsocketConnection(this.ws, 'Invalid opcode received')\n          return callback()\n        }\n\n        if (masked) {\n          failWebsocketConnection(this.ws, 'Frame cannot be masked')\n          return callback()\n        }\n\n        // MUST be 0 unless an extension is negotiated that defines meanings\n        // for non-zero values.  If a nonzero value is received and none of\n        // the negotiated extensions defines the meaning of such a nonzero\n        // value, the receiving endpoint MUST _Fail the WebSocket\n        // Connection_.\n        // This document allocates the RSV1 bit of the WebSocket header for\n        // PMCEs and calls the bit the \"Per-Message Compressed\" bit.  On a\n        // WebSocket connection where a PMCE is in use, this bit indicates\n        // whether a message is compressed or not.\n        if (rsv1 !== 0 && !this.#extensions.has('permessage-deflate')) {\n          failWebsocketConnection(this.ws, 'Expected RSV1 to be clear.')\n          return\n        }\n\n        if (rsv2 !== 0 || rsv3 !== 0) {\n          failWebsocketConnection(this.ws, 'RSV1, RSV2, RSV3 must be clear')\n          return\n        }\n\n        if (fragmented && !isTextBinaryFrame(opcode)) {\n          // Only text and binary frames can be fragmented\n          failWebsocketConnection(this.ws, 'Invalid frame type was fragmented.')\n          return\n        }\n\n        // If we are already parsing a text/binary frame and do not receive either\n        // a continuation frame or close frame, fail the connection.\n        if (isTextBinaryFrame(opcode) && this.#fragments.length > 0) {\n          failWebsocketConnection(this.ws, 'Expected continuation frame')\n          return\n        }\n\n        if (this.#info.fragmented && fragmented) {\n          // A fragmented frame can't be fragmented itself\n          failWebsocketConnection(this.ws, 'Fragmented frame exceeded 125 bytes.')\n          return\n        }\n\n        // \"All control frames MUST have a payload length of 125 bytes or less\n        // and MUST NOT be fragmented.\"\n        if ((payloadLength > 125 || fragmented) && isControlFrame(opcode)) {\n          failWebsocketConnection(this.ws, 'Control frame either too large or fragmented')\n          return\n        }\n\n        if (isContinuationFrame(opcode) && this.#fragments.length === 0 && !this.#info.compressed) {\n          failWebsocketConnection(this.ws, 'Unexpected continuation frame')\n          return\n        }\n\n        if (payloadLength <= 125) {\n          this.#info.payloadLength = payloadLength\n          this.#state = parserStates.READ_DATA\n        } else if (payloadLength === 126) {\n          this.#state = parserStates.PAYLOADLENGTH_16\n        } else if (payloadLength === 127) {\n          this.#state = parserStates.PAYLOADLENGTH_64\n        }\n\n        if (isTextBinaryFrame(opcode)) {\n          this.#info.binaryType = opcode\n          this.#info.compressed = rsv1 !== 0\n        }\n\n        this.#info.opcode = opcode\n        this.#info.masked = masked\n        this.#info.fin = fin\n        this.#info.fragmented = fragmented\n      } else if (this.#state === parserStates.PAYLOADLENGTH_16) {\n        if (this.#byteOffset < 2) {\n          return callback()\n        }\n\n        const buffer = this.consume(2)\n\n        this.#info.payloadLength = buffer.readUInt16BE(0)\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.PAYLOADLENGTH_64) {\n        if (this.#byteOffset < 8) {\n          return callback()\n        }\n\n        const buffer = this.consume(8)\n        const upper = buffer.readUInt32BE(0)\n\n        // 2^31 is the maximum bytes an arraybuffer can contain\n        // on 32-bit systems. Although, on 64-bit systems, this is\n        // 2^53-1 bytes.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_array_length\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/common/globals.h;drc=1946212ac0100668f14eb9e2843bdd846e510a1e;bpv=1;bpt=1;l=1275\n        // https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/js-array-buffer.h;l=34;drc=1946212ac0100668f14eb9e2843bdd846e510a1e\n        if (upper > 2 ** 31 - 1) {\n          failWebsocketConnection(this.ws, 'Received payload length > 2^31 bytes.')\n          return\n        }\n\n        const lower = buffer.readUInt32BE(4)\n\n        this.#info.payloadLength = (upper << 8) + lower\n        this.#state = parserStates.READ_DATA\n      } else if (this.#state === parserStates.READ_DATA) {\n        if (this.#byteOffset < this.#info.payloadLength) {\n          return callback()\n        }\n\n        const body = this.consume(this.#info.payloadLength)\n\n        if (isControlFrame(this.#info.opcode)) {\n          this.#loop = this.parseControlFrame(body)\n          this.#state = parserStates.INFO\n        } else {\n          if (!this.#info.compressed) {\n            this.#fragments.push(body)\n\n            // If the frame is not fragmented, a message has been received.\n            // If the frame is fragmented, it will terminate with a fin bit set\n            // and an opcode of 0 (continuation), therefore we handle that when\n            // parsing continuation frames, not here.\n            if (!this.#info.fragmented && this.#info.fin) {\n              const fullMessage = Buffer.concat(this.#fragments)\n              websocketMessageReceived(this.ws, this.#info.binaryType, fullMessage)\n              this.#fragments.length = 0\n            }\n\n            this.#state = parserStates.INFO\n          } else {\n            this.#extensions.get('permessage-deflate').decompress(body, this.#info.fin, (error, data) => {\n              if (error) {\n                closeWebSocketConnection(this.ws, 1007, error.message, error.message.length)\n                return\n              }\n\n              this.#fragments.push(data)\n\n              if (!this.#info.fin) {\n                this.#state = parserStates.INFO\n                this.#loop = true\n                this.run(callback)\n                return\n              }\n\n              websocketMessageReceived(this.ws, this.#info.binaryType, Buffer.concat(this.#fragments))\n\n              this.#loop = true\n              this.#state = parserStates.INFO\n              this.#fragments.length = 0\n              this.run(callback)\n            })\n\n            this.#loop = false\n            break\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Take n bytes from the buffered Buffers\n   * @param {number} n\n   * @returns {Buffer}\n   */\n  consume (n) {\n    if (n > this.#byteOffset) {\n      throw new Error('Called consume() before buffers satiated.')\n    } else if (n === 0) {\n      return emptyBuffer\n    }\n\n    if (this.#buffers[0].length === n) {\n      this.#byteOffset -= this.#buffers[0].length\n      return this.#buffers.shift()\n    }\n\n    const buffer = Buffer.allocUnsafe(n)\n    let offset = 0\n\n    while (offset !== n) {\n      const next = this.#buffers[0]\n      const { length } = next\n\n      if (length + offset === n) {\n        buffer.set(this.#buffers.shift(), offset)\n        break\n      } else if (length + offset > n) {\n        buffer.set(next.subarray(0, n - offset), offset)\n        this.#buffers[0] = next.subarray(n - offset)\n        break\n      } else {\n        buffer.set(this.#buffers.shift(), offset)\n        offset += next.length\n      }\n    }\n\n    this.#byteOffset -= n\n\n    return buffer\n  }\n\n  parseCloseBody (data) {\n    assert(data.length !== 1)\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.5\n    /** @type {number|undefined} */\n    let code\n\n    if (data.length >= 2) {\n      // _The WebSocket Connection Close Code_ is\n      // defined as the status code (Section 7.4) contained in the first Close\n      // control frame received by the application\n      code = data.readUInt16BE(0)\n    }\n\n    if (code !== undefined && !isValidStatusCode(code)) {\n      return { code: 1002, reason: 'Invalid status code', error: true }\n    }\n\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.6\n    /** @type {Buffer} */\n    let reason = data.subarray(2)\n\n    // Remove BOM\n    if (reason[0] === 0xEF && reason[1] === 0xBB && reason[2] === 0xBF) {\n      reason = reason.subarray(3)\n    }\n\n    try {\n      reason = utf8Decode(reason)\n    } catch {\n      return { code: 1007, reason: 'Invalid UTF-8', error: true }\n    }\n\n    return { code, reason, error: false }\n  }\n\n  /**\n   * Parses control frames.\n   * @param {Buffer} body\n   */\n  parseControlFrame (body) {\n    const { opcode, payloadLength } = this.#info\n\n    if (opcode === opcodes.CLOSE) {\n      if (payloadLength === 1) {\n        failWebsocketConnection(this.ws, 'Received close frame with a 1-byte body.')\n        return false\n      }\n\n      this.#info.closeInfo = this.parseCloseBody(body)\n\n      if (this.#info.closeInfo.error) {\n        const { code, reason } = this.#info.closeInfo\n\n        closeWebSocketConnection(this.ws, code, reason, reason.length)\n        failWebsocketConnection(this.ws, reason)\n        return false\n      }\n\n      if (this.ws[kSentClose] !== sentCloseFrameState.SENT) {\n        // If an endpoint receives a Close frame and did not previously send a\n        // Close frame, the endpoint MUST send a Close frame in response.  (When\n        // sending a Close frame in response, the endpoint typically echos the\n        // status code it received.)\n        let body = emptyBuffer\n        if (this.#info.closeInfo.code) {\n          body = Buffer.allocUnsafe(2)\n          body.writeUInt16BE(this.#info.closeInfo.code, 0)\n        }\n        const closeFrame = new WebsocketFrameSend(body)\n\n        this.ws[kResponse].socket.write(\n          closeFrame.createFrame(opcodes.CLOSE),\n          (err) => {\n            if (!err) {\n              this.ws[kSentClose] = sentCloseFrameState.SENT\n            }\n          }\n        )\n      }\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this.ws[kReadyState] = states.CLOSING\n      this.ws[kReceivedClose] = true\n\n      return false\n    } else if (opcode === opcodes.PING) {\n      // Upon receipt of a Ping frame, an endpoint MUST send a Pong frame in\n      // response, unless it already received a Close frame.\n      // A Pong frame sent in response to a Ping frame must have identical\n      // \"Application data\"\n\n      if (!this.ws[kReceivedClose]) {\n        const frame = new WebsocketFrameSend(body)\n\n        this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG))\n\n        if (channels.ping.hasSubscribers) {\n          channels.ping.publish({\n            payload: body\n          })\n        }\n      }\n    } else if (opcode === opcodes.PONG) {\n      // A Pong frame MAY be sent unsolicited.  This serves as a\n      // unidirectional heartbeat.  A response to an unsolicited Pong frame is\n      // not expected.\n\n      if (channels.pong.hasSubscribers) {\n        channels.pong.publish({\n          payload: body\n        })\n      }\n    }\n\n    return true\n  }\n\n  get closingInfo () {\n    return this.#info.closeInfo\n  }\n}\n\nmodule.exports = {\n  ByteParser\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsZ0NBQWE7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGdDQUFhO0FBQ3BDLFFBQVEsa0VBQWtFLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTtBQUNqRyxRQUFRLHFEQUFxRCxFQUFFLG1CQUFPLENBQUMsMkVBQVc7QUFDbEYsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxtRkFBd0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMscUVBQVE7QUFDcEIsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLHVFQUFTO0FBQ2hELFFBQVEsMkJBQTJCLEVBQUUsbUJBQU8sQ0FBQyxpRkFBYztBQUMzRCxRQUFRLG9CQUFvQixFQUFFLG1CQUFPLENBQUMsaUdBQXNCOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsZ0NBQWdDO0FBQzdDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Riw2Q0FBNkMsTUFBTSxNQUFNO0FBQ3JKLHFHQUFxRyxLQUFLO0FBQzFHO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZTtBQUNmOztBQUVBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxZQUFZLHdCQUF3Qjs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixlQUFlOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFxyZWNlaXZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnbm9kZTpzdHJlYW0nKVxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnbm9kZTphc3NlcnQnKVxuY29uc3QgeyBwYXJzZXJTdGF0ZXMsIG9wY29kZXMsIHN0YXRlcywgZW1wdHlCdWZmZXIsIHNlbnRDbG9zZUZyYW1lU3RhdGUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsga1JlYWR5U3RhdGUsIGtTZW50Q2xvc2UsIGtSZXNwb25zZSwga1JlY2VpdmVkQ2xvc2UgfSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7IGNoYW5uZWxzIH0gPSByZXF1aXJlKCcuLi8uLi9jb3JlL2RpYWdub3N0aWNzJylcbmNvbnN0IHtcbiAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gIGlzVmFsaWRPcGNvZGUsXG4gIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uLFxuICB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQsXG4gIHV0ZjhEZWNvZGUsXG4gIGlzQ29udHJvbEZyYW1lLFxuICBpc1RleHRCaW5hcnlGcmFtZSxcbiAgaXNDb250aW51YXRpb25GcmFtZVxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IFdlYnNvY2tldEZyYW1lU2VuZCB9ID0gcmVxdWlyZSgnLi9mcmFtZScpXG5jb25zdCB7IGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbiB9ID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJylcbmNvbnN0IHsgUGVyTWVzc2FnZURlZmxhdGUgfSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJylcblxuLy8gVGhpcyBjb2RlIHdhcyBpbmZsdWVuY2VkIGJ5IHdzIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbi8vIENvcHlyaWdodCAoYykgMjAxMSBFaW5hciBPdHRvIFN0YW5ndmlrIDxlaW5hcm9zQGdtYWlsLmNvbT5cbi8vIENvcHlyaWdodCAoYykgMjAxMyBBcm5vdXQgS2F6ZW1pZXIgYW5kIGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE2IEx1aWdpIFBpbmNhIGFuZCBjb250cmlidXRvcnNcblxuY2xhc3MgQnl0ZVBhcnNlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgI2J1ZmZlcnMgPSBbXVxuICAjYnl0ZU9mZnNldCA9IDBcbiAgI2xvb3AgPSBmYWxzZVxuXG4gICNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG5cbiAgI2luZm8gPSB7fVxuICAjZnJhZ21lbnRzID0gW11cblxuICAvKiogQHR5cGUge01hcDxzdHJpbmcsIFBlck1lc3NhZ2VEZWZsYXRlPn0gKi9cbiAgI2V4dGVuc2lvbnNcblxuICBjb25zdHJ1Y3RvciAod3MsIGV4dGVuc2lvbnMpIHtcbiAgICBzdXBlcigpXG5cbiAgICB0aGlzLndzID0gd3NcbiAgICB0aGlzLiNleHRlbnNpb25zID0gZXh0ZW5zaW9ucyA9PSBudWxsID8gbmV3IE1hcCgpIDogZXh0ZW5zaW9uc1xuXG4gICAgaWYgKHRoaXMuI2V4dGVuc2lvbnMuaGFzKCdwZXJtZXNzYWdlLWRlZmxhdGUnKSkge1xuICAgICAgdGhpcy4jZXh0ZW5zaW9ucy5zZXQoJ3Blcm1lc3NhZ2UtZGVmbGF0ZScsIG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShleHRlbnNpb25zKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rXG4gICAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAgICovXG4gIF93cml0ZSAoY2h1bmssIF8sIGNhbGxiYWNrKSB7XG4gICAgdGhpcy4jYnVmZmVycy5wdXNoKGNodW5rKVxuICAgIHRoaXMuI2J5dGVPZmZzZXQgKz0gY2h1bmsubGVuZ3RoXG4gICAgdGhpcy4jbG9vcCA9IHRydWVcblxuICAgIHRoaXMucnVuKGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgd2hlbmV2ZXIgYSBuZXcgY2h1bmsgaXMgcmVjZWl2ZWQuXG4gICAqIENhbGxiYWNrIGlzIGNhbGxlZCB3aGVuZXZlciB0aGVyZSBhcmUgbm8gbW9yZSBjaHVua3MgYnVmZmVyaW5nLFxuICAgKiBvciBub3QgZW5vdWdoIGJ5dGVzIGFyZSBidWZmZXJlZCB0byBwYXJzZS5cbiAgICovXG4gIHJ1biAoY2FsbGJhY2spIHtcbiAgICB3aGlsZSAodGhpcy4jbG9vcCkge1xuICAgICAgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuSU5GTykge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmVuJ3QgZW5vdWdoIGJ5dGVzIHRvIHBhcnNlIHRoZSBwYXlsb2FkIGxlbmd0aCwgZXRjLlxuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDIpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDIpXG4gICAgICAgIGNvbnN0IGZpbiA9IChidWZmZXJbMF0gJiAweDgwKSAhPT0gMFxuICAgICAgICBjb25zdCBvcGNvZGUgPSBidWZmZXJbMF0gJiAweDBGXG4gICAgICAgIGNvbnN0IG1hc2tlZCA9IChidWZmZXJbMV0gJiAweDgwKSA9PT0gMHg4MFxuXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ZWQgPSAhZmluICYmIG9wY29kZSAhPT0gb3Bjb2Rlcy5DT05USU5VQVRJT05cbiAgICAgICAgY29uc3QgcGF5bG9hZExlbmd0aCA9IGJ1ZmZlclsxXSAmIDB4N0ZcblxuICAgICAgICBjb25zdCByc3YxID0gYnVmZmVyWzBdICYgMHg0MFxuICAgICAgICBjb25zdCByc3YyID0gYnVmZmVyWzBdICYgMHgyMFxuICAgICAgICBjb25zdCByc3YzID0gYnVmZmVyWzBdICYgMHgxMFxuXG4gICAgICAgIGlmICghaXNWYWxpZE9wY29kZShvcGNvZGUpKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0ludmFsaWQgb3Bjb2RlIHJlY2VpdmVkJylcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hc2tlZCkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdGcmFtZSBjYW5ub3QgYmUgbWFza2VkJylcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTVVTVCBiZSAwIHVubGVzcyBhbiBleHRlbnNpb24gaXMgbmVnb3RpYXRlZCB0aGF0IGRlZmluZXMgbWVhbmluZ3NcbiAgICAgICAgLy8gZm9yIG5vbi16ZXJvIHZhbHVlcy4gIElmIGEgbm9uemVybyB2YWx1ZSBpcyByZWNlaXZlZCBhbmQgbm9uZSBvZlxuICAgICAgICAvLyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zIGRlZmluZXMgdGhlIG1lYW5pbmcgb2Ygc3VjaCBhIG5vbnplcm9cbiAgICAgICAgLy8gdmFsdWUsIHRoZSByZWNlaXZpbmcgZW5kcG9pbnQgTVVTVCBfRmFpbCB0aGUgV2ViU29ja2V0XG4gICAgICAgIC8vIENvbm5lY3Rpb25fLlxuICAgICAgICAvLyBUaGlzIGRvY3VtZW50IGFsbG9jYXRlcyB0aGUgUlNWMSBiaXQgb2YgdGhlIFdlYlNvY2tldCBoZWFkZXIgZm9yXG4gICAgICAgIC8vIFBNQ0VzIGFuZCBjYWxscyB0aGUgYml0IHRoZSBcIlBlci1NZXNzYWdlIENvbXByZXNzZWRcIiBiaXQuICBPbiBhXG4gICAgICAgIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uIHdoZXJlIGEgUE1DRSBpcyBpbiB1c2UsIHRoaXMgYml0IGluZGljYXRlc1xuICAgICAgICAvLyB3aGV0aGVyIGEgbWVzc2FnZSBpcyBjb21wcmVzc2VkIG9yIG5vdC5cbiAgICAgICAgaWYgKHJzdjEgIT09IDAgJiYgIXRoaXMuI2V4dGVuc2lvbnMuaGFzKCdwZXJtZXNzYWdlLWRlZmxhdGUnKSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdFeHBlY3RlZCBSU1YxIHRvIGJlIGNsZWFyLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnN2MiAhPT0gMCB8fCByc3YzICE9PSAwKSB7XG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ1JTVjEsIFJTVjIsIFJTVjMgbXVzdCBiZSBjbGVhcicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZnJhZ21lbnRlZCAmJiAhaXNUZXh0QmluYXJ5RnJhbWUob3Bjb2RlKSkge1xuICAgICAgICAgIC8vIE9ubHkgdGV4dCBhbmQgYmluYXJ5IGZyYW1lcyBjYW4gYmUgZnJhZ21lbnRlZFxuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdJbnZhbGlkIGZyYW1lIHR5cGUgd2FzIGZyYWdtZW50ZWQuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IHBhcnNpbmcgYSB0ZXh0L2JpbmFyeSBmcmFtZSBhbmQgZG8gbm90IHJlY2VpdmUgZWl0aGVyXG4gICAgICAgIC8vIGEgY29udGludWF0aW9uIGZyYW1lIG9yIGNsb3NlIGZyYW1lLCBmYWlsIHRoZSBjb25uZWN0aW9uLlxuICAgICAgICBpZiAoaXNUZXh0QmluYXJ5RnJhbWUob3Bjb2RlKSAmJiB0aGlzLiNmcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdFeHBlY3RlZCBjb250aW51YXRpb24gZnJhbWUnKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuI2luZm8uZnJhZ21lbnRlZCAmJiBmcmFnbWVudGVkKSB7XG4gICAgICAgICAgLy8gQSBmcmFnbWVudGVkIGZyYW1lIGNhbid0IGJlIGZyYWdtZW50ZWQgaXRzZWxmXG4gICAgICAgICAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24odGhpcy53cywgJ0ZyYWdtZW50ZWQgZnJhbWUgZXhjZWVkZWQgMTI1IGJ5dGVzLicpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBcIkFsbCBjb250cm9sIGZyYW1lcyBNVVNUIGhhdmUgYSBwYXlsb2FkIGxlbmd0aCBvZiAxMjUgYnl0ZXMgb3IgbGVzc1xuICAgICAgICAvLyBhbmQgTVVTVCBOT1QgYmUgZnJhZ21lbnRlZC5cIlxuICAgICAgICBpZiAoKHBheWxvYWRMZW5ndGggPiAxMjUgfHwgZnJhZ21lbnRlZCkgJiYgaXNDb250cm9sRnJhbWUob3Bjb2RlKSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdDb250cm9sIGZyYW1lIGVpdGhlciB0b28gbGFyZ2Ugb3IgZnJhZ21lbnRlZCcpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDb250aW51YXRpb25GcmFtZShvcGNvZGUpICYmIHRoaXMuI2ZyYWdtZW50cy5sZW5ndGggPT09IDAgJiYgIXRoaXMuI2luZm8uY29tcHJlc3NlZCkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdVbmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBmcmFtZScpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF5bG9hZExlbmd0aCA8PSAxMjUpIHtcbiAgICAgICAgICB0aGlzLiNpbmZvLnBheWxvYWRMZW5ndGggPSBwYXlsb2FkTGVuZ3RoXG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICAgIH0gZWxzZSBpZiAocGF5bG9hZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF8xNlxuICAgICAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfNjRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1RleHRCaW5hcnlGcmFtZShvcGNvZGUpKSB7XG4gICAgICAgICAgdGhpcy4jaW5mby5iaW5hcnlUeXBlID0gb3Bjb2RlXG4gICAgICAgICAgdGhpcy4jaW5mby5jb21wcmVzc2VkID0gcnN2MSAhPT0gMFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jaW5mby5vcGNvZGUgPSBvcGNvZGVcbiAgICAgICAgdGhpcy4jaW5mby5tYXNrZWQgPSBtYXNrZWRcbiAgICAgICAgdGhpcy4jaW5mby5maW4gPSBmaW5cbiAgICAgICAgdGhpcy4jaW5mby5mcmFnbWVudGVkID0gZnJhZ21lbnRlZFxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLlBBWUxPQURMRU5HVEhfMTYpIHtcbiAgICAgICAgaWYgKHRoaXMuI2J5dGVPZmZzZXQgPCAyKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuY29uc3VtZSgyKVxuXG4gICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9IGJ1ZmZlci5yZWFkVUludDE2QkUoMClcbiAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuUkVBRF9EQVRBXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuI3N0YXRlID09PSBwYXJzZXJTdGF0ZXMuUEFZTE9BRExFTkdUSF82NCkge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IDgpIHtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdGhpcy5jb25zdW1lKDgpXG4gICAgICAgIGNvbnN0IHVwcGVyID0gYnVmZmVyLnJlYWRVSW50MzJCRSgwKVxuXG4gICAgICAgIC8vIDJeMzEgaXMgdGhlIG1heGltdW0gYnl0ZXMgYW4gYXJyYXlidWZmZXIgY2FuIGNvbnRhaW5cbiAgICAgICAgLy8gb24gMzItYml0IHN5c3RlbXMuIEFsdGhvdWdoLCBvbiA2NC1iaXQgc3lzdGVtcywgdGhpcyBpc1xuICAgICAgICAvLyAyXjUzLTEgYnl0ZXMuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0Vycm9ycy9JbnZhbGlkX2FycmF5X2xlbmd0aFxuICAgICAgICAvLyBodHRwczovL3NvdXJjZS5jaHJvbWl1bS5vcmcvY2hyb21pdW0vY2hyb21pdW0vc3JjLysvbWFpbjp2OC9zcmMvY29tbW9uL2dsb2JhbHMuaDtkcmM9MTk0NjIxMmFjMDEwMDY2OGYxNGViOWUyODQzYmRkODQ2ZTUxMGExZTticHY9MTticHQ9MTtsPTEyNzVcbiAgICAgICAgLy8gaHR0cHM6Ly9zb3VyY2UuY2hyb21pdW0ub3JnL2Nocm9taXVtL2Nocm9taXVtL3NyYy8rL21haW46djgvc3JjL29iamVjdHMvanMtYXJyYXktYnVmZmVyLmg7bD0zNDtkcmM9MTk0NjIxMmFjMDEwMDY2OGYxNGViOWUyODQzYmRkODQ2ZTUxMGExZVxuICAgICAgICBpZiAodXBwZXIgPiAyICoqIDMxIC0gMSkge1xuICAgICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsICdSZWNlaXZlZCBwYXlsb2FkIGxlbmd0aCA+IDJeMzEgYnl0ZXMuJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxvd2VyID0gYnVmZmVyLnJlYWRVSW50MzJCRSg0KVxuXG4gICAgICAgIHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCA9ICh1cHBlciA8PCA4KSArIGxvd2VyXG4gICAgICAgIHRoaXMuI3N0YXRlID0gcGFyc2VyU3RhdGVzLlJFQURfREFUQVxuICAgICAgfSBlbHNlIGlmICh0aGlzLiNzdGF0ZSA9PT0gcGFyc2VyU3RhdGVzLlJFQURfREFUQSkge1xuICAgICAgICBpZiAodGhpcy4jYnl0ZU9mZnNldCA8IHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBib2R5ID0gdGhpcy5jb25zdW1lKHRoaXMuI2luZm8ucGF5bG9hZExlbmd0aClcblxuICAgICAgICBpZiAoaXNDb250cm9sRnJhbWUodGhpcy4jaW5mby5vcGNvZGUpKSB7XG4gICAgICAgICAgdGhpcy4jbG9vcCA9IHRoaXMucGFyc2VDb250cm9sRnJhbWUoYm9keSlcbiAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNpbmZvLmNvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuI2ZyYWdtZW50cy5wdXNoKGJvZHkpXG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmcmFtZSBpcyBub3QgZnJhZ21lbnRlZCwgYSBtZXNzYWdlIGhhcyBiZWVuIHJlY2VpdmVkLlxuICAgICAgICAgICAgLy8gSWYgdGhlIGZyYW1lIGlzIGZyYWdtZW50ZWQsIGl0IHdpbGwgdGVybWluYXRlIHdpdGggYSBmaW4gYml0IHNldFxuICAgICAgICAgICAgLy8gYW5kIGFuIG9wY29kZSBvZiAwIChjb250aW51YXRpb24pLCB0aGVyZWZvcmUgd2UgaGFuZGxlIHRoYXQgd2hlblxuICAgICAgICAgICAgLy8gcGFyc2luZyBjb250aW51YXRpb24gZnJhbWVzLCBub3QgaGVyZS5cbiAgICAgICAgICAgIGlmICghdGhpcy4jaW5mby5mcmFnbWVudGVkICYmIHRoaXMuI2luZm8uZmluKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bGxNZXNzYWdlID0gQnVmZmVyLmNvbmNhdCh0aGlzLiNmcmFnbWVudHMpXG4gICAgICAgICAgICAgIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCh0aGlzLndzLCB0aGlzLiNpbmZvLmJpbmFyeVR5cGUsIGZ1bGxNZXNzYWdlKVxuICAgICAgICAgICAgICB0aGlzLiNmcmFnbWVudHMubGVuZ3RoID0gMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiNzdGF0ZSA9IHBhcnNlclN0YXRlcy5JTkZPXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2V4dGVuc2lvbnMuZ2V0KCdwZXJtZXNzYWdlLWRlZmxhdGUnKS5kZWNvbXByZXNzKGJvZHksIHRoaXMuI2luZm8uZmluLCAoZXJyb3IsIGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VXZWJTb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsIDEwMDcsIGVycm9yLm1lc3NhZ2UsIGVycm9yLm1lc3NhZ2UubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy4jZnJhZ21lbnRzLnB1c2goZGF0YSlcblxuICAgICAgICAgICAgICBpZiAoIXRoaXMuI2luZm8uZmluKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuSU5GT1xuICAgICAgICAgICAgICAgIHRoaXMuI2xvb3AgPSB0cnVlXG4gICAgICAgICAgICAgICAgdGhpcy5ydW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB3ZWJzb2NrZXRNZXNzYWdlUmVjZWl2ZWQodGhpcy53cywgdGhpcy4jaW5mby5iaW5hcnlUeXBlLCBCdWZmZXIuY29uY2F0KHRoaXMuI2ZyYWdtZW50cykpXG5cbiAgICAgICAgICAgICAgdGhpcy4jbG9vcCA9IHRydWVcbiAgICAgICAgICAgICAgdGhpcy4jc3RhdGUgPSBwYXJzZXJTdGF0ZXMuSU5GT1xuICAgICAgICAgICAgICB0aGlzLiNmcmFnbWVudHMubGVuZ3RoID0gMFxuICAgICAgICAgICAgICB0aGlzLnJ1bihjYWxsYmFjaylcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHRoaXMuI2xvb3AgPSBmYWxzZVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGFrZSBuIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIEJ1ZmZlcnNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5cbiAgICogQHJldHVybnMge0J1ZmZlcn1cbiAgICovXG4gIGNvbnN1bWUgKG4pIHtcbiAgICBpZiAobiA+IHRoaXMuI2J5dGVPZmZzZXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGVkIGNvbnN1bWUoKSBiZWZvcmUgYnVmZmVycyBzYXRpYXRlZC4nKVxuICAgIH0gZWxzZSBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuIGVtcHR5QnVmZmVyXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI2J1ZmZlcnNbMF0ubGVuZ3RoID09PSBuKSB7XG4gICAgICB0aGlzLiNieXRlT2Zmc2V0IC09IHRoaXMuI2J1ZmZlcnNbMF0ubGVuZ3RoXG4gICAgICByZXR1cm4gdGhpcy4jYnVmZmVycy5zaGlmdCgpXG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pXG4gICAgbGV0IG9mZnNldCA9IDBcblxuICAgIHdoaWxlIChvZmZzZXQgIT09IG4pIHtcbiAgICAgIGNvbnN0IG5leHQgPSB0aGlzLiNidWZmZXJzWzBdXG4gICAgICBjb25zdCB7IGxlbmd0aCB9ID0gbmV4dFxuXG4gICAgICBpZiAobGVuZ3RoICsgb2Zmc2V0ID09PSBuKSB7XG4gICAgICAgIGJ1ZmZlci5zZXQodGhpcy4jYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aCArIG9mZnNldCA+IG4pIHtcbiAgICAgICAgYnVmZmVyLnNldChuZXh0LnN1YmFycmF5KDAsIG4gLSBvZmZzZXQpLCBvZmZzZXQpXG4gICAgICAgIHRoaXMuI2J1ZmZlcnNbMF0gPSBuZXh0LnN1YmFycmF5KG4gLSBvZmZzZXQpXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIuc2V0KHRoaXMuI2J1ZmZlcnMuc2hpZnQoKSwgb2Zmc2V0KVxuICAgICAgICBvZmZzZXQgKz0gbmV4dC5sZW5ndGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLiNieXRlT2Zmc2V0IC09IG5cblxuICAgIHJldHVybiBidWZmZXJcbiAgfVxuXG4gIHBhcnNlQ2xvc2VCb2R5IChkYXRhKSB7XG4gICAgYXNzZXJ0KGRhdGEubGVuZ3RoICE9PSAxKVxuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy4xLjVcbiAgICAvKiogQHR5cGUge251bWJlcnx1bmRlZmluZWR9ICovXG4gICAgbGV0IGNvZGVcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+PSAyKSB7XG4gICAgICAvLyBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIENsb3NlIENvZGVfIGlzXG4gICAgICAvLyBkZWZpbmVkIGFzIHRoZSBzdGF0dXMgY29kZSAoU2VjdGlvbiA3LjQpIGNvbnRhaW5lZCBpbiB0aGUgZmlyc3QgQ2xvc2VcbiAgICAgIC8vIGNvbnRyb2wgZnJhbWUgcmVjZWl2ZWQgYnkgdGhlIGFwcGxpY2F0aW9uXG4gICAgICBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMClcbiAgICB9XG5cbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkICYmICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgcmV0dXJuIHsgY29kZTogMTAwMiwgcmVhc29uOiAnSW52YWxpZCBzdGF0dXMgY29kZScsIGVycm9yOiB0cnVlIH1cbiAgICB9XG5cbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi03LjEuNlxuICAgIC8qKiBAdHlwZSB7QnVmZmVyfSAqL1xuICAgIGxldCByZWFzb24gPSBkYXRhLnN1YmFycmF5KDIpXG5cbiAgICAvLyBSZW1vdmUgQk9NXG4gICAgaWYgKHJlYXNvblswXSA9PT0gMHhFRiAmJiByZWFzb25bMV0gPT09IDB4QkIgJiYgcmVhc29uWzJdID09PSAweEJGKSB7XG4gICAgICByZWFzb24gPSByZWFzb24uc3ViYXJyYXkoMylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmVhc29uID0gdXRmOERlY29kZShyZWFzb24pXG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4geyBjb2RlOiAxMDA3LCByZWFzb246ICdJbnZhbGlkIFVURi04JywgZXJyb3I6IHRydWUgfVxuICAgIH1cblxuICAgIHJldHVybiB7IGNvZGUsIHJlYXNvbiwgZXJyb3I6IGZhbHNlIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgY29udHJvbCBmcmFtZXMuXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBib2R5XG4gICAqL1xuICBwYXJzZUNvbnRyb2xGcmFtZSAoYm9keSkge1xuICAgIGNvbnN0IHsgb3Bjb2RlLCBwYXlsb2FkTGVuZ3RoIH0gPSB0aGlzLiNpbmZvXG5cbiAgICBpZiAob3Bjb2RlID09PSBvcGNvZGVzLkNMT1NFKSB7XG4gICAgICBpZiAocGF5bG9hZExlbmd0aCA9PT0gMSkge1xuICAgICAgICBmYWlsV2Vic29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCAnUmVjZWl2ZWQgY2xvc2UgZnJhbWUgd2l0aCBhIDEtYnl0ZSBib2R5LicpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICB0aGlzLiNpbmZvLmNsb3NlSW5mbyA9IHRoaXMucGFyc2VDbG9zZUJvZHkoYm9keSlcblxuICAgICAgaWYgKHRoaXMuI2luZm8uY2xvc2VJbmZvLmVycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgY29kZSwgcmVhc29uIH0gPSB0aGlzLiNpbmZvLmNsb3NlSW5mb1xuXG4gICAgICAgIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbih0aGlzLndzLCBjb2RlLCByZWFzb24sIHJlYXNvbi5sZW5ndGgpXG4gICAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHRoaXMud3MsIHJlYXNvbilcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLndzW2tTZW50Q2xvc2VdICE9PSBzZW50Q2xvc2VGcmFtZVN0YXRlLlNFTlQpIHtcbiAgICAgICAgLy8gSWYgYW4gZW5kcG9pbnQgcmVjZWl2ZXMgYSBDbG9zZSBmcmFtZSBhbmQgZGlkIG5vdCBwcmV2aW91c2x5IHNlbmQgYVxuICAgICAgICAvLyBDbG9zZSBmcmFtZSwgdGhlIGVuZHBvaW50IE1VU1Qgc2VuZCBhIENsb3NlIGZyYW1lIGluIHJlc3BvbnNlLiAgKFdoZW5cbiAgICAgICAgLy8gc2VuZGluZyBhIENsb3NlIGZyYW1lIGluIHJlc3BvbnNlLCB0aGUgZW5kcG9pbnQgdHlwaWNhbGx5IGVjaG9zIHRoZVxuICAgICAgICAvLyBzdGF0dXMgY29kZSBpdCByZWNlaXZlZC4pXG4gICAgICAgIGxldCBib2R5ID0gZW1wdHlCdWZmZXJcbiAgICAgICAgaWYgKHRoaXMuI2luZm8uY2xvc2VJbmZvLmNvZGUpIHtcbiAgICAgICAgICBib2R5ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIpXG4gICAgICAgICAgYm9keS53cml0ZVVJbnQxNkJFKHRoaXMuI2luZm8uY2xvc2VJbmZvLmNvZGUsIDApXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xvc2VGcmFtZSA9IG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQoYm9keSlcblxuICAgICAgICB0aGlzLndzW2tSZXNwb25zZV0uc29ja2V0LndyaXRlKFxuICAgICAgICAgIGNsb3NlRnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5DTE9TRSksXG4gICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgdGhpcy53c1trU2VudENsb3NlXSA9IHNlbnRDbG9zZUZyYW1lU3RhdGUuU0VOVFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICAvLyBVcG9uIGVpdGhlciBzZW5kaW5nIG9yIHJlY2VpdmluZyBhIENsb3NlIGNvbnRyb2wgZnJhbWUsIGl0IGlzIHNhaWRcbiAgICAgIC8vIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ2xvc2luZyBIYW5kc2hha2UgaXMgU3RhcnRlZF8gYW5kIHRoYXQgdGhlXG4gICAgICAvLyBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ0xPU0lORyBzdGF0ZS5cbiAgICAgIHRoaXMud3Nba1JlYWR5U3RhdGVdID0gc3RhdGVzLkNMT1NJTkdcbiAgICAgIHRoaXMud3Nba1JlY2VpdmVkQ2xvc2VdID0gdHJ1ZVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2UgaWYgKG9wY29kZSA9PT0gb3Bjb2Rlcy5QSU5HKSB7XG4gICAgICAvLyBVcG9uIHJlY2VpcHQgb2YgYSBQaW5nIGZyYW1lLCBhbiBlbmRwb2ludCBNVVNUIHNlbmQgYSBQb25nIGZyYW1lIGluXG4gICAgICAvLyByZXNwb25zZSwgdW5sZXNzIGl0IGFscmVhZHkgcmVjZWl2ZWQgYSBDbG9zZSBmcmFtZS5cbiAgICAgIC8vIEEgUG9uZyBmcmFtZSBzZW50IGluIHJlc3BvbnNlIHRvIGEgUGluZyBmcmFtZSBtdXN0IGhhdmUgaWRlbnRpY2FsXG4gICAgICAvLyBcIkFwcGxpY2F0aW9uIGRhdGFcIlxuXG4gICAgICBpZiAoIXRoaXMud3Nba1JlY2VpdmVkQ2xvc2VdKSB7XG4gICAgICAgIGNvbnN0IGZyYW1lID0gbmV3IFdlYnNvY2tldEZyYW1lU2VuZChib2R5KVxuXG4gICAgICAgIHRoaXMud3Nba1Jlc3BvbnNlXS5zb2NrZXQud3JpdGUoZnJhbWUuY3JlYXRlRnJhbWUob3Bjb2Rlcy5QT05HKSlcblxuICAgICAgICBpZiAoY2hhbm5lbHMucGluZy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICAgIGNoYW5uZWxzLnBpbmcucHVibGlzaCh7XG4gICAgICAgICAgICBwYXlsb2FkOiBib2R5XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3Bjb2RlID09PSBvcGNvZGVzLlBPTkcpIHtcbiAgICAgIC8vIEEgUG9uZyBmcmFtZSBNQVkgYmUgc2VudCB1bnNvbGljaXRlZC4gIFRoaXMgc2VydmVzIGFzIGFcbiAgICAgIC8vIHVuaWRpcmVjdGlvbmFsIGhlYXJ0YmVhdC4gIEEgcmVzcG9uc2UgdG8gYW4gdW5zb2xpY2l0ZWQgUG9uZyBmcmFtZSBpc1xuICAgICAgLy8gbm90IGV4cGVjdGVkLlxuXG4gICAgICBpZiAoY2hhbm5lbHMucG9uZy5oYXNTdWJzY3JpYmVycykge1xuICAgICAgICBjaGFubmVscy5wb25nLnB1Ymxpc2goe1xuICAgICAgICAgIHBheWxvYWQ6IGJvZHlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZ2V0IGNsb3NpbmdJbmZvICgpIHtcbiAgICByZXR1cm4gdGhpcy4jaW5mby5jbG9zZUluZm9cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQnl0ZVBhcnNlclxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/sender.js":
/*!*********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/sender.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { WebsocketFrameSend } = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/undici/lib/web/websocket/frame.js\")\nconst { opcodes, sendHints } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst FixedQueue = __webpack_require__(/*! ../../dispatcher/fixed-queue */ \"(rsc)/./node_modules/undici/lib/dispatcher/fixed-queue.js\")\n\n/** @type {typeof Uint8Array} */\nconst FastBuffer = Buffer[Symbol.species]\n\n/**\n * @typedef {object} SendQueueNode\n * @property {Promise<void> | null} promise\n * @property {((...args: any[]) => any)} callback\n * @property {Buffer | null} frame\n */\n\nclass SendQueue {\n  /**\n   * @type {FixedQueue}\n   */\n  #queue = new FixedQueue()\n\n  /**\n   * @type {boolean}\n   */\n  #running = false\n\n  /** @type {import('node:net').Socket} */\n  #socket\n\n  constructor (socket) {\n    this.#socket = socket\n  }\n\n  add (item, cb, hint) {\n    if (hint !== sendHints.blob) {\n      const frame = createFrame(item, hint)\n      if (!this.#running) {\n        // fast-path\n        this.#socket.write(frame, cb)\n      } else {\n        /** @type {SendQueueNode} */\n        const node = {\n          promise: null,\n          callback: cb,\n          frame\n        }\n        this.#queue.push(node)\n      }\n      return\n    }\n\n    /** @type {SendQueueNode} */\n    const node = {\n      promise: item.arrayBuffer().then((ab) => {\n        node.promise = null\n        node.frame = createFrame(ab, hint)\n      }),\n      callback: cb,\n      frame: null\n    }\n\n    this.#queue.push(node)\n\n    if (!this.#running) {\n      this.#run()\n    }\n  }\n\n  async #run () {\n    this.#running = true\n    const queue = this.#queue\n    while (!queue.isEmpty()) {\n      const node = queue.shift()\n      // wait pending promise\n      if (node.promise !== null) {\n        await node.promise\n      }\n      // write\n      this.#socket.write(node.frame, node.callback)\n      // cleanup\n      node.callback = node.frame = null\n    }\n    this.#running = false\n  }\n}\n\nfunction createFrame (data, hint) {\n  return new WebsocketFrameSend(toBuffer(data, hint)).createFrame(hint === sendHints.string ? opcodes.TEXT : opcodes.BINARY)\n}\n\nfunction toBuffer (data, hint) {\n  switch (hint) {\n    case sendHints.string:\n      return Buffer.from(data)\n    case sendHints.arrayBuffer:\n    case sendHints.blob:\n      return new FastBuffer(data)\n    case sendHints.typedArray:\n      return new FastBuffer(data.buffer, data.byteOffset, data.byteLength)\n  }\n}\n\nmodule.exports = { SendQueue }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3NlbmRlci5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLHFCQUFxQixFQUFFLG1CQUFPLENBQUMsdUVBQVM7QUFDaEQsUUFBUSxxQkFBcUIsRUFBRSxtQkFBTyxDQUFDLCtFQUFhO0FBQ3BELG1CQUFtQixtQkFBTyxDQUFDLCtGQUE4Qjs7QUFFekQsV0FBVyxtQkFBbUI7QUFDOUI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxzQkFBc0I7QUFDcEMsY0FBYywyQkFBMkI7QUFDekMsY0FBYyxlQUFlO0FBQzdCOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBLGFBQWEsMkJBQTJCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXHNlbmRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuY29uc3QgeyBXZWJzb2NrZXRGcmFtZVNlbmQgfSA9IHJlcXVpcmUoJy4vZnJhbWUnKVxuY29uc3QgeyBvcGNvZGVzLCBzZW5kSGludHMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IEZpeGVkUXVldWUgPSByZXF1aXJlKCcuLi8uLi9kaXNwYXRjaGVyL2ZpeGVkLXF1ZXVlJylcblxuLyoqIEB0eXBlIHt0eXBlb2YgVWludDhBcnJheX0gKi9cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gU2VuZFF1ZXVlTm9kZVxuICogQHByb3BlcnR5IHtQcm9taXNlPHZvaWQ+IHwgbnVsbH0gcHJvbWlzZVxuICogQHByb3BlcnR5IHsoKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpfSBjYWxsYmFja1xuICogQHByb3BlcnR5IHtCdWZmZXIgfCBudWxsfSBmcmFtZVxuICovXG5cbmNsYXNzIFNlbmRRdWV1ZSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7Rml4ZWRRdWV1ZX1cbiAgICovXG4gICNxdWV1ZSA9IG5ldyBGaXhlZFF1ZXVlKClcblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICAjcnVubmluZyA9IGZhbHNlXG5cbiAgLyoqIEB0eXBlIHtpbXBvcnQoJ25vZGU6bmV0JykuU29ja2V0fSAqL1xuICAjc29ja2V0XG5cbiAgY29uc3RydWN0b3IgKHNvY2tldCkge1xuICAgIHRoaXMuI3NvY2tldCA9IHNvY2tldFxuICB9XG5cbiAgYWRkIChpdGVtLCBjYiwgaGludCkge1xuICAgIGlmIChoaW50ICE9PSBzZW5kSGludHMuYmxvYikge1xuICAgICAgY29uc3QgZnJhbWUgPSBjcmVhdGVGcmFtZShpdGVtLCBoaW50KVxuICAgICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICAgIC8vIGZhc3QtcGF0aFxuICAgICAgICB0aGlzLiNzb2NrZXQud3JpdGUoZnJhbWUsIGNiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyoqIEB0eXBlIHtTZW5kUXVldWVOb2RlfSAqL1xuICAgICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICAgIHByb21pc2U6IG51bGwsXG4gICAgICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgICAgIGZyYW1lXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcXVldWUucHVzaChub2RlKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtTZW5kUXVldWVOb2RlfSAqL1xuICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICBwcm9taXNlOiBpdGVtLmFycmF5QnVmZmVyKCkudGhlbigoYWIpID0+IHtcbiAgICAgICAgbm9kZS5wcm9taXNlID0gbnVsbFxuICAgICAgICBub2RlLmZyYW1lID0gY3JlYXRlRnJhbWUoYWIsIGhpbnQpXG4gICAgICB9KSxcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIGZyYW1lOiBudWxsXG4gICAgfVxuXG4gICAgdGhpcy4jcXVldWUucHVzaChub2RlKVxuXG4gICAgaWYgKCF0aGlzLiNydW5uaW5nKSB7XG4gICAgICB0aGlzLiNydW4oKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jICNydW4gKCkge1xuICAgIHRoaXMuI3J1bm5pbmcgPSB0cnVlXG4gICAgY29uc3QgcXVldWUgPSB0aGlzLiNxdWV1ZVxuICAgIHdoaWxlICghcXVldWUuaXNFbXB0eSgpKSB7XG4gICAgICBjb25zdCBub2RlID0gcXVldWUuc2hpZnQoKVxuICAgICAgLy8gd2FpdCBwZW5kaW5nIHByb21pc2VcbiAgICAgIGlmIChub2RlLnByb21pc2UgIT09IG51bGwpIHtcbiAgICAgICAgYXdhaXQgbm9kZS5wcm9taXNlXG4gICAgICB9XG4gICAgICAvLyB3cml0ZVxuICAgICAgdGhpcy4jc29ja2V0LndyaXRlKG5vZGUuZnJhbWUsIG5vZGUuY2FsbGJhY2spXG4gICAgICAvLyBjbGVhbnVwXG4gICAgICBub2RlLmNhbGxiYWNrID0gbm9kZS5mcmFtZSA9IG51bGxcbiAgICB9XG4gICAgdGhpcy4jcnVubmluZyA9IGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRnJhbWUgKGRhdGEsIGhpbnQpIHtcbiAgcmV0dXJuIG5ldyBXZWJzb2NrZXRGcmFtZVNlbmQodG9CdWZmZXIoZGF0YSwgaGludCkpLmNyZWF0ZUZyYW1lKGhpbnQgPT09IHNlbmRIaW50cy5zdHJpbmcgPyBvcGNvZGVzLlRFWFQgOiBvcGNvZGVzLkJJTkFSWSlcbn1cblxuZnVuY3Rpb24gdG9CdWZmZXIgKGRhdGEsIGhpbnQpIHtcbiAgc3dpdGNoIChoaW50KSB7XG4gICAgY2FzZSBzZW5kSGludHMuc3RyaW5nOlxuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEpXG4gICAgY2FzZSBzZW5kSGludHMuYXJyYXlCdWZmZXI6XG4gICAgY2FzZSBzZW5kSGludHMuYmxvYjpcbiAgICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihkYXRhKVxuICAgIGNhc2Ugc2VuZEhpbnRzLnR5cGVkQXJyYXk6XG4gICAgICByZXR1cm4gbmV3IEZhc3RCdWZmZXIoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBTZW5kUXVldWUgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/symbols.js":
/*!**********************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/symbols.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("\n\nmodule.exports = {\n  kWebSocketURL: Symbol('url'),\n  kReadyState: Symbol('ready state'),\n  kController: Symbol('controller'),\n  kResponse: Symbol('response'),\n  kBinaryType: Symbol('binary type'),\n  kSentClose: Symbol('sent close'),\n  kReceivedClose: Symbol('received close'),\n  kByteParser: Symbol('byte parser')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3N5bWJvbHMuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbG9yZHJcXERvd25sb2Fkc1xcQW5pVGVhbXMtbWFpblxcbm9kZV9tb2R1bGVzXFx1bmRpY2lcXGxpYlxcd2ViXFx3ZWJzb2NrZXRcXHN5bWJvbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBrV2ViU29ja2V0VVJMOiBTeW1ib2woJ3VybCcpLFxuICBrUmVhZHlTdGF0ZTogU3ltYm9sKCdyZWFkeSBzdGF0ZScpLFxuICBrQ29udHJvbGxlcjogU3ltYm9sKCdjb250cm9sbGVyJyksXG4gIGtSZXNwb25zZTogU3ltYm9sKCdyZXNwb25zZScpLFxuICBrQmluYXJ5VHlwZTogU3ltYm9sKCdiaW5hcnkgdHlwZScpLFxuICBrU2VudENsb3NlOiBTeW1ib2woJ3NlbnQgY2xvc2UnKSxcbiAga1JlY2VpdmVkQ2xvc2U6IFN5bWJvbCgncmVjZWl2ZWQgY2xvc2UnKSxcbiAga0J5dGVQYXJzZXI6IFN5bWJvbCgnYnl0ZSBwYXJzZXInKVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/symbols.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/util.js":
/*!*******************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/util.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/websocket/symbols.js\")\nconst { states, opcodes } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst { ErrorEvent, createFastMessageEvent } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { isUtf8 } = __webpack_require__(/*! node:buffer */ \"node:buffer\")\nconst { collectASequenceOfCodePointsFast, removeHTTPWhitespace } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\n\n/* globals Blob */\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isConnecting (ws) {\n  // If the WebSocket connection is not yet established, and the connection\n  // is not yet closed, then the WebSocket connection is in the CONNECTING state.\n  return ws[kReadyState] === states.CONNECTING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isEstablished (ws) {\n  // If the server's response is validated as provided for above, it is\n  // said that _The WebSocket Connection is Established_ and that the\n  // WebSocket Connection is in the OPEN state.\n  return ws[kReadyState] === states.OPEN\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isClosing (ws) {\n  // Upon either sending or receiving a Close control frame, it is said\n  // that _The WebSocket Closing Handshake is Started_ and that the\n  // WebSocket connection is in the CLOSING state.\n  return ws[kReadyState] === states.CLOSING\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @returns {boolean}\n */\nfunction isClosed (ws) {\n  return ws[kReadyState] === states.CLOSED\n}\n\n/**\n * @see https://dom.spec.whatwg.org/#concept-event-fire\n * @param {string} e\n * @param {EventTarget} target\n * @param {(...args: ConstructorParameters<typeof Event>) => Event} eventFactory\n * @param {EventInit | undefined} eventInitDict\n */\nfunction fireEvent (e, target, eventFactory = (type, init) => new Event(type, init), eventInitDict = {}) {\n  // 1. If eventConstructor is not given, then let eventConstructor be Event.\n\n  // 2. Let event be the result of creating an event given eventConstructor,\n  //    in the relevant realm of target.\n  // 3. Initialize event’s type attribute to e.\n  const event = eventFactory(e, eventInitDict)\n\n  // 4. Initialize any other IDL attributes of event as described in the\n  //    invocation of this algorithm.\n\n  // 5. Return the result of dispatching event at target, with legacy target\n  //    override flag set if set.\n  target.dispatchEvent(event)\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n * @param {number} type Opcode\n * @param {Buffer} data application data\n */\nfunction websocketMessageReceived (ws, type, data) {\n  // 1. If ready state is not OPEN (1), then return.\n  if (ws[kReadyState] !== states.OPEN) {\n    return\n  }\n\n  // 2. Let dataForEvent be determined by switching on type and binary type:\n  let dataForEvent\n\n  if (type === opcodes.TEXT) {\n    // -> type indicates that the data is Text\n    //      a new DOMString containing data\n    try {\n      dataForEvent = utf8Decode(data)\n    } catch {\n      failWebsocketConnection(ws, 'Received invalid UTF-8 in text frame.')\n      return\n    }\n  } else if (type === opcodes.BINARY) {\n    if (ws[kBinaryType] === 'blob') {\n      // -> type indicates that the data is Binary and binary type is \"blob\"\n      //      a new Blob object, created in the relevant Realm of the WebSocket\n      //      object, that represents data as its raw data\n      dataForEvent = new Blob([data])\n    } else {\n      // -> type indicates that the data is Binary and binary type is \"arraybuffer\"\n      //      a new ArrayBuffer object, created in the relevant Realm of the\n      //      WebSocket object, whose contents are data\n      dataForEvent = toArrayBuffer(data)\n    }\n  }\n\n  // 3. Fire an event named message at the WebSocket object, using MessageEvent,\n  //    with the origin attribute initialized to the serialization of the WebSocket\n  //    object’s url's origin, and the data attribute initialized to dataForEvent.\n  fireEvent('message', ws, createFastMessageEvent, {\n    origin: ws[kWebSocketURL].origin,\n    data: dataForEvent\n  })\n}\n\nfunction toArrayBuffer (buffer) {\n  if (buffer.byteLength === buffer.buffer.byteLength) {\n    return buffer.buffer\n  }\n  return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength)\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455\n * @see https://datatracker.ietf.org/doc/html/rfc2616\n * @see https://bugs.chromium.org/p/chromium/issues/detail?id=398407\n * @param {string} protocol\n */\nfunction isValidSubprotocol (protocol) {\n  // If present, this value indicates one\n  // or more comma-separated subprotocol the client wishes to speak,\n  // ordered by preference.  The elements that comprise this value\n  // MUST be non-empty strings with characters in the range U+0021 to\n  // U+007E not including separator characters as defined in\n  // [RFC2616] and MUST all be unique strings.\n  if (protocol.length === 0) {\n    return false\n  }\n\n  for (let i = 0; i < protocol.length; ++i) {\n    const code = protocol.charCodeAt(i)\n\n    if (\n      code < 0x21 || // CTL, contains SP (0x20) and HT (0x09)\n      code > 0x7E ||\n      code === 0x22 || // \"\n      code === 0x28 || // (\n      code === 0x29 || // )\n      code === 0x2C || // ,\n      code === 0x2F || // /\n      code === 0x3A || // :\n      code === 0x3B || // ;\n      code === 0x3C || // <\n      code === 0x3D || // =\n      code === 0x3E || // >\n      code === 0x3F || // ?\n      code === 0x40 || // @\n      code === 0x5B || // [\n      code === 0x5C || // \\\n      code === 0x5D || // ]\n      code === 0x7B || // {\n      code === 0x7D // }\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7-4\n * @param {number} code\n */\nfunction isValidStatusCode (code) {\n  if (code >= 1000 && code < 1015) {\n    return (\n      code !== 1004 && // reserved\n      code !== 1005 && // \"MUST NOT be set as a status code\"\n      code !== 1006 // \"MUST NOT be set as a status code\"\n    )\n  }\n\n  return code >= 3000 && code <= 4999\n}\n\n/**\n * @param {import('./websocket').WebSocket} ws\n * @param {string|undefined} reason\n */\nfunction failWebsocketConnection (ws, reason) {\n  const { [kController]: controller, [kResponse]: response } = ws\n\n  controller.abort()\n\n  if (response?.socket && !response.socket.destroyed) {\n    response.socket.destroy()\n  }\n\n  if (reason) {\n    // TODO: process.nextTick\n    fireEvent('error', ws, (type, init) => new ErrorEvent(type, init), {\n      error: new Error(reason),\n      message: reason\n    })\n  }\n}\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-5.5\n * @param {number} opcode\n */\nfunction isControlFrame (opcode) {\n  return (\n    opcode === opcodes.CLOSE ||\n    opcode === opcodes.PING ||\n    opcode === opcodes.PONG\n  )\n}\n\nfunction isContinuationFrame (opcode) {\n  return opcode === opcodes.CONTINUATION\n}\n\nfunction isTextBinaryFrame (opcode) {\n  return opcode === opcodes.TEXT || opcode === opcodes.BINARY\n}\n\nfunction isValidOpcode (opcode) {\n  return isTextBinaryFrame(opcode) || isContinuationFrame(opcode) || isControlFrame(opcode)\n}\n\n/**\n * Parses a Sec-WebSocket-Extensions header value.\n * @param {string} extensions\n * @returns {Map<string, string>}\n */\n// TODO(@Uzlopak, @KhafraDev): make compliant https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\nfunction parseExtensions (extensions) {\n  const position = { position: 0 }\n  const extensionList = new Map()\n\n  while (position.position < extensions.length) {\n    const pair = collectASequenceOfCodePointsFast(';', extensions, position)\n    const [name, value = ''] = pair.split('=')\n\n    extensionList.set(\n      removeHTTPWhitespace(name, true, false),\n      removeHTTPWhitespace(value, false, true)\n    )\n\n    position.position++\n  }\n\n  return extensionList\n}\n\n/**\n * @see https://www.rfc-editor.org/rfc/rfc7692#section-7.1.2.2\n * @description \"client-max-window-bits = 1*DIGIT\"\n * @param {string} value\n */\nfunction isValidClientWindowBits (value) {\n  for (let i = 0; i < value.length; i++) {\n    const byte = value.charCodeAt(i)\n\n    if (byte < 0x30 || byte > 0x39) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// https://nodejs.org/api/intl.html#detecting-internationalization-support\nconst hasIntl = typeof process.versions.icu === 'string'\nconst fatalDecoder = hasIntl ? new TextDecoder('utf-8', { fatal: true }) : undefined\n\n/**\n * Converts a Buffer to utf-8, even on platforms without icu.\n * @param {Buffer} buffer\n */\nconst utf8Decode = hasIntl\n  ? fatalDecoder.decode.bind(fatalDecoder)\n  : function (buffer) {\n    if (isUtf8(buffer)) {\n      return buffer.toString('utf-8')\n    }\n    throw new TypeError('Invalid utf-8 received.')\n  }\n\nmodule.exports = {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isClosed,\n  fireEvent,\n  isValidSubprotocol,\n  isValidStatusCode,\n  failWebsocketConnection,\n  websocketMessageReceived,\n  utf8Decode,\n  isControlFrame,\n  isContinuationFrame,\n  isTextBinaryFrame,\n  isValidOpcode,\n  parseExtensions,\n  isValidClientWindowBits\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosUUFBUSxrRUFBa0UsRUFBRSxtQkFBTyxDQUFDLDJFQUFXO0FBQy9GLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQywrRUFBYTtBQUNqRCxRQUFRLHFDQUFxQyxFQUFFLG1CQUFPLENBQUMseUVBQVU7QUFDakUsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN4QyxRQUFRLHlEQUF5RCxFQUFFLG1CQUFPLENBQUMsZ0ZBQW1COztBQUU5Rjs7QUFFQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlDQUFpQztBQUM1QyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGFBQWE7QUFDeEIsV0FBVyx5REFBeUQ7QUFDcEUsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQSx1R0FBdUc7QUFDdkc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHFCQUFxQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUMsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBLFVBQVUsbURBQW1EOztBQUU3RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxvREFBb0Q7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTs7QUFFdkU7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxvcmRyXFxEb3dubG9hZHNcXEFuaVRlYW1zLW1haW5cXG5vZGVfbW9kdWxlc1xcdW5kaWNpXFxsaWJcXHdlYlxcd2Vic29ja2V0XFx1dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGtSZWFkeVN0YXRlLCBrQ29udHJvbGxlciwga1Jlc3BvbnNlLCBrQmluYXJ5VHlwZSwga1dlYlNvY2tldFVSTCB9ID0gcmVxdWlyZSgnLi9zeW1ib2xzJylcbmNvbnN0IHsgc3RhdGVzLCBvcGNvZGVzIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpXG5jb25zdCB7IEVycm9yRXZlbnQsIGNyZWF0ZUZhc3RNZXNzYWdlRXZlbnQgfSA9IHJlcXVpcmUoJy4vZXZlbnRzJylcbmNvbnN0IHsgaXNVdGY4IH0gPSByZXF1aXJlKCdub2RlOmJ1ZmZlcicpXG5jb25zdCB7IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0LCByZW1vdmVIVFRQV2hpdGVzcGFjZSB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuXG4vKiBnbG9iYWxzIEJsb2IgKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNDb25uZWN0aW5nICh3cykge1xuICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgbm90IHlldCBlc3RhYmxpc2hlZCwgYW5kIHRoZSBjb25uZWN0aW9uXG4gIC8vIGlzIG5vdCB5ZXQgY2xvc2VkLCB0aGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBpcyBpbiB0aGUgQ09OTkVDVElORyBzdGF0ZS5cbiAgcmV0dXJuIHdzW2tSZWFkeVN0YXRlXSA9PT0gc3RhdGVzLkNPTk5FQ1RJTkdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi93ZWJzb2NrZXQnKS5XZWJTb2NrZXR9IHdzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFc3RhYmxpc2hlZCAod3MpIHtcbiAgLy8gSWYgdGhlIHNlcnZlcidzIHJlc3BvbnNlIGlzIHZhbGlkYXRlZCBhcyBwcm92aWRlZCBmb3IgYWJvdmUsIGl0IGlzXG4gIC8vIHNhaWQgdGhhdCBfVGhlIFdlYlNvY2tldCBDb25uZWN0aW9uIGlzIEVzdGFibGlzaGVkXyBhbmQgdGhhdCB0aGVcbiAgLy8gV2ViU29ja2V0IENvbm5lY3Rpb24gaXMgaW4gdGhlIE9QRU4gc3RhdGUuXG4gIHJldHVybiB3c1trUmVhZHlTdGF0ZV0gPT09IHN0YXRlcy5PUEVOXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzQ2xvc2luZyAod3MpIHtcbiAgLy8gVXBvbiBlaXRoZXIgc2VuZGluZyBvciByZWNlaXZpbmcgYSBDbG9zZSBjb250cm9sIGZyYW1lLCBpdCBpcyBzYWlkXG4gIC8vIHRoYXQgX1RoZSBXZWJTb2NrZXQgQ2xvc2luZyBIYW5kc2hha2UgaXMgU3RhcnRlZF8gYW5kIHRoYXQgdGhlXG4gIC8vIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGluIHRoZSBDTE9TSU5HIHN0YXRlLlxuICByZXR1cm4gd3Nba1JlYWR5U3RhdGVdID09PSBzdGF0ZXMuQ0xPU0lOR1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3dlYnNvY2tldCcpLldlYlNvY2tldH0gd3NcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Nsb3NlZCAod3MpIHtcbiAgcmV0dXJuIHdzW2tSZWFkeVN0YXRlXSA9PT0gc3RhdGVzLkNMT1NFRFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNjb25jZXB0LWV2ZW50LWZpcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7KC4uLmFyZ3M6IENvbnN0cnVjdG9yUGFyYW1ldGVyczx0eXBlb2YgRXZlbnQ+KSA9PiBFdmVudH0gZXZlbnRGYWN0b3J5XG4gKiBAcGFyYW0ge0V2ZW50SW5pdCB8IHVuZGVmaW5lZH0gZXZlbnRJbml0RGljdFxuICovXG5mdW5jdGlvbiBmaXJlRXZlbnQgKGUsIHRhcmdldCwgZXZlbnRGYWN0b3J5ID0gKHR5cGUsIGluaXQpID0+IG5ldyBFdmVudCh0eXBlLCBpbml0KSwgZXZlbnRJbml0RGljdCA9IHt9KSB7XG4gIC8vIDEuIElmIGV2ZW50Q29uc3RydWN0b3IgaXMgbm90IGdpdmVuLCB0aGVuIGxldCBldmVudENvbnN0cnVjdG9yIGJlIEV2ZW50LlxuXG4gIC8vIDIuIExldCBldmVudCBiZSB0aGUgcmVzdWx0IG9mIGNyZWF0aW5nIGFuIGV2ZW50IGdpdmVuIGV2ZW50Q29uc3RydWN0b3IsXG4gIC8vICAgIGluIHRoZSByZWxldmFudCByZWFsbSBvZiB0YXJnZXQuXG4gIC8vIDMuIEluaXRpYWxpemUgZXZlbnTigJlzIHR5cGUgYXR0cmlidXRlIHRvIGUuXG4gIGNvbnN0IGV2ZW50ID0gZXZlbnRGYWN0b3J5KGUsIGV2ZW50SW5pdERpY3QpXG5cbiAgLy8gNC4gSW5pdGlhbGl6ZSBhbnkgb3RoZXIgSURMIGF0dHJpYnV0ZXMgb2YgZXZlbnQgYXMgZGVzY3JpYmVkIGluIHRoZVxuICAvLyAgICBpbnZvY2F0aW9uIG9mIHRoaXMgYWxnb3JpdGhtLlxuXG4gIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGRpc3BhdGNoaW5nIGV2ZW50IGF0IHRhcmdldCwgd2l0aCBsZWdhY3kgdGFyZ2V0XG4gIC8vICAgIG92ZXJyaWRlIGZsYWcgc2V0IGlmIHNldC5cbiAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNmZWVkYmFjay1mcm9tLXRoZS1wcm90b2NvbFxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgT3Bjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBhcHBsaWNhdGlvbiBkYXRhXG4gKi9cbmZ1bmN0aW9uIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCAod3MsIHR5cGUsIGRhdGEpIHtcbiAgLy8gMS4gSWYgcmVhZHkgc3RhdGUgaXMgbm90IE9QRU4gKDEpLCB0aGVuIHJldHVybi5cbiAgaWYgKHdzW2tSZWFkeVN0YXRlXSAhPT0gc3RhdGVzLk9QRU4pIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIDIuIExldCBkYXRhRm9yRXZlbnQgYmUgZGV0ZXJtaW5lZCBieSBzd2l0Y2hpbmcgb24gdHlwZSBhbmQgYmluYXJ5IHR5cGU6XG4gIGxldCBkYXRhRm9yRXZlbnRcblxuICBpZiAodHlwZSA9PT0gb3Bjb2Rlcy5URVhUKSB7XG4gICAgLy8gLT4gdHlwZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZGF0YSBpcyBUZXh0XG4gICAgLy8gICAgICBhIG5ldyBET01TdHJpbmcgY29udGFpbmluZyBkYXRhXG4gICAgdHJ5IHtcbiAgICAgIGRhdGFGb3JFdmVudCA9IHV0ZjhEZWNvZGUoZGF0YSlcbiAgICB9IGNhdGNoIHtcbiAgICAgIGZhaWxXZWJzb2NrZXRDb25uZWN0aW9uKHdzLCAnUmVjZWl2ZWQgaW52YWxpZCBVVEYtOCBpbiB0ZXh0IGZyYW1lLicpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gb3Bjb2Rlcy5CSU5BUlkpIHtcbiAgICBpZiAod3Nba0JpbmFyeVR5cGVdID09PSAnYmxvYicpIHtcbiAgICAgIC8vIC0+IHR5cGUgaW5kaWNhdGVzIHRoYXQgdGhlIGRhdGEgaXMgQmluYXJ5IGFuZCBiaW5hcnkgdHlwZSBpcyBcImJsb2JcIlxuICAgICAgLy8gICAgICBhIG5ldyBCbG9iIG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gICAgICBvYmplY3QsIHRoYXQgcmVwcmVzZW50cyBkYXRhIGFzIGl0cyByYXcgZGF0YVxuICAgICAgZGF0YUZvckV2ZW50ID0gbmV3IEJsb2IoW2RhdGFdKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAtPiB0eXBlIGluZGljYXRlcyB0aGF0IHRoZSBkYXRhIGlzIEJpbmFyeSBhbmQgYmluYXJ5IHR5cGUgaXMgXCJhcnJheWJ1ZmZlclwiXG4gICAgICAvLyAgICAgIGEgbmV3IEFycmF5QnVmZmVyIG9iamVjdCwgY3JlYXRlZCBpbiB0aGUgcmVsZXZhbnQgUmVhbG0gb2YgdGhlXG4gICAgICAvLyAgICAgIFdlYlNvY2tldCBvYmplY3QsIHdob3NlIGNvbnRlbnRzIGFyZSBkYXRhXG4gICAgICBkYXRhRm9yRXZlbnQgPSB0b0FycmF5QnVmZmVyKGRhdGEpXG4gICAgfVxuICB9XG5cbiAgLy8gMy4gRmlyZSBhbiBldmVudCBuYW1lZCBtZXNzYWdlIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LCB1c2luZyBNZXNzYWdlRXZlbnQsXG4gIC8vICAgIHdpdGggdGhlIG9yaWdpbiBhdHRyaWJ1dGUgaW5pdGlhbGl6ZWQgdG8gdGhlIHNlcmlhbGl6YXRpb24gb2YgdGhlIFdlYlNvY2tldFxuICAvLyAgICBvYmplY3TigJlzIHVybCdzIG9yaWdpbiwgYW5kIHRoZSBkYXRhIGF0dHJpYnV0ZSBpbml0aWFsaXplZCB0byBkYXRhRm9yRXZlbnQuXG4gIGZpcmVFdmVudCgnbWVzc2FnZScsIHdzLCBjcmVhdGVGYXN0TWVzc2FnZUV2ZW50LCB7XG4gICAgb3JpZ2luOiB3c1trV2ViU29ja2V0VVJMXS5vcmlnaW4sXG4gICAgZGF0YTogZGF0YUZvckV2ZW50XG4gIH0pXG59XG5cbmZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKGJ1ZmZlcikge1xuICBpZiAoYnVmZmVyLmJ5dGVMZW5ndGggPT09IGJ1ZmZlci5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWZmZXIuYnVmZmVyXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5idWZmZXIuc2xpY2UoYnVmZmVyLmJ5dGVPZmZzZXQsIGJ1ZmZlci5ieXRlT2Zmc2V0ICsgYnVmZmVyLmJ5dGVMZW5ndGgpXG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTVcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMyNjE2XG4gKiBAc2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM5ODQwN1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3RvY29sXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTdWJwcm90b2NvbCAocHJvdG9jb2wpIHtcbiAgLy8gSWYgcHJlc2VudCwgdGhpcyB2YWx1ZSBpbmRpY2F0ZXMgb25lXG4gIC8vIG9yIG1vcmUgY29tbWEtc2VwYXJhdGVkIHN1YnByb3RvY29sIHRoZSBjbGllbnQgd2lzaGVzIHRvIHNwZWFrLFxuICAvLyBvcmRlcmVkIGJ5IHByZWZlcmVuY2UuICBUaGUgZWxlbWVudHMgdGhhdCBjb21wcmlzZSB0aGlzIHZhbHVlXG4gIC8vIE1VU1QgYmUgbm9uLWVtcHR5IHN0cmluZ3Mgd2l0aCBjaGFyYWN0ZXJzIGluIHRoZSByYW5nZSBVKzAwMjEgdG9cbiAgLy8gVSswMDdFIG5vdCBpbmNsdWRpbmcgc2VwYXJhdG9yIGNoYXJhY3RlcnMgYXMgZGVmaW5lZCBpblxuICAvLyBbUkZDMjYxNl0gYW5kIE1VU1QgYWxsIGJlIHVuaXF1ZSBzdHJpbmdzLlxuICBpZiAocHJvdG9jb2wubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3RvY29sLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgY29kZSA9IHByb3RvY29sLmNoYXJDb2RlQXQoaSlcblxuICAgIGlmIChcbiAgICAgIGNvZGUgPCAweDIxIHx8IC8vIENUTCwgY29udGFpbnMgU1AgKDB4MjApIGFuZCBIVCAoMHgwOSlcbiAgICAgIGNvZGUgPiAweDdFIHx8XG4gICAgICBjb2RlID09PSAweDIyIHx8IC8vIFwiXG4gICAgICBjb2RlID09PSAweDI4IHx8IC8vIChcbiAgICAgIGNvZGUgPT09IDB4MjkgfHwgLy8gKVxuICAgICAgY29kZSA9PT0gMHgyQyB8fCAvLyAsXG4gICAgICBjb2RlID09PSAweDJGIHx8IC8vIC9cbiAgICAgIGNvZGUgPT09IDB4M0EgfHwgLy8gOlxuICAgICAgY29kZSA9PT0gMHgzQiB8fCAvLyA7XG4gICAgICBjb2RlID09PSAweDNDIHx8IC8vIDxcbiAgICAgIGNvZGUgPT09IDB4M0QgfHwgLy8gPVxuICAgICAgY29kZSA9PT0gMHgzRSB8fCAvLyA+XG4gICAgICBjb2RlID09PSAweDNGIHx8IC8vID9cbiAgICAgIGNvZGUgPT09IDB4NDAgfHwgLy8gQFxuICAgICAgY29kZSA9PT0gMHg1QiB8fCAvLyBbXG4gICAgICBjb2RlID09PSAweDVDIHx8IC8vIFxcXG4gICAgICBjb2RlID09PSAweDVEIHx8IC8vIF1cbiAgICAgIGNvZGUgPT09IDB4N0IgfHwgLy8ge1xuICAgICAgY29kZSA9PT0gMHg3RCAvLyB9XG4gICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tNy00XG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZSAoY29kZSkge1xuICBpZiAoY29kZSA+PSAxMDAwICYmIGNvZGUgPCAxMDE1KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGNvZGUgIT09IDEwMDQgJiYgLy8gcmVzZXJ2ZWRcbiAgICAgIGNvZGUgIT09IDEwMDUgJiYgLy8gXCJNVVNUIE5PVCBiZSBzZXQgYXMgYSBzdGF0dXMgY29kZVwiXG4gICAgICBjb2RlICE9PSAxMDA2IC8vIFwiTVVTVCBOT1QgYmUgc2V0IGFzIGEgc3RhdHVzIGNvZGVcIlxuICAgIClcbiAgfVxuXG4gIHJldHVybiBjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vd2Vic29ja2V0JykuV2ViU29ja2V0fSB3c1xuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSByZWFzb25cbiAqL1xuZnVuY3Rpb24gZmFpbFdlYnNvY2tldENvbm5lY3Rpb24gKHdzLCByZWFzb24pIHtcbiAgY29uc3QgeyBba0NvbnRyb2xsZXJdOiBjb250cm9sbGVyLCBba1Jlc3BvbnNlXTogcmVzcG9uc2UgfSA9IHdzXG5cbiAgY29udHJvbGxlci5hYm9ydCgpXG5cbiAgaWYgKHJlc3BvbnNlPy5zb2NrZXQgJiYgIXJlc3BvbnNlLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICByZXNwb25zZS5zb2NrZXQuZGVzdHJveSgpXG4gIH1cblxuICBpZiAocmVhc29uKSB7XG4gICAgLy8gVE9ETzogcHJvY2Vzcy5uZXh0VGlja1xuICAgIGZpcmVFdmVudCgnZXJyb3InLCB3cywgKHR5cGUsIGluaXQpID0+IG5ldyBFcnJvckV2ZW50KHR5cGUsIGluaXQpLCB7XG4gICAgICBlcnJvcjogbmV3IEVycm9yKHJlYXNvbiksXG4gICAgICBtZXNzYWdlOiByZWFzb25cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi01LjVcbiAqIEBwYXJhbSB7bnVtYmVyfSBvcGNvZGVcbiAqL1xuZnVuY3Rpb24gaXNDb250cm9sRnJhbWUgKG9wY29kZSkge1xuICByZXR1cm4gKFxuICAgIG9wY29kZSA9PT0gb3Bjb2Rlcy5DTE9TRSB8fFxuICAgIG9wY29kZSA9PT0gb3Bjb2Rlcy5QSU5HIHx8XG4gICAgb3Bjb2RlID09PSBvcGNvZGVzLlBPTkdcbiAgKVxufVxuXG5mdW5jdGlvbiBpc0NvbnRpbnVhdGlvbkZyYW1lIChvcGNvZGUpIHtcbiAgcmV0dXJuIG9wY29kZSA9PT0gb3Bjb2Rlcy5DT05USU5VQVRJT05cbn1cblxuZnVuY3Rpb24gaXNUZXh0QmluYXJ5RnJhbWUgKG9wY29kZSkge1xuICByZXR1cm4gb3Bjb2RlID09PSBvcGNvZGVzLlRFWFQgfHwgb3Bjb2RlID09PSBvcGNvZGVzLkJJTkFSWVxufVxuXG5mdW5jdGlvbiBpc1ZhbGlkT3Bjb2RlIChvcGNvZGUpIHtcbiAgcmV0dXJuIGlzVGV4dEJpbmFyeUZyYW1lKG9wY29kZSkgfHwgaXNDb250aW51YXRpb25GcmFtZShvcGNvZGUpIHx8IGlzQ29udHJvbEZyYW1lKG9wY29kZSlcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGV4dGVuc2lvbnNcbiAqIEByZXR1cm5zIHtNYXA8c3RyaW5nLCBzdHJpbmc+fVxuICovXG4vLyBUT0RPKEBVemxvcGFrLCBAS2hhZnJhRGV2KTogbWFrZSBjb21wbGlhbnQgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tOS4xXG5mdW5jdGlvbiBwYXJzZUV4dGVuc2lvbnMgKGV4dGVuc2lvbnMpIHtcbiAgY29uc3QgcG9zaXRpb24gPSB7IHBvc2l0aW9uOiAwIH1cbiAgY29uc3QgZXh0ZW5zaW9uTGlzdCA9IG5ldyBNYXAoKVxuXG4gIHdoaWxlIChwb3NpdGlvbi5wb3NpdGlvbiA8IGV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgY29uc3QgcGFpciA9IGNvbGxlY3RBU2VxdWVuY2VPZkNvZGVQb2ludHNGYXN0KCc7JywgZXh0ZW5zaW9ucywgcG9zaXRpb24pXG4gICAgY29uc3QgW25hbWUsIHZhbHVlID0gJyddID0gcGFpci5zcGxpdCgnPScpXG5cbiAgICBleHRlbnNpb25MaXN0LnNldChcbiAgICAgIHJlbW92ZUhUVFBXaGl0ZXNwYWNlKG5hbWUsIHRydWUsIGZhbHNlKSxcbiAgICAgIHJlbW92ZUhUVFBXaGl0ZXNwYWNlKHZhbHVlLCBmYWxzZSwgdHJ1ZSlcbiAgICApXG5cbiAgICBwb3NpdGlvbi5wb3NpdGlvbisrXG4gIH1cblxuICByZXR1cm4gZXh0ZW5zaW9uTGlzdFxufVxuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzc2OTIjc2VjdGlvbi03LjEuMi4yXG4gKiBAZGVzY3JpcHRpb24gXCJjbGllbnQtbWF4LXdpbmRvdy1iaXRzID0gMSpESUdJVFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENsaWVudFdpbmRvd0JpdHMgKHZhbHVlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBieXRlID0gdmFsdWUuY2hhckNvZGVBdChpKVxuXG4gICAgaWYgKGJ5dGUgPCAweDMwIHx8IGJ5dGUgPiAweDM5KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2ludGwuaHRtbCNkZXRlY3RpbmctaW50ZXJuYXRpb25hbGl6YXRpb24tc3VwcG9ydFxuY29uc3QgaGFzSW50bCA9IHR5cGVvZiBwcm9jZXNzLnZlcnNpb25zLmljdSA9PT0gJ3N0cmluZydcbmNvbnN0IGZhdGFsRGVjb2RlciA9IGhhc0ludGwgPyBuZXcgVGV4dERlY29kZXIoJ3V0Zi04JywgeyBmYXRhbDogdHJ1ZSB9KSA6IHVuZGVmaW5lZFxuXG4vKipcbiAqIENvbnZlcnRzIGEgQnVmZmVyIHRvIHV0Zi04LCBldmVuIG9uIHBsYXRmb3JtcyB3aXRob3V0IGljdS5cbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXJcbiAqL1xuY29uc3QgdXRmOERlY29kZSA9IGhhc0ludGxcbiAgPyBmYXRhbERlY29kZXIuZGVjb2RlLmJpbmQoZmF0YWxEZWNvZGVyKVxuICA6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICBpZiAoaXNVdGY4KGJ1ZmZlcikpIHtcbiAgICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoJ3V0Zi04JylcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCB1dGYtOCByZWNlaXZlZC4nKVxuICB9XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0Nvbm5lY3RpbmcsXG4gIGlzRXN0YWJsaXNoZWQsXG4gIGlzQ2xvc2luZyxcbiAgaXNDbG9zZWQsXG4gIGZpcmVFdmVudCxcbiAgaXNWYWxpZFN1YnByb3RvY29sLFxuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgZmFpbFdlYnNvY2tldENvbm5lY3Rpb24sXG4gIHdlYnNvY2tldE1lc3NhZ2VSZWNlaXZlZCxcbiAgdXRmOERlY29kZSxcbiAgaXNDb250cm9sRnJhbWUsXG4gIGlzQ29udGludWF0aW9uRnJhbWUsXG4gIGlzVGV4dEJpbmFyeUZyYW1lLFxuICBpc1ZhbGlkT3Bjb2RlLFxuICBwYXJzZUV4dGVuc2lvbnMsXG4gIGlzVmFsaWRDbGllbnRXaW5kb3dCaXRzXG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/undici/lib/web/websocket/websocket.js":
/*!************************************************************!*\
  !*** ./node_modules/undici/lib/web/websocket/websocket.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { webidl } = __webpack_require__(/*! ../fetch/webidl */ \"(rsc)/./node_modules/undici/lib/web/fetch/webidl.js\")\nconst { URLSerializer } = __webpack_require__(/*! ../fetch/data-url */ \"(rsc)/./node_modules/undici/lib/web/fetch/data-url.js\")\nconst { environmentSettingsObject } = __webpack_require__(/*! ../fetch/util */ \"(rsc)/./node_modules/undici/lib/web/fetch/util.js\")\nconst { staticPropertyDescriptors, states, sentCloseFrameState, sendHints } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/undici/lib/web/websocket/constants.js\")\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kBinaryType,\n  kResponse,\n  kSentClose,\n  kByteParser\n} = __webpack_require__(/*! ./symbols */ \"(rsc)/./node_modules/undici/lib/web/websocket/symbols.js\")\nconst {\n  isConnecting,\n  isEstablished,\n  isClosing,\n  isValidSubprotocol,\n  fireEvent\n} = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/undici/lib/web/websocket/util.js\")\nconst { establishWebSocketConnection, closeWebSocketConnection } = __webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/undici/lib/web/websocket/connection.js\")\nconst { ByteParser } = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/undici/lib/web/websocket/receiver.js\")\nconst { kEnumerableProperty, isBlobLike } = __webpack_require__(/*! ../../core/util */ \"(rsc)/./node_modules/undici/lib/core/util.js\")\nconst { getGlobalDispatcher } = __webpack_require__(/*! ../../global */ \"(rsc)/./node_modules/undici/lib/global.js\")\nconst { types } = __webpack_require__(/*! node:util */ \"node:util\")\nconst { ErrorEvent, CloseEvent } = __webpack_require__(/*! ./events */ \"(rsc)/./node_modules/undici/lib/web/websocket/events.js\")\nconst { SendQueue } = __webpack_require__(/*! ./sender */ \"(rsc)/./node_modules/undici/lib/web/websocket/sender.js\")\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n  #protocol = ''\n  #extensions = ''\n\n  /** @type {SendQueue} */\n  #sendQueue\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    webidl.util.markAsUncloneable(this)\n\n    const prefix = 'WebSocket constructor'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    const options = webidl.converters['DOMString or sequence<DOMString> or WebSocketInit'](protocols, prefix, 'options')\n\n    url = webidl.converters.USVString(url, prefix, 'url')\n    protocols = options.protocols\n\n    // 1. Let baseURL be this's relevant settings object's API base URL.\n    const baseURL = environmentSettingsObject.settingsObject.baseUrl\n\n    // 1. Let urlRecord be the result of applying the URL parser to url with baseURL.\n    let urlRecord\n\n    try {\n      urlRecord = new URL(url, baseURL)\n    } catch (e) {\n      // 3. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 4. If urlRecord’s scheme is \"http\", then set urlRecord’s scheme to \"ws\".\n    if (urlRecord.protocol === 'http:') {\n      urlRecord.protocol = 'ws:'\n    } else if (urlRecord.protocol === 'https:') {\n      // 5. Otherwise, if urlRecord’s scheme is \"https\", set urlRecord’s scheme to \"wss\".\n      urlRecord.protocol = 'wss:'\n    }\n\n    // 6. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(\n        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,\n        'SyntaxError'\n      )\n    }\n\n    // 7. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash || urlRecord.href.endsWith('#')) {\n      throw new DOMException('Got fragment', 'SyntaxError')\n    }\n\n    // 8. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 9. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 10. Set this's url to urlRecord.\n    this[kWebSocketURL] = new URL(urlRecord.href)\n\n    // 11. Let client be this's relevant settings object.\n    const client = environmentSettingsObject.settingsObject\n\n    // 12. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(\n      urlRecord,\n      protocols,\n      client,\n      this,\n      (response, extensions) => this.#onConnectionEstablished(response, extensions),\n      options\n    )\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING\n\n    this[kSentClose] = sentCloseFrameState.NOT_SENT\n\n    // The extensions attribute must initially return the empty string.\n\n    // The protocol attribute must initially return the empty string.\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.close'\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, prefix, 'code', { clamp: true })\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason, prefix, 'reason')\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError')\n      }\n    }\n\n    let reasonByteLength = 0\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason)\n\n      if (reasonByteLength > 123) {\n        throw new DOMException(\n          `Reason must be less than 123 bytes; received ${reasonByteLength}`,\n          'SyntaxError'\n        )\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    closeWebSocketConnection(this, code, reason, reasonByteLength)\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    const prefix = 'WebSocket.send'\n    webidl.argumentLengthCheck(arguments, 1, prefix)\n\n    data = webidl.converters.WebSocketSendData(data, prefix, 'data')\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (isConnecting(this)) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return\n    }\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const length = Buffer.byteLength(data)\n\n      this.#bufferedAmount += length\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= length\n      }, sendHints.string)\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.arrayBuffer)\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      this.#bufferedAmount += data.byteLength\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.byteLength\n      }, sendHints.typedArray)\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      this.#bufferedAmount += data.size\n      this.#sendQueue.add(data, () => {\n        this.#bufferedAmount -= data.size\n      }, sendHints.blob)\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState]\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL])\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#extensions\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#protocol\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.close = fn\n      this.addEventListener('close', fn)\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kBinaryType]\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob'\n    } else {\n      this[kBinaryType] = type\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n   */\n  #onConnectionEstablished (response, parsedExtensions) {\n    // processResponse is called when the \"response’s header list has been received and initialized.\"\n    // once this happens, the connection is open\n    this[kResponse] = response\n\n    const parser = new ByteParser(this, parsedExtensions)\n    parser.on('drain', onParserDrain)\n    parser.on('error', onParserError.bind(this))\n\n    response.socket.ws = this\n    this[kByteParser] = parser\n\n    this.#sendQueue = new SendQueue(response.socket)\n\n    // 1. Change the ready state to OPEN (1).\n    this[kReadyState] = states.OPEN\n\n    // 2. Change the extensions attribute’s value to the extensions in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n    const extensions = response.headersList.get('sec-websocket-extensions')\n\n    if (extensions !== null) {\n      this.#extensions = extensions\n    }\n\n    // 3. Change the protocol attribute’s value to the subprotocol in use, if\n    //    it is not the null value.\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n    const protocol = response.headersList.get('sec-websocket-protocol')\n\n    if (protocol !== null) {\n      this.#protocol = protocol\n    }\n\n    // 4. Fire an event named open at the WebSocket object.\n    fireEvent('open', this)\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V, prefix, argument) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V, prefix, argument)\n}\n\n// This implements the proposal made in https://github.com/whatwg/websockets/issues/42\nwebidl.converters.WebSocketInit = webidl.dictionaryConverter([\n  {\n    key: 'protocols',\n    converter: webidl.converters['DOMString or sequence<DOMString>'],\n    defaultValue: () => new Array(0)\n  },\n  {\n    key: 'dispatcher',\n    converter: webidl.converters.any,\n    defaultValue: () => getGlobalDispatcher()\n  },\n  {\n    key: 'headers',\n    converter: webidl.nullableConverter(webidl.converters.HeadersInit)\n  }\n])\n\nwebidl.converters['DOMString or sequence<DOMString> or WebSocketInit'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && !(Symbol.iterator in V)) {\n    return webidl.converters.WebSocketInit(V)\n  }\n\n  return { protocols: webidl.converters['DOMString or sequence<DOMString>'](V) }\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, { strict: false })\n    }\n\n    if (ArrayBuffer.isView(V) || types.isArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V)\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nfunction onParserDrain () {\n  this.ws[kResponse].socket.resume()\n}\n\nfunction onParserError (err) {\n  let message\n  let code\n\n  if (err instanceof CloseEvent) {\n    message = err.reason\n    code = err.code\n  } else {\n    message = err.message\n  }\n\n  fireEvent('error', this, () => new ErrorEvent('error', { error: err, message }))\n\n  closeWebSocketConnection(this, code)\n}\n\nmodule.exports = {\n  WebSocket\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdW5kaWNpL2xpYi93ZWIvd2Vic29ja2V0L3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixRQUFRLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDRFQUFpQjtBQUM1QyxRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ3JELFFBQVEsNEJBQTRCLEVBQUUsbUJBQU8sQ0FBQyx3RUFBZTtBQUM3RCxRQUFRLG9FQUFvRSxFQUFFLG1CQUFPLENBQUMsK0VBQWE7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLDJFQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHFFQUFRO0FBQ3BCLFFBQVEseURBQXlELEVBQUUsbUJBQU8sQ0FBQyxpRkFBYztBQUN6RixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLDZFQUFZO0FBQzNDLFFBQVEsa0NBQWtDLEVBQUUsbUJBQU8sQ0FBQyxxRUFBaUI7QUFDckUsUUFBUSxzQkFBc0IsRUFBRSxtQkFBTyxDQUFDLCtEQUFjO0FBQ3RELFFBQVEsUUFBUSxFQUFFLG1CQUFPLENBQUMsNEJBQVc7QUFDckMsUUFBUSx5QkFBeUIsRUFBRSxtQkFBTyxDQUFDLHlFQUFVO0FBQ3JELFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMseUVBQVU7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGFBQWEsV0FBVztBQUN4Qjs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxtQkFBbUI7QUFDbkU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5RUFBeUUsYUFBYTtBQUN0Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxXQUFXLGlCQUFpQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsMkNBQTJDO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSwyREFBMkQscUJBQXFCOztBQUVoRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsb3JkclxcRG93bmxvYWRzXFxBbmlUZWFtcy1tYWluXFxub2RlX21vZHVsZXNcXHVuZGljaVxcbGliXFx3ZWJcXHdlYnNvY2tldFxcd2Vic29ja2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IHdlYmlkbCB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvd2ViaWRsJylcbmNvbnN0IHsgVVJMU2VyaWFsaXplciB9ID0gcmVxdWlyZSgnLi4vZmV0Y2gvZGF0YS11cmwnKVxuY29uc3QgeyBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0IH0gPSByZXF1aXJlKCcuLi9mZXRjaC91dGlsJylcbmNvbnN0IHsgc3RhdGljUHJvcGVydHlEZXNjcmlwdG9ycywgc3RhdGVzLCBzZW50Q2xvc2VGcmFtZVN0YXRlLCBzZW5kSGludHMgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHtcbiAga1dlYlNvY2tldFVSTCxcbiAga1JlYWR5U3RhdGUsXG4gIGtDb250cm9sbGVyLFxuICBrQmluYXJ5VHlwZSxcbiAga1Jlc3BvbnNlLFxuICBrU2VudENsb3NlLFxuICBrQnl0ZVBhcnNlclxufSA9IHJlcXVpcmUoJy4vc3ltYm9scycpXG5jb25zdCB7XG4gIGlzQ29ubmVjdGluZyxcbiAgaXNFc3RhYmxpc2hlZCxcbiAgaXNDbG9zaW5nLFxuICBpc1ZhbGlkU3VicHJvdG9jb2wsXG4gIGZpcmVFdmVudFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5jb25zdCB7IGVzdGFibGlzaFdlYlNvY2tldENvbm5lY3Rpb24sIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbiB9ID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJylcbmNvbnN0IHsgQnl0ZVBhcnNlciB9ID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpXG5jb25zdCB7IGtFbnVtZXJhYmxlUHJvcGVydHksIGlzQmxvYkxpa2UgfSA9IHJlcXVpcmUoJy4uLy4uL2NvcmUvdXRpbCcpXG5jb25zdCB7IGdldEdsb2JhbERpc3BhdGNoZXIgfSA9IHJlcXVpcmUoJy4uLy4uL2dsb2JhbCcpXG5jb25zdCB7IHR5cGVzIH0gPSByZXF1aXJlKCdub2RlOnV0aWwnKVxuY29uc3QgeyBFcnJvckV2ZW50LCBDbG9zZUV2ZW50IH0gPSByZXF1aXJlKCcuL2V2ZW50cycpXG5jb25zdCB7IFNlbmRRdWV1ZSB9ID0gcmVxdWlyZSgnLi9zZW5kZXInKVxuXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNpbnRlcmZhY2UtZGVmaW5pdGlvblxuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgRXZlbnRUYXJnZXQge1xuICAjZXZlbnRzID0ge1xuICAgIG9wZW46IG51bGwsXG4gICAgZXJyb3I6IG51bGwsXG4gICAgY2xvc2U6IG51bGwsXG4gICAgbWVzc2FnZTogbnVsbFxuICB9XG5cbiAgI2J1ZmZlcmVkQW1vdW50ID0gMFxuICAjcHJvdG9jb2wgPSAnJ1xuICAjZXh0ZW5zaW9ucyA9ICcnXG5cbiAgLyoqIEB0eXBlIHtTZW5kUXVldWV9ICovXG4gICNzZW5kUXVldWVcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcHJvdG9jb2xzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCBwcm90b2NvbHMgPSBbXSkge1xuICAgIHN1cGVyKClcblxuICAgIHdlYmlkbC51dGlsLm1hcmtBc1VuY2xvbmVhYmxlKHRoaXMpXG5cbiAgICBjb25zdCBwcmVmaXggPSAnV2ViU29ja2V0IGNvbnN0cnVjdG9yJ1xuICAgIHdlYmlkbC5hcmd1bWVudExlbmd0aENoZWNrKGFyZ3VtZW50cywgMSwgcHJlZml4KVxuXG4gICAgY29uc3Qgb3B0aW9ucyA9IHdlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiBvciBXZWJTb2NrZXRJbml0J10ocHJvdG9jb2xzLCBwcmVmaXgsICdvcHRpb25zJylcblxuICAgIHVybCA9IHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyh1cmwsIHByZWZpeCwgJ3VybCcpXG4gICAgcHJvdG9jb2xzID0gb3B0aW9ucy5wcm90b2NvbHNcblxuICAgIC8vIDEuIExldCBiYXNlVVJMIGJlIHRoaXMncyByZWxldmFudCBzZXR0aW5ncyBvYmplY3QncyBBUEkgYmFzZSBVUkwuXG4gICAgY29uc3QgYmFzZVVSTCA9IGVudmlyb25tZW50U2V0dGluZ3NPYmplY3Quc2V0dGluZ3NPYmplY3QuYmFzZVVybFxuXG4gICAgLy8gMS4gTGV0IHVybFJlY29yZCBiZSB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBVUkwgcGFyc2VyIHRvIHVybCB3aXRoIGJhc2VVUkwuXG4gICAgbGV0IHVybFJlY29yZFxuXG4gICAgdHJ5IHtcbiAgICAgIHVybFJlY29yZCA9IG5ldyBVUkwodXJsLCBiYXNlVVJMKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIDMuIElmIHVybFJlY29yZCBpcyBmYWlsdXJlLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oZSwgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICAvLyA0LiBJZiB1cmxSZWNvcmTigJlzIHNjaGVtZSBpcyBcImh0dHBcIiwgdGhlbiBzZXQgdXJsUmVjb3Jk4oCZcyBzY2hlbWUgdG8gXCJ3c1wiLlxuICAgIGlmICh1cmxSZWNvcmQucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICAgIHVybFJlY29yZC5wcm90b2NvbCA9ICd3czonXG4gICAgfSBlbHNlIGlmICh1cmxSZWNvcmQucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgICAvLyA1LiBPdGhlcndpc2UsIGlmIHVybFJlY29yZOKAmXMgc2NoZW1lIGlzIFwiaHR0cHNcIiwgc2V0IHVybFJlY29yZOKAmXMgc2NoZW1lIHRvIFwid3NzXCIuXG4gICAgICB1cmxSZWNvcmQucHJvdG9jb2wgPSAnd3NzOidcbiAgICB9XG5cbiAgICAvLyA2LiBJZiB1cmxSZWNvcmTigJlzIHNjaGVtZSBpcyBub3QgXCJ3c1wiIG9yIFwid3NzXCIsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGlmICh1cmxSZWNvcmQucHJvdG9jb2wgIT09ICd3czonICYmIHVybFJlY29yZC5wcm90b2NvbCAhPT0gJ3dzczonKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICBgRXhwZWN0ZWQgYSB3czogb3Igd3NzOiBwcm90b2NvbCwgZ290ICR7dXJsUmVjb3JkLnByb3RvY29sfWAsXG4gICAgICAgICdTeW50YXhFcnJvcidcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyA3LiBJZiB1cmxSZWNvcmTigJlzIGZyYWdtZW50IGlzIG5vbi1udWxsLCB0aGVuIHRocm93IGEgXCJTeW50YXhFcnJvclwiXG4gICAgLy8gICAgRE9NRXhjZXB0aW9uLlxuICAgIGlmICh1cmxSZWNvcmQuaGFzaCB8fCB1cmxSZWNvcmQuaHJlZi5lbmRzV2l0aCgnIycpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdHb3QgZnJhZ21lbnQnLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIC8vIDguIElmIHByb3RvY29scyBpcyBhIHN0cmluZywgc2V0IHByb3RvY29scyB0byBhIHNlcXVlbmNlIGNvbnNpc3RpbmdcbiAgICAvLyAgICBvZiBqdXN0IHRoYXQgc3RyaW5nLlxuICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnc3RyaW5nJykge1xuICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc11cbiAgICB9XG5cbiAgICAvLyA5LiBJZiBhbnkgb2YgdGhlIHZhbHVlcyBpbiBwcm90b2NvbHMgb2NjdXIgbW9yZSB0aGFuIG9uY2Ugb3Igb3RoZXJ3aXNlXG4gICAgLy8gICAgZmFpbCB0byBtYXRjaCB0aGUgcmVxdWlyZW1lbnRzIGZvciBlbGVtZW50cyB0aGF0IGNvbXByaXNlIHRoZSB2YWx1ZVxuICAgIC8vICAgIG9mIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBmaWVsZHMgYXMgZGVmaW5lZCBieSBUaGUgV2ViU29ja2V0XG4gICAgLy8gICAgcHJvdG9jb2wsIHRoZW4gdGhyb3cgYSBcIlN5bnRheEVycm9yXCIgRE9NRXhjZXB0aW9uLlxuICAgIGlmIChwcm90b2NvbHMubGVuZ3RoICE9PSBuZXcgU2V0KHByb3RvY29scy5tYXAocCA9PiBwLnRvTG93ZXJDYXNlKCkpKS5zaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtUHJvdG9jb2wgdmFsdWUnLCAnU3ludGF4RXJyb3InKVxuICAgIH1cblxuICAgIGlmIChwcm90b2NvbHMubGVuZ3RoID4gMCAmJiAhcHJvdG9jb2xzLmV2ZXJ5KHAgPT4gaXNWYWxpZFN1YnByb3RvY29sKHApKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignSW52YWxpZCBTZWMtV2ViU29ja2V0LVByb3RvY29sIHZhbHVlJywgJ1N5bnRheEVycm9yJylcbiAgICB9XG5cbiAgICAvLyAxMC4gU2V0IHRoaXMncyB1cmwgdG8gdXJsUmVjb3JkLlxuICAgIHRoaXNba1dlYlNvY2tldFVSTF0gPSBuZXcgVVJMKHVybFJlY29yZC5ocmVmKVxuXG4gICAgLy8gMTEuIExldCBjbGllbnQgYmUgdGhpcydzIHJlbGV2YW50IHNldHRpbmdzIG9iamVjdC5cbiAgICBjb25zdCBjbGllbnQgPSBlbnZpcm9ubWVudFNldHRpbmdzT2JqZWN0LnNldHRpbmdzT2JqZWN0XG5cbiAgICAvLyAxMi4gUnVuIHRoaXMgc3RlcCBpbiBwYXJhbGxlbDpcblxuICAgIC8vICAgIDEuIEVzdGFibGlzaCBhIFdlYlNvY2tldCBjb25uZWN0aW9uIGdpdmVuIHVybFJlY29yZCwgcHJvdG9jb2xzLFxuICAgIC8vICAgICAgIGFuZCBjbGllbnQuXG4gICAgdGhpc1trQ29udHJvbGxlcl0gPSBlc3RhYmxpc2hXZWJTb2NrZXRDb25uZWN0aW9uKFxuICAgICAgdXJsUmVjb3JkLFxuICAgICAgcHJvdG9jb2xzLFxuICAgICAgY2xpZW50LFxuICAgICAgdGhpcyxcbiAgICAgIChyZXNwb25zZSwgZXh0ZW5zaW9ucykgPT4gdGhpcy4jb25Db25uZWN0aW9uRXN0YWJsaXNoZWQocmVzcG9uc2UsIGV4dGVuc2lvbnMpLFxuICAgICAgb3B0aW9uc1xuICAgIClcblxuICAgIC8vIEVhY2ggV2ViU29ja2V0IG9iamVjdCBoYXMgYW4gYXNzb2NpYXRlZCByZWFkeSBzdGF0ZSwgd2hpY2ggaXMgYVxuICAgIC8vIG51bWJlciByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBjb25uZWN0aW9uLiBJbml0aWFsbHkgaXQgbXVzdFxuICAgIC8vIGJlIENPTk5FQ1RJTkcgKDApLlxuICAgIHRoaXNba1JlYWR5U3RhdGVdID0gV2ViU29ja2V0LkNPTk5FQ1RJTkdcblxuICAgIHRoaXNba1NlbnRDbG9zZV0gPSBzZW50Q2xvc2VGcmFtZVN0YXRlLk5PVF9TRU5UXG5cbiAgICAvLyBUaGUgZXh0ZW5zaW9ucyBhdHRyaWJ1dGUgbXVzdCBpbml0aWFsbHkgcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG5cbiAgICAvLyBUaGUgcHJvdG9jb2wgYXR0cmlidXRlIG11c3QgaW5pdGlhbGx5IHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuXG4gICAgLy8gRWFjaCBXZWJTb2NrZXQgb2JqZWN0IGhhcyBhbiBhc3NvY2lhdGVkIGJpbmFyeSB0eXBlLCB3aGljaCBpcyBhXG4gICAgLy8gQmluYXJ5VHlwZS4gSW5pdGlhbGx5IGl0IG11c3QgYmUgXCJibG9iXCIuXG4gICAgdGhpc1trQmluYXJ5VHlwZV0gPSAnYmxvYidcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY2xvc2VcbiAgICogQHBhcmFtIHtudW1iZXJ8dW5kZWZpbmVkfSBjb2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gcmVhc29uXG4gICAqL1xuICBjbG9zZSAoY29kZSA9IHVuZGVmaW5lZCwgcmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgY29uc3QgcHJlZml4ID0gJ1dlYlNvY2tldC5jbG9zZSdcblxuICAgIGlmIChjb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvZGUgPSB3ZWJpZGwuY29udmVydGVyc1sndW5zaWduZWQgc2hvcnQnXShjb2RlLCBwcmVmaXgsICdjb2RlJywgeyBjbGFtcDogdHJ1ZSB9KVxuICAgIH1cblxuICAgIGlmIChyZWFzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVhc29uID0gd2ViaWRsLmNvbnZlcnRlcnMuVVNWU3RyaW5nKHJlYXNvbiwgcHJlZml4LCAncmVhc29uJylcbiAgICB9XG5cbiAgICAvLyAxLiBJZiBjb2RlIGlzIHByZXNlbnQsIGJ1dCBpcyBuZWl0aGVyIGFuIGludGVnZXIgZXF1YWwgdG8gMTAwMCBub3IgYW5cbiAgICAvLyAgICBpbnRlZ2VyIGluIHRoZSByYW5nZSAzMDAwIHRvIDQ5OTksIGluY2x1c2l2ZSwgdGhyb3cgYW5cbiAgICAvLyAgICBcIkludmFsaWRBY2Nlc3NFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAoY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29kZSAhPT0gMTAwMCAmJiAoY29kZSA8IDMwMDAgfHwgY29kZSA+IDQ5OTkpKSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ2ludmFsaWQgY29kZScsICdJbnZhbGlkQWNjZXNzRXJyb3InKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCByZWFzb25CeXRlTGVuZ3RoID0gMFxuXG4gICAgLy8gMi4gSWYgcmVhc29uIGlzIHByZXNlbnQsIHRoZW4gcnVuIHRoZXNlIHN1YnN0ZXBzOlxuICAgIGlmIChyZWFzb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gMS4gTGV0IHJlYXNvbkJ5dGVzIGJlIHRoZSByZXN1bHQgb2YgZW5jb2RpbmcgcmVhc29uLlxuICAgICAgLy8gMi4gSWYgcmVhc29uQnl0ZXMgaXMgbG9uZ2VyIHRoYW4gMTIzIGJ5dGVzLCB0aGVuIHRocm93IGFcbiAgICAgIC8vICAgIFwiU3ludGF4RXJyb3JcIiBET01FeGNlcHRpb24uXG4gICAgICByZWFzb25CeXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgocmVhc29uKVxuXG4gICAgICBpZiAocmVhc29uQnl0ZUxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFxuICAgICAgICAgIGBSZWFzb24gbXVzdCBiZSBsZXNzIHRoYW4gMTIzIGJ5dGVzOyByZWNlaXZlZCAke3JlYXNvbkJ5dGVMZW5ndGh9YCxcbiAgICAgICAgICAnU3ludGF4RXJyb3InXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBSdW4gdGhlIGZpcnN0IG1hdGNoaW5nIHN0ZXBzIGZyb20gdGhlIGZvbGxvd2luZyBsaXN0OlxuICAgIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbih0aGlzLCBjb2RlLCByZWFzb24sIHJlYXNvbkJ5dGVMZW5ndGgpXG4gIH1cblxuICAvKipcbiAgICogQHNlZSBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LXNlbmRcbiAgICogQHBhcmFtIHtOb2RlSlMuVHlwZWRBcnJheXxBcnJheUJ1ZmZlcnxCbG9ifHN0cmluZ30gZGF0YVxuICAgKi9cbiAgc2VuZCAoZGF0YSkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGNvbnN0IHByZWZpeCA9ICdXZWJTb2NrZXQuc2VuZCdcbiAgICB3ZWJpZGwuYXJndW1lbnRMZW5ndGhDaGVjayhhcmd1bWVudHMsIDEsIHByZWZpeClcblxuICAgIGRhdGEgPSB3ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRTZW5kRGF0YShkYXRhLCBwcmVmaXgsICdkYXRhJylcblxuICAgIC8vIDEuIElmIHRoaXMncyByZWFkeSBzdGF0ZSBpcyBDT05ORUNUSU5HLCB0aGVuIHRocm93IGFuXG4gICAgLy8gICAgXCJJbnZhbGlkU3RhdGVFcnJvclwiIERPTUV4Y2VwdGlvbi5cbiAgICBpZiAoaXNDb25uZWN0aW5nKHRoaXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdTZW50IGJlZm9yZSBjb25uZWN0ZWQuJywgJ0ludmFsaWRTdGF0ZUVycm9yJylcbiAgICB9XG5cbiAgICAvLyAyLiBSdW4gdGhlIGFwcHJvcHJpYXRlIHNldCBvZiBzdGVwcyBmcm9tIHRoZSBmb2xsb3dpbmcgbGlzdDpcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi02LjFcbiAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzY0NTUjc2VjdGlvbi01LjJcblxuICAgIGlmICghaXNFc3RhYmxpc2hlZCh0aGlzKSB8fCBpc0Nsb3NpbmcodGhpcykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIElmIGRhdGEgaXMgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgYW5kIHRoZSBXZWJTb2NrZXRcbiAgICAgIC8vIGNsb3NpbmcgaGFuZHNoYWtlIGhhcyBub3QgeWV0IHN0YXJ0ZWQsIHRoZW4gdGhlIHVzZXIgYWdlbnRcbiAgICAgIC8vIG11c3Qgc2VuZCBhIFdlYlNvY2tldCBNZXNzYWdlIGNvbXByaXNlZCBvZiB0aGUgZGF0YSBhcmd1bWVudFxuICAgICAgLy8gdXNpbmcgYSB0ZXh0IGZyYW1lIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy5cbiAgICAgIC8vIGJlY2F1c2UgaXQgd291bGQgbmVlZCB0byBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLFxuICAgICAgLy8gdGhlIHVzZXIgYWdlbnQgbXVzdCBmbGFnIHRoZSBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZVxuICAgICAgLy8gdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLiBBbnkgaW52b2NhdGlvbiBvZiB0aGlzIG1ldGhvZCB3aXRoIGFcbiAgICAgIC8vIHN0cmluZyBhcmd1bWVudCB0aGF0IGRvZXMgbm90IHRocm93IGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlXG4gICAgICAvLyB0aGUgYnVmZmVyZWRBbW91bnQgYXR0cmlidXRlIGJ5IHRoZSBudW1iZXIgb2YgYnl0ZXMgbmVlZGVkIHRvXG4gICAgICAvLyBleHByZXNzIHRoZSBhcmd1bWVudCBhcyBVVEYtOC5cblxuICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSlcblxuICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoXG4gICAgICB0aGlzLiNzZW5kUXVldWUuYWRkKGRhdGEsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYnVmZmVyZWRBbW91bnQgLT0gbGVuZ3RoXG4gICAgICB9LCBzZW5kSGludHMuc3RyaW5nKVxuICAgIH0gZWxzZSBpZiAodHlwZXMuaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgLy8gSWYgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkLCBhbmQgdGhlIFdlYlNvY2tldFxuICAgICAgLy8gY2xvc2luZyBoYW5kc2hha2UgaGFzIG5vdCB5ZXQgc3RhcnRlZCwgdGhlbiB0aGUgdXNlciBhZ2VudCBtdXN0XG4gICAgICAvLyBzZW5kIGEgV2ViU29ja2V0IE1lc3NhZ2UgY29tcHJpc2VkIG9mIGRhdGEgdXNpbmcgYSBiaW5hcnkgZnJhbWVcbiAgICAgIC8vIG9wY29kZTsgaWYgdGhlIGRhdGEgY2Fubm90IGJlIHNlbnQsIGUuZy4gYmVjYXVzZSBpdCB3b3VsZCBuZWVkXG4gICAgICAvLyB0byBiZSBidWZmZXJlZCBidXQgdGhlIGJ1ZmZlciBpcyBmdWxsLCB0aGUgdXNlciBhZ2VudCBtdXN0IGZsYWdcbiAgICAgIC8vIHRoZSBXZWJTb2NrZXQgYXMgZnVsbCBhbmQgdGhlbiBjbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24uXG4gICAgICAvLyBUaGUgZGF0YSB0byBiZSBzZW50IGlzIHRoZSBkYXRhIHN0b3JlZCBpbiB0aGUgYnVmZmVyIGRlc2NyaWJlZFxuICAgICAgLy8gYnkgdGhlIEFycmF5QnVmZmVyIG9iamVjdC4gQW55IGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCBhblxuICAgICAgLy8gQXJyYXlCdWZmZXIgYXJndW1lbnQgdGhhdCBkb2VzIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gbXVzdFxuICAgICAgLy8gaW5jcmVhc2UgdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZSBieSB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgICAgLy8gQXJyYXlCdWZmZXIgaW4gYnl0ZXMuXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IGRhdGEuYnl0ZUxlbmd0aFxuICAgICAgdGhpcy4jc2VuZFF1ZXVlLmFkZChkYXRhLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IGRhdGEuYnl0ZUxlbmd0aFxuICAgICAgfSwgc2VuZEhpbnRzLmFycmF5QnVmZmVyKVxuICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQsIGFuZCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkLCB0aGVuIHRoZSB1c2VyIGFnZW50IG11c3RcbiAgICAgIC8vIHNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSBjb21wcmlzZWQgb2YgZGF0YSB1c2luZyBhIGJpbmFyeSBmcmFtZVxuICAgICAgLy8gb3Bjb2RlOyBpZiB0aGUgZGF0YSBjYW5ub3QgYmUgc2VudCwgZS5nLiBiZWNhdXNlIGl0IHdvdWxkIG5lZWQgdG9cbiAgICAgIC8vIGJlIGJ1ZmZlcmVkIGJ1dCB0aGUgYnVmZmVyIGlzIGZ1bGwsIHRoZSB1c2VyIGFnZW50IG11c3QgZmxhZyB0aGVcbiAgICAgIC8vIFdlYlNvY2tldCBhcyBmdWxsIGFuZCB0aGVuIGNsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gVGhlXG4gICAgICAvLyBkYXRhIHRvIGJlIHNlbnQgaXMgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSBzZWN0aW9uIG9mIHRoZSBidWZmZXJcbiAgICAgIC8vIGRlc2NyaWJlZCBieSB0aGUgQXJyYXlCdWZmZXIgb2JqZWN0IHRoYXQgZGF0YSByZWZlcmVuY2VzLiBBbnlcbiAgICAgIC8vIGludm9jYXRpb24gb2YgdGhpcyBtZXRob2Qgd2l0aCB0aGlzIGtpbmQgb2YgYXJndW1lbnQgdGhhdCBkb2VzXG4gICAgICAvLyBub3QgdGhyb3cgYW4gZXhjZXB0aW9uIG11c3QgaW5jcmVhc2UgdGhlIGJ1ZmZlcmVkQW1vdW50IGF0dHJpYnV0ZVxuICAgICAgLy8gYnkgdGhlIGxlbmd0aCBvZiBkYXRh4oCZcyBidWZmZXIgaW4gYnl0ZXMuXG5cbiAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50ICs9IGRhdGEuYnl0ZUxlbmd0aFxuICAgICAgdGhpcy4jc2VuZFF1ZXVlLmFkZChkYXRhLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuI2J1ZmZlcmVkQW1vdW50IC09IGRhdGEuYnl0ZUxlbmd0aFxuICAgICAgfSwgc2VuZEhpbnRzLnR5cGVkQXJyYXkpXG4gICAgfSBlbHNlIGlmIChpc0Jsb2JMaWtlKGRhdGEpKSB7XG4gICAgICAvLyBJZiB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQsIGFuZCB0aGUgV2ViU29ja2V0XG4gICAgICAvLyBjbG9zaW5nIGhhbmRzaGFrZSBoYXMgbm90IHlldCBzdGFydGVkLCB0aGVuIHRoZSB1c2VyIGFnZW50IG11c3RcbiAgICAgIC8vIHNlbmQgYSBXZWJTb2NrZXQgTWVzc2FnZSBjb21wcmlzZWQgb2YgZGF0YSB1c2luZyBhIGJpbmFyeSBmcmFtZVxuICAgICAgLy8gb3Bjb2RlOyBpZiB0aGUgZGF0YSBjYW5ub3QgYmUgc2VudCwgZS5nLiBiZWNhdXNlIGl0IHdvdWxkIG5lZWQgdG9cbiAgICAgIC8vIGJlIGJ1ZmZlcmVkIGJ1dCB0aGUgYnVmZmVyIGlzIGZ1bGwsIHRoZSB1c2VyIGFnZW50IG11c3QgZmxhZyB0aGVcbiAgICAgIC8vIFdlYlNvY2tldCBhcyBmdWxsIGFuZCB0aGVuIGNsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi4gVGhlIGRhdGFcbiAgICAgIC8vIHRvIGJlIHNlbnQgaXMgdGhlIHJhdyBkYXRhIHJlcHJlc2VudGVkIGJ5IHRoZSBCbG9iIG9iamVjdC4gQW55XG4gICAgICAvLyBpbnZvY2F0aW9uIG9mIHRoaXMgbWV0aG9kIHdpdGggYSBCbG9iIGFyZ3VtZW50IHRoYXQgZG9lcyBub3QgdGhyb3dcbiAgICAgIC8vIGFuIGV4Y2VwdGlvbiBtdXN0IGluY3JlYXNlIHRoZSBidWZmZXJlZEFtb3VudCBhdHRyaWJ1dGUgYnkgdGhlIHNpemVcbiAgICAgIC8vIG9mIHRoZSBCbG9iIG9iamVjdOKAmXMgcmF3IGRhdGEsIGluIGJ5dGVzLlxuXG4gICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCArPSBkYXRhLnNpemVcbiAgICAgIHRoaXMuI3NlbmRRdWV1ZS5hZGQoZGF0YSwgKCkgPT4ge1xuICAgICAgICB0aGlzLiNidWZmZXJlZEFtb3VudCAtPSBkYXRhLnNpemVcbiAgICAgIH0sIHNlbmRIaW50cy5ibG9iKVxuICAgIH1cbiAgfVxuXG4gIGdldCByZWFkeVN0YXRlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICAvLyBUaGUgcmVhZHlTdGF0ZSBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlzJ3MgcmVhZHkgc3RhdGUuXG4gICAgcmV0dXJuIHRoaXNba1JlYWR5U3RhdGVdXG4gIH1cblxuICBnZXQgYnVmZmVyZWRBbW91bnQgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNidWZmZXJlZEFtb3VudFxuICB9XG5cbiAgZ2V0IHVybCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgLy8gVGhlIHVybCBnZXR0ZXIgc3RlcHMgYXJlIHRvIHJldHVybiB0aGlzJ3MgdXJsLCBzZXJpYWxpemVkLlxuICAgIHJldHVybiBVUkxTZXJpYWxpemVyKHRoaXNba1dlYlNvY2tldFVSTF0pXG4gIH1cblxuICBnZXQgZXh0ZW5zaW9ucyAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI2V4dGVuc2lvbnNcbiAgfVxuXG4gIGdldCBwcm90b2NvbCAoKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgcmV0dXJuIHRoaXMuI3Byb3RvY29sXG4gIH1cblxuICBnZXQgb25vcGVuICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLm9wZW5cbiAgfVxuXG4gIHNldCBvbm9wZW4gKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5vcGVuKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCB0aGlzLiNldmVudHMub3BlbilcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMub3BlbiA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLm9wZW4gPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IG9uZXJyb3IgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzLiNldmVudHMuZXJyb3JcbiAgfVxuXG4gIHNldCBvbmVycm9yIChmbikge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIGlmICh0aGlzLiNldmVudHMuZXJyb3IpIHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLiNldmVudHMuZXJyb3IpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gZm5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLmVycm9yID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBvbmNsb3NlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLmNsb3NlXG4gIH1cblxuICBzZXQgb25jbG9zZSAoZm4pIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodGhpcy4jZXZlbnRzLmNsb3NlKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy4jZXZlbnRzLmNsb3NlKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5jbG9zZSA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgZm4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2V2ZW50cy5jbG9zZSA9IG51bGxcbiAgICB9XG4gIH1cblxuICBnZXQgb25tZXNzYWdlICgpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICByZXR1cm4gdGhpcy4jZXZlbnRzLm1lc3NhZ2VcbiAgfVxuXG4gIHNldCBvbm1lc3NhZ2UgKGZuKSB7XG4gICAgd2ViaWRsLmJyYW5kQ2hlY2sodGhpcywgV2ViU29ja2V0KVxuXG4gICAgaWYgKHRoaXMuI2V2ZW50cy5tZXNzYWdlKSB7XG4gICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLiNldmVudHMubWVzc2FnZSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLiNldmVudHMubWVzc2FnZSA9IGZuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmbilcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZXZlbnRzLm1lc3NhZ2UgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgZ2V0IGJpbmFyeVR5cGUgKCkge1xuICAgIHdlYmlkbC5icmFuZENoZWNrKHRoaXMsIFdlYlNvY2tldClcblxuICAgIHJldHVybiB0aGlzW2tCaW5hcnlUeXBlXVxuICB9XG5cbiAgc2V0IGJpbmFyeVR5cGUgKHR5cGUpIHtcbiAgICB3ZWJpZGwuYnJhbmRDaGVjayh0aGlzLCBXZWJTb2NrZXQpXG5cbiAgICBpZiAodHlwZSAhPT0gJ2Jsb2InICYmIHR5cGUgIT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgIHRoaXNba0JpbmFyeVR5cGVdID0gJ2Jsb2InXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba0JpbmFyeVR5cGVdID0gdHlwZVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2ZlZWRiYWNrLWZyb20tdGhlLXByb3RvY29sXG4gICAqL1xuICAjb25Db25uZWN0aW9uRXN0YWJsaXNoZWQgKHJlc3BvbnNlLCBwYXJzZWRFeHRlbnNpb25zKSB7XG4gICAgLy8gcHJvY2Vzc1Jlc3BvbnNlIGlzIGNhbGxlZCB3aGVuIHRoZSBcInJlc3BvbnNl4oCZcyBoZWFkZXIgbGlzdCBoYXMgYmVlbiByZWNlaXZlZCBhbmQgaW5pdGlhbGl6ZWQuXCJcbiAgICAvLyBvbmNlIHRoaXMgaGFwcGVucywgdGhlIGNvbm5lY3Rpb24gaXMgb3BlblxuICAgIHRoaXNba1Jlc3BvbnNlXSA9IHJlc3BvbnNlXG5cbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgQnl0ZVBhcnNlcih0aGlzLCBwYXJzZWRFeHRlbnNpb25zKVxuICAgIHBhcnNlci5vbignZHJhaW4nLCBvblBhcnNlckRyYWluKVxuICAgIHBhcnNlci5vbignZXJyb3InLCBvblBhcnNlckVycm9yLmJpbmQodGhpcykpXG5cbiAgICByZXNwb25zZS5zb2NrZXQud3MgPSB0aGlzXG4gICAgdGhpc1trQnl0ZVBhcnNlcl0gPSBwYXJzZXJcblxuICAgIHRoaXMuI3NlbmRRdWV1ZSA9IG5ldyBTZW5kUXVldWUocmVzcG9uc2Uuc29ja2V0KVxuXG4gICAgLy8gMS4gQ2hhbmdlIHRoZSByZWFkeSBzdGF0ZSB0byBPUEVOICgxKS5cbiAgICB0aGlzW2tSZWFkeVN0YXRlXSA9IHN0YXRlcy5PUEVOXG5cbiAgICAvLyAyLiBDaGFuZ2UgdGhlIGV4dGVuc2lvbnMgYXR0cmlidXRl4oCZcyB2YWx1ZSB0byB0aGUgZXh0ZW5zaW9ucyBpbiB1c2UsIGlmXG4gICAgLy8gICAgaXQgaXMgbm90IHRoZSBudWxsIHZhbHVlLlxuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucycpXG5cbiAgICBpZiAoZXh0ZW5zaW9ucyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy4jZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnNcbiAgICB9XG5cbiAgICAvLyAzLiBDaGFuZ2UgdGhlIHByb3RvY29sIGF0dHJpYnV0ZeKAmXMgdmFsdWUgdG8gdGhlIHN1YnByb3RvY29sIGluIHVzZSwgaWZcbiAgICAvLyAgICBpdCBpcyBub3QgdGhlIG51bGwgdmFsdWUuXG4gICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2NDU1I3NlY3Rpb24tMS45XG4gICAgY29uc3QgcHJvdG9jb2wgPSByZXNwb25zZS5oZWFkZXJzTGlzdC5nZXQoJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnKVxuXG4gICAgaWYgKHByb3RvY29sICE9PSBudWxsKSB7XG4gICAgICB0aGlzLiNwcm90b2NvbCA9IHByb3RvY29sXG4gICAgfVxuXG4gICAgLy8gNC4gRmlyZSBhbiBldmVudCBuYW1lZCBvcGVuIGF0IHRoZSBXZWJTb2NrZXQgb2JqZWN0LlxuICAgIGZpcmVFdmVudCgnb3BlbicsIHRoaXMpXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jb25uZWN0aW5nXG5XZWJTb2NrZXQuQ09OTkVDVElORyA9IFdlYlNvY2tldC5wcm90b3R5cGUuQ09OTkVDVElORyA9IHN0YXRlcy5DT05ORUNUSU5HXG4vLyBodHRwczovL3dlYnNvY2tldHMuc3BlYy53aGF0d2cub3JnLyNkb20td2Vic29ja2V0LW9wZW5cbldlYlNvY2tldC5PUEVOID0gV2ViU29ja2V0LnByb3RvdHlwZS5PUEVOID0gc3RhdGVzLk9QRU5cbi8vIGh0dHBzOi8vd2Vic29ja2V0cy5zcGVjLndoYXR3Zy5vcmcvI2RvbS13ZWJzb2NrZXQtY2xvc2luZ1xuV2ViU29ja2V0LkNMT1NJTkcgPSBXZWJTb2NrZXQucHJvdG90eXBlLkNMT1NJTkcgPSBzdGF0ZXMuQ0xPU0lOR1xuLy8gaHR0cHM6Ly93ZWJzb2NrZXRzLnNwZWMud2hhdHdnLm9yZy8jZG9tLXdlYnNvY2tldC1jbG9zZWRcbldlYlNvY2tldC5DTE9TRUQgPSBXZWJTb2NrZXQucHJvdG90eXBlLkNMT1NFRCA9IHN0YXRlcy5DTE9TRURcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViU29ja2V0LnByb3RvdHlwZSwge1xuICBDT05ORUNUSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBPUEVOOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TSU5HOiBzdGF0aWNQcm9wZXJ0eURlc2NyaXB0b3JzLFxuICBDTE9TRUQ6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIHVybDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcmVhZHlTdGF0ZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYnVmZmVyZWRBbW91bnQ6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ub3Blbjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25lcnJvcjoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgb25jbG9zZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgY2xvc2U6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIG9ubWVzc2FnZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgYmluYXJ5VHlwZToga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgc2VuZDoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgZXh0ZW5zaW9uczoga0VudW1lcmFibGVQcm9wZXJ0eSxcbiAgcHJvdG9jb2w6IGtFbnVtZXJhYmxlUHJvcGVydHksXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiB7XG4gICAgdmFsdWU6ICdXZWJTb2NrZXQnLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV2ViU29ja2V0LCB7XG4gIENPTk5FQ1RJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIE9QRU46IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NJTkc6IHN0YXRpY1Byb3BlcnR5RGVzY3JpcHRvcnMsXG4gIENMT1NFRDogc3RhdGljUHJvcGVydHlEZXNjcmlwdG9yc1xufSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ3NlcXVlbmNlPERPTVN0cmluZz4nXSA9IHdlYmlkbC5zZXF1ZW5jZUNvbnZlcnRlcihcbiAgd2ViaWRsLmNvbnZlcnRlcnMuRE9NU3RyaW5nXG4pXG5cbndlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddID0gZnVuY3Rpb24gKFYsIHByZWZpeCwgYXJndW1lbnQpIHtcbiAgaWYgKHdlYmlkbC51dGlsLlR5cGUoVikgPT09ICdPYmplY3QnICYmIFN5bWJvbC5pdGVyYXRvciBpbiBWKSB7XG4gICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzWydzZXF1ZW5jZTxET01TdHJpbmc+J10oVilcbiAgfVxuXG4gIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5ET01TdHJpbmcoViwgcHJlZml4LCBhcmd1bWVudClcbn1cblxuLy8gVGhpcyBpbXBsZW1lbnRzIHRoZSBwcm9wb3NhbCBtYWRlIGluIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvd2Vic29ja2V0cy9pc3N1ZXMvNDJcbndlYmlkbC5jb252ZXJ0ZXJzLldlYlNvY2tldEluaXQgPSB3ZWJpZGwuZGljdGlvbmFyeUNvbnZlcnRlcihbXG4gIHtcbiAgICBrZXk6ICdwcm90b2NvbHMnLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+J10sXG4gICAgZGVmYXVsdFZhbHVlOiAoKSA9PiBuZXcgQXJyYXkoMClcbiAgfSxcbiAge1xuICAgIGtleTogJ2Rpc3BhdGNoZXInLFxuICAgIGNvbnZlcnRlcjogd2ViaWRsLmNvbnZlcnRlcnMuYW55LFxuICAgIGRlZmF1bHRWYWx1ZTogKCkgPT4gZ2V0R2xvYmFsRGlzcGF0Y2hlcigpXG4gIH0sXG4gIHtcbiAgICBrZXk6ICdoZWFkZXJzJyxcbiAgICBjb252ZXJ0ZXI6IHdlYmlkbC5udWxsYWJsZUNvbnZlcnRlcih3ZWJpZGwuY29udmVydGVycy5IZWFkZXJzSW5pdClcbiAgfVxuXSlcblxud2ViaWRsLmNvbnZlcnRlcnNbJ0RPTVN0cmluZyBvciBzZXF1ZW5jZTxET01TdHJpbmc+IG9yIFdlYlNvY2tldEluaXQnXSA9IGZ1bmN0aW9uIChWKSB7XG4gIGlmICh3ZWJpZGwudXRpbC5UeXBlKFYpID09PSAnT2JqZWN0JyAmJiAhKFN5bWJvbC5pdGVyYXRvciBpbiBWKSkge1xuICAgIHJldHVybiB3ZWJpZGwuY29udmVydGVycy5XZWJTb2NrZXRJbml0KFYpXG4gIH1cblxuICByZXR1cm4geyBwcm90b2NvbHM6IHdlYmlkbC5jb252ZXJ0ZXJzWydET01TdHJpbmcgb3Igc2VxdWVuY2U8RE9NU3RyaW5nPiddKFYpIH1cbn1cblxud2ViaWRsLmNvbnZlcnRlcnMuV2ViU29ja2V0U2VuZERhdGEgPSBmdW5jdGlvbiAoVikge1xuICBpZiAod2ViaWRsLnV0aWwuVHlwZShWKSA9PT0gJ09iamVjdCcpIHtcbiAgICBpZiAoaXNCbG9iTGlrZShWKSkge1xuICAgICAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLkJsb2IoViwgeyBzdHJpY3Q6IGZhbHNlIH0pXG4gICAgfVxuXG4gICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhWKSB8fCB0eXBlcy5pc0FycmF5QnVmZmVyKFYpKSB7XG4gICAgICByZXR1cm4gd2ViaWRsLmNvbnZlcnRlcnMuQnVmZmVyU291cmNlKFYpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdlYmlkbC5jb252ZXJ0ZXJzLlVTVlN0cmluZyhWKVxufVxuXG5mdW5jdGlvbiBvblBhcnNlckRyYWluICgpIHtcbiAgdGhpcy53c1trUmVzcG9uc2VdLnNvY2tldC5yZXN1bWUoKVxufVxuXG5mdW5jdGlvbiBvblBhcnNlckVycm9yIChlcnIpIHtcbiAgbGV0IG1lc3NhZ2VcbiAgbGV0IGNvZGVcblxuICBpZiAoZXJyIGluc3RhbmNlb2YgQ2xvc2VFdmVudCkge1xuICAgIG1lc3NhZ2UgPSBlcnIucmVhc29uXG4gICAgY29kZSA9IGVyci5jb2RlXG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9IGVyci5tZXNzYWdlXG4gIH1cblxuICBmaXJlRXZlbnQoJ2Vycm9yJywgdGhpcywgKCkgPT4gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywgeyBlcnJvcjogZXJyLCBtZXNzYWdlIH0pKVxuXG4gIGNsb3NlV2ViU29ja2V0Q29ubmVjdGlvbih0aGlzLCBjb2RlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV2ViU29ja2V0XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/undici/lib/web/websocket/websocket.js\n");

/***/ })

};
;